relation Store(mapping(`T3 => `T4) idx1,
               mapping(`T3 => `T4) idx2,
               `T3 key, `T4 value).

/* relates the type of the two relation parameters*/
relation Type(mapping(`T11 => `T12) mppp1, mapping(`T11 => `T12) mppp2).

pred Map<idx2> == Type(self,idx2).

/*
checkentail mp::Map<mp8> & Store(mp33,mp8,0,5) |- mp::Map<mp55> & mp55[0]=5.
expect Valid.

checkentail mp::Map<mp8> & Store(mp33,mp8,0,5) |- (exists mp55: mp::Map<mp55> & mp55[0]=5).
expect Valid.

 checkentail mp'::Map<mp2> & Store(mp1,mp2,0,5) & mp1=mp8
 |-  (exists mp9_91: mp'::Map<mp9_91> & mp9[0]=5 & mp9_91=mp9 ).
 expect Fail.

checkentail mp'::Map<mp2> & Store(mp1,mp2,0,5) & mp1=mp8
 |-  (exists mp9_91: mp'::Map<mp9_91> & mp9_91[0]=5 ).
expect Valid.

checkentail  Store(mp1,mp2,0,5)
 |-  (exists mp9_91:  mp9[0]=5 & mp9_91=mp9 & mp2=mp9_91).
expect Fail.

checkentail  Store(mp1,mp2,0,5)
 |-  (exists mp9_91:  mp9_91[0]=5 & mp2=mp9_91).
expect Valid.

 checkentail mp'::Map<mp2>  & Store(mp01,mp0,0,9) & Store(mp0,mp1,0,6) & Store(mp1,mp2,0,5) & mp1=mp8
 |-  (exists mp9_91: mp'::Map<mp9_91> & mp9_91[0]=5 ).
 expect Valid.
*/

// @L <: @M ---> false has no effect on predicates which have empty heap
checkentail mp::Map<Anon_11>@L&v_int_9_2159'=9 & v_int_9_2160'=0 & mp'=mp & mp[aaa]=0 & aaa=0
 |-  mp'::Map<mp1>@M.
 print residue.
 expect Fail.



data node{
     int val;
}.

checkentail x::node<_>@L |- x::node<_>@M.
