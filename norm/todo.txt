# norm/ex21u2.slk (OK)

pred_elim_useless [ll].
//no change

pred_elim_useless [app2].
//elim y

# Loc : can we refine the command's to the following:

Instead of printing every view. Can we
either print:
  "No predicates here has useless parameters"

or:
  Pred P has parameter ? eliminated ..

The command should be idempotent in that the 
2nd application will cause no-change.
===================================================================
# ex21u1.slk --dd-calls-all

# was lemma proving invoked?
  It seems that lemmas were generated
  but never proven? compare with ex21r4.slk

(==lemma.ml#1863==)
generate_view_rev_rec_lemmas@3
generate_view_rev_rec_lemmas inp1 : view G2<p:node,y:node>= 
  EList
    :EBase 
       (* lbl: *){1}->emp&self=y&{FLOW,(1,26)=__flow#E}[]
    || :EBase 
          exists (Impl)[Anon_14; tt; pp](* lbl: *){2}->(exists pp_16,
          y_17: (* lbl: *){2}->self::node<Anon_14,pp,tt>@M * 
                               tt::G2<pp_16,y_17>@M&
          pp_16=pp & y_17=y&{FLOW,(1,26)=__flow#E}[])
    
generate_view_rev_rec_lemmas@3 EXIT:[=>coerc rev_G2_65
	 head: (self::G2{}<p,y>@M[HeapNode1]) * ([] & !(((self:node)) = ((y:node))))( FLOW __flow)
	 body:((tt::node{}<Anon_14,pp,y,>@M[HeapNode1]) * (self::G2{}<pp,tt>@M[HeapNode1])) * ([] & true)( FLOW __flow)safe lemmas(added to store only if valid)
]

(==lemma.ml#1863==)
generate_view_rev_rec_lemmas@4
generate_view_rev_rec_lemmas inp1 : view G1<y:node>= 
  EBase 
    exists (Impl)[Anon_13; t; p](* lbl: *){3}->(exists p_18,
    y_19: (* lbl: *){3}->self::node<Anon_13,p,t>@M * t::G2<p_18,y_19>@M&
    p_18=p & y_19=y&{FLOW,(1,26)=__flow#E}[])
generate_view_rev_rec_lemmas@4 EXIT:[]

===================================================================
# ex21r3.slk

pred lseg2a<n,p> == self = p & n=0
	or self::node<_, q> * q::lseg111<n-1,p> 
  inv true.

pred lseg3<n,p> == self = p & n=0
	or self::node<_, q> * q::lseg111<n-1,p> 
  inv true.

pred lseg111<n,p> == self = p & n=0
	or self::node<_, q> * q::lseg111<n-1,p> 
  inv true.

pred_reuse [*][*].

!!! **norm.ml#193:norm_reuse (from_vns):[lseg111,lseg2a,lseg3]
!!! **norm.ml#194:norm_reuse (to_vns):[lseg111,lseg2a,lseg3]

# should we use topological sorting? where shorter names 
  come first..

Since lseg3 is shorter than lseg2a, we would expect
it to come first.
===================================================================
# ex21r3c.slk

 pred lseg<n,p> == self::lseg111<n,p>.

# raw base case need to include non-heap and non-recursive item
 raw_base_case : self::lseg111<n,p>

  not sure if guarded base-case is useful?

-----

lseg111<..>
  materialized vars: [(self,partial,[])]
  addr vars: self
  
  raw base case: 
  (* lbl: *){1}->emp&self=p & n=0&{FLOW,(1,26)=__flow#E}
  []base case: n=0->self=p & 
                                                                    n=0
lseg111<..>
  materialized vars: [(self,full,[lseg111])]
===================================================================
# ex21s1.slk (test file in ex21s1b.slk)

relDefn zip(x,y,z) <->
  x=null & y=null & z=null
or x::node<_,p>*y::node<_,q>*z::node<_,t>*zip(p,q,t).
../
pred_split [zip].

# Instead of relDefn, can we use pred:
  What is @RO? root?

pred zip<y,z> ==
   self=null & y=null & z=null
or self::node<_,p>*y::node<_,q>*z::node<_,t>*p::zip<q,t>.


# After that, call lemma_infer, followed by shape_derive_view[P1,P2,p3];
  as shown in ex21s1a.slk

===================================================================
# ex21r4d.slk (FIXED)

!!! **norm.ml#186:
 Failed : self::lseg3<p,n>@M&{FLOW,(1,26)=__flow#E}[] <->  self::lseg2a<n,p>@M&{FLOW,(1,26)=__flow#E}[]
!!! **sleekengine.ml#2502:

# GOT
PRED REUSE FOUND:[(lseg2a,lseg2a),(lseg3,lseg3)]

# EXPECTS:
PRED REUSE FOUND:[(lseg2a,lseg2a),(lseg3,lseg2a)]


# equiv proving fails. the reason is that we prove
  using two separate <-- and -->
  instead of a single <->

  Can we do this?
===================================================================
# ex21a3.slk (FIXED by marking unknown type parameter useless)

 pred_elim_hd_node [app2].

# a sleek failure msg for app with y. 
  can print the elim_hd lemma generated?

========================
 Performing Deriving Segmented Views
========================

!!! **syn.ml#696:derived_views:
[ view DP_68<y_67:TVar[43]>= 
  EList
    :EBase 
       self::app2<y_67>@M&self!=null&{FLOW,(1,26)=__flow#E}[]
    || :EBase 
          self::node<Anon_104,flted_14_105>@M * flted_14_105::GP_106<self>@M&
          self!=null&{FLOW,(1,26)=__flow#E}[]
    || :EBase 
          emp&self=null&{FLOW,(1,26)=__flow#E}[]
    ]
Last Proving Location: ex21a3-pred-elim-hd-node.slk_11:4_11:30

ERROR: at _0:0_0:0
Message: GP_106 is neither 2 a data nor view name

Exception processed: Failure("GP_106 is neither 2 a data nor view name")
error at: 
SLEEK FAILURE (END)
===================================================================
# ex21a4.slk (OK)

checkentail x::app2<> |- x::node<_,q>.
print residue.

Residue:
 <1>q::DP_62<>@M&{FLOW,(20,21)=__norm#E}[]
[[ Unfold 0 ==>  Match(x,x)]]


# can we tidy with re-using pred in body by:
  pred_reuse_subs [*]
  print_view [*]
  print_view_long [*]

--------------------------------------

!!! **sleekengine.ml#3003:[ view ll<>= 
  EList
    :EBase 
       (* lbl: *){3}->emp&self=null&{FLOW,(1,26)=__flow#E}[]
    || :EBase 
          exists (Impl)[Anon_12; 
          q](* lbl: *){4}->self::node<Anon_12,q>@M * q::ll<>@M&
          {FLOW,(1,26)=__flow#E}[]
    , view DP_65<>= 

===================================================================
# ex21a5.slk

pred_reuse_subs [*].

!!! **norm.ml#233:TBI: view:
 view lseg<n:int,p:node>= 
  EList
    :EBase 
       (* lbl: *){3}->emp&self=p & n=0&{FLOW,(1,26)=__flow#E}[]
    || :EBase 
          exists (Impl)[Anon_12; q](* lbl: *){4}->(exists p_20,
          flted_11_19: (* lbl: *){4}->self::node<Anon_12,q>@M * 
                                      q::lseg<flted_11_19,p_20>@M&
          flted_11_19+1=n & p_20=p&{FLOW,(1,26)=__flow#E}[])
    equiv_set: ([1,0],lseg2)
  
# change after to self::lseg<p,n> == self::lseg2<p,n> after reuse detection


!!! **norm.ml#234:TBI: from:(lseg,[n,p])
!!! **norm.ml#235:TBI: to:(lseg2,[p,n])
===================================================================
# ex21a6a.slk

pred app5<> == self=null
        or self::node<_,q> * q::app5a<>
  inv true.

pred app5a<> == self=null 
	or self::node<_, q> * q::app5b<> 
  inv true.

pred app5b<> == self=null 
	or self::node<_, q> * q::app5<> 
  inv true.

# deeper mutual recursion requires simultaneous lemma
  proving considerations.
===================================================================
# udisj-1.slk

pred_disj_unify [ll_last].

# sleek parser failure ..

File "udisj-1.slk", line 22, characters 17-18
 error: Stream.Error("EOF expected after [command_list] (in [sprog])")
 at:
Exception processed: Stream.Error("EOF expected after [command_list] (in [sprog])")
error at: 
SLEEK FAILURE (END)

Stop z3... 0 invocations 
0 false contexts at: ()
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
