====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
# ex13b1.slk

checkentail xx::arr_seg<i,n> & i<n |- xx::arr_seg<i+1,n>.

Validate 2: OK
Residue:
 <1>xx::arr_seg<i,mmm_144>@M&mmm_149=i+1 & mmm_149=mmm_144 & i<mmm_144 & 
                             mmm_144<=n & Univ(mmm_149) & Univ(mmm_144) & i<n&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  COND ==>  (Lemma ==> lem_14(xx,xx)) ==>  SEARCH ==>  COND ==>  Match(xx,xx)]]

This example fail with --adhoc-7. Could it be due to 
the last match?

    [[ SEARCH ==>  SEARCH ==>  (Lemma ==> lem_14(xx,xx)) ==>  SEARCH ==>  COND ==>  BaseCaseUnfold]]

====================================================================
# ex12b5.slk

pred arr_seg<i,n> == i=n  & self!=null & i>=0 & BasePtr(self)
  or xxx::arrI<_>*self::arr_seg<i+1,n> & xxx=self+i & i>=0
    inv //BG([(self,i,n)],
       n>=i &
       i>=0 & self!=null & BasePtr(self)
    //)
    .
# why did we have failure?

pred arr_seg<i,n> == i=n & i>=0 & self!=null //& BasePtr(self)
  or xxx::arrI<_>*self::arr_seg<i+2,n> & xxx=self+i & i>=0

chinwn@loris-7:~/hg/sleekex/ptr1/slk$ ../../sleek ex12b5-array_baga.slk | grep Fail
Inv Check: Fail.(View arr_seg:Over)
chinwn@loris-7:~/hg/sleekex/ptr1/slk$
====================================================================
# ex12b3.slk

pred arr_seg<i,n> == i=n & i>=0 & self!=null //& BasePtr(self)
  or xxx::arrI<_>*self::arr_seg<i+1,n> & xxx=self+i & i>=0
    //inv BG([(self,i,n)], n>=i & i>=0 & self!=null & BasePtr(self))
    .

# handling fixcalc with BasePtr(self)?

!!! **astsimp.ml#2524:allow_ex_vs:[]fixcalc: bad mutual recursion detected :"BasePtr"


# why isn't n>=i captured?

  inv: i>=0 & self>=1
  
  baga over inv: [([], i>=0 & self>=1)]
  baga over inv (unfolded): [([], ((0<=i & 1<=self) | (self<=(0-1) & 0<=i)))]
  
  xform: ((0<=i & self!=null) | (i=n & 0<=n & self!=null))


(==fixcalc.ml#670==)
compute_invs_fixcalc@59
compute_invs_fixcalc inp1 :arr_seg:={[self,i_43,n_44] -> [] -> []: (0=0 && i_43=n_44 && 0<=i_43 && self>0) ||  exists (n_16,flted_6_15,xxx,Anon_13: (xxx>0 && self>0) && flted_6_15=1+i_43 && xxx=i_43+self && 0<=i_43 && n_16=n_44)
};
bottomupgen([arr_seg], [1], SimHeur);
compute_invs_fixcalc@59 EXIT:[ i_43>=0 & self>=1]
====================================================================
# ex12b1.slk


# a bit hard to handle. maybe unnecessary..

// cannot handle a>0 or k>=base ..
checkentail base::arr_seg<a,y> * k::arrI<_> & a<y & k=base+a-1
   |- k>=base
   //a>0
  .

Residue:

 MaybeErr Context: 
   fe_kind: MAY
   fe_name: logical bug
   fe_locs: {
     fc_message:  0<=a & a<=y & a<y & base_282!=k & (((base+a)>k | k>=(base+y))) & k!=null & 
 base!=null & k+1=base+a |-  base<=k. LOCS:[0;7;73;74] (may-bug)
     fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
   }
 [[empty]]
 CEX:false

====================================================================
# ex9b7b2.slk --pcp

checkentail xx::arr_seg<2,mmm> 
      & Univ(mmm) & 2<mmm<=4 //& BasePtr(xx)
   |- [k] xx::arr_seg<k,5>.

# why did isn't BasePtr is not included in xform & baga_over_inv

  inv: i<=n & 0<=i & self!=null & BasePtr(self)
  
  baga over inv: [([], i<=n & 0<=i & self!=null & BasePtr(self))]
  baga over inv (unfolded): [([], ((0<=i & i<=n & 1<=self) | (0<=i & i<=n & self<=(0-1))))]
  
  xform: ((0<=i & i<n & self!=null) | (i=n & 0<=n & self!=null))

!!! **astsimp.ml#2058:xform:
 ((i=n & 0<=i & self!=null & BasePtr(self)) | 
  (0<=i & self!=null & BasePtr(self) & (i+self)!=null & (1+i)<=n & 0<=(1+i)))

!!!ex9b7b2-array-lemma-4-5-6.slk:5: 21: **astsimp.ml#1950:xform1: ((i=n & 0<=n & self!=null) | (0<=i & i<n & self!=null))

(==solver.ml#8849==)
xpure_heap#9@52@49
xpure_heap#9 inp1 : xx::arr_seg<flted_14_70,mmm>@M
xpure_heap#9 inp2 : flted_14_70=2 & Univ(mmm) & 2<mmm & mmm<=4
xpure_heap#9 inp3 :1
xpure_heap#9@52 EXIT:( ((0<=flted_14_70 & flted_14_70<mmm & xx!=null) | 
  (flted_14_70=mmm & 0<=mmm & xx!=null)),[], [])#true

(==solver.ml#13674==)
do_base_fold@49
do_base_fold inp1 :  xx::arr_seg<flted_14_70,mmm>@M&mmm<=4 & 2<mmm & Univ(mmm) & flted_14_70=2&
{FLOW,(20,21)=__norm#E}[]
 es_evars: [flted_16_71]
 es_gen_impl_vars(E): []
 es_ante_evars: [flted_14_70]
 es_gen_expl_vars: [k]
 es_subst (from,to): []:[]
 es_trace:  SEARCH ==>  COND ==>  BaseCaseFold
do_base_fold inp2 : xx::arr_seg<k,flted_16_71>@M&flted_16_71=5&{FLOW,(20,21)=__norm#E}[]
do_base_fold@49 EXIT: failctxfe_kind: MAY
====================================================================
# ex9b7b2.slk

checkentail xx::arr_seg<2,mmm> //* xx::arr_seg<mmm,4> 
      & Univ(mmm) & 2<mmm<=4 //& BasePtr(xx)
   |- [k] xx::arr_seg<k,5>.

# why did isn't BasePtr picked from xpure?

   fe_locs: {
     fc_message:  mmm<=4 & 2<mmm & Univ(mmm) & 
 (((0<=2 & 2<mmm & xx!=null) | (2=mmm & 0<=mmm & xx!=null))) |-  BasePtr(xx). LOCS:[15;14;0;1;5] (may-bug)
     fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}

====================================================================
# ex7a4a1.slk

checkentail base::arr_seg<2,2> * base::arr_seg<2,3> |- false.
expect Fail. 
print residue.

# this unsoundness need to be fixed..

(==cvutil.ml#1992==)
xpure_heap_mem_enum#6@79@78@77@76@75
xpure_heap_mem_enum#6 inp1 : base::arr_seg<flted_12_107,flted_12_106>@M * 
 base::arr_seg<flted_12_105,flted_12_104>@M
xpure_heap_mem_enum#6 inp2 :lhs_pure: flted_12_107=2 & flted_12_106=2 & flted_12_105=2 & flted_12_104=3
xpure_heap_mem_enum#6 inp3 :xpure_int:1
xpure_heap_mem_enum#6@79 EXIT: false #  [[_133,_133]]
====================================================================
# ex9b6d.slk -dre "ef_\|imply"

// (7)
checkentail xxx::ll<n> * yyy::ll<m> & n>0 |- xxx!=yyy.
expect Valid.
print residue.

# below is not used for implication? only for unsat checks?

(==tpdispatcher.ml#3315==)
imply_cache@228@226@225@224@223@216@215@214@213
imply_cache inp1 : xxx!=null & yyy!=null
imply_cache inp2 : xxx!=yyy
imply_cache@228 EXIT:found?:false ans:false

(====)
ef_conv_enum@136@135
ef_conv_enum inp1 :([xxx,yyy], 0<n & 0<m)
ef_conv_enum@136 EXIT: xxx=1 & yyy=2 & 0<n & 0<m

(====)
ef_unsat@135
ef_unsat inp1 :([xxx,yyy], 0<n & 0<m)
ef_unsat@135 EXIT:false
====================================================================
# ex9b6.slk  

pred arr_seg<i,n> == i=n & i>=0 & self!=null
  or x::arrI<_>*self::arr_seg<i+1,n> & x=self+i & i>=0
  inv n>=i & i>=0 & self!=null.

checkentail arr::arr_seg<1,2> * arr::arr_seg<1,2> |- false.
expect Valid.
print residue.

Need to extend baga format to array segment

====================================================================
# ex9b5e.slk --adhoc-4 (FIXED)

checkentail xx::arr_seg<i,m> * xx::arr_seg<m,n> 
      & i+1<n & i<m<=n & Univ(m) |- xx::arr_seg<i+3,n>.

# unsound to be valid..
# why was a Univ(n) introduced???

!!!:0: 0: **solver.ml#7679:univ_vars2:[m,nnn,m_136,m_131]
!!!:0: 0: **solver.ml#7683:qp with univ: m_136=m_131 & i<m_131 & m_131<=m & Univ(m_131) & m=nnn & (1+i)<nnn & i<m & 
 m<=nnn & Univ(m) & xx!=null & 0<=m & Univ(m) & Univ(nnn) & Univ(m_136) & 
 Univ(m_131)
!

why was lemma triggered?

<1>xx::arr_seg<i,m_131>@M&m=n & m_137=i+3 & m_137=m_131 & i<m_131 & 
                           m_131<=m & (1+i)<n & i<m & m<=n & xx!=null & 
                           0<=m & Univ(m) & Univ(n) & Univ(m_137) & 
                           Univ(m_131)&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  SEARCH ==>  COND ==>  COND ==>  BaseCaseUnfold ==>  SEARCH ==>  COND ==>  (Lemma ==> lem_13(xx,xx)) ==>  SEARCH ==>  COND ==>  Match(xx,xx)]]
===================================================================
# ex9b4k2.slk (FIXED but not using consumed heap)

// below could succeed with an unfold and some inst of i & n?
checkentail xx::arr_seg<ii,nn> & Univ(ii) & Univ(nn) & ii<nn 
    |- pp::arrI<_> & pp=xx+ii.
expect Valid.
print residue.

 below could succeed with an unfold and univ inst ii!=nn
!!! **solver.ml#13379:lhs_node (M_unfold): xx::arr_seg<ii,ni>@M
!!! **solver.ml#13380:rhs_node (M_unfold): pp::arrI<Anon_13>@M
!!! **cast.ml#3154:arguments:[xx,ii,ni]
!!! **cast.ml#3155:parameters:[self,i,n]
!!! **cast.ml#3158:pure (before): i=n
!!! **cast.ml#3159:pure (after subs): ii=ni
!!! **solver.ml#13384:is_data_rhs:true
!!! **solver.ml#13385:lhs_name:arr_seg
!!! **solver.ml#13386:base_pure:Some( ii=ni)
!!! **solver.ml#13388:estate: ex_formula : xx::arr_seg<ii,ni>@M&ii<ni & Univ(ni) & Univ(ii)&{FLOW,(20,21)=__norm#E}[]
 es_heap:emp
!!! **solver.ml#13394:TODO:to add univ_imply checking before unfold
!!! **solver.ml#13396:rhs_univ_inst: !(ii=ni)
!!! **solver.ml#13399:new_estate: ex_formula : xx::arr_seg<ii,ni>@M&ii<ni & Univ(ni) & Univ(ii) & !(ii=ni)&{FLOW,(20,21)=__norm#E}[]

=================================================================
# ex9b4k1.slk --dre ".*univ" --trace-log-num 2 (FIXED)

# why did we filter inv? 
# it seems like we are filtering out disjunction which may
  be too strong thing to do..

@2!:0: 0: **tpdispatcher.ml#3736:Processing univ instantiation
@2!:0: 0: **tpdispatcher.ml#3737:univ var:[i]
@2!:0: 0: **tpdispatcher.ml#3738:ante0: Univ(i) & ((i=n | i<n)) & 0<=i
@2!:0: 0: **tpdispatcher.ml#3739:conseq0: i!=n
@2!:0: 0: **tpdispatcher.ml#3741:prev_inst: true
@2!:0: 0: **tpdispatcher.ml#3744:ante1 (aftre filter inv): 0<=i
@2! **cpure.ml#2960:vs(mkExists):[i]
@2! **cpure.ml#2961:vs(filtered rel type):[i]
@2!:0: 0: **tpdispatcher.ml#3749:new_conseq: exists(i:0<=i & i!=n)
@2! **cpure.ml#2960:vs(mkExists):[i]
@2! **cpure.ml#2961:vs(filtered rel type):[i]
@2! **omega.ml#901:simplify_ops_x(after trans_arr):: exists(i:0<=i & i!=n)
Starting Omega.../usr/local/bin/oc

*/

checkentail 0<=i & (i=n | i<n) & Univ(i) |- i!=n.
expect Valid.
print residue.

=================================================================
# tpdispatcher.ml

(* 

    # imply_timeout_univ

    below appears to add (exists univ_var ..) to conseq
    but this does not check if we had strengthened the LHS unnecessarily..
*)

let imply_timeout_univ univ_vars ante0 conseq0 imp_no timeout process =
    let () = y_dinfo_pp "Processing univ instantiation" in
    let () = y_dinfo_hp (add_str "univ var" (pr_list !CP.print_sv)) univ_vars in
    let () = y_dinfo_hp (add_str "ante0" !CP.print_formula) ante0 in
    let () = y_dinfo_hp (add_str "conseq0" !CP.print_formula) conseq0 in
    let prev_inst = univ_rhs_store # get in
    let () = y_dinfo_hp (add_str "prev_inst" !CP.print_formula) prev_inst in
    let ante0 = CP.drop_rel_formula ante0 in
    let ante1 = filter_inv ante0 in
    let () = y_dinfo_hp (add_str "ante1 (aftre filter inv)" !CP.print_formula) ante1 in
    let new_conseq = CP.mkAnd ante1 prev_inst no_pos in
    (* let () = y_tinfo_hp (add_str "univ_vars2" (pr_list !CP.print_sv)) univ_vars in *)
    let new_conseq = CP.mkAnd new_conseq conseq0 no_pos in
    let new_conseq = CP.mkExists univ_vars new_conseq None no_pos in
    let () = y_dinfo_hp (add_str "new_conseq" !CP.print_formula) new_conseq in
    let (b,_,_) as r = x_add imply_timeout ante0 new_conseq imp_no timeout process in
    let () = y_dinfo_hp (add_str "imply_timeout_univ: b " string_of_bool) b in
    if b then
      let () = univ_rhs_store # set conseq0 in r
    else r
=================================================================
# ex9b4f.slk

checkentail xx::arr_seg<i,m>*
  xx::arr_seg<m,n> & i<m<=n & i+1<n & Univ(m)
    |- xx::arr_seg<i+3,n>.
print residue.
expect Fail.

# Why did base-case unfold lead to a univ instantiation?

# perhaps it isn't quite right to do univ inst for every implication
but to control where univ_inst is done at check_entail empty_rhs?


Entail 1: Valid. 
Residue:
 <1>xx::arr_seg<i,m>@M&n=i+3 & i<m & m<=n & (1+i)<n & Univ(m) & m_51=m & 
                       xx!=null & 0<=m_51 & m_51=n&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  COND ==>  BaseCaseUnfold ==>  SEARCH ==>  COND ==>  BaseCaseFold]]

=================================================================
# ex9b4e.slk

# can dis-dsb be automatically set?
# using --dsb lead to less precise outcome for univ..

        (* TODO: change to if univ inst expected *)
        let univ_vs = TP.get_univs_from_ante a0 in
        if CP.no_andl a0 && !Globals.deep_split_disjuncts  && univ_vs==[] 

checkentail
  m_51=m & Univ(m) & (1+i)<n & m<=n & i<m & 
 (((0<=i & i<m & xx!=null) | (i=m & 0<=m & xx!=null))) & 
 (((0<=m_51 & m_51<n & xx!=null) | (m_51=n & 0<=n & xx!=null)))
|- m_51=i+1.
=================================================================
# ex13a.slk

// can we scedule a base-case-fold after view match failure?
// match and base-case-fold need to be both scheduled..

checkentail x::arr_seg<2,n> & n>=2  |- x::arr_seg<2,2> .
print residue.
expect Valid.

# ex13a.slk -dre "compute_action"

# schedule a base-case-fold instead of base-case-unfold ..

  COND =>[
   Prio:1
   Match =>
     Type: Root
     LHS: x::arr_seg<flted_13_47,n>@M
     RHS: x::arr_seg<flted_13_67,flted_13_66>@M
     root_inst: None
     lhs_rest: emp
     rhs_rest: emp
     alias set: [x]rhs_inst: []rhs_infer: None;
   Prio:3
   BaseCaseUnfold =>
     Type: Root
     LHS: x::arr_seg<flted_13_47,n>@M
     RHS: x::arr_seg<flted_13_67,flted_13_66>@M
     root_inst: None
     lhs_rest: emp
     rhs_rest: emp
     alias set: [x]rhs_inst: []rhs_infer: None
   ]
   ]

//(16)
checkentail x::arr_seg<1,n> & n>=2   |- x::arr_seg<2,2> * y1::arrI<_> & y1=x+1.
print residue.
expect Valid.

=================================================================
# ex14c.slk

Did we not use LHS /\ RHS |- x=y? where C= LHS & RHS?

       C |- x=y
  -------------------------------------match node
      x::arr<v1> |- y::arr<v2>

Can we prune out match of x,z and it is unlikely..

checkentail x::arrI<_> * y::arrI<_> & y=x+1 |- z::arrI<_> & z=x+1.
print residue.
expect Valid.


(==context.ml#3810==)
process_matches@1
process_matches inp1 :lhs_h: x::arrI<Anon_13>@M * y::arrI<Anon_14>@M
process_matches inp2 :matches:
[ Type: Root
 LHS: x::arrI<Anon_13>@M
 RHS: z::arrI<Anon_15>@M
 root_inst: None
 lhs_rest: y::arrI<Anon_14>@M
 rhs_rest: emp
 alias set: [y,x,z]rhs_inst: []rhs_infer: None, Type: Root
 LHS: y::arrI<Anon_14>@M
 RHS: z::arrI<Anon_15>@M
 root_inst: None
 lhs_rest: x::arrI<Anon_13>@M
 rhs_rest: emp
 alias set: [y,x,z]rhs_inst: []rhs_infer: None]
process_matches inp3 :rhs_node: z::arrI<Anon_15>@M
process_matches inp4 :rhs_rest: emp
process_matches@1 EXIT: Prio:-1
 SEARCH =>[
  Prio:1
  Match =>;
  Prio:1
  Match =>
  ]
=================================================================
# ex14b1.slk

# wrong pairing as did not take LHS & RHS when doing a
  fold where c has been instantiated.

!!! **context.ml#3928:compute_action (steps) :
 ### RHS Cand :[ x::arr_seg<i,n>@M]
 ### action :
 SEARCH =>[
  Prio:1
  Fold =>
    LHS: x::arrI<Anon_13>@M
    RHS: x::arr_seg<i,n>@M
  ]
=================================================================
# ex14b2a.slk

Residue:
 <1>y::arrI<Anon_13>@M&i=n & 0<=i & y=x&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  Fold]]

# fold succeed on the base case only..

# TODO : fix recursive appln op folding ..

=================================================================
# ex14b2d.slk

infer [ii] x=y+ii |- y=x.

# why is ii undefined?

Last Proving Location: ex14b2c-arrseg-fold.slk_6:5_6:54

ERROR: at _0:0_0:0
Message: ii is undefined (7)

(==typeinfer.ml#614==)
unify_ptr_arithmetic@12@7@4@2
unify_ptr_arithmetic inp1 :Unknown
unify_ptr_arithmetic inp2 :Unknown
unify_ptr_arithmetic inp3 :TVar[13]
unify_ptr_arithmetic inp4 :[(ii:15:Unknown)(y:14:Unknown)(TVar__13:13:TVar[13])(x:12:TVar[12])(TVar__12:12:TVar[12])]
unify_ptr_arithmetic@12 EXIT:([(ii:15:Unknown)(y:14:Unknown)(TVar__13:13:TVar[13])(x:12:TVar[12])(TVar__12:12:TVar[12])],Unknown)

(==typeinfer.ml#851==)
gather_type_info_exp@7@4@2
gather_type_info_exp inp1 :y+ii
gather_type_info_exp inp2 :[(TVar__13:13:TVar[13])(x:12:TVar[12])(TVar__12:12:TVar[12])]
gather_type_info_exp inp3 :TVar[13]
gather_type_info_exp@7 EXIT:[(ii:15:Unknown)(y:14:Unknown)(TVar__13:13:TVar[13])(x:12:TVar[12])(TVar__12:12:TVar[12])], Unknown

=================================================================
# Non-termination for sleek8.slk

Checking sleek7.slk (runs with extra options:  --dis-lem-gen )
Checking sleek8.slk (runs with extra options:  --dis-lem-gen )

=================================================================
# ex14c1.slk

checkentail x::arrI<_>  |- y::arr_seg<0,1> & y=x . // fail cos y is not existential

# why impl existential not helping here.
  why we did not inst impl for ptr arithmetic?

INPUT 0: [][] 
 ### ante =  x::arrI<Anon_13>@M&{FLOW,(20,21)=__norm#E}[]
 ### conseq =  EBase 
   exists (Impl)[y](exists flted_22_51,
   flted_22_52: y::arr_seg<flted_22_52,flted_22_51>@M&
   flted_22_52=0 & flted_22_51=1 & y=x&{FLOW,(20,21)=__norm#E}[])
=================================================================
# ex9b.slk

# below fail but got Valid..

checkentail xx::arr_seg<i,n> & i+1<n |- xx::arr_seg<i+3,n>.
print residue.
expect Fail.


checkentail xx::arr_seg<i,n> & i+1<n |- xx::arr_seg<i+4,n>.
print residue.
expect Fail.
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
=================================================================
