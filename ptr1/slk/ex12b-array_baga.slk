data arrI {
  int val;
}.

pred arr_seg<i,n> == i=n & i>=0 & self!=null
  or xxx::arrI<_>*self::arr_seg<i+1,n> & xxx=self+i & i>=0
    inv BG([(self,i,n)], n>=i & i>=0 & self!=null
    ).

checkentail base::arr_seg<x,y> * base::arr_seg<a,b>  
   |- a>=y | x>=b.
expect Valid.
print residue.


checkentail base::arr_seg<a,y> * base::arr_seg<a,b> & a<y & y<=b
   |- a>=y | a>=b.
expect Valid.
print residue.


//(3)
checkentail base::arr_seg<a,y> * k::arrI<_> & a<y & k=base+a 
   |- false.
expect Valid.
print residue.

//(4)
// not (k>=base+a && k<base+y) => k<base+a | k>=base+y
checkentail base::arr_seg<a,y> * k::arrI<_> & a<y & k=base+b
   |- b<a | b>=y.
expect Valid.
print residue.


checkentail k::arrI<_> * k2::arrI<_> & k2=base+b2+1 & k=base+b & b=b2+1
   |- false.
expect Valid.
print residue.

checkentail k::arrI<_> * k2::arrI<_> & k2=base+b2+1 & k=base+b & b=b2
   |- false.
expect Fail.
print residue.

checkentail base::arr_seg<a,y> * k::arrI<_> & a<y & k=base+b
   |- false.
expect Fail.
print residue.


checkentail base::arr_seg<a,y> * k::arrI<_> & a<y & k=base+a
   |- false.
expect Valid.
print residue.


checkentail base::arr_seg<a,y> * k::arrI<_> & a<y & k=base+a-1
   |- k!=null.
expect Valid.
print residue.

checkentail base::arr_seg<a,y> * k::arrI<_> & a<y & k=base+a-1
   |- a>=0.
expect Valid.
print residue.

checkentail base::arr_seg<a,y> * k::arrI<_> & a<y & k=base+a-1
   |- k!=null.
expect Valid.
print residue.

// cannot handle a>0 or k>=base ..
checkentail base::arr_seg<a,y> * k::arrI<_> & a<y & k=base+a-1
   |- k>=base.
expect Valid.
print residue.

/*
Residue:

 MaybeErr Context: 
   fe_kind: MAY
   fe_name: logical bug
   fe_locs: {
     fc_message:  0<=a & a<=y & a<y & base_282!=k & (((base+a)>k | k>=(base+y))) & k!=null & 
 base!=null & k+1=base+a |-  base<=k. LOCS:[0;7;73;74] (may-bug)
     fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
   }
 [[empty]]
 CEX:false

*/
