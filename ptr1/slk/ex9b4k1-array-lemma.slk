/*
# ex9b4k1.slk

# why did we filter inv? what exactly is inv?

@2!:0: 0: **tpdispatcher.ml#3736:Processing univ instantiation
@2!:0: 0: **tpdispatcher.ml#3737:univ var:[i]
@2!:0: 0: **tpdispatcher.ml#3738:ante0: Univ(i) & ((i=n | i<n)) & 0<=i
@2!:0: 0: **tpdispatcher.ml#3739:conseq0: i!=n
@2!:0: 0: **tpdispatcher.ml#3741:prev_inst: true
@2!:0: 0: **tpdispatcher.ml#3744:ante1 (aftre filter inv): 0<=i
@2! **cpure.ml#2960:vs(mkExists):[i]
@2! **cpure.ml#2961:vs(filtered rel type):[i]
@2!:0: 0: **tpdispatcher.ml#3749:new_conseq: exists(i:0<=i & i!=n)
@2! **cpure.ml#2960:vs(mkExists):[i]
@2! **cpure.ml#2961:vs(filtered rel type):[i]
@2! **omega.ml#901:simplify_ops_x(after trans_arr):: exists(i:0<=i & i!=n)
Starting Omega.../usr/local/bin/oc

*/

// checkentail 0<=i & (i=n | i<n) & Univ(i) |- i!=n.
// expect Fail.
// print residue.

// checkentail 0<=i & i<=n & Univ(i) |- i!=n.
// expect Fail.
// print residue.

checkentail 0<=i & i<=n & Univ(i) & Univ(n) |- i!=n.
expect Valid.
print residue.

// checkentail 0<=i & (i=n | i<n) & Univ(i) & Univ(n) |- i!=n.
// expect Valid.
// print residue.

// //should we trigger a contradiction?

// checkentail  Univ(i) & Univ(n) |- false.
// expect Fail.
// print residue.
