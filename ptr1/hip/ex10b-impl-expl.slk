/*
data cell {
  int val;
}.

pred foo<i> == self::cell<n> & i>n
  inv self!=null
.

checkentail x::cell<5> |- x::foo<6>.
expect Valid.
print residue.


checkentail x::cell<5> |- [i] x::foo<i> & i=6.
expect Valid.
print residue.

checkentail x::cell<5> |- x::foo<i> & i=6.
expect Fail. // due to early inst..
print residue.

*/

pred goo<i> == self=null & i>0
  inv true
.

checkentail xx=null |- xx::goo<ii>.
print residue.
expect Valid.

checkentail true |- xx::goo<ii>.
print residue.
expect Valid.
// isn't xx implicit? if so, need to make it evar leh..

checkentail true |- [xx] xx::goo<ii>.
print residue.
expect Valid.

/*
# bug10b.slk 

# Can is base-case fold not working with BasePtr(base2)?

@4! **solver.ml#8919:rhs_p : BasePtr(base2) & 0<=j_61 & j_61=m_62
@4! **solver.ml#8921:m_lhs: j=m & 0<=j
@4! **solver.ml#8927:tmp3: j=m & 0<=j
@4! **solver.ml#8954:exist_vars(b4):[j_61,m_62]
@4! **solver.ml#8955:es_evars:[j_61,m_62]
@4! **solver.ml#8956:es_ivars:[]
@4! **solver.ml#8957:es_expl_vars:[]
@4! **solver.ml#8958:es_impl_vars:[base2]

How did impl_vars got transferred to es_evars?
Why we did not do it for self?

@1! **solver.ml#8956:exist_vars(b4):[ii]
@1! **solver.ml#8957:es_evars:[ii]
@1! **solver.ml#8958:es_ivars:[]
@1! **solver.ml#8959:es_expl_vars:[]
@1! **solver.ml#8960:es_impl_vars:[ii]

*/

