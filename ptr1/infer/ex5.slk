data arrI
{
 int value;
     }.

pred arr_seg<i,n> == i=n & i>=0
    or x::arrI<_>*self::arr_seg<i+1,n> & x=self+i & i>=0
inv n>=i & i>=0.

relation U(int u1,int u2, int u3, int u4).
relation U2(int u1,int u2).

// checkentail a::arr_seg<1,5> |- a::arr_seg<1,5>.
// print residue.

// checkentail a::arr_seg<1,5> |- a::arr_seg<2,3>.
// print residue.

// Because j m are existential...
infer[U] a::arr_seg<i,n> & U2(i,n) |- a::arr_seg<j,m>.
print residue.

infer[U] a::arr_seg<u1,u2> & U(u1,u2,u3,u4) |- a::arr_seg<u3,u4>.
print residue.
/*
<1>emp&U(u1,u2,u3,u4)&{FLOW,(20,21)=__norm#E}[]
 inferred rel: [RELASS [U]: ( U(u1,u2,u3,u4)) -->  ((u2=u4 & u1=u3 & 0<=u3 & u3<u4) | (0<=u2 & u1=u2)); 
                RELASS [U]: ( U(u1,u2,u3,u4)) -->  ((0<=u1 & u1<u2) | (0<=u4 & u3=u4 & u2=u4 & u1=u4))]

*/

infer[U] a::arr_seg<u1,u2> & U(u1,u2,m,m+1) |- a::arr_seg<m,m+1>. 
print residue.
/*
<1>emp&2<=(u2+a) & 1<=u2 & U(u1,u2,m,1+m) & u1=u2-1 & m=u2-1&{FLOW,(20,21)=__norm#E}[]
 inferred rel: [RELASS [U]: ( U(u1,u2,m,1+m)) -->  ((u2=m+1 & u1=m & 0<=m) | (0<=u2 & u1=u2)); 
                RELASS [U]: ( U(u1,u2,m,1+m)) -->  (u2!=u1 | 0>u1)]
*/



// infer[b]  a>b |- a>3 .
// print residue.


