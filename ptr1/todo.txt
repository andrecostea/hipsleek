ex6b.ss (due to incomplete same_base computation)

# can we automatically determine ghost parameter 
  base=a-i, based on the values of the parameters a,i?

# can base be monomorphic recursive?

void init2(arrI a,int i)
  requires base::arr_seg<i,m> & a=base+i & m=10 & 0<=i & i<=m
  ensures  base::arr_seg_zero<i,m>;
{
Exception Failure("**context.ml#750:view matching..") Occurred!
===============================================================
# ex6a5.slk -dre "choose_c" -trace-log-num 1 (FIXED)

checkentail x::arr_seg<i+1,n> & r=x+i & r=x1+1 
 |-  [j] x1::arr_seg<j,n> & j=i+1.
print residue.

# to support view matching with arithmetic ..

Entail 2: EXCast. Failure("**context.ml#750:view matching..")
: no residue 

===============================================================
# ex6a5b.slk -dre "choose_c"  (FIXED)

checkentail x::arrI<5> & x=a+1
 |-  x2::arrI<j> & x2=a+1.

# alias set is coming from the right
  but does not work with ptr aritmetic
  (compare ex6a5c.slk)

(==context.ml#3471==)
choose_context@1
choose_context inp1 :LHS node: x::arrI<flted_24_45>@M
choose_context inp2 :RHS node: x2::arrI<j>@M
choose_context inp3 :LHS pure: x=1+a & flted_24_45=5
choose_context inp4 :RHS pure: x2=1+a
choose_context inp5 :right aliase:[]
choose_context@1 EXIT:[]
===============================================================
# ex6a5d.slk -dre "choose_c" (FIXED)

checkentail base::arr_seg<i,n> & a=base+i 
 |-  base2::arr_seg<j,n> & a=base2+i.

!!! **context.ml#742:rhs_ptr:base2
!!! **context.ml#736:rhs(eq):[ n_58=n, a=i+base2]
!!! **context.ml#737:sel_rhs: a=i+base2

# alias set for base_ptr does not work.
  Is there a notion that two base-ptrs share the same root?
  This is so if we can prove that 
     base1-base_2 >= 0
  They share some ptr vars that can be shown to be equiv.

(====)
choose_context@2
choose_context inp1 :LHS node: base::arr_seg<i,n>@M
choose_context inp2 :RHS node: base2::arr_seg<j,n_73>@M
choose_context inp3 :LHS pure: a=i+base
choose_context inp4 :RHS pure: a=i+base2 & n_73=n
choose_context inp5 :right aliase:[(n_73,n)]
choose_context@2 EXIT:[]
===============================================================
# ex6a5d1.slk 

# logging below is wrong

 log(bigger)(>4s)(4):(20.,[(SAT:63<3:Z3,5.);
 (SAT:69<4:Z3,5.);(SAT:83<6:Z3,5.);(SAT:99<8:Z3,5.)])
Total verification time: 0.157231 second(s)
	Time spent in main process: 0.118078 second(s)
	Time spent in child processes: 0.039153 second(s)
===============================================================
# ex6d3a.ss 

arr_seg_sorted<i,n,mi> == x::arrI<mi> & i=n-1 
  or x::arrI<mi>*self::arr_seg_sorted<i+1,m2> & x=self+i 
       & i>=0 & i<n-1 & mi<=m2
  inv n>i & i>=0;

# funny error message

Exception occurred: Failure("predicate arr_seg_sorted does not have the correct number of arguments[flted_10_24,m2] vs [\"\",\"\",\"\"]")
Error3(s) detected at main 
===============================================================
# ex6d3b.slk (FIXED x->a)

checkentail
  a::arrI<i> * base::arr_seg_sorted<i+1,n,i+1>
   & x=base+i & i>=0 & i<n-1 & mi<=m2
  |- base::arr_seg_sorted<i,n,i>.

# why isn't folding working properly..

 ### LHS : a::arrI<i>@M * base::arr_seg_sorted<flted_15_103,n,flted_15_102>@M
 ### RHS : base::arr_seg_sorted<i_136,n_137,i_138>@M
 ### matches :
[ Type: Root
 LHS: base::arr_seg_sorted<flted_15_103,n,flted_15_102>@M
 RHS: base::arr_seg_sorted<i_136,n_137,i_138>@M
 root_inst: None
 lhs_rest: a::arrI<i>@M
 rhs_rest: emp
 alias set: [base]rhs_inst: []rhs_infer: None]
===============================================================
# ex6d3d.slk (FIXED)

# to improve actual root computation : (DONE)

# folding still not working for arr_seg2 example..

pred arr_seg2<i,n> == x::arrI<_> & i=n-1 & i>=0
  or x::arrI<mi>*self::arr_seg2<i+1,n> & x=self+i 
       & i>=0 & i<n-1 
  inv n>i & i>=0.

checkentail
  a::arrI<i> * base::arr_seg2<i+1,n> & x=base+i & i>=0 & i<n-1 
  |- base::arr_seg2<i,n>.

# why isn't non-empty folding working properly..
  actual root not correctly captured?

!!! **astsimp.ml#2708:lst(choose smallest in each branch):
  [[(x, i+1=n & x=i+self)],[(x, x=i+self)]]
!!! **astsimp.ml#2711:TODO: ensuresame root for all branches:
  [(x, i+1=n & x=i+self)]
!!! **astsimp.ml#2714:TODO: lst(fresh_name):
  [(x, i+1=n & x=i+self)]
!!! **astsimp.ml#2741:Actual roots..:
  [(x, i+1=n & x=i+self)]

!!! **astsimp.ml#2710:lst(choose smallest in each branch):[[(x, i+1=n & x=i+self)],[(x, x=i+self)]]
(====)
simplify(TP)@19
simplify(TP) inp1 : ((i+1=n & x=i+self) | x=i+self)
simplify(TP)@19 EXIT: ((i+1=n & x=i+self) | x=i+self)


Possibly empty
--------------
 actual_root: 
  Some((x, x=i+self))

Non-empty
---------
actual_root: 
  None

 [[ COND ==>  BaseCaseUnfold]]
 CEX:false
Validate 1: Expecting(3)Valid BUT got : Fail_May

===============================================================
# ex6d3d2.slk (see ex6d3e.slk for examples) (FIXED)

checkentail
  x::arrI<_> & x=base+j & j>=0 
  |- (exists i: x2::arrI<_> & x2=base+i).
expect Valid.

!!! **context.ml#671:view_root_rhs:None
!!! **context.ml#692:same_base:[]
   ---> include also rhs? if existential?
!!! **context.ml#715:lhs_p: 0<=j & x=j+base
!!! **context.ml#723:lhs_nodes(ptr_arith):[x]
!!! **context.ml#736:rhs(eq):[ x2=i_77+base]
!!! **context.ml#737:sel_rhs: x2=i_77+base
!!! **context.ml#751:rhs_inst_eq:[ x2=i_77+base]
!!! **context.ml#752:rhs_ptr:x2
!!! **context.ml#803:estate:  x::arrI<Anon_13>@M&0<=j & x=j+base&{FLOW,(20,21)=__norm#E}[]
 es_evars: [i_77]
 es_gen_impl_vars(E): [x2; Anon_14]
 es_evars: [i_77]

# same base? existential var?
===============================================================
# ex6d3f1.slk (FIXED by adding eqn' into same base)

checkentail a::arrI<i>@M& x=i+base & a=x & i>=0
 |-  base::arr_seg_sorted<i,m,i> . 

# transitive same_base via eq

!!! **context.ml#739:rhs(eq):[ n_105=m, mi_104=i_89, a=i_88+base, flted_6_106=1+i_88]
!!! **context.ml#740:sel_rhs: flted_6_106=1+i_88 & a=i_88+base
!!! **context.ml#754:rhs_inst_eq:[ flted_6_106=1+i_88 & a=i_88+base]
!!! **context.ml#755:rhs_ptr:a
!!! **context.ml#671:view_root_rhs:Some((x_107, base=x_107-flted_6_106))
!!! **context.ml#694:same_base:[(x,base)]
!!! **context.ml#695:same_base_rhs:[(a,base)]
!!! **context.ml#718:lhs_p: x=base+i & a=x & 0<=i
!!! **context.ml#726:lhs_nodes(ptr_arith):[a]
===============================================================
# ex6d3f3.sl --pcp (FIXED)

pred arr_seg_sorted<i,n,mi> == x1::arrI<mi> & x1=self+i & i=n-1 & i>=0
  or x::arrI<mi>*self::arr_seg_sorted<i+1,n,m2> & x=self+i 
       & i>=0 & i<n-1 & mi<=m2

   actual_root: 
  Some((x1, true))

# Need to do consistent renaming for each branch.

!!! **astsimp.ml#2712:lst(choose smallest in each branch):[[(x1, i+1=n & x1=i+se
lf)],[(x, x=i+self)]]
!!! **astsimp.ml#2681:need to rename root var
!!! **astsimp.ml#2715:TODO: ensure same root for all branches:[(x1, true)]
!!! **astsimp.ml#2718:TODO: lst(fresh_name):[(x1, true)]
===============================================================
# ex6d3d4.slk -dre "choose_c" (FIXED with sorting)

  checkentail_exact
  y::arrI<_> * x::arrI<_> & x=base+j & y=x+1 & j>=0 //& i<n 
  |- base::arr_seg2<i,n>.


<1>x::arrI<Anon_14>@M&j=i-1 & base=(x-i)+1 & y=x+1 & n=i+1 & 1<=i&{FLOW,(20,21)=__norm#E}[]
[[ COND ==>  Fold ==>  COND ==>  Match(y,x_110)]]

# Sort list of matched item, so that smaller ones come first
  esp for folding.

--------------------------
(==context.ml#3523==)
choose_context@1
choose_context inp1 :LHS node: y::arrI<Anon_13>@M * x::arrI<Anon_14>@M
choose_context inp2 :RHS node: base::arr_seg2<i,n>@M
choose_context inp3 :LHS pure: 0<=j & y=1+x & x=j+base
choose_context inp4 :RHS pure: true
choose_context inp5 :right alias:[]
choose_context@1 EXIT:[ Type: Root
 LHS: y::arrI<Anon_13>@M
 RHS: base::arr_seg2<i,n>@M
 root_inst: Some(y)
 lhs_rest: x::arrI<Anon_14>@M
 rhs_rest: emp
 alias set: [x,y,base]rhs_inst: []rhs_infer: None, Type: Root
 LHS: x::arrI<Anon_14>@M
 RHS: base::arr_seg2<i,n>@M
 root_inst: Some(x)
 lhs_rest: y::arrI<Anon_13>@M
 rhs_rest: emp
 alias set: [x,y,base]rhs_inst: []rhs_infer: None]
===============================================================
# ex6d3d5.slk

checkentail
  x::arrI<_> & x=base+j & j>=0 
  |- (exists i: x2::arrI<_> & x2=base+i).

Can we infer base:arrI from above?
===============================================================
# ex7a.slk

pred arr_seg<i,n> == i=n & i>=0
  or x::arrI<_>*self::arr_seg<i+1,n> & x=self+i & i>=0
  inv BG([],i=n&i>=0) | BG([x], x=self+i & i<n & i>=0).

!!! **astsimp.ml#2113:baga_over_formula: 
 emp&(exists(x:i=x-self & self<=x & x!=null & x<(n+self)) 
     | (i=n & 0<=n))

!!! **WARNING****astsimp.ml#2470:extr_exists_vars TBI
===============================================================
# ex7a1.slk -dre "h_formula_2_mem" --trace-log-num 25

# unsound false:
  baga over inv: [([(x,y)], x=i+self & y=n+self & i<=n & 0<=i)]
  baga over inv (unfolded): [([(x,y)], x=i+self & y=n+self & i<=n & 0<=i)]

@25! **cast.ml#1703:look_up_view_baga: baga= :Some([([(xxx,y)], xxx=i+self & y=n+self & i<=n & 0<=i)])
@25! **cast.ml#1706:from_svs:[self,i,n]
@25! **cast.ml#1707:to_svs:[base,i,n]
@25! **cast.ml#1716:baga (subst)= :[([(xxx,y)], xxx=i+base & y=n+base & i<=n & 0<=i)]
@25! **excore.ml#622:Omega mk_star_disj:start 1 invocations
@25! **excore.ml#626:Omega mk_star_disj:end 1 invocations
@25! **WARNING****cpure.ml#5900:TODO: get_pure**cpure.ml#5900:
@25!:0: 0: **tpdispatcher.ml#2119:SAT #41
@25!:0: 0: **tpdispatcher.ml#2120: xxx=1 & xxx=i+base & y=n+base & i<=n & 0<=i
@25! **cast.ml#1723:baga (filtered)= :[([xxx], xxx=i+base & y=n+base & i<=n & 0<=i)]
@25! **cast.ml#1726:baga (hulled)= :[xxx]
@25! **cvutil.ml#916:baga(view_node):[xxx]

(==cvutil.ml#1354==)
h_formula_2_mem@23
h_formula_2_mem inp1 : xxx::arrI<Anon_11>@M * self::arr_seg<flted_7_13,n_14>@M
h_formula_2_mem inp2 : flted_7_13=1+i & xxx=i+self & 0<=i & n_14=n
h_formula_2_mem inp3 :[]
h_formula_2_mem@23 EXIT: [[xxx,self,self]]

(==cvutil.ml#1740==)
h_formula_2_mem@24
h_formula_2_mem inp1 : base::arr_seg<i,n>@M * base::arr_seg<j,m>@M
h_formula_2_mem inp2 : true
h_formula_2_mem inp3 :[]
h_formula_2_mem@24 EXIT: [[xxx,xxx]]

(==cvutil.ml#1354==)
h_formula_2_mem@25
h_formula_2_mem inp1 : base::arr_seg<i,n>@M * base::arr_seg<j,m>@M
h_formula_2_mem inp2 : true

h_formula_2_mem inp3 :[]
h_formula_2_mem@25 EXIT: [[xxx,xxx]]

checkentail base::arr_seg<i,n> * base::arr_seg<j,m>
   |-  false.
expect Fail.

 <1>hfalse&false&{FLOW,(20,21)=__norm#E}[]
===============================================================
# ex7a1b.slk (FIXED)

# why is there a false..

  view_domains: 
   view arr_seg<i:int,n:int>= 
    EList
      :EBase 
         (* lbl: *){1}->emp&i=n & 0<=i&{FLOW,(1,26)=__flow#E}[]
      || :EBase 
            (* lbl: *){2}->hfalse&false&{FLOW,(1,26)=__flow#E}[]
      
  view vars: i,n
  cont vars: n
  unstructured formula: 
    (* lbl: *){1}->emp&i=n & 0<=i&{FLOW,(1,26)=__flow#E}[]
    || (* lbl: *){2}->hfalse&false&{FLOW,(1,26)=__flow#E}[]

================================================================
# ex7a1b.slk -dre "ef_unsat\|.*enum\|get_spec_baga\|is_sat_tp" 

# need fresh existential is_sat_tp..


(====)
is_sat_tp@31@25@1
is_sat_tp inp1 : y=n+self & (1+i)<=n & 0<=(1+i) & 1+i+self=i+self & (1+i+self)!=null & 
 (1+i+self)!=null & 0<=i
is_sat_tp@31 EXIT:false

(====)
imply_mix_formula#1@25@1
imply_mix_formula#1 inp1 : ((i=n & 0<=i) | 
  (y=n+self & (1+i)<=n & 0<=(1+i) & 1+i+self=i+self & (1+i+self)!=null & 
   (1+i+self)!=null & 0<=i))
imply_mix_formula#1 inp2 :Some( ((i=n & 0<=i) | 
  (y=n+self & (1+i)<=n & 0<=(1+i) & 1+i+self=i+self & (1+i+self)!=null & 
   (1+i+self)!=null & 0<=i)))
imply_mix_formula#1 inp3 : 0<=i & i<=n & y=self+n & xxx=self+i & xxx!=null
imply_mix_formula#1 inp4 : []
imply_mix_formula#1@25 EXIT:(false,Some(([ i=n & 0<=i, y=n+self & (1+i)<=n & 0<=(1+i) & 1+i+self=i+self & (1+i+self)!=null & 
 (1+i+self)!=null & 0<=i],[ i=n & 0<=i, y=n+self & (1+i)<=n & 0<=(1+i) & 1+i+self=i+self & (1+i+self)!=null & 
 (1+i+self)!=null & 0<=i])))

===============================================================
# ex7a1c.slk (FIXED by not unfolding ptr view for dupl unfolding)

checkentail base::arr_seg<i,n> * base::arr_seg<j,m>
   |-  i<=n.

-dre "ef_unsat\|.*enum\|get_spec_baga\|add_epure" 

Entail 5: Fail.(may) cause:OrL[
infinite unfolding,
valid
]

Validate 5: Expecting(3)Valid BUT got : Fail_May

===============================================================
# ex7a1c.slk 

# for merging @L + @A etc nodes..

!!! **immutable.ml#2634:* between overlapping heaps:( base::arr_seg<i,n>@M, base::arr_seg<j,m>@M)
(====)
compatible_nodes@2
compatible_nodes inp1 : base::arr_seg<i,n>@M
compatible_nodes inp2 : base::arr_seg<j,m>@M
compatible_nodes@2 EXIT:(false, base::arr_seg<i,n>@M,None,[])

!!! **immutable.ml#2634:* between overlapping heaps:( base::arr_seg<i,n>@M, base::arr_seg<j,m>@M)
!!! **immutable.ml#2634:* between overlapping heaps:( base::arr_seg<i,n>@M, base::arr_seg<j,m>@M)

===============================================================
# ex6d5.ss 

# fail in post-cond proving..

id: 64; caller: []; line: 45; classic: false; kind: POST; hec_num: 1; evars: []; impl_vars: []; infer_vars: [ ]; c_heap: emp; others:  es_infer_obj: [] globals: [@flow,@ver_post]
 checkentail x_2205::arrI<mi_2202>@M * 
 base::arr_seg_sorted<flted_10_2204,n_2203,m2_2206>@M * a_2220::arrI<v'>@M&
a!=null & Anon_12=Anon_14 & a_2220=a & v'<=v_2165 & v_2165=mi_2202 & 
a_2164=x_2205 & flted_10_2204=1+flted_44_2145 & x_2205=flted_44_2145+base & 
0<=flted_44_2145 & (flted_44_2145+1)<m_2144 & mi<=m2_2206 & mi_2202=mi & 
n_2203=m_2144 & !(v_bool_48_2001') & m_2144=m & flted_44_2145=1+i & 
(1+i)!=m & a=i+base & 0<=i & v'=v & m'=m & i'=i & base'=base & (1+i')!=m' & 
v_bool_53_2000' & MayLoop[]&{FLOW,(4,5)=__norm#E}[]
 |-  (exists i_121,m_122,
flted_45_118: base::arr_seg_sorted<i_121,m_122,flted_45_118>@M&
flted_45_118=min(v,mi) & i_121=i & m_122=m&{FLOW,(4,5)=__norm#E}[]). 
ho_vars: nothing?
res:  failctxfe_kind: MAY
        fe_name: separation entailment
        fe_locs: {
    fc_message: base_case_unfold failed
    fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}
  }

===============================================================
# ex7a2.slk

 infer[] base::arr_seg<0,1> * base::arr_seg<0,1> |- false.

# should be Valid

 Entail (1) : Fail.(must) cause: true |-  false. LOCS:[0] (RHS: contradiction)

-pnum 3

(==cvutil.ml#1758==)
h_formula_2_mem@145@144
h_formula_2_mem inp1 : yy::arrI<Anon_12>@M * yy::arrI<Anon_13>@M
h_formula_2_mem inp2 : true
h_formula_2_mem inp3 :[]
h_formula_2_mem@145 EXIT: [[yy,yy]]

-dre "xpure\|.*_mem" -pnum 2 --trace-log-num 145
(==cvutil.ml#1758==)
h_formula_2_mem@145@144
h_formula_2_mem inp1 : base::arr_seg<flted_15_95,flted_15_94>@M * 
 base::arr_seg<flted_15_93,flted_15_92>@M
h_formula_2_mem inp2 : flted_15_95=0 & flted_15_94=1 & flted_15_93=0 & flted_15_92=1
h_formula_2_mem inp3 :[]
h_formula_2_mem@145 EXIT: []

===============================================================
# ex6d3e --pnum 4

# re-ordering caused failure..

 x_2205::arrI<mi_2202>@M 
 * a_2220::arrI<v'>@M

!!! **sleekengine.ml#1383:inside run_infer_one_pass:4
Entail (4) : Fail.(may) cause:base case unfold failed

===============================================================
# ex7a2d.slk --pcp --print-type (FIXED)

pred arr_seg2<iii,n> == iii=n & iii>=0 & self!=null
  or xxx::arrI<_>*self::arr_seg2<iii+1,n> & xxx=self+iii & iii>=0 & self!=null
  inv n>=iii & iii>=0 & self!=null.

# why does adding self!=null caused view_data_name and actual_root information to be
  lost?

  view_data_name: 
  type_of_self: 
  None
  actual_root: 

===============================================================
# ex7a3a.slk (FIXED)

 infer[] base::arr_seg<0,1> * base::arr_seg<0,1> |- false.

# Where is _!=null introduced?

!!! **astsimp.ml#2443:inv:(_ != null) & ((n >= i) & (i >= 0))

===============================================================
# ex7a3c.slk

# expect failure of invariant

can we have expect Fail for baga inv..

# Why the warnings below? (FIXED)

!!! **WARNING****cpure.ml#6007:is_eq_baga may be unsound
!!! **WARNING****cpure.ml#6007:is_eq_baga may be unsound
!!! **WARNING****cpure.ml#6007:is_eq_baga may be unsound
===============================================================
# ex7a3a.slk (to improve)

# -dre "compute_unfold_baga"

# unfolded loses precision ..

baga over inv: [([(_,( self+i, n-i))], i<=n & 0<=i)]
  baga over inv (unfolded): [([], 0<=i & i<=n)]

(==astsimp.ml#1973==)
compute_unfold_baga@1
compute_unfold_baga inp1 :Some([([(_,( self+i, n-i))], i<=n & 0<=i)])
compute_unfold_baga inp2 : (* lbl: *){1}->emp&i=n & 0<=i&{FLOW,(1,26)=__flow#E}[]
 or (* lbl: *){2}->(exists n_14,flted_7_13,xxx,
    Anon_11: (* lbl: *){2}->xxx::arrI<Anon_11>@M * 
                            self::arr_seg<flted_7_13,n_14>@M&
    flted_7_13=1+i & xxx=i+self & 0<=i & n_14=n&{FLOW,(1,26)=__flow#E}[])
 
compute_unfold_baga@1 EXIT:Some([([], 0<=i & i<=n)])

# tmp fix below which do not unfold for those with intervals.

(==astsimp.ml#1974==)
compute_unfold_baga@1
compute_unfold_baga inp1 :Some([([(_,( self+i, n-i))], i<=n & 0<=i)])
compute_unfold_baga inp2 : (* lbl: *){1}->emp&i=n & 0<=i&{FLOW,(1,26)=__flow#E}[]
 or (* lbl: *){2}->(exists n_14,flted_7_13,xxx,
    Anon_11: (* lbl: *){2}->xxx::arrI<Anon_11>@M * 
                            self::arr_seg<flted_7_13,n_14>@M&
    flted_7_13=1+i & xxx=i+self & 0<=i & n_14=n&{FLOW,(1,26)=__flow#E}[])
 
compute_unfold_baga@1 EXIT:Some([([(_,( self+i, n-i))], i<=n & 0<=i)])

===============================================================
# ex9a.slk

# need to use real intervals below to detect overlap..

infer[] base::arr_seg<0,2> * base::arr_seg<1,2>  |- false.
expect Valid.

  # normalization
  [(a,d1)],[(c,d2)] & c=a+d1 --> [(a,d1+d2)]
  [(a,d)] & d<=0  --> []
  [a] --> [(a,1)]

  [a],[(c,d)] & c=a+1 --> [(a,d+1)]
  [(c,d)],[a] & a=c+1 --> [(c,d+1)]

  # false detection
  [(a,d1)],[(b,d2)] &  b<a+d1 & a<b+d2 --> false
    (a..a+d1 b..b+d2) // 
  [(a,d1)],[(a,d2)] &  d1!=0 & d2!=0 --> false

   # sorting..
   a<c --> (a,d1) < (c,d2)
   a>c --> (a,d1) > (c,d2)
   a=c --> (a,d1) = (c,d2)

  (* throws exception when duplicate detected during merge *)
  let norm_baga (state:formula) (b:t list) = 
    let () = y_binfo_pp x_tbi in
    b
  let rec merge_baga b1 b2 =

===============================================================
# ex6e.ss 

# check and elim warnings below..


 !!! **astsimp.ml#2740:inconsistent roots:[[]]
!!! **astsimp.ml#2740:inconsistent roots:[[]]
!!! **astsimp.ml#2740:inconsistent roots:[[]]
!!! **astsimp.ml#2740:inconsistent roots:[[]]
!!! **astsimp.ml#2740:inconsistent roots:[[]]
!!! **astsimp.ml#2740:inconsistent roots:[[]]

# print views checked..

Inv Check: Valid.(Over)

Inv Check: Valid.(Over)

Inv Check: Valid.(Over)

Inv Check: Valid.(Over)
===============================================================
# ex6e3e.slk (FIXED)

-dre ".*univ" --trace-log-num 2

do_universal@2@1
do_universal inp1 : xx::arr_seg<i,n>@M
do_universal inp2 : emp&i<n&{FLOW,(20,21)=__norm#E}[]
do_universal inp3 : xx::arr_seg<flted_12_100,n_99>@M&flted_12_100=1+i & n_99=n&
{FLOW,(20,21)=__norm#E}[]

!!! **solver.ml#14218:f_univ_vars:[mmm_105]
!!! **solver.ml#14232:lhs_guard_p: i<mmm_105 & mmm_105<=n

# need to first prove guard existentially satisfiable.
# after that add i<mmm_105 & mmm_105<=n & Univ(mmm_105) to LHS together with
==============================================================
# ex6e3f.slk 

//(4)
checkentail xx::arr_seg<i,n> & i<n |- [mm] xx::arr_seg<mm,n> & mm=i+2.
print residue.
expect Fail.
// isn't this unsound?
===============================================================
ex6e3f2.slk (FIXED)

checkentail x::arrI<m> & i<m & m<=n |- [mm] x::arrI<mm> & mm=i+2 .

# explicit inst mm=m should go to RHS, not LHS..

imply_timeout 2 inp1 : m<=n & i<m & mm=m & x!=null
imply_timeout 2 inp2 : exists(mm:mm=i+2)
===============================================================
# slower + old-lemma-settings include --old-univ-lemma

Total number of errors: 3 in files:
  lemmas/sll_tailL.slk({L1#Valid},{L2#Valid}) lemmas/dseg-new.slk({L2#Fail},{L3#Valid}) lemmas/dseg1.slk({L1#Valid}).
!!! WARNING: for "no result" errors please check the script's options, provers' settings, etc.
Total verification time: 275.29 second
	Time spent in main process: 153.89 second
	Time spent in child processes: 121.40 second
	Number of false contexts: 98
===============================================================
ex6e3f3.slk  (below is OK)

# expl inst may go to LHS if Univ not present in LHS
  since we may allowed it to strengthen formula on LHS?
# alternative is to add Univ(m) on LHS?

checkentail x::arrI<m> & i<m & m<=n |- [mm] x::arrI<mm> & mm=i+1 .
expect Valid.
// fails when mm=m move to RHS ..
// unsound if Univ(m) is present to move to LHS..

checkentail x::arrI<m> & m>3 |- [mm] x::arrI<mm> & mm=4.
expect Valid.
// fail but expect Valid when m=mm move to RHS?

===============================================================
# ex6e3f4.slk 

checkentail  i<m & m<=n & mm=m & Univ(m) |- mm=i+1 .

 <1>emp&Univ(m) & mm=m & m<=n & i<m&{FLOW,(20,21)=__norm#E}[]

# can we add the instantiation m=i+1 after the proving?
  so that its universal instantiation value can be fixed
  by such proving. need to add mm=i+1 to LHS after proving
  to support universal instantiation

# the inst probably done at heap_empty_rhs, and could be signalled
  by some univ_flag from @4 or @2.

(====)
imply_timeout 1@5@3@2@1
imply_timeout 1 inp1 : Univ(m) & mm=m & m<=n & i<m
imply_timeout 1 inp2 : exists(m:exists(mm:mm=i+1 & mm=m) & m<=n & i<m)
imply_timeout 1@5 EXIT:true

(==tpdispatcher.ml#3804==)
imply_timeout 2@3@2@1
imply_timeout 2 inp1 : Univ(m) & mm=m & m<=n & i<m
imply_timeout 2 inp2 : mm=i+1
imply_timeout 2@3 EXIT:true

(==tpdispatcher.ml#3818==)
imply_timeout 3@2@1
imply_timeout 3 inp1 : Univ(m) & mm=m & m<=n & i<m
imply_timeout 3 inp2 : mm=i+1
imply_timeout 3 inp3 :timeout:10.
imply_timeout 3 inp4 :2
imply_timeout 3@2 EXIT:true

(==solver.ml#7980==)
heap_entail_empty_rhs_heap#1@1
heap_entail_empty_rhs_heap#1 inp1 :es:
  emp&Univ(m) & mm=m & m<=n & i<m&{FLOW,(20,21)=__norm#E}[]
 es_gen_impl_vars(E): []
 
heap_entail_empty_rhs_heap#1 inp2 :lhs-base-f: emp&Univ(m) & mm=m & m<=n & i<m&{FLOW,(20,21)=__norm#E}[]
heap_entail_empty_rhs_heap#1 inp3 :rhs-mix: mm=1+i
heap_entail_empty_rhs_heap#1 inp4 :is_folding:false
heap_entail_empty_rhs_heap#1@1 EXIT: [ emp&Univ(m) & mm=m & m<=n & i<m&{FLOW,(20,21)=__norm#E}[]
  es_gen_impl_vars(E): []
  ]

===============================================================
===============================================================
===============================================================
===============================================================
===============================================================
===============================================================
===============================================================
===============================================================
===============================================================
===============================================================
===============================================================
===============================================================
===============================================================
===============================================================
