void init(int arr[], int pos){
   if (pos < len) {
     arr[pos] = 0;
     init(arr, pos+1);
   }
}
P(arr, pos, len) as pre-condition.

A: P(arr, pos,len) & pos<length |- arr::elem(pos,_) * R(arr,pos,len)
B: arr::elem(pos,_) * R(arr,pos,len) & pos<len |- P(arr,pos+1,len) * R1(arr,pos,len)
===
A: P(arr, f1(pos,len),f2(pos,len)) & pos<length |- arr::elem(pos,_) --> ( P(arr, pos, len) => P1(arr,f1(pos,len),pos) * arr::elem(pos,_) * P2(arr,pos+1,f2(pos,len))
B: P1(arr,f1(pos,len),pos) * arr::elem(pos,_) * P2(arr,pos,f2(pos,len)) |- P(arr,f1(pos+1,len),f2(pos+1,len)
P1(arr,f1(pos,len),pos) * arr::elem(pos,_) * P2(arr,pos+1,f2(pos,len)) |- P1(arr,f1(pos+1,len),pos+1) * arr::elem(pos+1,_) * P2(arr,pos+2,f2(pos+2,len))
P1(arr,f1(pos,len),pos) * arr::elem(pos,_) => P1(arr,f1(pos+1,len),pos+1)
P1(arr,k1*pos+k2*len+k3,pos) * arr::elem(pos,_) => P1(arr,k1*pos+k2*len+(k1+k3),pos+1)
P1'(arr,k1*pos+k2*len+k3,k1*pos+k2*len+(k1+k3)) * P1(arr,k1*pos+k2*len+(k1+k3),pos) * arr::elem(pos,_) =>  P1(arr,k1*pos+k2*len+(k1+k3),pos+1)


P1'(arr,f1(pos+1,len),f1(pos,len)) * P1(arr,f1(pos,len),pos) *  arr::elem(pos,_) => P1(arr,f1(pos+1,len),pos+1)


P2(arr,pos+1,f2(pos,len))  => arr::elem(pos+1,_) * P2(arr,pos+2,f2(pos+2,len)) * R2(arr,f2(pos+2,len),f2(pos,len))

===

1. pre-processing
Target: Transform to ones with same predicates in both sides

replace P(arr,pos,len) & pos<len with arr::elem(pos,_) * R(arr,pos,len) & pos<len
B will be:
arr::elem(pos,_) * R(arr,pos,len) & pos<len |- arr:elem(pos+1,_) * R(arr,pos+1,len) * R1(arr,pos,len)

arr::elem(pos+1,_) can only be matched by R(arr,pos,len)
rewrite R(arr,pos,len) as arr::elem(pos+1,_) * R2(arr,pos,len)

arr::elem(pos,_) * arr::elem(pos+1,_) * R2(arr,pos,len) & pos<len |- 
arr:elem(pos+1,_) * arr::elem(pos+2,_) * R2(arr,pos+1,len) * R1(arr,pos,len)

match arr:elem(pos+1,_)
arr::elem(pos,_) * R2(arr,pos,len) & pos<len |- 
arr::elem(pos+2,_) * R2(arr,pos+1,len) * R1(arr,pos,len)

compared with
arr::elem(pos,_) * R(arr,pos,len) & pos<10 |- 
arr:elem(pos+1,_) * R(arr,pos+1,len) * R1(arr,pos)

Since arr::elem(pos,_) and R1(arr,pos,len) do not change, they should be matched, hence R1(arr,pos,len)

R2(arr,pos,len) & pos<len |- 
arr::elem(pos+2,_) * R2(arr,pos+1,len)

similarly ?????
R(arr,pos,len) & pos<len |- 
arr:elem(pos+1,_) * R(arr,pos+1,len)
Now with both sides R, we can assume that R is a single predicate plus a common heap
assume R = Aseg() * Q, Q can be removed

Assume R = Aseg(f1(pos), f2(pos))
f1(pos) = min(pos+1, f1(pos+1))
f2(pos) = max(pos+1, f2(pos+1))
f2(pos)-f1(pos) = 1 + f2(pos+1)-f1(pos+1)
(pos+1=f1(pos+1)-1 or pos+1==f2(pos+1))


============================================================
void init(int arr[], int pos){
   if (arr[pos] != arr[length]) {
     arr[pos] = 0;
     init(arr, pos+1);
   }
}

void init(int arr[], int pos){
   int tmp1 = arr[pos];
   int tmp2 = arr[length];
   if (tmp1 != tmp2) {
     arr[pos] = 0;
     init(arr, pos+1);
   }
}

void init(int arr[], int pos){
   int tmp1 = arr[pos];
   int tmp2 = arr[length];
   if (*) {
     arr[pos] = 0;
     init(arr, pos+1);
   }
}


===
P(arr,f1(pos,len),f2(pos,len)) |- arr::elem(pos,v1) --> (P(arr,f1(pos,len),f2(pos,len)) => P1(arr,f1(pos,len),pos) * arr::elem(pos,v1) * P2(arr,pos+1,f2(pos,len))

===

P(arr,pos) |- arr::elem(pos,v1) * R(arr,pos)
arr::elem(pos,v1) * R(arr,pos) |- arr::elem(length, v2) * R1(arr,pos)
arr::elem(length, v2) * R1(arr,pos) & v1!=v2 |- arr::elem(pos,v1) * R2(arr,pos)
arr::elem(pos,_) * R2(arr,pos) |- P(arr, pos+1) * R3(arr,pos)

P(arr,pos) |- arr::elem(pos,v1) * R(arr,pos)
arr::elem(pos,v1) * R(arr,pos) |- arr::elem(length, v2) * R1(arr,pos)
pos > length pos = length pos < length
pos > length or pos < length
arr::elem(length, v2) * R1(arr,pos) & v1!=v2 |- arr::elem(pos,v1) * R2(arr,pos)
arr::elem(pos,_) * R2(arr,pos) |- P(arr, pos+1) * R3(arr,pos)


pos > length:
R(arr, pos) = arr::elem(l, _) * S2(arr,pos,l)
R1(arr,pos) = arr::elem(pos,_) * S2(arr,pos,l)
P(arr,pos) = arr::elem(pos,_) * S2(arr,pos,l) * arr::elem(l,_)

arr::elem(length, v2) * R1(arr,pos) & v1!=v2 |- arr::elem(pos,_) * R2(arr,pos)
==>
arr::elem(length, v2) * arr::elem(pos,_) * S2(arr,pos,l) & v1!=v2 |- arr::elem(pos,_) * R2(arr,pos)
== match ==>
arr::elem(length, v2) * S2(arr,pos,l) & v1!=v2 |- R2(arr,pos)

arr::elem(pos,_) * R2(arr,pos) |- P(arr, pos+1) * R3(arr,pos)
== replace R2 & P==>
arr::elem(pos,_) * arr::elem(l, v2) * S2(arr,pos,l) |- 
arr::elem(pos+1,_) * S2(arr,pos+1,l) * arr::elem(l,_) * R3(arr,pos)
== match ==>
A:
arr::elem(pos,_) * S2(arr,pos,l) |- 
arr::elem(pos+1,_) * S2(arr,pos+1,l)  * R3(arr,pos)

S2(arr,pos,l) = arr::elem(pos+1) * R4(arr,pos,l)

arr::elem(pos,_) * arr::elem(pos+1) * R4(arr,pos,l) |- 
arr::elem(pos+1,_) *  arr::elem(pos+2) * R4(arr,pos+1,l) * R3(arr,pos)
==>
B:
arr::elem(pos,_) * R4(arr,pos,l) |- 
arr::elem(pos+2) * R4(arr,pos+1,l) * R3(arr,pos)

A and B has similar structure, R3 and arr::elem(pos,_) unchanged,
R3 and arr:elem(pos,_) have to match

arr::elem(pos,_) * S2(arr,pos,l) |- 
arr::elem(pos+1,_) * S2(arr,pos+1,l)  * R3(arr,pos)
==>
S2(arr,pos,l) |- 
arr::elem(pos+1,_) * S2(arr,pos+1,l)
==> with the condition pos>length, it is not possible to conclude
S2(arr,pos,l) |- 
arr::elem(pos+1,_) * arr::elem(pos+2,_) * S2(arr,pos+2,l)
if S2(arr,pos,l) = aseg(pos,l), pos<=length

P(arr, pos) & pos<length |- arr::elem(pos,v1) * R(arr,pos)
arr::elem(pos,v1) * R(arr,pos) & v1 = tmp1 |- arr::elem(length, v2) * R1(arr,pos)


===========================================================
void bubble_push(int arr[], int i, int m){
   if (i<m-1){
      bubble_push(arr, i+1, m);
      int tmp1 = arr[i];
      int tmp2 = arr[i+1];
      if (tmp1>tmp2) {
        arr[i] = tmp2;
        arr[i+1] = tmp1;
      }
   }
}

P(arr, i, m) |- P(arr, i+1, m) * R1(arr, i, m)
P(arr, i+1, m) * R1(arr, i, m) |- arr::elem(i,_) * R2(arr, i, m)
arr::elem(i,_) * R2(arr, i, m) |- arr::elem(i+1,_) * R3(arr,i, m)

arr::elem(i,_) * R2(arr, i, m) |- arr::elem(i+1,_) * R3(arr,i, m)
can be converted to:
arr::elem(i,_) * arr::elem(i+1,_) * R2'(arr, i, m) |- arr::elem(i+1,_) * arr:elem(i,_) * R3'(arr,i, m)
R2'(arr, i, m) |- R3'(arr, i, m) : When one side has only one predicate, the one predicate replaces the other one

P(arr, i, m) |- P(arr, i+1, m) * R1(arr, i, m)
P(arr, i+1, m) * R1(arr, i, m) |- arr::elem(i,_) * arr::elem(i+1,_) * R2'(arr, i, m)


Continuous segment?
How to find minimal?

＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝＝
void init(int arr[], int pos, int len){
   if (pos<len) {
    arr[pos] = 0;
    init(pos+1, len);
   }
}
Start with emp as pre-condition

first round
emp & pos<len |- arr::elem(pos,_) --> ( arr::elem(pos,_) )
emp & pos>=len |- emp --> ( true )
==> pre = pos<len & arr::elem(pos,_) 
          or pos>=len & emp

second round
pre & pos<len = pos<len & arr::elem(pos,_) |- arr::elem(pos,_)
pos<len & arr::elem(pos,_) |- (pos+1<len & arr::elem(pos+1,_) or pos+1>=len & emp)
To solve this one, split left hand side
pos<len & (pos+1<len & arr::elem(pos,_) or pos+1>=len & arr::elem(pos,_) ) |- (pos+1<len & arr::elem(pos+1,_) or pos+1>=len & emp)
simplify as:
(pos+1<len & arr::elem(pos,_) or pos+1==len & arr::elem(pos,_) ) |- (pos+1<len & arr::elem(pos+1,_) or pos+1>=len & emp)
For pos+1<len, infer arr::elem(pos+1,_) as anti-frame
For pos+1=len, success.
The pre will be enhanced as ( pos+1<len & arr::elem(pos,_) * arr::elem(pos+1,_) or pos+1==len & arr::elem(pos,_) )
Since it is in the form arr::elem(pos,_) * arr::elem(pos+k,_), we abstract to the max k
Abstract into ( pos<len & arr::aseg(pos, len) )
==> pre = pos<len & arr::aseg(pos,len)
          or pos>=len & emp

Third round, pre & pos<len = pos<len & arr::aseg(pos,len) |- arr::elem(pos,_)
pos<len & arr::elem(pos,_) & arr::aseg(pos+1,len) |- arr::elem(pos,_)
pos<len & arr::elem(pos,_) & arr::aseg(pos+1,len) |- pos+1<len & arr::aseg(pos+1,len) or pos+1>=len & emp

pos<len & (pos+1<len & arr::elem(pos,_) & arr::aseg(pos+1,len) or pos+1=len & arr::elem(pos,_) & arr::aseg(pos+1,len)) |- 
pos+1<len & arr::aseg(pos+1,len) or pos+1>=len & emp
Both go through, the pre-condition stablizes.

= = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 
void init(int arr[], int pos, int len){
   int tmp1 = arr[pos];
   int tmp2 = arr[len];
   if (tmp1 != tmp2) {
    arr[pos] = 0;
    init(pos+1, len);
   }
}

Start with emp as pre-condition
first round
emp |- arr::elem(pos,_)
==> pre = arr::elem(pos,_)

second round
arr::elem(pos,_) |- arr::elem(pos,_)
arr::elem(pos,v1) & tmp1 = v1 |- arr::elem(len,_)
Solving this gives three answers,
1. pos = len
2. pos<len & arr::elem(pos,v1) * arr::elem(len,_)
3. pos>len & arr::elem(pos,v1) * arr::elem(len,_)
==> pre = 1. pos = len & arr::elem(pos,v1) 
          2. pos<len & arr::elem(pos,v1) * arr::elem(len,_)
          3. pos>len & arr::elem(pos,v1) * arr::elem(len,_)

third round
For 1.
pos = len & arr::elem(pos,v1) & tmp1 = v1 & tmp2 = v1 & tmp1!=tmp2 contradicts
pos = len & arr::elem(pos,v1) & tmp1 = v1 & tmp2 = v1 & tmp1=tmp2 finish

For 2.
pos < len & arr::elem(pos,v1) * arr::elem(len,v2) & v1 = v2 finish

pos < len & arr::elem(pos,v1) * arr::elem(len,v2) & v1 != v2 |-
1. pos+1 = len & arr::elem(pos+1,_)
2. pos+1 < len & arr::elem(pos+1,_) * arr::elem(len,_)
3. pos+1 > len & arr::elem(pos+1,_) * arr::elem(len,_), this path does not work
because pos>len-1.
for pos+1 = len (pos=len-1), arr::elem(pos+1,_) is infered as anti-frame,
for pos+1 < len (pos<len-1), arr::elem(pos+1,_) is infered as anti-frame,
pos+1<=len, arr::elem(pos,v1) * arr::elem(pos+1,_) * arr::elem(len,v2),
abstract as pos+1<=len, arr::aseg(pos,len+1)

For these two cases, the content properties have to be merged,
two branches merge to pos+1<=len, arr::aseg(pos,len+1)

For 3.
pos > len & arr::elem(pos,v1) * arr::elem(len,v2) & v1 = v2 finish

pos > len & arr::elem(pos,v1) * arr::elem(len,v2) & v1 != v2 |-
1. pos+1 = len & arr::elem(pos+1,_)
2. pos+1 < len & arr::elem(pos+1,_) * arr::elem(len,_) this path does not work
3. pos+1 > len & arr::elem(pos+1,_) * arr::elem(len,_)

for pos+1 = len, arr::elem(pos+1,_) is inferred as anti-frame
for pos+1 > len, arr::elem(pos+1,_) is inferred as anti-frame
pos+1>=len, arr::elem(pos,_)*arr::elem(pos+1,_)*arr::elem(len,_),
abstract fails, so we only have !(pos+1>=len) & v1 != v2

Sum up to be
pos = len & arr::elem(pos,v1) 
or pos < len & arr::aseg(pos,len+1)
or pos + 1 < len

================================
But maybe we can have more precise specs
exists k. pos>len & pos<k, elem(len,v) * aseg(pos, pos+k) * elem(pos+k,v),

For 2.
pos < len & arr::elem(pos,v1) * arr::elem(len,v2) & v1 = v2 finish

pos < len & arr::elem(pos,v1) * arr::elem(len,v2) & v1 != v2 |-
1. pos+1 = len & arr::elem(pos+1,_)
2. pos+1 < len & arr::elem(pos+1,_) * arr::elem(len,_)
3. pos+1 > len & arr::elem(pos+1,_) * arr::elem(len,_), this path does not work
because pos>len-1.

for pos+1 < len (pos<len-1), arr::elem(pos+1,_) is infered as anti-frame,
pos<len, v1!=v2 & arr::elem(pos,v1) * arr::elem(pos+1,_) * arr::elem(len,v2),
pos<len, v1=v2 & arr::elem(pos,v1) * arr::elem(len,v2) & v1=v2,


Again, a new round before the recursive call,
pos<len, v1!=v2 & arr::elem(pos,v1) * arr::elem(pos+1,_) * arr::elem(len,v2) |-
1. pos+1 = len & arr::elem(pos+1,_) success
2a. pos+1 < len & arr::elem(pos+1,v1') * arr::elem(len,_) & v1'=v2, success
2b. pos+1 < len & arr::elem(pos+1,v1') * arr::elem(pos+2,_) * arr::elem(len,v2) &
    v1'!=v2
3. pos+1 > len impossible

First, it was
pos<len, v1=v2 & arr::elem(pos,v1) * arr::elem(len,v2)
then, it becomes
pos+1<len, v1!=v2 & v1'=v2 & arr::elem(pos,v1) * arr::elem(pos+1,v1') * arr::elem(len,v2)

Approximate these two safe conditions to exists k: pos<len & v=v2 & arr::aseg(pos,pos+k) * arr::elem(pos+k,v) * arr::elem(len,v2)

For 3. should be similar to 2.

=============================================================================================
void visit_str(char str[], int pos){
  if (str[pos] !='\0') {
     visit_str(str, pos+1);
  }
}

first round:
emp |- str::elem(pos,_)
==> pre = str::elem(pos,_)

second round:
str::elem(pos,_) |- str::elem(pos,_)
str::elem(pos,v) & v='\0' |- emp success
str::elem(pos,v) & v!='\0' |- str(pos+1,_)
==> pre = str::elem(pos,v) & v='\0'
          or str::elem(pos,v) * str::elem(pos+1,v') & v!='\0'

third round:
str::elem(pos,v) * str::elem(pos+1,v') & v!='\0' |-
1. str::elem(pos+1,v') * v'='\0' ==> v'='\0'
2. str::elem(pos+1,v') * str::elem(pos+2,v'') & v'!='\0'
From 
str::elem(pos,v) & v='\0'
or str::elem(pos,v) * str::elem(pos+1,v') & v!='\0'
to
str::elem(pos,v) & v='\0'
or str::elem(pos,v) * str::elem(pos+1,v') & v'='\0'

Approximate to str::aseg(pos,pos+k) * str::elem(pos+k,v) & v='\0'

=============================================================================================
void bubble_push(int arr[], int cur, int len){
   if (cur < len-1) {//At least two elements
      bubble_push(arr, cur+1, len);  
      int tmp1 = arr[cur];
      int tmp2 = arr[cur+1];
      if (tmp1>tmp2) {
        arr[cur] = tmp2;
        arr[cur+1] = tmp1;
      }
    }
}

Start with emp
first round:
emp & cur<len-1 |- emp
emp |- arr::elem(cur,_)
==> pre = cur>=len-1 & emp
          or cur<len-1 & arr::elem(cur)

second round:
cur<len-1 & arr::elem(cur,_) |- arr::elem(cur+1,_) // recursive call
==> pre = cur>=len-1 & emp
          or cur<len-1 & arr::elem(cur,_) * arr::elem(cur+1,_)
These two can be abstracted into
pre = cur>=len-1 & emp
          or cur<len-1 & arr::aseg(cur, top(cur,cur+1))
==>
pre = cur>=len-1 & emp
          or cur<len-1 & arr::aseg(cur, len-1)

third round:
cur<len-1 & arr::aseg(cur, len-1) |- arr::aseg(cur+1,len-1)
cur<len * arr::elem(cur,_) * arr::aseg(cur+1,len-1) |- arr::elem(cur,_)
cur<len * arr::elem(cur,_) * arr::aseg(cur+1,len-1) |- arr::elem(cur+1,_)
cur<len * arr::elem(cur,_) * arr::elem(cur+1,_) * arr::aseg(cur+2,len-1) |- arr::elem(cur+1,_)

===========================================================================================
void init_loop(int arr[], int cur, int len){
    ??
    for (int i=cur; i<len; i++) {
      arr[i] = 0;
    }
    !!
}

infer the point [??]
start with emp
emp |- arr[cur] ==> revise to arr::elem(cur,_)
!! becomes arr[cur]
i++
arr[cur] |- arr[cur+1] => revise to arr::elem(cur,_) * arr::elem(cur+1,_)
abstract to arr::aseg(cur, len) in [??]

===========================================================================================

int test_fun(int a[], int N)
{
    int i;
    int res = 0;
    for (i = 0; i < N; i++) {
        while (a[i] > 0) {
            a[i]--;
            res++;
        }
    }
    return res;
}

infer the inner loop
while (a[i] > 0) {
   a[i]--;
   res++;
}
start with emp,
emp |- a::elem(i,_)
==> pre = a::elem(i,_)
stablize with this one

infer the outer loop
for (i = 0; i < N; i++) {
        while (a[i] > 0) {
            a[i]--;
            res++;
        }
}
emp & i < N |- a::elem(i,_)
==> pre = i>=N & emp
          & a::elem(i,_)
second round:
a::elem(i,_) & i<N |- a::elem(i,_)
a::elem(i,_) & i+1<N |- a::elem(i+1,_)
==> pre = i>=N & emp
          & i=N-1 & a::elem(i,_) 
          & i<N-1 & a::elem(i,_) * a::elem(i+1,_)
abstract to 
==> pre = i>=N & emp
          & i<=N-1 & a::aseg(i,N)

Stablize here

=================================================================================
char *(cstrcat)(char *s1, const char *s2)
 {
     char *s = s1;
     /* Move s so that it points to the end of s1.  */
     while (*s != '\0')
         s++;
     /* Do the copying in a loop.  */
     while ((*s++ = *s2++) != '\0')
         ;               /* The body of this loop is left empty. */
     /* Return the destination string.  */
     return s1;
 }
???

=================================================================================
char *(cstrchr)(const char *s, int c)
 {
     /* Scan s for the character.  When this loop is finished,
        s will either point to the end of the string or the
        character we were looking for.  */
     while (*s != '\0' && *s != (char)c)
         s++;
     return ( (*s == c) ? (char *) s : 0 );
 }
