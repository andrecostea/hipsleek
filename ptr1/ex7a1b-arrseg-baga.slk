
data arrI {
  int val;
}.

pred arr_seg<i,n> == i=n & i>=0
  or xxx::arrI<_>*self::arr_seg<i+1,n> & xxx=self+i & i>=0
  inv BG([(xxx,y)], xxx=self+i & y=self+n & n>=i & i>=0).


// i,n-1  j,m-1
/*
checkentail base::arr_seg<i,n> * base::arr_seg<j,m>
   |-  i=n.
print residue.
expect Valid.
*/

/*
# ex7a1b.slk

xxx (from a node) is not in baga, but 
xxx_51 (from a view) is in baga

ef_unsat@3
ef_unsat inp1 :([xxx_51], flted_7_13=1+i & xxx=i+self & 0<=i 
   & n_14=n & xxx_51=flted_7_13+self & 
 y_52=n_14+self & flted_7_13<=n_14 & 0<=flted_7_13)
ef_unsat@3 EXIT:false

# why is there a false..

  view_domains: 
   view arr_seg<i:int,n:int>= 
    EList
      :EBase 
         (* lbl: *){1}->emp&i=n & 0<=i&{FLOW,(1,26)=__flow#E}[]
      || :EBase 
            (* lbl: *){2}->hfalse&false&{FLOW,(1,26)=__flow#E}[]
      
  view vars: i,n
  cont vars: n
  unstructured formula: 
    (* lbl: *){1}->emp&i=n & 0<=i&{FLOW,(1,26)=__flow#E}[]
    || (* lbl: *){2}->hfalse&false&{FLOW,(1,26)=__flow#E}[]

  (x,y) => x<=y
  (x,y) & x=y = []
  (x,y) & x<y = {x,..,y-1}

  {(x,Some(self,i,n-i))}


# unsound false:
  baga over inv: [([(x,y)], x=i+self & y=n+self & i<=n & 0<=i)]
  baga over inv (unfolded): [([(x,y)], x=i+self & y=n+self & i<=n & 0<=i)]
 

!!! **cast.ml#1704:look_up_view_baga: baga= :
  Some([([(xxx,y)], xxx=i+self & y=n+self & i<=n & 0<=i)])
!!! **cast.ml#1705:baga ex vars= :[xxx,y]

!!! **cast.ml#1723:baga (filtered)= :[([xxx], xxx=j+base & y=m+base & j<=m & 0<=j)]
!!! **cast.ml#1726:baga (hulled)= :[xxx]
!!! **cvutil.ml#916:baga(view_node):[xxx]
!!! **cvutil.ml#1355:h0: base::arr_seg<i,n>@M * base::arr_seg<j,m>@M
!!! **cvutil.ml#1357:memset: [[xxx,xxx]]

checkentail base::arr_seg<i,n> * base::arr_seg<j,m>
   |-  false.
expect Fail.

 <1>hfalse&false&{FLOW,(20,21)=__norm#E}[]


*/

