# ex21.ss

This produced:

  x=(b'-a')+x'+1 & y=(y'-b')+a'+1 & a'<=(b'+x') & b'<=(y'+a') 
   & R(x,y,a',b') -->  R(x',y',a',b'),
  y=(y'-b')+a'+1 & x=(b'-a')+x'+1 & (y'+a')<b' & a'<=(b'+x') 
   & R(x,y,a',b') -->  R(x',y',a',b'),
  x=(b'-a')+x'+1 & y=(y'-b')+a'+1 & (b'+x')<a' & b'<=(y'+a') 
   & R(x,y,a',b')) -->  R(x',y',a',b')]

which seem sufficient to analyse that

   a,b are unchanged across recursion  a'=a, b'=b
   x,y are inductively changed by x'=nxt1(x); y'= nxt2(y)

# more formally:

 parameter analysis for loo

 loo1(x,y,a,b) = [loo2(IND([x,a,b],x+a-b-1)
                      ,IND([y,a,b],y+b-a-1)
                      ,FLOW(a)
                      ,FLOW(b))
                    ,
                  loo1(...)
         ]
 
 a-b-1=0
 b-a-1=0
 a=b
 a-b-1<0
 b-a-1>0
 

# Add an option --analyse-param to trigger the output

  x,y are inductive
  a,b are unchanged

# Earlier context were as follows. Are they similar to above?

  State:
      emp&a'=a & b'=b & y'=y & x=x' & 1<=y & R(x,y,a,b) & 1<=x'
    CtxOR
      emp&a'=a & b'=b & y'=y & x=x' & y<=0 & R(x,y,a,b) & 1<=x'&
    CtxOR
      emp&a'=a & b'=b & x=x' & y'=y & x'<=0 & 1<=y & R(x,y,a,b)&

================================================================
# ex22.ss

This is a command to analyse the parameters of a self-recursive
funtion. It should produce infer in ex21.ss; and later
mention that
  x,y are inductive
  a,b are unchanged
This info should later be attached to proc_decl
================================================================
# ex21a.ss -dre "analyse_param"

(==cformula.ml#1725==)
analyse_param@1
analyse_param inp1 :[( 
x=(b'-a')+x'+1 & y=((a'+y')-b')+1 & (b'+x')<a' & b'<=(a'+y') & R(x,y,a',b'), R(x',y',a',b')),
( y=((a'+y')-b')+1 & x=(b'-a')+x'+1 & (a'+y')<b' & a'<=(b'+x') & R(x,y,a',b'), R(x',y',a',b')),
( x=(b'-a')+x'+1 & y=((a'+y')-b')+1 & a'<=(b'+x') & b'<=(a'+y') & R(x,y,a',b'), R(x',y',a',b'))]
analyse_param inp2 :[(int,x),(int,y),(int,a),(int,b)]
analyse_param@1 EXIT:[[IND([x,b',a',x'], x=(b'-a')+x'+1),IND([y,a',y',b'], y=((a'+y')-b')+1),FLO(a'),FLO(b')],[IND([x,b',a',x'], x=(b'-a')+x'+1),IND([y,a',y',b'], y=((a'+y')-b')+1),FLO(a'),FLO(b')],[IND([x,b',a',x'], x=(b'-a')+x'+1),IND([y,a',y',b'], y=((a'+y')-b')+1),FLO(a'),FLO(b')]]

From this:
x=(b'-a')+x'+1 & y=((a'+y')-b')+1 & (b'+x')<a' & b'<=(a'+y') 
  & R(x,y,a',b'), R(x',y',a',b')),

We need to extract:
 R(x,y,a',b') --> R(x',y',a',b')

And then using:
 x-->x'  with x=(b-a)+x'+1     
 y-->y'  with y=((a+y')-b)+1
 a-->a' with a=a'
 b-->b' with b=b'

After that, we re-arrange the formula to give:
 x-->x'  with x'=x-(b-a)-1     
 y-->y'  with y'=y-(a-b)-1
 a-->a' with  a'=a
 b-->b' with  b'=b

 Finally:
 x-->x'  with x'=IND(x-(b-a)-1)     
 y-->y'  with y'=IND(y-(a-b)-1)
 a-->a' with  a'=FLOW(a)
 b-->b' with  b'=FLOW(b)

 R(x,y,a',b') --> R(x',y',a',b')

For linear expressions, the above can be assisted by Omega, as shown
in ex21a1-param.oc. However, this may affect non-linear formula.

# oc ex21a1-param.oc

Rel := {[x,y,a,b]->[x',y',a',b']:a=a' & b=b' & x=(b'-a')+x'+1 & y=((a'+y')-b')+1 & (b'+x')<a' & b'<=(a'+y')};

Rel1 := {[x,y,a,b]->[x',y',a',b']:exists(y',a',b':a=a' & b=b' & x=(b'-a')+x'+1 & y=((a'+y')-b')+1 & (b'+x')<a' & b'<=(a'+y'))};

Rel1;
#{[x,y,a,b] -> [x+a-b-1,y',a',b'] : x <= 0 && 1 <= y}

Rel2 := {[x,y,a,b]->[x',y',a',b']:exists(x',a',b':a=a' & b=b' & x=(b'-a')+x'+1 & y=((a'+y')-b')+1 & (b'+x')<a' & b'<=(a'+y'))};

Rel2;
#{[x,y,a,b] -> [x',y-a+b-1,a',b'] : x <= 0 && 1 <= y}

Rel3 := {[x,y,a,b]->[x',y',a',b']:exists(x',y',b':a=a' & b=b' & x=(b'-a')+x'+1 & y=((a'+y')-b')+1 & (b'+x')<a' & b'<=(a'+y'))};

Rel3;
#{[x,y,a,b] -> [x',y',a,b'] : x <= 0 && 1 <= y}

Rel4 := {[x,y,a,b]->[x',y',a',b']:exists(x',y',a':a=a' & b=b' & x=(b'-a')+x'+1 & y=((a'+y')-b')+1 & (b'+x')<a' & b'<=(a'+y'))};

Rel4;
#{[x,y,a,b] -> [x',y',a',b] : x <= 0 && 1 <= y}

================================================================
# ex27b.ss 

  if (x>0) {
    x = 2*x+y;
    y=y+1;

# I guess the warning below can be downplayed
  as we had 2*x there which is later converted.

WARNING: _0:0_0:0:[omega.ml] Non-linear arithmetic is not supported by Omega.
push_list:[]

WARNING: _0:0_0:0:[omega.ml] Non-linear arithmetic is not supported by Omega.
push_list:[]
================================================================
# ex27d3.ss 

infer [@term]
case {
   x+y < 0 -> ensures true;
   x+y = 0 -> ensures true;
   x+y > 0 -> ensures true;
}

# why did we have some post-inference?
# Aren't they redundant?


Procedure loo: FALSE - Counterexample:  {call 14:4}
 case {
   x<=((0-y)-1) & x<=0 -> requires emp & Term[63,1]
                          ensures true & (y+x)<0;
================================================================
# ex21.ss

!!! **infer.ml#2149:RelInferred (simplified):[
RELDEFN R: ( x=(b'-a')+x'+1 & y=(y'-b')+a'+1 & a'<=(b'+x') & b'<=(y'+a') 
   & R(x,y,a',b')) -->  R(x',y',a',b')]

I think we need to change to:

RELDEFN R: ( x=(b'-a')+x'+1 & y=(y'-b')+a'+1 & a'<=(b'+x') & b'<=(y'+a') 
   & a=a' & b=b' & R(x,y,a,b)) -->  R(x',y',a',b')]

This would allow us apply to specvar a' and b'

================================================================
================================================================
================================================================
================================================================
================================================================
================================================================
================================================================
================================================================
================================================================
================================================================
================================================================
================================================================
