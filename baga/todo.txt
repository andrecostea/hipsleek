==============================================
# app1.slk

inv_exact BG([],self=null & n=0) | BG([self],n>0)

When inv_exact given, we should use it for both
over_baga and under_baga.

why did we have failure below?

MaybeErr Context: 
                   fe_kind: MAY
                   fe_name: logical bug
                   fe_locs: {
                             fc_message: 
  ((self=Cnull & n=0) | self!=Cnull) 
  |-  ((self=Cnull & n=0) | (0<self & 0<n)). LOCS:[6;7;0;11] (may-bug)
                             fc_current_lhs_flow: {FLOW,(1,24)=__flow}}

Starting Omega...oc
Fatal error: exception Failure("view defn for ll does not entail supplied invariant
Two problems
  (1) why --esl not working (FIXED)
  (2) seems that user_inv is true (FIXED)
==============================================
# sleek10.slk

pred ll<n> == self = null & n = 0
         or self::node<_,r> * r::ll<n - 1>
.

!! baga_over:None

without invariant, we can use
a default of "true" for baga_over too
rather than None
==============================================
# baga1.slk

pred l5<k> == 
  self::node<q>*q::node<_> & k=q & self!=q
inv self!=null
//inv BG([self,k],true)
.

Given
!!! baga over inv(l5):[([], self!=Cnull)]
We derived:
!!! baga_over(unfolded):Some([([self], true)])

However, I expect to get:
    inv BG([self,k],true)
==============================================
# baga1.slk (FIXED)

pred l5<k> == 
  self::node<q>*q::node<_> & k=q & self!=q
inv self!=null
//inv BG([self,k],true)
.

Given
!!! baga over inv(l5):[([], self!=Cnull)]
We derived:
!!! baga_over(unfolded):Some([([self], true)])

However, I expect to get:
    inv BG([self,k],true)
==============================================
# baga2.slk (FIXED)

pred l5<k> == 
  self::node<q>*q::node<_> & k=q & self!=q
//inv self!=null
inv BG([self,k],true)
.

Given
!!! baga over inv(l5):[([self,k], true)]
We derived:
!!! baga_over(unfolded):Some([([self], true)])

which is less accurate than the given baga.
However, I expect to get:
    inv BG([self,k],true)
==============================================
# baga1.slk

pred l5<k> == 
  self::node<q>*q::node<_> & k=q & self!=q
inv self!=null
//inv BG([self,k],true)

Could Omega.simplify be improved to preserve disequality?

!!! pure1 = : exists(q:k=q & self!=q)
!!! pure2 = : (k<self | self<k)

!!! baga_over(unfolded):Some([([k,self], (k<self | self<k))])

# use Omega.gist to remove self!=k
==============================================
# infer4.slk

infer [q] q=null |- q::ll<n> & n>0.
print residue.
expect Valid.

GOT:
 inferred pure: [q!=0]

 should be q!=null 
==============================================
# infer5.slk  (FIXED)

//(3)
infer [x,y] b::node<1,y>   |- x::node<_,b>*b::node<_,y>*y::node<_,null>.
print residue.
// TODO : "b" part of the inferred?
// --baga-xpure (1) why is inf_b_91=1 inferred?
//         this seems to be due to baga enumeration
// --dis-baga-xpure (2) why this fail?
// --imm (3) why did it fail?

 <1>emp&flted_22_60=1 & Anon_16=flted_22_60 & Anon_15=inf_Anon_90 & Anon_17=inf_Anon_94 & inf_b_91=1 & inf_flted_22_95=Cnull&{FLOW,(21,22)=__norm}[]
 inferred heap: [y::node<inf_Anon_94,inf_flted_22_95>; 
                 x::node<inf_Anon_90,inf_b_91>]
 inferred pure: [inf_flted_22_95=Cnull; inf_b_91=1]

Using xpure_heap_sym
--------------------
@8!infer5.slk:12: 33: >>>>>> infer_pure_m <<<<<<
@8!infer5.slk:12: 33: Did not manage to infer a useful precondition
@8!infer5.slk:12: 33: LHS : : x!=y & y!=Cnull & x!=Cnull & b!=Cnull & x!=b & y!=b
@8!infer5.slk:12: 33: RHS : : inf_flted_12_104=Cnull & inf_b_112=b
@8!infer5.slk:12: 33: LHS REL : :None
@8!infer5.slk:12: 33: new_p_ass: : ((y=1 & inf_flted_12_104!=Cnull) | ((y+1)<=x & y=Cnull & 

Using xpure_heap
----------------


==============================================
# app-inv.slk --dis-baga-xpure

  inv: n>=0
  
  why did below fail for --dis-baga-xpure

checkentail xxx::ll<nnnn> & nnnn<0 |- false.
print residue.
expect Valid.

why below not triggered by --dis-baga-xpure
(below from --baga-xpure)
 id: 50<-1; prover: Z3; loc: app-inv_slk_7:5_7:34; kind: Sleek_Entail(1)
 raw proof:no proof raw result:no result
 Sat:  nnnn<0 & (((xxx=Cnull & nnnn=0) | (xxx=1 & 1<=nnnn)))
 res: UNSAT
==============================================
# examples/working/hip_baga/cll.ss

Message: view defn for hd does not entail supplied invariant

With inv in cll:

!!! xform': ((self=Cnull & n=0) | 
(exists(r:exists(flted_18_22:exists(self_23:self_23=self & 
(((1<=flted_18_22 & r!=Cnull & self_23!=r) | (self_23=r & 
flted_18_22=0)))) & flted_18_22+1=n)) & self!=Cnull))

With inv_exact in cll:
!!! xform': ((self=Cnull & n=0) | (exists(flted_18_22:flted_18_22+1=n) & 
exists(self_23:self_23=self) & self!=Cnull))

==============================================
# baga/ll-1.slk --elp

lemma "V1" self::ll_s<n> -> self::ll<>.

Entailing lemma V1: Fail. (cex)(may) cause: OrR[ ((self_V1=1 & r_60=Cnull & flted_5_58=0) | (r_60=1 & self_V1=2 & 
1<=flted_5_58)) |-  self_V1=Cnull. LOCS:[5;4;0;1;8] (must-bug),valid]

Failed to prove V1:==> in current context.
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================


