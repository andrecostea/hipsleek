==============================================
# app1.slk

inv_exact BG([],self=null & n=0) | BG([self],n>0)

When inv_exact given, we should use it for both
over_baga and under_baga.

why did we have failure below?

MaybeErr Context: 
                   fe_kind: MAY
                   fe_name: logical bug
                   fe_locs: {
                             fc_message: 
  ((self=Cnull & n=0) | self!=Cnull) 
  |-  ((self=Cnull & n=0) | (0<self & 0<n)). LOCS:[6;7;0;11] (may-bug)
                             fc_current_lhs_flow: {FLOW,(1,24)=__flow}}

Starting Omega...oc
Fatal error: exception Failure("view defn for ll does not entail supplied invariant
Two problems
  (1) why --esl not working (FIXED)
  (2) seems that user_inv is true (FIXED)
==============================================
# sleek10.slk

pred ll<n> == self = null & n = 0
         or self::node<_,r> * r::ll<n - 1>
.

!! baga_over:None

without invariant, we can use
a default of "true" for baga_over too
rather than None
==============================================
# baga1.slk

pred l5<k> == 
  self::node<q>*q::node<_> & k=q & self!=q
inv self!=null
//inv BG([self,k],true)
.

Given
!!! baga over inv(l5):[([], self!=Cnull)]
We derived:
!!! baga_over(unfolded):Some([([self], true)])

However, I expect to get:
    inv BG([self,k],true)
==============================================
# baga1.slk (FIXED)

pred l5<k> == 
  self::node<q>*q::node<_> & k=q & self!=q
inv self!=null
//inv BG([self,k],true)
.

Given
!!! baga over inv(l5):[([], self!=Cnull)]
We derived:
!!! baga_over(unfolded):Some([([self], true)])

However, I expect to get:
    inv BG([self,k],true)
==============================================
# baga2.slk (FIXED)

pred l5<k> == 
  self::node<q>*q::node<_> & k=q & self!=q
//inv self!=null
inv BG([self,k],true)
.

Given
!!! baga over inv(l5):[([self,k], true)]
We derived:
!!! baga_over(unfolded):Some([([self], true)])

which is less accurate than the given baga.
However, I expect to get:
    inv BG([self,k],true)
==============================================
# baga1.slk

Could Omega.simplify be improved to preserve disequality?

!!! pure1 = : exists(q:k=q & self!=q)
!!! pure2 = : (k<self | self<k)
==============================================
# infer5.slk

//(3)
infer [x,y] b::node<1,y>   |- x::node<_,b>*b::node<_,y>*y::node<_,null>.
print residue.
// TODO : "b" part of the inferred?
// --baga-xpure (1) why is inf_b_91=1 inferred?
//         this seems to be due to baga enuemration
// --dis-baga-xpure (2) why this fail?

 <1>emp&flted_22_60=1 & Anon_16=flted_22_60 & Anon_15=inf_Anon_90 & Anon_17=inf_Anon_94 & inf_b_91=1 & inf_flted_22_95=Cnull&{FLOW,(21,22)=__norm}[]
 inferred heap: [y::node<inf_Anon_94,inf_flted_22_95>; 
                 x::node<inf_Anon_90,inf_b_91>]
 inferred pure: [inf_flted_22_95=Cnull; inf_b_91=1]
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================
==============================================


