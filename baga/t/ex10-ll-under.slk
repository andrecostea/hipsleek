/* avl trees */

/* representation of a node in an avl tree */
data node {
  int val;
  node next;
}.


pred ll<n> == self=null & n=0 
   or self::node<_,q>*q::ll<n-1>
// inv_sat BG([],n>=0) // wrong
//inv_sat BG([],self=null & n=0) // valid
//inv_sat BG([self],n>=0) // wrong
//inv_sat BG([self],n>=1) // valid
//inv_sat BG([self],n>=3) // valid
//inv_sat BG([self],2<=n<=10000) // valid 
// how is this inductively proven?
//inv_sat BG([],false) // reported valid but unsat!
//inv_sat BG([self],false) // reported valid but unsat!
inv_sat BG([self],n=0) // wrong
//inv_sat BG([self],2=n | n>2) // valid 
//inv_sat BG([],false) // reported valid but unsat!
//inv_sat BG([self],n>=10) // valid but reported incorrect..
//inv_sat BG([self],n>=4) // valid but reported incorrect..
//inv_sat BG([self],2=n | n>3) // valid but fail
.


/*
# ex10-11-under.slk


Can we distinguish something that is
definitely UNSAT such as ([],false)  or  ([self],n=0)

from over-approx such as ([self],n>=0)
or unknown such as ([self],n>=10)

?


Valid.(Over)
Valid.(Under)

*/