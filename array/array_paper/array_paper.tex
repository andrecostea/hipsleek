\documentclass[]{article}
\usepackage{listings}
\usepackage{amsmath}
%opening
\title{Automatic Inference of Array Content Property}
\author{}

\begin{document}
\lstset{language=C}
\lstset{showstringspaces=false}
\maketitle

\begin{abstract}
Analysis of array content properties is an interesting but challenging topic. We present a method for inferring array content properties. It is implemented as augmentation of Hip/Sleek system and it proves to be capable to capture numeric of array properties for programs with bounded number of array elements manipulated.

\end{abstract}
% Introduction: About what the problem is. Give some motivating examples and expected results
% Describe what is array property
\section{Introduction}
An array is a simple but important data structure that is heavily used. The analysis of different array properties has been an interesting topic for a long time. For example, array bound checking has been widely explored. Properties of array contents is also an important part of array properties, yet there are much less research results about analyzing them. Array content property analysis focuses on the relationships among values of array elements. Intuitively speaking, array property analysis attempts to find out what is inside an array after the execution of a piece of code. However, due to the unbounded nature of arrays, automatic discovery of such properties has been a challenging mission.\\

Here we use three simple examples to illustrate what are the expected result for array contents analysis. In the first example, the if-condition branches according to the value of the 7th element of array \textbf{arr} (starting from zero) and update \textbf{arr}[5] to either 7 or 8 and returns \textbf{arr}[5] as the result of the function at the end. After the execution of this piece of code, we wish to capture that when \textbf{arr}[6] is greater than 0, the value of \textbf{arr}[5] is updated into 7; when \textbf{arr}[6] is less or equal to 0, the value of \textbf{arr}[5] is updated into 8; and in both branches, with array \textbf{arr}, only the 6th element(\textbf{arr}[5]) is updated, all the other elements stay unchanged and the returned result equals to \textbf{arr}[5].\\

\begin{lstlisting}
int foo(ref int[] arr){
	if(arr[6]>0){
		arr[5] = 7;
	}
	else{
		arr[5] = 8;
	}
	return arr[5];
}
\end{lstlisting}

The second example is slightly more complicated, in which recursive updates of array elements are involved. \textbf{arr}[5] in array \textbf{arr} keep decreasing if it is greater than zero; otherwise, the procedure will return \textbf{arr}[5]+10.\\

\begin{lstlisting}
int foo(ref int[] arr){
	if(arr[5]>0){
		arr[5] = arr[5]-1;
		return foo(arr);
	}
	else{
		return arr[5]+10;
	}
}
\end{lstlisting}
In this case, it is not so obvious to find out what is inside \textbf{arr}[5] after the execution of this piece of code and what other elements of arr are like. Ideally, the captured property of array \textbf{arr} should imply that if \textbf{arr}[5] is less or equal to 0 initially, none of the array elements will be updated and the returned result will be arr[5]+10; if \textbf{arr}[5] is greater than 0 at the beginning, then at the end of the execution, \textbf{arr}[5] will become 0 and the returned result will equal to 10 while other elements of \textbf{arr} stay unchanged.\\

The third example also have multiple update to some array elements. However, in this case, the it is in the form of while-loop.\\
\begin{lstlisting}
int loop(ref int[] arr){
	while(arr[5]>0){
		arr[5] = arr[5] -1;
	}
	return arr[5];
}
\end{lstlisting}

The target property for this case is very similar to the recursive one, in which we wish to capture either that \textbf{arr}[5] decreases to zero if it is positive at the beginning or stay unchanged otherwise.\\

In this paper, we explore the possibility to automatically discover properties of array contents for such input programs.

\section{Related Work}

\section{Array Content Analysis}
Due to compound nature of array, array elements will not be manipulated in a consistent way. In order to get an accurate predicate describing the content properties of an array after executing some code, at least two main aspects of the target array need considering, the changed part and the unchanged part. First, for the changed part, we need to discover the numeric properties after all the updates. However, some part of the array may never be updated during the execution, which requires us the have a second analysis to cover those unchanged elements. In a word, we wish to find out whether each part of the array(ideally one element) is updated after the execution of the code; if so, find out what are inside these changed parts.\\

Based on such observation, we build up our method with two parts. The first part is to capture the numeric properties of the array elements that are updated. One straightforward solution is to make array elements into normal variable or segments when there are unbounded number of elements and infer the numeric property of the normal variables or segments as the array elements represented. Our method shares such intuitive idea. We first discovery the set the array elements that are updated, then expand the array into these elements and at the end assemble the information of these elements and reconstruct the inferred result for the target array. This is practical enough if there are only bounded number of array elements are manipulated.\\

The second part of the analysis targets at the unchanged part of the array. From the inferred formula of properties(??), we calculate a set of elements that may be updated during the execution and the complement set is the set of unchanged elements.\\

\section{Implementation}
We build up a prototype by augmenting the Hip/Sleek system. Hip/Sleek system is a powerful tool for program verification and inference. Besides implementing the array content analysis prototype into the Hip/Sleek system, we also needs to extend the original verification and inference mechanism to support array reasoning. We achieve this goal by providing a translating method to turn an array-involved into an array-free formula, which can be handled by the existing solver in Hip/Sleek.

\subsection{Array Solver}
An expression of array element contains two kinds of information, the value and the index.
Our array translation scheme is based on two observation:
\begin{itemize}
\item An array element can be represented by a fresh normal variable, which is capable of capturing the value of array elements;
\item For any array \textbf{arr} and valid index \textbf{i, j}, if \textbf{i=j}, then \textbf{arr[i]=arr[j]}.
\end{itemize}

According to our first observation, for an array element a[i], we introduce a fresh normal variable $a_i$ to represent it to retain its value. By doing this, all the operations on a[i] can be equivalent to operations on the fresh variable $a_i$. However, by doing this we only retain the array value, in which we lose the information that the index of array may have. For example, it is implied that a[j]=a[6] when j equals to 6. If there are only $a_j$ and $a_6$, there is no clue of relationship between j and 6. Hench we need to add in such information. Based on our second observation, we can introduce i=j $\rightarrow$ a[i]=a[j] safely. And since we now already have fresh normal variables to represent the value of array elements, we can have i=j $\rightarrow$ $a_i$=$a_j$. In the translation process, we are actually not introducing any new information into the formula and hence it is obvious that the process is sound.\\

Here we use an simple example to illustrate how we translate an array-involved formula into a formula with only normal variables.
\[input: a[5]>5 \: \& \: a[i]=10 \: \& \: i=5 \: \&\: a[6]=3 \]

\begin{itemize}
\item First, we collect a set of possible useful index, here the set is {i,5,6};
\item Second, we introduce index information according to the set of index we have. Here we introduce i=5 $\rightarrow$ a[i]=a[5] and i=6 $\rightarrow$ a[i]=a[6];
\item Third, we translate all the array elements into normal variables. Here we translate a[i] to $a_i$, a[5] to $a_5$ and a[6] to $a_6$;
\end{itemize}
\[output: a_5>5 \: \& \: a_i=10\: \& \: i=5 \:\&\: a_6=3 
\: \& \:  i=5 \rightarrow a_i=a_5 \: \& \:  i=6 \rightarrow a_i = a_6 \]

\section{Result}
Our method is now capable to infer programs that manipulates a bounded set of array elements. Here we show some result for array-involved programs, where examples 1-3 are the examples mentioned in the first section.\\

\textbf{Example 1:}\\

\begin{lstlisting}[frame=single]
int foo(ref int[] arr){
	if(arr[6]>0){
		arr[5] = 7;
	}
	else{
		arr[5] = 8;
	}
	return arr[5];
}
\end{lstlisting}
\textbf{Result:} 
\begin{lstlisting}[mathescape]
0>=(a'[6]) & a'[6]=a[6] & 8=a'[5] & 8=res & 
forall(i:(not(i=5)) | a[i]=a'[i]) 
$\lor$
a'[6]>=1 & a'[6]=a[6] & 7=a'[5] & 7=res & 
forall(i:(not(i=5)) | a[i]=a'[i])
\end{lstlisting}

\textbf{Example 2:}
\begin{lstlisting}[frame=single]
int foo(ref int[] arr){
	if(arr[5]>0){
		arr[5] = arr[5]-1;
		return foo(arr);
	}
	else{
		return arr[5]+10;
	}
}
\end{lstlisting}
\textbf{Result:}
\begin{lstlisting}[mathescape]
a[5]>=1 & 0=a'[5] & 10=res 
& forall(i:(not(i=5)|a[i]=a'[i])) 
$\lor$ 
0>=a'[5] & (a'[5])+10=res & a=a'
\end{lstlisting}

\textbf{Example 3:}
\begin{lstlisting}[frame=single]
int loop(ref int[] arr){
	while(arr[5]>0){
		arr[5] = arr[5] -1;
	}
	return arr[5];
}
\end{lstlisting}
\textbf{Result:}
\begin{lstlisting}[mathescape]
((res=0 & a'[5]=0 & 1<=(a[5]))
& forall(i:(not(i=5)|a[i]=a'[i]))
$\lor$ 
(a'=a & res=a[5] & (a[5])<=0))
\end{lstlisting}

Example 4 is slightly more complicated than other examples in that there is array update after recursive call and more than one but finite number of array elements are updated, by which we intend to show the capability of handling bounded number of array elements.\\

\textbf{Example 4:}
\begin{lstlisting}[frame=single]
int foo(ref int[] a)
{
  if (a[5]>0) {
    a[1] = a[1]+1;
    a[5] = a[5]-1;
    int r = foo(a);
    a[6] = a[6]+2;
    return r;
  }
  else {
    return a[1];
  }
}
\end{lstlisting}
\textbf{Result:}
\begin{lstlisting}[mathescape]
a[5]>=1 & 0=a'[5]
& a'[1]=res & a'[1]=a[1]+a[5]
& a'[6]=a[6]+2*(a[5]) 
& forall(i:((not(i=6)&not(i=5)&not(i=1))| a[i]=a'[i]))
$\lor$
0>=(a'[5]) & a[1]=res & a=a'
\end{lstlisting}
In the result for \textbf{Example 4}, we can see that after the execution when \textbf{a[5]} is less or equal to 0 initially, nothing in the array is changed; otherwise, \textbf{a[1]} will keep increasing by 1 and \textbf{a[6]} will keep increasing by 2 while in the same time \textbf{a[5]} keeps decreasing by 1 until \textbf{a[5]} reaches 0 and any other array elements stay unchanged.

\section{Future Work}
Currently, our method can only handle programs with bounded set of array elements manipulated, which only covers a small subset of array-involved problems. Our future work is to extend our current array translation scheme to a more adaptive one.\\
Here is a motivating example for such problem:
\begin{lstlisting}
int loop(ref int[] arr){
	int i = N;
	while(i>0){
		arr[i] = 10;
		i--;
	}
	return arr[5];
}
\end{lstlisting}
In this example, the property we wish to capture is that elements from 1 to N in array \textbf{arr} are assigned to 10.

\section{References}

\end{document}
