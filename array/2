longph 12895 Wed Sep 17 11:49:17 2014 +0800: module DD = Debug
longph 12895 Wed Sep 17 11:49:17 2014 +0800: open Globals
longph 12895 Wed Sep 17 11:49:17 2014 +0800: open Wrapper
longph 12895 Wed Sep 17 11:49:17 2014 +0800: open Others
longph 12895 Wed Sep 17 11:49:17 2014 +0800: open Stat_global
longph 12895 Wed Sep 17 11:49:17 2014 +0800: open Global_var
longph 12895 Wed Sep 17 11:49:17 2014 +0800: open Exc.GTable
longph 12895 Wed Sep 17 11:49:17 2014 +0800: open Solver
longph 12895 Wed Sep 17 11:49:17 2014 +0800: open Cast
longph 12895 Wed Sep 17 11:49:17 2014 +0800: open Gen.Basic
longph 12895 Wed Sep 17 11:49:17 2014 +0800: open Perm
longph 12895 Wed Sep 17 11:49:17 2014 +0800: open Label
longph 12895 Wed Sep 17 11:49:17 2014 +0800: module CF = Cformula
longph 12895 Wed Sep 17 11:49:17 2014 +0800: module CP = Cpure
longph 12895 Wed Sep 17 11:49:17 2014 +0800: module TP = Tpdispatcher
longph 12895 Wed Sep 17 11:49:17 2014 +0800: module PTracer = Prooftracer
longph 12895 Wed Sep 17 11:49:17 2014 +0800: module I = Iast
longph 12895 Wed Sep 17 11:49:17 2014 +0800: module CEQ = Checkeq
longph 12895 Wed Sep 17 11:49:17 2014 +0800: module M = Lexer.Make(Token.Token)
longph 12895 Wed Sep 17 11:49:17 2014 +0800: module H = Hashtbl
longph 12895 Wed Sep 17 11:49:17 2014 +0800: module LO2 = Label_only.Lab2_List
longph 12895 Wed Sep 17 11:49:17 2014 +0800: 
longph 12937 Fri Sep 19 19:34:33 2014 +0800: let rec add_relation prog proc sf rel_name rel_type = match sf with
longph 12943 Sat Sep 20 16:56:30 2014 +0800:   | CF.EList el -> CF.EList (List.map (fun (lbl,sf) ->
longph 12943 Sat Sep 20 16:56:30 2014 +0800:         (lbl,add_relation prog proc sf rel_name rel_type)) el)
longph 12937 Fri Sep 19 19:34:33 2014 +0800:   | CF.EBase eb ->
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let cont = eb.CF.formula_struc_continuation in (
longph 12937 Fri Sep 19 19:34:33 2014 +0800:             match cont with
longph 12937 Fri Sep 19 19:34:33 2014 +0800:               | None -> sf
longph 12937 Fri Sep 19 19:34:33 2014 +0800:               | Some cont -> CF.EBase {eb with CF.formula_struc_continuation = Some (add_relation prog proc cont rel_name rel_type)} )
longph 12937 Fri Sep 19 19:34:33 2014 +0800:   | CF.EAssume ea ->
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let rel_vars = (List.map (fun (t,id) -> CP.mk_typed_spec_var t id) proc.proc_args)@[CP.mk_typed_spec_var proc.proc_return res_name] in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let rel_formula = CP.mkTrue no_pos in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let rel_decl = {rel_name = rel_name; rel_vars = rel_vars; rel_formula = rel_formula} in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let _ = prog.prog_rel_decls <- prog.prog_rel_decls@[rel_decl] in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let rel_spec_var = CP.mk_typed_spec_var rel_type rel_name in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let rel_args = (List.map (fun (_,id) -> CP.mkVar (CP.mk_spec_var id) no_pos) proc.proc_args)@[CP.mkVar (CP.mk_spec_var res_name) no_pos] in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let new_rel = CP.mkRel rel_spec_var rel_args no_pos in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let old_f = ea.CF.formula_assume_simpl in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let h,p,fl,t,a = CF.split_components old_f in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let new_p = MCP.mix_of_pure (CP.mkAnd (MCP.pure_of_mix p) new_rel no_pos) in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let new_f = CF.mkBase h new_p t fl a no_pos in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let new_struc_f = CF.mkEBase new_f None no_pos in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         CF.EAssume {ea with
longph 12937 Fri Sep 19 19:34:33 2014 +0800:             CF.formula_assume_simpl = new_f;
longph 12937 Fri Sep 19 19:34:33 2014 +0800:             CF.formula_assume_struc = new_struc_f}
longph 12943 Sat Sep 20 16:56:30 2014 +0800:   | CF.EInfer ei ->
longph 12943 Sat Sep 20 16:56:30 2014 +0800:         let rel_name = fresh_any_name "post" in
longph 12943 Sat Sep 20 16:56:30 2014 +0800:         let rel_type = RelT ((List.map (fun (t,_) -> t) proc.proc_args)@[proc.proc_return]) in
longph 12943 Sat Sep 20 16:56:30 2014 +0800:         CF.EInfer {ei with
longph 12943 Sat Sep 20 16:56:30 2014 +0800:             CF.formula_inf_vars = ei.CF.formula_inf_vars@[CP.mk_typed_spec_var rel_type rel_name];
longph 12943 Sat Sep 20 16:56:30 2014 +0800:             CF.formula_inf_continuation = add_relation prog proc ei.CF.formula_inf_continuation rel_name rel_type}
longph 12937 Fri Sep 19 19:34:33 2014 +0800:   | _ -> sf
longph 12937 Fri Sep 19 19:34:33 2014 +0800: 
longph 12943 Sat Sep 20 16:56:30 2014 +0800: let rec is_infer_post sf = match sf with
longph 12943 Sat Sep 20 16:56:30 2014 +0800:   | CF.EList el -> List.exists (fun (lbl,sf) ->
longph 12943 Sat Sep 20 16:56:30 2014 +0800:         is_infer_post sf) el
longph 12937 Fri Sep 19 19:34:33 2014 +0800:   | CF.EInfer ei ->
longph 12937 Fri Sep 19 19:34:33 2014 +0800:         let inf_obj = ei.CF.formula_inf_obj in
longph 12943 Sat Sep 20 16:56:30 2014 +0800:         (inf_obj # is_post)
longph 12943 Sat Sep 20 16:56:30 2014 +0800:   | _ -> false
longph 12943 Sat Sep 20 16:56:30 2014 +0800: 
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (* let rec is_infer_post prog proc sf = match sf with *)
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (*   | CF.EList el -> CF.EList (List.map (fun (lbl,sf) -> *)
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (*         (lbl,is_infer_post prog proc sf)) el) *)
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (*   | CF.EInfer ei -> *)
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (*         let inf_obj = ei.CF.formula_inf_obj in *)
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (*         if (inf_obj # is_post) then *)
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (*           let rel_name = fresh_any_name "post" in *)
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (*           let rel_type = RelT ((List.map (fun (t,_) -> t) proc.proc_args)@[proc.proc_return]) in *)
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (*           CF.EInfer {ei with *)
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (*               CF.formula_inf_vars = ei.CF.formula_inf_vars@[CP.mk_typed_spec_var rel_type rel_name]; *)
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (*               CF.formula_inf_continuation = add_relation prog proc ei.CF.formula_inf_continuation rel_name rel_type} *)
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (*         else *)
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (*           sf *)
longph 12943 Sat Sep 20 16:56:30 2014 +0800: (*   | _ -> sf *)
longph 12937 Fri Sep 19 19:34:33 2014 +0800: 
longph 12941 Sat Sep 20 15:53:11 2014 +0800: let infer_post (prog : prog_decl) (scc : proc_decl list) =
longph 12937 Fri Sep 19 19:34:33 2014 +0800:   let pr = !CP.print_formula in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:   let proc_specs = List.fold_left (fun acc proc -> acc@[CF.simplify_ann (proc.proc_stk_of_static_specs # top)]) [] scc in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:   let rels = Infer.infer_rel_stk # get_stk in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:   let (rels,rest) = (List.partition (fun (a1,a2,a3) -> match a1 with | CP.RelDefn _ -> true | _ -> false) rels) in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:   let (lst_assume,lst_rank) = (List.partition (fun (a1,a2,a3) -> match a1 with | CP.RelAssume _ -> true | _ -> false) rest) in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:   if rels = [] then ()
longph 12937 Fri Sep 19 19:34:33 2014 +0800:   else
longph 12950 Sun Sep 21 09:16:10 2014 +0800:     let new_specs =
longph 12950 Sun Sep 21 09:16:10 2014 +0800:       let rels = Infer.infer_rel_stk # get_stk in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:       let _ = Infer.infer_rel_stk # reset in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:       let pres,posts_wo_rel,all_posts,inf_vars,pre_fmls,grp_post_rel_flag =
longph 12950 Sun Sep 21 09:16:10 2014 +0800:         List.fold_left (fun (pres_acc,posts_wo_rel_acc,all_posts_acc,inf_vars_acc,pre_fmls_acc,grp_post_rel_flag) proc ->
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let pres,posts_wo_rel,all_posts,inf_vars,pre_fmls,grp_post_rel_flag =
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               CF.get_pre_post_vars [] Cvutil.xpure_heap (proc.proc_stk_of_static_specs # top) prog in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             (pres_acc@pres,posts_wo_rel_acc@posts_wo_rel,all_posts_acc@all_posts,inf_vars_acc@inf_vars,pre_fmls_acc@pre_fmls,grp_post_rel_flag)) ([],[],[],[],[],0) scc
longph 12950 Sun Sep 21 09:16:10 2014 +0800:       in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:       let pre_rel_fmls = List.concat (List.map CF.get_pre_rels pre_fmls) in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:       let pre_rel_fmls = List.filter (fun x -> CP.intersect (CP.get_rel_id_list x) inf_vars != []) pre_rel_fmls in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:       let pre_vars = CP.remove_dups_svl (List.fold_left (fun pres proc ->
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           pres @ (List.map (fun (t,id) -> CP.SpecVar (t,id,Unprimed)) proc.proc_args)) pres scc) in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:       let post_vars_wo_rel = CP.remove_dups_svl posts_wo_rel in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:       let post_vars = CP.remove_dups_svl all_posts in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:       try
longph 12950 Sun Sep 21 09:16:10 2014 +0800:         begin
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           let _ = DD.ninfo_pprint ">>>>>> do_compute_fixpoint <<<<<<" no_pos in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           let tuples =
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let rels = Gen.Basic.remove_dups rels in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             if rels !=[] then
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               begin
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 print_endline "\n*************************************";
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 print_endline "*******pure relation assumption ******";
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 print_endline "*************************************";
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 print_endline (Gen.Basic.pr_list_ln (CP.string_of_infer_rel) (List.rev rels));
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 print_endline "*************************************";
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               end;
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let _ = if !Globals.sa_gen_slk then
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               try
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 let pre_rel_ids = List.filter (fun sv -> CP.is_rel_typ sv
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                     && not(CP.mem_svl sv post_vars)) pre_vars in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 let post_rel_ids = List.filter (fun sv -> CP.is_rel_typ sv) post_vars in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 Fixpoint.gen_slk_file_4fix prog (List.hd !Globals.source_files)
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                     pre_rel_ids post_rel_ids rels
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               with _ -> ()
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             else ()
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let reloblgs, reldefns = List.partition (fun (rt,_,_) -> CP.is_rel_assume rt) rels in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let reldefns = List.map (fun (_,f1,f2) -> (f1,f2)) reldefns in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let is_post_rel fml pvars =
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               let rhs_rel_defn = List.concat (List.map CP.get_rel_id_list (CP.list_of_conjs fml)) in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               List.for_all (fun x -> List.mem x pvars) rhs_rel_defn
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let post_rel_df,pre_rel_df = List.partition (fun (_,x) -> is_post_rel x post_vars) reldefns in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let pre_rel_ids = List.filter (fun x -> CP.is_rel_typ x
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 && not(Gen.BList.mem_eq CP.eq_spec_var x post_vars)) pre_vars in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let post_rel_ids = List.filter (fun sv -> CP.is_rel_typ sv) post_vars in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let post_rel_df_new =
longph 12937 Fri Sep 19 19:34:33 2014 +0800:             if pre_rel_ids=[] then post_rel_df
longph 12937 Fri Sep 19 19:34:33 2014 +0800:             else List.concat (List.map (fun (f1,f2) ->
longph 12937 Fri Sep 19 19:34:33 2014 +0800:                 if Tpdispatcher.is_bag_constraint f1 then [(CP.remove_cnts pre_rel_ids f1,f2)]
longph 12937 Fri Sep 19 19:34:33 2014 +0800:                 else
longph 12937 Fri Sep 19 19:34:33 2014 +0800:                   let tmp = List.filter (fun x -> CP.intersect
longph 12937 Fri Sep 19 19:34:33 2014 +0800:                       (CP.get_rel_id_list x) pre_rel_ids=[]) (CP.list_of_conjs f1) in
longph 12937 Fri Sep 19 19:34:33 2014 +0800:                   if tmp=[] then [] else [(CP.conj_of_list tmp no_pos,f2)]
longph 12937 Fri Sep 19 19:34:33 2014 +0800:             ) post_rel_df)
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let proc = List.hd scc in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let pre_invs,post_invs =
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               List.fold_left (fun (pre_invs,post_invs) proc ->
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                   let new_pre_invs,new_post_invs =
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                     CF.get_pre_post_invs pre_rel_ids post_rel_ids (Fixpoint.get_inv prog) (proc.proc_stk_of_static_specs # top) in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 (pre_invs@new_pre_invs,post_invs@new_post_invs)
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               ) ([],[]) scc
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let post_inv = CP.join_disjunctions post_invs in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let bottom_up_fp0 = Fixcalc.compute_fixpoint 2 post_rel_df_new pre_vars (List.hd proc_specs) in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             (* let bottom_up_fp0 = List.fold_left (fun acc proc_spec -> acc@(Fixcalc.compute_fixpoint 2 post_rel_df_new pre_vars proc_spec)) [] proc_specs in *)
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let bottom_up_fp = List.map (fun (r,p) ->
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 let p1 = Tpdispatcher.om_gist p post_inv in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 let p2 = Tpdispatcher.pairwisecheck_raw p1 in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 (r,p2)
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             ) bottom_up_fp0 in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let proc_spec = List.hd proc_specs in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             Fixpoint.update_with_td_fp bottom_up_fp pre_rel_fmls pre_fmls pre_invs
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 Fixcalc.compute_fixpoint_td
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 Fixcalc.fixc_preprocess reloblgs pre_rel_df post_rel_df_new post_rel_df pre_vars proc_spec grp_post_rel_flag;
longph 12937 Fri Sep 19 19:34:33 2014 +0800:           in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           Infer.fixcalc_rel_stk # push_list tuples;
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           if not(Infer.fixcalc_rel_stk # is_empty || !Globals.print_min) then
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             begin
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               print_endline "\n*************************************";
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               print_endline "*******fixcalc of pure relation *******";
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               print_endline "*************************************";
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               print_endline (Infer.fixcalc_rel_stk # string_of_reverse);
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               print_endline "*************************************"
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             end;
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           Infer.fixcalc_rel_stk # reset;
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           let tuples = List.map (fun (rel_post,post,rel_pre,pre) ->
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               let pre_new = if CP.isConstTrue rel_pre then
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 let exist_vars = CP.diff_svl (CP.fv_wo_rel rel_post) inf_vars in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 TP.simplify_exists_raw exist_vars post
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               else pre in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               (rel_post,post,rel_pre,pre_new)) tuples in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           let evars = stk_evars # get_stk in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           let _ = List.iter (fun (rel_post,post,rel_pre,pre) ->
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             Debug.ninfo_zprint (lazy (("REL POST : "^Cprinter.string_of_pure_formula rel_post))) no_pos;
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               Debug.ninfo_zprint (lazy (("POST: "^Cprinter.string_of_pure_formula post))) no_pos;
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               Debug.ninfo_zprint (lazy (("REL PRE : "^Cprinter.string_of_pure_formula rel_pre))) no_pos;
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               Debug.ninfo_zprint (lazy (("PRE : "^Cprinter.string_of_pure_formula pre))) no_pos
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           ) tuples in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           let triples = List.map (fun (a,b,c,d) -> (a,b,d)) tuples in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           if triples = [] then
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             List.map (fun old_spec -> fst (Fixpoint.simplify_relation old_spec None
longph 12950 Sun Sep 21 09:16:10 2014 +0800:               pre_vars post_vars_wo_rel prog true (* inf_post_flag *) evars lst_assume)) proc_specs
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           else
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             let new_specs1 = List.map (fun proc_spec -> CF.transform_spec proc_spec (CF.list_of_posts proc_spec)) proc_specs in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             List.map (fun new_spec1 -> fst (Fixpoint.simplify_relation new_spec1
longph 12950 Sun Sep 21 09:16:10 2014 +0800:                 (Some triples) pre_vars post_vars_wo_rel prog true (* inf_post_flag *) evars lst_assume)
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             ) new_specs1
longph 12950 Sun Sep 21 09:16:10 2014 +0800:         end
longph 12950 Sun Sep 21 09:16:10 2014 +0800:       with ex ->
longph 12937 Fri Sep 19 19:34:33 2014 +0800:           begin
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             Debug.info_pprint "PROBLEM with fix-point calculation" no_pos;
longph 12950 Sun Sep 21 09:16:10 2014 +0800:             raise ex
longph 12950 Sun Sep 21 09:16:10 2014 +0800:           end
longph 12950 Sun Sep 21 09:16:10 2014 +0800:     in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:     (* let new_specs = List.map (fun new_spec -> CF.norm_struc_with_lexvar new_spec false) new_specs in *)
longph 12950 Sun Sep 21 09:16:10 2014 +0800:     let new_specs = List.map (fun new_spec -> CF.flatten_struc_formula new_spec) new_specs in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:     let _ = List.iter (fun (proc,new_spec) ->
longph 12950 Sun Sep 21 09:16:10 2014 +0800:         let _ = proc.proc_stk_of_static_specs # push new_spec in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:         print_endline "\nPost Inference result:";
longph 12950 Sun Sep 21 09:16:10 2014 +0800:         print_endline proc.proc_name;
longph 12937 Fri Sep 19 19:34:33 2014 +0800:       print_endline (Cprinter.string_of_struc_formula_for_spec new_spec);
longph 12950 Sun Sep 21 09:16:10 2014 +0800:     ) (List.combine scc new_specs) in
longph 12950 Sun Sep 21 09:16:10 2014 +0800:     ()
longph 12938 Sat Sep 20 10:12:00 2014 +0800: 
