=============================================
=============================================
msess/examples$ ../../sleek ex4-1B1S1S-a1.slk
==============================================

Status: SOLVED

it's now parsing, but fails at type check as below:

------------------------------------------------
!!! **astsimp.ml#9170:@TINA: update_temp_heap_name
Last Proving Location: hodef.slk_1:10_1:42

ERROR: at ex4-1B1S1S-a1.slk_5:22_5:26
Message: **typeinfer.ml#1626: is neither 2 a data nor view name

Entail 1: EXCast. Failure("**typeinfer.ml#1626: is neither 2 a data nor view name")
Validate 1: Expecting1 FailBUT got no residue
------------------------------------------------

Sol:
(i)  unk preds are set to a dedicated view name: SESS_TEMP
(ii) while creating a heap node, set a proper session kind flag
(iii) use the session flag during iformula normalization
      to update the heap name approriately
(i) & (ii) are already implemented
(iii) partially implemented. To continue as below:
      call a transform for formula which in turn
      calls Session.IProjection.update_temp_heap_name
      to update the heap. 


=============================================
=============================================

Status: SOLVED

change @ --> @S to flag a session formula inside
the HO arg list.

=============================================
=============================================

./sleek msess/examples/ex4-1B1S1S-a1.slk -dre "update_formula"
=============================================

Status: SOLVED

(i) to check why temp pred name for R is empty instead of SESS_TEMP
(ii) to check why typeinfer still complains about not finding view name:

(====)
update_formula@5@2@1
update_formula inp1 :(aa::{+ (emp ; (emp ; emp)) * ([] & 0 <= msg)( FLOW __flow)}<>@M[HeapNode1]) * ([] & true)( FLOW __flow)
update_formula@5 EXIT:(aa::R{+ (emp ; (emp ; emp)) * ([] & 0 <= msg)( FLOW __flow)}<>@M[HeapNode1]) * ([] & true)( FLOW __flow)

Last Proving Location: msess/examples/hodef.slk_1:10_1:42

ERROR: at msess/examples/ex4-1B1S1S-a1.slk_5:60_5:75
Message: **typeinfer.ml#1626: is neither 2 a data nor view name

Entail 1: EXCast. Failure("**typeinfer.ml#1626: is neither 2 a data nor view name")
Validate 1: Expecting1 FailBUT got no residue

=============================================
=============================================

Status: Solved, done in parser by applying right associativity to sequence

(1) NORM1
to normalize seq such that head is base/or/*/pred:

self::Seq{self::Seq{a.b}, self::Seq{c,d}}
 |
 |
 V
self::Seq{a, self::Seq{b, self::Seq{c,d}}} 

=============================================
=============================================

Status: Solved
Status: Reverted, we might not require it.

(2) NORM2
to normalize second HO arg of seq such that
it contains no base/or/*/pred unless they are
part of a seq:

self::Seq{a,c}}
 |
 |
 V
self::Seq{a, self::Seq{c, emp}} 


self::Seq{a, c or/* b}}
 |
 |
 V
self::Seq{a, self::Seq{c or/* b, emp}}

=============================================
=============================================

Status: solved

create a wrapper to disable classic ent chek for
HO args when not base.


=============================================
=============================================

!!!disjunction


=============================================
=============================================

Status: Solved; Star node wasn't wrapped in
a Sequence.

./../sleek ex4-1B1S1S-a1.slk --pcp
=============================================

fail reason should have involved classical reason,
but instead:

Entail 15: Fail.(must) cause:matching of ho_args failed (matching of ho_args failed (matching of ho_args failed (do_unmatched_rhs : a::S{ - emp&msg=1&{FLOW,(1,26)=__flow#E}[]}<>@M(may))))

=============================================
=============================================

Status: Solved

Transform from struc_formula to session for
Projection only.

=============================================
=============================================

Status: Solved

Print compact Projection in cprinter/iprinter,
for h_formula.
Also add a flag to disable/enable compact
printing. By default, compact.

=============================================
=============================================

Status: Solved

Add support for second-order variables in projection
formula.

=============================================
=============================================

Solved: split into session type and node type

Should predicate nodes have Projection/Protocol
types in h_formula_heap_session_kind? Right now
it's None, which is not consistent with the
other types of nodes.

=============================================
=============================================

to support both multiparty projection, as well
as two-party with fences:
Projection vs TPProjection

=============================================
=============================================

Status: In Progress, added a batch of tests

to add test cases in run-fast-test and test
the second order vars.

=============================================
=============================================

When defining predicates such as:

pred_sess_proj ll12<n> == (c!self = null & n = 0) or (d?self = null).

We have a warning and an error:

WARNING: ex.slk_22:15_22:22:compute_view_fw_bw: data name in view is empty

Last Proving Location: ./hodef.slk_1:10_1:42

ERROR: at ex.slk_22:15_22:22
Message: compute_view_fw_bw: data not found:

This is because view_data_name is not set.
Should we do something about this?

=============================================
=============================================
to make use of our transformers here:

sleekengine.ml:8833: let f = Session.IProjection.update_formula f

Should check whether it's multi or two party session.
It works because that method is the same anyway but it's not
quite rigorous.

=============================================
=============================================

Status: Solved

Make fields in node_session_info mandatory, not optional.

=============================================
=============================================

Status: Solved

To investigate: why iformulas are embedded in EX.

Use --pip.

pred_sess_proj ll12<n> == (c!self = null & n = 0) or (d?self = null).

becomes

(EX  . (self::Sess{. (EX  . (self::SOr{. (EX  . (c::S{- (EX  . (emp)*([] & (self = null) & (n = 0))( FLOW __flow))}<>@M[HeapNode1])*([] & true)( FLOW __flow))
or(EX  . (d::R{+ (EX  . (emp)*([] & self = null)( FLOW __flow))}<>@M[HeapNode1])*([] & true)( FLOW __flow))}<>@M[HeapNode1])*([] & true)( FLOW __flow))}<>@M[HeapNode1])*([] & true)( FLOW __flow))

According to the comments in the code, it's a "magic trick":
(*existential wrapping and other magic tricks, avail_vars -> program variables, function arguments...*)

We support it although it's not clear why it's so.

=============================================
=============================================

Status: Solved

Change IFs into match clauses in trans_h_formula_to_session

Use get_node_kind.

=============================================
=============================================

Status: Solved

Move is_projection to session.ml.

=============================================
=============================================

Add test cases for two party projection.

=============================================
=============================================

Status: Solved

Normalization: embed every node in a Seq node

We embed every node into a Seq node. This makes it easy
to deal with OR nodes, because for each OR branch we append the tail,
which is going to be the content of the Seq node.
The second element of the new Seq will be empty.

a::R{...}
 |
 |
 V
self::Seq{a::R{...}, emp}

=============================================
=============================================
./sleek msess/examples/ex6c1-msg-var-subtype.slk --dis-print-compact-projection-formula --print-type -dre "do_match" --pcp
=============================================
Below should fail because of inconsistent type
<msg_93:int> vs <www_97:boolean>

Instead it fails because it cannot prove
msg_93:int=0 |-  msg_93:int

......
//3
checkentail x::Sess{@S ?0}<>
            |- x::Sess{@S ?www#www}<>.
print residue.
expect Fail.

/*


(==solver.ml#12882==)
do_match@189
do_match inp1 : x:void::Sess{ . chan:Unknown::R{ + emp&msg_93:int=0&{FLOW,(1,26)=__flow#E}}<msg_93:int>@M&
{FLOW,(1,26)=__flow#E}}<>@M
do_match inp2 : x:Unknown::Sess{ . chan:Unknown::R{ + emp&www_97:boolean&{FLOW,(1,26)=__flow#E}}<www_97:boolean>@M&
....

run_infer:
 x:void::Sess{ . chan:Unknown::R{ + emp&msg_93:int=0&{FLOW,(1,26)=__flow#E}}<msg_93:int>@M&
{FLOW,(1,26)=__flow#E}}<>@M&
{FLOW,(20,21)=__norm#E} [] |-  EBase 
   exists (Impl)[www_97:boolean]x:Unknown::Sess{ . chan:Unknown::R{ + emp&www_97:boolean&{FLOW,(1,26)=__flow#E}}<www_97:boolean>@M&
{FLOW,(1,26)=__flow#E}}<>@M&
   {FLOW,(20,21)=__norm#E}

Entail 3: Fail.(must) cause:matching of ho_args failed (matching of ho_args failed ( msg_93:int=0 |-  msg_93:int. LOCS:[0;20;21] (must-bug)))
*/

#######
SOLUTION: LATE TYPE CHECK:
########
---------------
to add a type check in do_match, before renaming (or during). Fail
if it cannot check the subtype!

for y:t1 and yy:t2 to check if
(i)  t1<:t2 (Typeinfer.sub_type) for Recv
(ii) t2<:t1 (Typeinfer.sub_type) for Send

=============================================
=============================================
./sleek msess/examples/ex6b1-S-and-R-no-arg.slk --pcp --dis-print-compact-projection-formula
=============================================

Status: Solved

norm of seq is a bit broken: too  many seq inserted
Seq should be inserted only for last element or when
the session formula contains a single base (incl SOr).


//2
checkentail x::Sess{@S ?0;;?1}<>
            |- x::Sess{@S ?0;;?1}<>.

  |
  |
  V


run_infer:
x::Sess{ . self::Seq{ . self::Seq{ . chan::R{ + msg::node<Anon_12,Anon_13>}<>,  emp}<>,
         . self::Seq{ . chan::R{ + emp&msg=null}<>, emp}<>}<>}<>
   |-
   exists (Impl)[Anon_14; Anon_15]
   x::Sess{ . self::Seq{ . self::Seq{ . chan::R{ + msg::node<Anon_14,Anon_15>}<>, emp}<>,
   . self::Seq{ . chan::R{ + emp&msg=null}<>, . emp}<>}<>}<>

lhs should be:

x::Sess{ . self::Seq{ . chan::R{ + msg::node<Anon_12,Anon_13>}<>,
         . self::Seq{ . chan::R{ + emp&msg=null}<>, emp}<>}<>}<>

=============================================
=============================================

Remove msg prim pred from hodef and parser,
as well as node kind.

=============================================
=============================================

Status: solved

NORM3, similar to NORM1 but without parser tricks.

self::Seq{self::Seq{a.b}, self::Seq{c,d}}
 |
 |
 V
self::Seq{a, self::Seq{b, self::Seq{c,d}}}

=============================================
=============================================

When creating a spec with checkentail and
specifying Sess predicate explicitly we don't
record the node type because it's not created
by session module. Set its kind as well.
We might be able to do it when updating
temporary heap names.

=============================================
=============================================
To check whether it's worth it to 
wrap the message formula into an exists

!v#F --> !(exists v: F)

=============================================
=============================================

Refactor translate_session with new transformer.

=============================================
=============================================

Comment parameters of transform_h_formula.


=============================================
=============================================
solver.ml
move new_consumed inside the post_do_match_
and update the es correspondingly

(eg. for Sor{A or B} --> new_consumed =A or new_consumed=B)

=============================================
=============================================
SOLVED

detect unsat for lhs disjuncts when inferring rel 
=============================================
SOLVED

create a HO rel (kind of a hybrid between ho var
and ho rel) to account for the transmitted message
of the generic specs

ex ex7d1-ho-rel.slk


checkentail x::Sess{@S ?vvv#vvv::node<_,_>}<> * y::node<_,_>
            |- x::Sess{@S ?www#%L(www)}<> * %L(y).
print residue.
expect Valid.


Entail 2: Valid. 

Residue:

 <1>emp&Anon_16=Anon_18 & Anon_17=Anon_19&{FLOW,(20,21)=__norm#E}
 ho_vars: [L[vvv_94] --> vvv_94::node<Anon_16,Anon_17>@M&
           {FLOW,(1,26)=__flow#E}]
[[ SEARCH ==>  Match(x,x) ==>  SEARCH ==>  Match(y,y)]]


=============================================
=============================================
SOLVED

add rflow_session_kind to rflow, so that we can reduce
norm time (by only attempting to norm those HO which have
this flag set)


=============================================
=============================================
SOLVED

add seq for each single transmission protocol.
needed to correctly instantiate the HO vars
of send/receive specs:


void send (Channel c, int x)
  requires c::Chan{@S !v#%L(v);;%R}<this> //* %L(x)
  ensures  c::Chan{@S %R}<this>;


call site:

// c::Chan{@S !0}<this>
// to correctly identify %R the current state should
// instead be:  c::Chan{@S !0;;emp}<this>
send (c,0);

!!! this norm needs to be applied for the specs as well

=============================================
=============================================
SOLVED (collect Chan pointer and use it for all the transmissions)

./hip msess/examples/ex4a1-.ss

SOL: rename "this" to the Chan pointer if exists

either keep "this" as parameter for Chan
or avoid renaming of "this" in the specs

(==solver.ml#12944==)
do_match@1
do_match inp1 : c::Chan{ . this::Seq{ . this::S{ - emp&msg_101=0&{FLOW,(1,28)=__flow#E}}<msg_101>@M&
{FLOW,(1,28)=__flow#E}, . this::S{ - emp&msg_102=1&{FLOW,(1,28)=__flow#E}}<msg_102>@M&
{FLOW,(1,28)=__flow#E}}<>@M&
{FLOW,(1,28)=__flow#E}}<>@M
do_match inp2 : c'::Chan{ . this_1905::Seq{ . this_1905::S{ - HVar L[v_98]&{FLOW,(1,28)=__flow#E}}<v_98>@M&
{FLOW,(1,28)=__flow#E}, . HVar R[]&{FLOW,(1,28)=__flow#E}}<>@M&
{FLOW,(1,28)=__flow#E}}<>@M
do_match inp3 :  emp&v_int_35_1903'=0 & c'=c & id'=id&{FLOW,(4,5)=__norm#E}
 es_gen_impl_vars(E): [L; v_98; R; this_1905]
 es_subst (from,to): []:[]
 es_cond_path: [0]
 es_var_measures 1: Some(MayLoop[]{})
 es_trace:  SEARCH ==>  Match(c,c')
do_match inp4 : emp&{FLOW,(4,5)=__norm#E}
do_match inp5 :[]
do_match@1 EXIT: MustErr Context: 
   fe_kind: MUST
   fe_name: separation entailment
   fe_locs: {
     fc_message: matching of ho_args failed (do_unmatched_rhs : this_1905::Seq{ . this::S{ - HVar L[v_98]&{FLOW,(1,28)=__flow#E}}<v_98>@M&
{FLOW,(1,28)=__flow#E}, . HVar R[]&{FLOW,(1,28)=__flow#E}}<>@M(may))
     fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}
   }
 [[ SEARCH ==>  Match(c,c')]]
 CEX:true
*/


=============================================
=============================================
To refact split_Sor to behave as split_disj
to refact heap_transformer

=============================================
=============================================

to implement Dyn typing 

=============================================
=============================================
SOLVED

too many emp (wrap_last_seq_node )

wrap_last_seq_node@15
wrap_last_seq_node inp1 :(emp ; (emp ; (c::Chan{. ((((?((emp) * ([] & msg = 0))) ;; (!((emp) * ([] & msg = 7)))) or ((?((emp) * ([] & msg = 1))) ;; (!((emp) * ([] & msg = 9))))) ;; (?((emp) * ([] & v > 0)))
) * ([] & true)( FLOW __norm)}<this>[HeapNode1]))) * ([] & true)( FLOW __norm)
wrap_last_seq_node@15 EXIT:(emp ; (emp ; (c::Chan{. ((((?((emp) * ([] & msg = 0))) ;; ((!((emp) * ([] & msg = 7))) ;; (emp))) or ((?((emp) * ([] & msg = 1))) ;; ((!((emp) * ([] & msg = 9))) ;; (emp)))) ;; ((?((emp) * ([] & v > 0))) ;; (emp))
) * ([] & true)( FLOW __norm)}<this>[HeapNode1]))) * ([] & true)( FLOW __norm)



=============================================
=============================================
SOLVED 
../../sleek ex9c4-bug-deleg.slk -dre "do_match\|match_one\|match_ho" >a

seems like the print and certain sess operations
only apply on the first session encounter:

(==solver.ml#12970==)
do_match@7@6@5@4@3@2@1
do_match inp1 : !( v_51::Chan{ . this::S{ - emp&msg=0}<msg>@M}<this>@M)

do_match inp2 : !( HVar L[ww_60])
=============================================
=============================================

[SOLVED]
refactor the SOR split (specially the rebuild SeqSor)

=============================================
=============================================

SOLVED (filter match_one_ho_arg such that only newly collected
ho maps are added to the state)

./../sleek ex9c4-bug-deleg.slk

why so many duplicates in the residue:
Entail 1: Valid. 

Residue:

 <1>emp&{FLOW,(20,21)=__norm#E}
 ho_vars: [L[v_73] --> v_73::Chan{ . (!( emp&msg_74=0)) ;; (emp)
&{FLOW,(20,21)=__norm#E}}<this>@M&
           {FLOW,(20,21)=__norm#E};
 R --> emp&{FLOW,(20,21)=__norm#E};
 
           L[v_73] --> v_73::Chan{ . (!( emp&msg_74=0)) ;; (emp)
&{FLOW,(20,21)=__norm#E}}<this>@M&
           {FLOW,(20,21)=__norm#E};
 R --> emp&{FLOW,(20,21)=__norm#E};
 
           L[v_73] --> v_73::Chan{ . (!( emp&msg_74=0)) ;; (emp)
&{FLOW,(20,21)=__norm#E}}<this>@M&
           {FLOW,(20,21)=__norm#E};
 R --> emp&{FLOW,(20,21)=__norm#E};
 
           L[v_73] --> v_73::Chan{ . (!( emp&msg_74=0)) ;; (emp)
&{FLOW,(20,21)=__norm#E}}<this>@M&
           {FLOW,(20,21)=__norm#E};
 R --> emp&{FLOW,(20,21)=__norm#E};
 
           L[v_73] --> v_73::Chan{ . (!( emp&msg_74=0)) ;; (emp)
&{FLOW,(20,21)=__norm#E}}<this>@M&
           {FLOW,(20,21)=__norm#E};
 R --> emp&{FLOW,(20,21)=__norm#E}]
[[ SEARCH ==>  Match(c1,c1) ==>  SEARCH ==>  Match(c2,c2)]]



=============================================
=============================================

[SOLVED] allow args with values

checkentail x::Chan{@S Fp<1,0.4>;;!1;;!2}<> |- x::Fp<1,0.4>.

Exception processed: Stream.Error("[opt_ann_cid_list] expected after LT (in [view_header])")
error at: 
SLEEK FAILURE (END)

=============================================
=============================================

[SOLVED] norm lemmas with session:

lemma  self::Chan{@S Fp<id,a>;;%R}<> -> self::Chan{@S %R}<> * self::Fp<id,a>.

ERROR: at ex10c4-split-lemma.slk_7:21_7:33
Message: **typeinfer.ml#1670:SESS_TEMP is neither 2 a data nor view name

Exception processed: Failure("**typeinfer.ml#1670:SESS_TEMP is neither 2 a data nor view name")
error at: 
SLEEK FAILURE (END)


=============================================
=============================================

[SOLVED] unsafe use of List.hd!!!

./sleek msess/examples/ex10c4.slk

Exception(match_one_ho_arg_simple@307):Failure("hd")
=============================================
=============================================

to have a unique ptr for each set of fences

=============================================
=============================================

ex10c4.slk

lemma_norm "REL" self::Chan{@S Fp<id,a>;;%R}<> -> self::Chan{@S %R}<> * self::Fp<id,a>.

// lemma cannot fire for innermost one cause the ent is between seq |- seq, and not Chan |- Chan
// should try and keep the channel until all nested args are verified
// rebuild the chan node after each seq head is checked

checkentail x::Chan{@S Fp<1,0.5>;;!1;;Fp<1,0.5>;;!2}<> |- x::Chan{@S !1;;!2}<> * x::Fp<1,1.0>.
expect Valid.
print residue.

=============================================
=============================================
../../sleek floats/ex10c4-split-lemma.slk -dre "norm_w_coerc\|apply_one_coerc\|do_match"

when floats are used in non-space formulae, ent results are as expected
-------------------------------------------------------------------------
checkentail x::Fp<1,0.5> * x::Fp<1,0.5> |- x::Fp<1,1.0>.

do_match@7
do_match inp1 : x::Fp<flted_36_130,flted_9_200>@M
do_match inp2 : x::Fp<flted_36_215,flted_36_214>@M
do_match inp3 :  emp&
flted_9_200=b_159+flted_36_129 & flted_36_127=FLOAT 0.5 & flted_36_128=1 & 
flted_36_129=FLOAT 0.5 & flted_36_130=1 & id_161=flted_36_128 & 
b_159=flted_36_127&{FLOW,(4,5)=__norm#E}
 es_evars: [flted_36_214; flted_36_215]
 es_gen_impl_vars(E): []
 es_ante_evars: [flted_9_200]
 es_subst (from,to): []:[]
 es_trace: (Complex: ACC) ==>  SEARCH ==>  COND ==>  Match(x,x)
do_match inp4 :rest rhs: emp&flted_36_215=1 & flted_36_214=FLOAT 1.&{FLOW,(4,5)=__norm#E}
do_match inp5 :[]
do_match@7 EXIT: MustErr Context: 
   fe_kind: MUST
   fe_name: logical bug
   fe_locs: {
     fc_message:  flted_9_200=FLOAT 0.5+FLOAT 0.5 |-  flted_9_200=FLOAT 1.. LOCS:[0;9;36] (must-bug)
     fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}
   }
 [[(Complex: ACC) ==>  SEARCH ==>  COND ==>  Match(x,x)]]
 CEX:false

Entail 1: Fail.(must) cause:12

Entail 1: Fail.(must) cause:12
Validate 1: Expecting(3)Valid BUT got : Fail_Must

-------------------------------------------------------------------------

checkentail x = 0.5 + 0.5 |- x=1.0.

Entail 2: Valid. 


=============================================
=============================================

Partially SOLVED: Norm.linearize_rename_global_args

HO-args are not linearized 


(==astsimp.ml#9053==)
case_normalize_renamed_formula@148@147
case_normalize_renamed_formula inp1 :view_decls:[SOr,Seq,R,S,Chan,Sess,Trans,Ff,Fp,Ff2,Fp2]
case_normalize_renamed_formula inp2 :avail_vs:[]
case_normalize_renamed_formula inp3 :expl:[]
case_normalize_renamed_formula inp4 :ann_vs:[]
case_normalize_renamed_formula inp5 :(EX  . ((Fp2{}<[id,bbb,q]>) ;; (%R)
)*([] & true)( FLOW __norm))
case_normalize_renamed_formula@148 EXIT:
 ### f = (EX  . ((Fp2{}<[id,bbb,q]>) ;; (%R)
)*([] & true)( FLOW __norm))
 ### h = []
 ### expl = []


=============================================
=============================================

after verifying a method which requires fences
for sync, all fences are left in the residue.

What we could do is to use "consuming" fences (Fc),
to be the dual of "accumulating" fences (Fa - previously Fp) 

(A->B:\D_a * C->B:\D_c) ;; (B->D:\D_d * B->E:\D_e)

(A->B:\D_a * C->B:\D_c) ;; F(id) ;; (B->D:\D_d * B->E:\D_e)

((A->B:\D_a;;Fa(id,1/2)) * (C->B:\D_c;;Fa(id,1/2))) ;; ((Fc(id,1/2) ;; B->D:\D_d) * (F(id,1/2)B->E:\D_e))

lemmas:

lemma_norm "ACC"  self::Fa<id,aa> * self::Fa<id,bb> -> self::Fa<id,aa+bb>.
lemma_norm "FULL" self::Fa<id,aaa> & aaa=1 -> self::Fc<id,1>.
lemma_norm "REL"  self::Chan{@S Fa2<id,ppp,qq>;;%R}<> -> self::Chan{@S %R}<> * qq::Fa<id,ppp>.
lemma_norm "CON"  self::Chan{@S Fc2<id,ppp1,qq> ;; %R}<> * qq::Fc<id,ppp2> -> self::Chan{@S %R}<> * qq::Ff<id,ppp2-ppp1>.
lemma_norm "REM"  self::Fc<_,aaa> & aaa=0 -> emp.


=============================================
=============================================

./../../hip ex12b1-bug-tpp-parser.ss

pred_sess_proj GBC<> == Fc2<22,1.0,qqq> ;; ?1;

parser is confused and tries to parse a proj formula, instead of tproj

File "ex12b1-bug-tpp-parser.ss", line 25, characters 40-42
 --error: Stream.Error("[projection_formula] expected after SEMICOLONSEMICOLON (in [projection_formula])")
 at:caught

Exception occurred: Stream.Error("[projection_formula] expected after SEMICOLONSEMICOLON (in [projection_formula])")


=============================================
=============================================
[SOLVED] by adding a LEM_NORM check in do_coercion

../../../hip ex12c-ABCDE.ss -p B -tp oc --esl --print-type

why was REM not applied? fence qqq should have been removed
qqq:Unknown::Fc<flted_33_2634:int,flted_16_10612:float>@M&

from sleek_log_ex12c-ABCDE_ss.txt:

res:  1[
    qqq:Unknown::Fc<flted_33_2634:int,flted_16_10612:float>@M&
ppp2_10615:float=flted_16_10825:float &  .... ]
============================================= 
=============================================

../../../hip ex12c-ABCDE.ss -p B_F2 -tp oc


HVar is not linearized: (HVar L[v_int_82_2225'])



!!! **WARNING****solver.ml#4438:FREE VAR IN HEAP RHS :[v_int_82_2225']
impl/expl/evars vars:[]
LHS:
  d'::Chan{ . emp&{FLOW,(4,5)=__norm#E}}<>@M * 
 a'::Chan{ . emp&{FLOW,(4,5)=__norm#E}}<>@M * 
 c::Chan{ . (!msg_137#( emp&msg_137=1)) ;; (emp)
&{FLOW,(4,5)=__norm#E}}<>@M * 
 e'::Chan{ . emp&{FLOW,(4,5)=__norm#E}}<>@M&
ppp2_10687=flted_16_10897 & flted_75_2706=flted_75_2704 & 
ppp2_10715=flted_14_10409 & flted_75_2704=flted_75_2710 & 
flted_14_10409=FLOAT 1. & flted_13_10402=bb_7268+flted_75_2709 & 
flted_75_2703=FLOAT 0.5 & flted_75_2704=22 & flted_75_2705=FLOAT 0.5 & 
flted_75_2706=22 & flted_75_2707=FLOAT 0.5 & flted_75_2708=22 & 
flted_75_2709=FLOAT 0.5 & flted_75_2710=22 & e'=e & c'=c & d'=d & a'=a & 
x'=1 & z'=1 & id_7270=flted_75_2708 & bb_7268=flted_75_2707 & 
flted_16_10897+flted_75_2703=ppp2_10715 & 
flted_16_11013+flted_75_2705=ppp2_10687 & v_int_82_2225'=1&
{FLOW,(4,5)=__norm#E}
 es_gen_impl_vars(E): []
RHS:
 EBase 
   exists (Impl)[v_106; R; 
   L]c'::Chan{ . (!v_106#( HVar L[v_106])) ;; (%R)
&{FLOW,(4,5)=__norm#E}}<>@M * 
     (HVar L[v_int_82_2225'])&
   {FLOW,(4,5)=__norm#E}
   EBase 
     emp&MayLoop[]&{FLOW,(4,5)=__norm#E}
     EAssume 
       c'::Chan{ . HVar R[]&{FLOW,(4,5)=__norm#E}}<>@M&{FLOW,(4,5)=__norm#E}
       struct:EBase 
                c'::Chan{ . HVar R[]&{FLOW,(4,5)=__norm#E}}<>@M&
                {FLOW,(4,5)=__norm#E}


=============================================
=============================================


too many norm attempts:


../../../hip ex12c-ABCDE.ss  -tp oc

too many norm attempts:

Total verification time: 58.5503 second(s)
	Time spent in main process: 51.570776 second(s)
	Time spent in child processes: 6.979524 second(s)

../../../hip ex12c-ABCDE.ss  -tp z3

Total verification time: 44.123804 second(s)
	Time spent in main process: 43.67408 second(s)
	Time spent in child processes: 0.449724 second(s)
	Z3 Prover Time: 0.011886 second(s)



=============================================
=============================================

=============================================
=============================================

to add support for quantification in global prot ex17.ss


=============================================
=============================================
../../hip ex17-careful-vs-regular-distributor.ss --esl

Proving precondition in method send$Channel~int Failed.
  (may) cause:  0<price' |-  price'=quot_3239. LOCS:[37;10] (may-bug)


id: 226; caller: []; line: 38; classic: false; kind: PRE; hec_num: 1; evars: []; impl_vars: [v_139,R,L]; infer_vars: [ ]; c_heap: emp; others:  es_infer_obj: [] globals: [@dis_err]
 checkentail dc::Chan{ . (G{}<[B,S,Dc,Dr,budget]>) ;; (emp)
&{FLOW,(4,5)=__norm#E}}<>@M * 
 dr::Chan{ . (G{}<[B,S,Dc,Dr,budget]>) ;; (emp)
&{FLOW,(4,5)=__norm#E}}<>@M * 
 c'::Chan{ . (!price_3241#( emp&0<price_3241 & price_3241=quot_3239)) ;; ((((?msg_3242#( emp&msg_3242=1)) ;; ((?qty_3243#( emp&0<=qty_3243)) ;; (?addr_3245#( addr_3245::Addr<Anon_3244>@M)))) or (?msg_3246#( emp&msg_3246=0))) ;; (emp))
&
{FLOW,(4,5)=__norm#E}}<>@M&
0<bound & bound'=bound & dr'=dr & dc'=dc & c'=c & 1<=id' & 0<price' & 
MayLoop[]&{FLOW,(4,5)=__norm#E}
 |-  c'::Chan{ . (!v_139#( HVar L[v_139])) ;; (%R)
&{FLOW,(4,5)=__norm#E}}<>@M * 
 (HVar L[price'])&
{FLOW,(4,5)=__norm#E}. 
ho_vars: nothing?
res:  failctxfe_kind: MAY
        fe_name: logical bug
        fe_locs: {
    fc_message:  0<price' |-  price'=quot_3239. LOCS:[37;10] (may-bug)
    fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}
  }
[[ SEARCH ==>  Match(c',c')]]false

=============================================
=============================================
dynamic-sync/ex16c
allow constants as parameters for session preds:

starting translation
Exception(case_normalize_program):Failure("**session.ml#474:: IPure.Var expected.")
Exception(trans_prog):Failure("**session.ml#474:: IPure.Var expected.")
Stop z3... 0 invocations caught

Exception occurred: Failure("**session.ml#474:: IPure.Var expected.")


=============================================
=============================================
dynamic-sync/ex16d.ss

why below is right? (FIXED)

============
RIGHT LEMMAS
============
[Lemma "CONCDL":  self::Chan{ . HVar R[]&{FLOW,(4,5)=__norm#E}}<>@M&{FLOW,(4,5)=__norm#E}<== (exists id_2278,
ptr_2279: self::Chan{ . (GC{}<[id_2278,ptr_2279]>) ;; (%R)
&{FLOW,(4,5)=__norm#E}}<>@M * 
          ptr_2279::GC<id_2278,ptr_2279>@M&
{FLOW,(4,5)=__norm#E})]


=============================================
=============================================
acc-cons-ver2/ex12b.ss

!!! **WARNING****solver.ml#4472:FREE VAR IN HEAP RHS :[res]
impl/expl/evars vars:[]
LHS:  (exists flted_26_201,flted_26_202,flted_26_203,flted_26_204,flted_26_205,
flted_26_206,
flted_26_207: a::Chan{ . (?msg_198#( emp&msg_198=1)) ;; ((Fp2{}<[flted_26_207,flted_26_206,qqq]>) ;; (emp))
&
{FLOW,(4,5)=__norm#E}}<>@M * 
              d::Chan{ . (?msg_199#( emp&msg_199=1)) ;; ((Fp2{}<[flted_26_205,flted_26_204,qqq]>) ;; (emp))
&
{FLOW,(4,5)=__norm#E}}<>@M * 
              c::Chan{ . (Fm2{}<[flted_26_203,flted_26_202,qqq,flted_26_201]>) ;; ((!msg_200#( emp&msg_200=1)) ;; (emp))
&
{FLOW,(4,5)=__norm#E}}<>@M&
MayLoop[] & flted_26_201=FLOAT 1. & flted_26_202=6 & flted_26_203=22 & 
flted_26_204=3 & flted_26_205=22 & flted_26_206=3 & flted_26_207=22 & c'=c & 
d'=d & a'=a&{FLOW,(4,5)=__norm#E})
 es_gen_impl_vars(E): []

=============================================
=============================================

=============================================
=============================================

=============================================
=============================================

=============================================
=============================================

=============================================
=============================================

=============================================
=============================================

=============================================
=============================================

=============================================
=============================================

=============================================
=============================================

=============================================
=============================================

=============================================
=============================================

