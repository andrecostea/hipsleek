=============================================
=============================================
msess/examples$ ../../sleek ex4-1B1S1S-a1.slk
==============================================

Status: SOLVED

it's now parsing, but fails at type check as below:

------------------------------------------------
!!! **astsimp.ml#9170:@TINA: update_temp_heap_name
Last Proving Location: hodef.slk_1:10_1:42

ERROR: at ex4-1B1S1S-a1.slk_5:22_5:26
Message: **typeinfer.ml#1626: is neither 2 a data nor view name

Entail 1: EXCast. Failure("**typeinfer.ml#1626: is neither 2 a data nor view name")
Validate 1: Expecting1 FailBUT got no residue
------------------------------------------------

Sol:
(i)  unk preds are set to a dedicated view name: SESS_TEMP
(ii) while creating a heap node, set a proper session kind flag
(iii) use the session flag during iformula normalization
      to update the heap name approriately
(i) & (ii) are already implemented
(iii) partially implemented. To continue as below:
      call a transform for formula which in turn
      calls Session.IProjection.update_temp_heap_name
      to update the heap. 


=============================================
=============================================

Status: SOLVED

change @ --> @S to flag a session formula inside
the HO arg list.

=============================================
=============================================

./sleek msess/examples/ex4-1B1S1S-a1.slk -dre "update_formula"
=============================================

Status: SOLVED

(i) to check why temp pred name for R is empty instead of SESS_TEMP
(ii) to check why typeinfer still complains about not finding view name:

(====)
update_formula@5@2@1
update_formula inp1 :(aa::{+ (emp ; (emp ; emp)) * ([] & 0 <= msg)( FLOW __flow)}<>@M[HeapNode1]) * ([] & true)( FLOW __flow)
update_formula@5 EXIT:(aa::R{+ (emp ; (emp ; emp)) * ([] & 0 <= msg)( FLOW __flow)}<>@M[HeapNode1]) * ([] & true)( FLOW __flow)

Last Proving Location: msess/examples/hodef.slk_1:10_1:42

ERROR: at msess/examples/ex4-1B1S1S-a1.slk_5:60_5:75
Message: **typeinfer.ml#1626: is neither 2 a data nor view name

Entail 1: EXCast. Failure("**typeinfer.ml#1626: is neither 2 a data nor view name")
Validate 1: Expecting1 FailBUT got no residue

=============================================
=============================================

Status: Solved, done in parser by applying right associativity to sequence

(1) NORM1
to normalize seq such that head is base/or/*/pred:

self::Seq{self::Seq{a.b}, self::Seq{c,d}}
 |
 |
 V
self::Seq{a, self::Seq{b, self::Seq{c,d}}} 

=============================================
=============================================

Status: Solved

(2) NORM2
to normalize second HO arg of seq such that
it contains no base/or/*/pred unless they are
part of a seq:

self::Seq{a,c}}
 |
 |
 V
self::Seq{a, self::Seq{c, emp}} 


self::Seq{a, c or/* b}}
 |
 |
 V
self::Seq{a, self::Seq{c or/* b, emp}}

=============================================
=============================================

Status: solved

create a wrapper to disable classic ent chek for
HO args when not base.


=============================================
=============================================

!!!disjunction


=============================================
=============================================

Status: Solved; Star node wasn't wrapped in
a Sequence.

./../sleek ex4-1B1S1S-a1.slk --pcp
=============================================

fail reason should have involved classical reason,
but instead:

Entail 15: Fail.(must) cause:matching of ho_args failed (matching of ho_args failed (matching of ho_args failed (do_unmatched_rhs : a::S{ - emp&msg=1&{FLOW,(1,26)=__flow#E}[]}<>@M(may))))

=============================================
=============================================

Status: Solved

Transform from struc_formula to session for
Projection only.

=============================================
=============================================

Status: Solved

Print compact Projection in cprinter/iprinter,
for h_formula.
Also add a flag to disable/enable compact
printing. By default, compact.

=============================================
=============================================

Status: Solved

Add support for second-order variables in projection
formula.

=============================================
=============================================

Solved: split into session type and node type

Should predicate nodes have Projection/Protocol
types in h_formula_heap_session_kind? Right now
it's None, which is not consistent with the
other types of nodes.

=============================================
=============================================

to support both multiparty projection, as well
as two-party with fences:
Projection vs TPProjection

=============================================
=============================================

Status: In Progress, added a batch of tests

to add test cases in run-fast-test and test
the second order vars.

=============================================
=============================================
./sleek msess/examples/ex5-ho.slk --pip
=============================================
using a dedicated var to denote transmitted
message confuses the typechecker:

Last Proving Location: ../../msess/notes/hodef.slk_7:10_7:31

ERROR: at ex5-ho.slk_25:48_25:49
Message: UNIFICATION ERROR : at location {(Line:25,Col:48),(Line:25,Col:49)} types node and int are inconsistent

Entail 6: EXCast. Failure("UNIFICATION ERROR : at location {(Line:25,Col:48),(Line:25,Col:49)} types node and int are inconsistent")

#######
SOLUTION:
########
to create a message container as below:
pred_prim Msg<a>.

The dedicated variable will then point to a
Msg structure whose parameter supports any type.

example (see also msess/examples/ex6a-Msg-AP.slk):
x::Sess{@S ?y::node<_,_>;;?0}<>
   |
   V
x::Sess{@S ?msg::Msg<y>  * y::node<_,_>;;?msg::Msg<z> & z=0}<>

=============================================
=============================================

When defining predicates such as:

pred_sess_proj ll12<n> == (c!self = null & n = 0) or (d?self = null).

We have a warning and an error:

WARNING: ex.slk_22:15_22:22:compute_view_fw_bw: data name in view is empty

Last Proving Location: ./hodef.slk_1:10_1:42

ERROR: at ex.slk_22:15_22:22
Message: compute_view_fw_bw: data not found:

This is because view_data_name is not set.
Should we do something about this?

=============================================
=============================================

sleekengine.ml:8833: let f = Session.IProjection.update_formula f

Should check whether it's multi or two party session.
It works because that method is the same anyway but it's not
quite rigorous.

=============================================
=============================================

Status: Solved

Make fields in node_session_info mandatory, not optional.

=============================================
=============================================

Status: Solved

To investigate: why iformulas are embedded in EX.

Use --pip.

pred_sess_proj ll12<n> == (c!self = null & n = 0) or (d?self = null).

becomes

(EX  . (self::Sess{. (EX  . (self::SOr{. (EX  . (c::S{- (EX  . (emp)*([] & (self = null) & (n = 0))( FLOW __flow))}<>@M[HeapNode1])*([] & true)( FLOW __flow))
or(EX  . (d::R{+ (EX  . (emp)*([] & self = null)( FLOW __flow))}<>@M[HeapNode1])*([] & true)( FLOW __flow))}<>@M[HeapNode1])*([] & true)( FLOW __flow))}<>@M[HeapNode1])*([] & true)( FLOW __flow))

According to the comments in the code, it's a "magic trick":
(*existential wrapping and other magic tricks, avail_vars -> program variables, function arguments...*)

We support it although it's not clear why it's so.

=============================================
=============================================

Status: Solved

Change IFs into match clauses in trans_h_formula_to_session

Use get_node_kind.

=============================================
=============================================

Status: Solved

Move is_projection to session.ml.

=============================================
=============================================

Add test cases for two party projection.

=============================================
=============================================

Status: Solved

Normalization: embed every node in a Seq node

We embed every node into a Seq node. This makes it easy
to deal with OR nodes, because for each OR branch we append the tail,
which is going to be the content of the Seq node.
The second element of the new Seq will be empty.

a::R{...}
 |
 |
 V
self::Seq{a::R{...}, emp}

=============================================
=============================================
./sleek msess/examples/ex6a-Msg-AP.slk --print-type -dre "match_one_ho"
=============================================
//3
checkentail x::Sess{@S ?msg::Msg<y>  & y=3;;?msg::Msg<z> & z=0}<> |-
            x::Sess{@S ?msg::Msg<yy> & yy;;?msg::Msg<zz> & zz=0}<>.
expect Fail.

/*
Entail 3: Valid. 

Validate 3: Expecting(3)Fail BUT got : Valid
*/

#######
SOLUTION: LATE TYPE CHECK:
########
---------------
to add a type check during match_one_ho...

match_one_ho_arg@24@23@22
match_one_ho_arg inp1 :(lhs: : + msg:Unknown::Msg<y:boolean>@M & y:boolean},
                        rhs: : + msg:Unknown::Msg<yy:int>@M & yy:int=3)
match_one_ho_arg@24 EXIT:(None,None,[])

for y:t1 and yy:t2 to check if
(i)  t1<:t2 (Typeinfer.sub_type) for Recv
(ii) t2<:t1 (Typeinfer.sub_type) for Send

=============================================
=============================================


=============================================
=============================================


=============================================
=============================================


=============================================
=============================================


=============================================
=============================================
