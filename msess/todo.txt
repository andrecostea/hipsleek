=============================================
=============================================
msess/examples$ ../../sleek ex4-1B1S1S-a1.slk
==============================================

Status: SOLVED

it's now parsing, but fails at type check as below:

------------------------------------------------
!!! **astsimp.ml#9170:@TINA: update_temp_heap_name
Last Proving Location: hodef.slk_1:10_1:42

ERROR: at ex4-1B1S1S-a1.slk_5:22_5:26
Message: **typeinfer.ml#1626: is neither 2 a data nor view name

Entail 1: EXCast. Failure("**typeinfer.ml#1626: is neither 2 a data nor view name")
Validate 1: Expecting1 FailBUT got no residue
------------------------------------------------

Sol:
(i)  unk preds are set to a dedicated view name: SESS_TEMP
(ii) while creating a heap node, set a proper session kind flag
(iii) use the session flag during iformula normalization
      to update the heap name approriately
(i) & (ii) are already implemented
(iii) partially implemented. To continue as below:
      call a transform for formula which in turn
      calls Session.IProjection.update_temp_heap_name
      to update the heap. 


=============================================
=============================================

Status: SOLVED

change @ --> @S to flag a session formula inside
the HO arg list.

=============================================
=============================================

./sleek msess/examples/ex4-1B1S1S-a1.slk -dre "update_formula"
=============================================

Status: SOLVED

(i) to check why temp pred name for R is empty instead of SESS_TEMP
(ii) to check why typeinfer still complains about not finding view name:

(====)
update_formula@5@2@1
update_formula inp1 :(aa::{+ (emp ; (emp ; emp)) * ([] & 0 <= msg)( FLOW __flow)}<>@M[HeapNode1]) * ([] & true)( FLOW __flow)
update_formula@5 EXIT:(aa::R{+ (emp ; (emp ; emp)) * ([] & 0 <= msg)( FLOW __flow)}<>@M[HeapNode1]) * ([] & true)( FLOW __flow)

Last Proving Location: msess/examples/hodef.slk_1:10_1:42

ERROR: at msess/examples/ex4-1B1S1S-a1.slk_5:60_5:75
Message: **typeinfer.ml#1626: is neither 2 a data nor view name

Entail 1: EXCast. Failure("**typeinfer.ml#1626: is neither 2 a data nor view name")
Validate 1: Expecting1 FailBUT got no residue

=============================================
=============================================

Status: Solved, done in parser by applying right associativity to sequence

(1) NORM1
to normalize seq such that head is base/or/*/pred:

self::Seq{self::Seq{a.b}, self::Seq{c,d}}
 |
 |
 V
self::Seq{a, self::Seq{b, self::Seq{c,d}}} 

=============================================
=============================================

Status: Solved
Status: Reverted, we might not require it.

(2) NORM2
to normalize second HO arg of seq such that
it contains no base/or/*/pred unless they are
part of a seq:

self::Seq{a,c}}
 |
 |
 V
self::Seq{a, self::Seq{c, emp}} 


self::Seq{a, c or/* b}}
 |
 |
 V
self::Seq{a, self::Seq{c or/* b, emp}}

=============================================
=============================================

Status: solved

create a wrapper to disable classic ent chek for
HO args when not base.


=============================================
=============================================

!!!disjunction


=============================================
=============================================

Status: Solved; Star node wasn't wrapped in
a Sequence.

./../sleek ex4-1B1S1S-a1.slk --pcp
=============================================

fail reason should have involved classical reason,
but instead:

Entail 15: Fail.(must) cause:matching of ho_args failed (matching of ho_args failed (matching of ho_args failed (do_unmatched_rhs : a::S{ - emp&msg=1&{FLOW,(1,26)=__flow#E}[]}<>@M(may))))

=============================================
=============================================

Status: Solved

Transform from struc_formula to session for
Projection only.

=============================================
=============================================

Status: Solved

Print compact Projection in cprinter/iprinter,
for h_formula.
Also add a flag to disable/enable compact
printing. By default, compact.

=============================================
=============================================

Status: Solved

Add support for second-order variables in projection
formula.

=============================================
=============================================

Solved: split into session type and node type

Should predicate nodes have Projection/Protocol
types in h_formula_heap_session_kind? Right now
it's None, which is not consistent with the
other types of nodes.

=============================================
=============================================

to support both multiparty projection, as well
as two-party with fences:
Projection vs TPProjection

=============================================
=============================================

Status: In Progress, added a batch of tests

to add test cases in run-fast-test and test
the second order vars.

=============================================
=============================================

When defining predicates such as:

pred_sess_proj ll12<n> == (c!self = null & n = 0) or (d?self = null).

We have a warning and an error:

WARNING: ex.slk_22:15_22:22:compute_view_fw_bw: data name in view is empty

Last Proving Location: ./hodef.slk_1:10_1:42

ERROR: at ex.slk_22:15_22:22
Message: compute_view_fw_bw: data not found:

This is because view_data_name is not set.
Should we do something about this?

=============================================
=============================================

sleekengine.ml:8833: let f = Session.IProjection.update_formula f

Should check whether it's multi or two party session.
It works because that method is the same anyway but it's not
quite rigorous.

=============================================
=============================================

Status: Solved

Make fields in node_session_info mandatory, not optional.

=============================================
=============================================

Status: Solved

To investigate: why iformulas are embedded in EX.

Use --pip.

pred_sess_proj ll12<n> == (c!self = null & n = 0) or (d?self = null).

becomes

(EX  . (self::Sess{. (EX  . (self::SOr{. (EX  . (c::S{- (EX  . (emp)*([] & (self = null) & (n = 0))( FLOW __flow))}<>@M[HeapNode1])*([] & true)( FLOW __flow))
or(EX  . (d::R{+ (EX  . (emp)*([] & self = null)( FLOW __flow))}<>@M[HeapNode1])*([] & true)( FLOW __flow))}<>@M[HeapNode1])*([] & true)( FLOW __flow))}<>@M[HeapNode1])*([] & true)( FLOW __flow))

According to the comments in the code, it's a "magic trick":
(*existential wrapping and other magic tricks, avail_vars -> program variables, function arguments...*)

We support it although it's not clear why it's so.

=============================================
=============================================

Status: Solved

Change IFs into match clauses in trans_h_formula_to_session

Use get_node_kind.

=============================================
=============================================

Status: Solved

Move is_projection to session.ml.

=============================================
=============================================

Add test cases for two party projection.

=============================================
=============================================

Status: Solved

Normalization: embed every node in a Seq node

We embed every node into a Seq node. This makes it easy
to deal with OR nodes, because for each OR branch we append the tail,
which is going to be the content of the Seq node.
The second element of the new Seq will be empty.

a::R{...}
 |
 |
 V
self::Seq{a::R{...}, emp}

=============================================
=============================================
./sleek msess/examples/ex6c1-msg-var-subtype.slk --dis-print-compact-projection-formula --print-type -dre "do_match" --pcp
=============================================
Below should fail because of inconsistent type
<msg_93:int> vs <www_97:boolean>

Instead it fails because it cannot prove
msg_93:int=0 |-  msg_93:int

......
//3
checkentail x::Sess{@S ?0}<>
            |- x::Sess{@S ?www#www}<>.
print residue.
expect Fail.

/*


(==solver.ml#12882==)
do_match@189
do_match inp1 : x:void::Sess{ . chan:Unknown::R{ + emp&msg_93:int=0&{FLOW,(1,26)=__flow#E}}<msg_93:int>@M&
{FLOW,(1,26)=__flow#E}}<>@M
do_match inp2 : x:Unknown::Sess{ . chan:Unknown::R{ + emp&www_97:boolean&{FLOW,(1,26)=__flow#E}}<www_97:boolean>@M&
....

run_infer:
 x:void::Sess{ . chan:Unknown::R{ + emp&msg_93:int=0&{FLOW,(1,26)=__flow#E}}<msg_93:int>@M&
{FLOW,(1,26)=__flow#E}}<>@M&
{FLOW,(20,21)=__norm#E} [] |-  EBase 
   exists (Impl)[www_97:boolean]x:Unknown::Sess{ . chan:Unknown::R{ + emp&www_97:boolean&{FLOW,(1,26)=__flow#E}}<www_97:boolean>@M&
{FLOW,(1,26)=__flow#E}}<>@M&
   {FLOW,(20,21)=__norm#E}

Entail 3: Fail.(must) cause:matching of ho_args failed (matching of ho_args failed ( msg_93:int=0 |-  msg_93:int. LOCS:[0;20;21] (must-bug)))
*/

#######
SOLUTION: LATE TYPE CHECK:
########
---------------
to add a type check in do_match, before renaming (or during). Fail
if it cannot check the subtype!

for y:t1 and yy:t2 to check if
(i)  t1<:t2 (Typeinfer.sub_type) for Recv
(ii) t2<:t1 (Typeinfer.sub_type) for Send

=============================================
=============================================
./sleek msess/examples/ex6b1-S-and-R-no-arg.slk --pcp --dis-print-compact-projection-formula
=============================================

Status: Solved

norm of seq is a bit broken: too  many seq inserted
Seq should be inserted only for last element or when
the session formula contains a single base (incl SOr).


//2
checkentail x::Sess{@S ?0;;?1}<>
            |- x::Sess{@S ?0;;?1}<>.

  |
  |
  V


run_infer:
x::Sess{ . self::Seq{ . self::Seq{ . chan::R{ + msg::node<Anon_12,Anon_13>}<>,  emp}<>,
         . self::Seq{ . chan::R{ + emp&msg=null}<>, emp}<>}<>}<>
   |-
   exists (Impl)[Anon_14; Anon_15]
   x::Sess{ . self::Seq{ . self::Seq{ . chan::R{ + msg::node<Anon_14,Anon_15>}<>, emp}<>,
   . self::Seq{ . chan::R{ + emp&msg=null}<>, . emp}<>}<>}<>

lhs should be:

x::Sess{ . self::Seq{ . chan::R{ + msg::node<Anon_12,Anon_13>}<>,
         . self::Seq{ . chan::R{ + emp&msg=null}<>, emp}<>}<>}<>

=============================================
=============================================

Remove msg prim pred from hodef and parser,
as well as node kind.

=============================================
=============================================

Status: solved

NORM3, similar to NORM1 but without parser tricks.

self::Seq{self::Seq{a.b}, self::Seq{c,d}}
 |
 |
 V
self::Seq{a, self::Seq{b, self::Seq{c,d}}}

=============================================
=============================================

When creating a spec with checkentail and
specifying Sess predicate explicitly we don't
record the node type because it's not created
by session module. Set its kind as well.
We might be able to do it when updating
temporary heap names.

=============================================
=============================================
