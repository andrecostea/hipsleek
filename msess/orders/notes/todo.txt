[DONE] to allow channel parsing as below:

pred_sess_prot G<A,B,C> == A->B:k(v#v=1) ;; C->B:k(2).

=====================================
=====================================
[DONE]  ex2.slk 
../../../../sleek ex2-assume.slk --pip
pred_sess_prot G1<A,B,C,k> == A->B:k(v#v=2) ;;Assume{x=1}<>;; C->B:k(2).

to check why assumes loses its its HO formula:
.........
session: (A -> B : (emp) * ([] & v = 2)( FLOW __stub)) ;; ((Assume{}<[]>) ;; (C -> B : (emp) * ([] & m
sg = 2)( FLOW __stub)))


to fix printer for session_predicate which ignores the ho params:
and string_of_session_predicate s =
    s.session_predicate_name ^ "{}" ^ "<" ^ ((pr_list !Base.print_param) s.session_predicate_params) ^ ">"

=====================================
=====================================
[DONE]
../../../../sleek ex2-assume.slk -dre "Session.trans_from_session"

to add debug location  + fix the below 

(====)
Session.trans_from_session@1
Session.trans_from_session inp1 :(!msg#((emp) * ([] & msg = 1)( FLOW __stub))) ;; (Assume{[. (emp) * (
[] & x = 1)( FLOW __norm)]}<[]>)                                                                     

Session.trans_from_session@1 EXIT:(!msg#((emp) * ([] & msg = 1))) ;; (Assume{[]}<[]>)

=====================================
=====================================
[DONE]
../../../../sleek ex2a-guard.slk -dre "norm_w_co\|apply_one_norm\|apply_left_coer\|match_one_ho"

!!! **solver.ml#15910:Andreea: add ho var info to new_ctx

**************************************************************
************** P_185 is discovered below as x=2: *************
**************************************************************
(==solver.ml#14743==)
match_one_ho_arg_simple@20@19@18@17@16@15@14@13@12@11@10@9@8@7
match_one_ho_arg_simple inp1 :( . (Guard{[ . emp&x=2]}<[]>) ;; ((!msg_172#( emp&msg_172=1)) ;; (emp))
&
{FLOW,(20,21)=__norm#E}, . (Guard{[ . HVar P_185[]]}<[]>) ;; (%R_184)
&{FLOW,(20,21)=__norm#E})
match_one_ho_arg_simple@20 EXIT:((ok:1,es:
Some(  emp&x=2&{FLOW,(20,21)=__norm#E}
 es_gen_impl_vars(E): []
 es_ho_vars_map: [P_185 --> emp&x=2&{FLOW,(20,21)=__norm#E}; 
                  R_184 --> (!msg_172#( emp&msg_172=1)) ;; (emp)
&
                  {FLOW,(20,21)=__norm#E}]
 es_heap: (Guard{[ . emp&x=2]}<[]>) ;; ((!msg_172#( emp&msg_172=1)) ;; (emp))
 * 
          c::Chan{ . (Guard{[ . emp&x=2]}<[]>) ;; ((!msg_172#( emp&msg_172=1)) ;; (emp))
&
{FLOW,(20,21)=__norm#E}}<>@M
 es_gen_expl_vars: [self_183; R_184; P_185]
 es_subst (from,to): []:[]
 es_trace: (Complex: lem_13) ==>  SEARCH ==>  COND ==>  Match(c,c))),(maps:[(P_185[], emp&x=2&{FLOW,(20,21)=__norm#E}),(R_184[], (!msg_172#( emp&msg_172=1)) ;; (emp)
&{FLOW,(20,21)=__norm#E})],subs:([],[])))

**************************************************************
********** trying to P_185 but its info was lost: ************
**************************************************************
(==solver.ml#15934==)
heap_entail@37@19@18@17@16@15@14@13@12@11@10@9@8@7
heap_entail inp1 : [ emp&x=2&{FLOW,(20,21)=__norm#E}
  es_gen_impl_vars(E): [msg_180]
  es_heap: c::Chan{ . (Guard{[ . emp&x=2]}<[]>) ;; ((!msg_172#( emp&msg_172=1)) ;; (emp))
&
{FLOW,(20,21)=__norm#E}}<>@M
  es_subst (from,to): []:[]
  es_trace: (Complex: lem_13)]
heap_entail inp2 : HVar P_185[]&{FLOW,(1,26)=__flow#E}
heap_entail@37 EXIT: MaybeErr Context: 
   fe_kind: MAY
   fe_name: separation entailment
   fe_locs: {
     fc_message: do_unmatched_rhs : HVar P_185[]
     fc_current_lhs_flow: {FLOW,(18,22)=__MayError#E}
   }
 [[(Complex: lem_13) ==>  SEARCH ==>  UnmatchedRHSData]]
 CEX:false


=====================================
=====================================
[DONE]
../../../../sleek ex3a-dis-classic.slk 

pred_prim Orders@nonclassic{%P}<>.

add support for nonclassic reasoning
when matching the HO args:

checkentail orders::Orders{ x::node<_,_> }<>
            |-
            orders::Orders{ emp }<>.
expect Valid.                                                                    
print residue.


=====================================
=====================================
[DONE - in-place replace of HO var] 
../../../../sleek ex3b-join-lemma-w-ho.slk

check lemma-application and HO vars renaming
P2 should be known below:
----------------
lemma_norm self::Orders{ %P1 }<> * self::Orders{ %P2 }<> -> self::Orders{ %P1 * %P2 }<>.
----------------
Validate 1: OK

Residue:

 <1>orders::Orders{ . (HVar P2[]) * 
   orders::HB{ . Event{[]}<[b1,flted_15_168]>
[AnnInactive,AnnInactive]&
{FLOW,(20,21)=__norm#E}, . Event{[]}<[c1,flted_15_167]>
[AnnInactive,AnnInactive]&
{FLOW,(20,21)=__norm#E}}<>@M&
{FLOW,(20,21)=__norm#E}}<>@M&flted_15_167=4 & 
                                                                    flted_15_168=2&{FLOW,(20,21)=__nor
m#E}                                                                                                 
[[(Complex: lem_12)]]

=====================================
=====================================
[DONE - use only in assume & guard]
add support for relations in Session

=====================================
=====================================
[DONE]
make chr work interactively

=====================================
=====================================
[DONE]
add ex3e to run-fast-test

=====================================
=====================================
[DONE]
merge border looses A related info:
-----------------------------------
(==order_summary.ml#455==)
merge_border@3@2@1
merge_border inp1 :(
RMap::[(B,B^id_55),(C,C^id_55)],
CMap::[(d,B-id_55->C)])
merge_border inp2 :(
RMap::[(A,A^id_54),(C,C^id_54)],
CMap::[(d,A-id_54->C)])
merge_border@3 EXIT:(
RMap::[(B,B^id_55),(C,C^id_55)],
CMap::[(d,B-id_55->C)])

=====================================
=====================================
../../../../sleek ex5a.....slk --sess

CHR fails for the chr example (which is ok since
Q is not defined), but the problem is that it
stops execution and doesn't check the
non-chr example. 

=====================================
=====================================
../../../../sleek ex5a.....slk
running this example without the --sess
argument leads to a loop.


=====================================
=====================================
[DONE]
to fix eqExp_list_f
eqExp_list_f => eqExp_set_f
eqExp_list_f => eqExp_pairwise_f 

=====================================
=====================================
add check for CHR relations in tpdispatcher.ml

=====================================
=====================================
[DONE]
bring rel id's to commons

=====================================
=====================================
[DONE]
clear the annotations (for pred & rel) eg. @send

=====================================
=====================================
why do we need 2 relations for HB, CB and Event?

=====================================
=====================================
[DONE] update examples/working/sleek/session/ex3e-lbl-rel.slk
to remove labels
