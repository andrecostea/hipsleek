sleek_include 'msess/notes/hodef.slk'.
sleek_include 'node.slk'.


checkentail x::node<a,_> |- (exists s: x::node<c,d> & s=0).

checkentail y::node<_,_> & x=0 or  y::node<_,_> &  x=2 or  y::node<_,_> & x=1 |- x>=0.
print residue.

checkentail x::Sess{@S !0 or !1 or !2}<> |- x::Sess{@S !v#v>=0}<>.

/*
checkentail x::Sess{@S (!0 or (!1;;!3) or !2) ;; !6}<> |- x::Sess{@S !v#v>=0}<>.


(((a or b) ;; c) or d) ;; e

((a;;c or b;;c) or d) ;; e

(a;;c;;d or b;;c;;d) ;;e

a;;c;;d;;e or b;;c;;d ;;e



 self::SOr{ . self::SOr{ . chan::S{ - emp&msg=0}<msg>  or chan::S{ - emp&msg=1}<msg>}<> or chan::S{ - emp&msg=2}<msg>}<>

f1: self::SOr{ . chan::S{ - emp&msg=0}<msg>  or chan::S{ - emp&msg=1}<msg>}<> & true
f2: chan::S{ - emp&msg=2}<msg> & true

*/


checkentail x::Sess{@S !0 or (!1;;!3) or !2;;!6}<> |-x::Sess{@S (!0;;!6) or ((!1;;!3);;!6) or (!2;;!6)}<>.

checkentail x::Sess{@S (!0 or (!1;;!3) or !2) ;; !6}<> |-x::Sess{@S (!0;;!6)}<>.



/*

x::Sess{ . self::Seq{ . self::SOr{ . self::SOr{ . chan::S{ - emp&msg=0}<msg>@M 
 or self::Seq{ . chan::S{ - emp&msg=1 }<msg>@M , . self::Seq{ . chan::S{ - emp&msg=3 }<msg>@M, emp }<> }<> }<> or chan::S{ - emp&msg=2 }<msg> }<> , .
  self::Seq{ . chan::S{ - emp&msg=6 }<msg>@M , . emp }<> }<> }<>
 |-  EBase 
   x::Sess{ . self::Seq{ . chan::S{ - emp&msg=0 }<msg>@M , . self::Seq{ . chan::S{ - emp&msg=6 }<msg>@M , . emp }<>@M&
 }<>@M&
 }<>@M&
   {FLOW,(20,21)=__norm#E}
*/



!1;!1;;(!0 or (!1;;(!2 or !3)) or !4) ;;!6 ;;!7

 |
 V

(!0;;!6 or (!1;;(!2 or !3));;!6 or !4;;!6

let rec fnc sf
match sf with
      | Sor k -> (fnk k.or) @ (fnc k.or2)
      | _     -> [sf]


[!0, (!1;;(!2 or !3)), !4]

[!0;;!6;;!7, (!1;;(!2 or !3));;(!6;;!7), !4;;!6;;!7]


(!1;;(!2 or !3));;(!6;;!7) |- !1;;(!2 or !3);;(!6;;!7)
 


