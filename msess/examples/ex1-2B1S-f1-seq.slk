/* model the communication instrument as a unique channel between one pair of processes */
/*  B1<->B2
    B1<->S
    B2<->S  */
/*
multi_buy(B1,S,B2) ==
   B1->S: string ;
   (S->B1 : int ;; B1->B2 : int)
   * (S->B2 : int) ;;
   (B2 -> S : 1 ;; B2 -> S : Addr ;; S -> B2 : Date 
    \/ B2 -> S : 0) .

P = P ;; P | (P \/ P) | (P) * (P) | F
F = A->B : k & \phi

*/
// ===============================================

pred_prim Trans{%P}<sender,receiver>.
pred_prim Sess{%P}<>.
pred_prim Chan<sess:Sess>.
pred_prim S{-%P}<>.
pred_prim R{+%P}<>.
pred_prim Seq{%P,%P}<>.

  /* //S_role */
  /* pred_msess sell(a,b) = a?String;a!Int;b!Int;(b?1;b?Addr;b!Date \/ b?0) */
pred sellor<a> == a::R{+ (exists r: r=1)}<> * a::R{+ emp}<> * a::S{- emp}<> or a::R{+ (exists r: r=0)}<>.
pred sell<a,b> == a::R{+ emp}<> * a::S{- emp}<> * b::S{- emp}<> * self::sellor<b>.
  /* //B1_role */
  /* pred_msess buy1(a,b) = a!String;a?Int;b!Int */
pred buy1<a,b> == a::S{- emp}<> * a::R{+ emp}<> * b::S{- emp}<>.
  /* //B2_role */
  /* pred_msess buy2(a,b) = a?int * b?int ; (b!1; b!Addr ; b?Date \/ b!0). */
/* pred buy2or<a> == a::S{- (exists r: r=1)}<> ;; a::S{- emp}<> ;; a::R{+ emp}<> or a::S{- (exists r: r=0)}<>.
   pred buy2<a,b> == a::R{+ emp}<> * b::R{+ emp}<> ;; self::buy2or<b>.
*/
/* pred_msess buy2(a,b) = a?int * b?int ;; (b!1;; b!Addr ;; b?Date \/ b!0). */
/*
pred buy2or<a> == self::Seq{a::S{- (exists r: r=1)}<>, self::Seq{ a::S{- emp}<>,  a::R{+ emp}<>}<>}<>
                  or a::S{- (exists r: r=0)}<>.
*/

pred buy2or<a> == self::Seq{a::S{- (exists r: r=1)}<>, self::Seq{ a::S{- emp}<>,  a::R{+ emp}<>}<>}<>
                  or self::Seq{a::S{- (exists r: r=0)}<>, emp}<>.

pred buy2<a,b> == self::Seq{a::R{+ emp}<> * b::R{+ emp}<> , emp}<>. //self::buy2or<b>}<>.
pred buy2p<a,b> == self::Seq{a::R{+ emp}<> * b::R{+ emp}<> , emp}<>. //self::buy2or<b>}<>.

data node {node next; int val;}.
data node2 {node2 next;}.

checkentail a::Chan<x> * b::Chan<x> * x::buy2<a,b> |- x::buy2<a,b>.
expect Valid.


checkentail a::Chan<x> * b::Chan<x> * x::buy2<a,b> |- x::buy2p<a,b>.
print residue.
expect Valid.

checkentail a::Chan<x> * b::Chan<x> * x::Seq{a::R{+ emp}<>, b::R{+ emp}<>}<> |- x::Seq{a::R{+ emp}<>, b::R{+ emp}<>}<> .
print residue.
expect Valid.

checkentail a::Chan<x> * b::Chan<x> * x::Seq{a::R{+ msg::node<_,_>}<>, b::R{+ emp}<>}<> |- x::Seq{a::R{+ emp}<>, b::R{+ emp}<>}<> .
print residue.
expect Fail.

checkentail a::Chan<x> * b::Chan<x> * x::Seq{a::R{+ msg::node<_,_>}<>, b::R{+ emp}<>}<> |- x::Seq{a::R{+ msg::node<_,_>}<>, b::R{+ emp}<>}<> .
print residue.
expect Valid.

checkentail a::Chan<x> * b::Chan<x> * x::Seq{a::R{+ msg::node<_,_>}<>, b::R{+ msg::node2<_>}<>}<> |- x::Seq{a::R{+ msg::node<_,_>}<>, b::R{+ msg::node2<_>}<>}<> .
print residue.
expect Valid.

/**
(i) normalize

Seq{P,emp}<> ---> P
Seq{emp,P}<> ---> P

*/

checkentail a::Chan<x> * b::Chan<x> * x::Seq{a::R{+ msg::node<_,_>}<>, x::Seq{b::R{+ msg::node2<_>}<>, emp}<>}<> |- x::Seq{a::R{+ msg::node<_,_>}<>, b::R{+ msg::node2<_>}<>}<> .
print residue.
expect Valid.

checkentail a::Chan<x> * b::Chan<x> * x::Seq{a::R{+ msg::node<_,_>}<>, b::R{+ msg::node2<_>}<>}<> |- x::Seq{a::R{+ msg::node<_,_>}<>, b::R{+ msg::node2<_>}<>}<> .
print residue.
expect Valid.

/**
(ii) how to tackle associativity ?
(A;B);C ~= A;(B;C)

always normalize to 
*/
//9
checkentail a::Chan<x> * b::Chan<x> * x::Seq{x::Seq{a::R{+ msg::node<_,_>}<>, b::R{+ msg::node2<_>}<>}<>, b::S{- msg::node2<_>}<>}<> |- x::Seq{a::R{+ msg::node<_,_>}<>,x::Seq{b::R{+ msg::node2<_>}<>, b::S{- msg::node2<_>}<>}<>}<> .
print residue.
expect Valid.

//10
checkentail a::Chan<x> * b::Chan<x> * x::Seq{a::R{+ msg::node<_,_>}<>, x::Seq{b::R{+ msg::node2<_>}<>, b::S{- msg::node2<_>}<>}<>}<> |- x::Seq{a::R{+ msg::node<_,_>}<>,x::Seq{b::R{+ msg::node2<_>}<>, b::S{- msg::node2<_>}<>}<>}<> .
print residue.
expect Valid.


//10
checkentail a::Chan<x> * b::Chan<x> *
            x::Seq{a::R{+ msg::node<_,_>}<>, x::Seq{b::R{+ msg::node2<_>}<>, b::S{- msg::node2<_>}<>}<>}<>
            |- x::Seq{a::R{+ msg::node<_,_>}<>,x::Seq{b::R{+ msg::node2<_>}<>, b::S{- msg::node2<_>}<>}<>}<> .
print residue.
expect Valid.



/*
data node {node next; int val;  }.

pred_prim Boo{%P}<>.
pred p1<a> == self::Boo{a::node<null,1>}<>.
pred p2<b> == self::Boo{b::node<null,1>}<>.
 
checkentail x::p1<c> |- x::p2<c>.
expect Valid.
*/


/*

((lhs: : . b::S{ - msg::node2<Anon_38>@M&{FLOW,(4,5)=__norm#E}[]}<>@M&
{FLOW,(4,5)=__norm#E}[],
rhs: : . x::Seq{ . b::R{ + msg::node2<Anon_41>@M&{FLOW,(4,5)=__norm#E}[]}<>@M&
{FLOW,(4,5)=__norm#E}[], . b::S{ - msg::node2<Anon_42>@M&{FLOW,(4,5)=__norm#E}[]}<>@M&
{FLOW,(4,5)=__norm#E}[]}<>@M&
{FLOW,(4,5)=__norm#E}[]),)

*/