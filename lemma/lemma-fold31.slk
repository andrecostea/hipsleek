data node {
	int val;
	node next;
}.

pred lseg<p, n> == self=p & n=0
	or self::node<_, r> * r::lseg<p, n-1>
	inv n>=0.

lemma_unsafe "lem_tail" self::lseg<p, n> 
   <- self::lseg<t, n-1> * t::node<_, p>.


checkentail_exact 
    self_lem_tail::node<_,r> * r::lseg<t,n-2> * t::node<_,p>
    |- self_lem_tail::lseg<p,n>.
expect Valid.
print residue.


// fold
checkentail_exact
     self_lem_tail::node<_,r> * r::lseg<t,n-2> * t::node<_,p>
    |- (exists r1: self_lem_tail::node<_, r1> * r1::lseg<p,n-1>).
expect Valid.
print residue.

/**

Entail 1: Fail.(must) cause:UnionR[ (((1<=flted_15_88 & r!=null) | (8=r & flted_15_88=0))) & flted_15_88+2=n |-  n_90=0 & n_90=n. LOCS:[1;0;15;6;16] (must-bug), exists(n_90:flted_15_88+1=n_90) & flted_15_88+2=n |-  flted_15_88+1=n_90 & n_90=n. LOCS:[15;7;16] (must-bug)]

Validate 1: Not Expected.

Entail 2: Valid.

Validate 2: Expected.


 <1>(exists flted_23_125: emp&flted_23_125+2=n & Anon_18=Anon_16 & t_132=t & exists(p_126:p=p_126) & exists(flted_24_127:flted_23_125+1=flted_24_127)&{FLOW,(21,22)=__norm})[]
[[ Match ==>  COND ==>  (Lemma <== lem_tail) ==>  Match ==>  Match ==> ]]

*/