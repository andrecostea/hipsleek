data node {
	int val;
	node next;
}.

pred lseg<p, n> == self=p & n=0
	or self::node<_, r> * r::lseg<p, n-1>
	inv n>=0.

lemma "ll_tail2" self::lseg<p, n> 
   <- self::lseg<t, n-1> * t::node<_, p>.

/*
# app-tl2c1.slk

 unsoundness in lemma application with 
  some existentials.

Expect: Valid.Fail.Valid.Fail.Valid.Fail.


Resulting in contradiction.
 <1>emp&qq=nn+1 & qq=2+nn&{FLOW,(21,22)=__norm}[]
[[ SEARCH ==>  (Lemma <== ll_tail2) ==> (right: ll_tail2) ==>  Match ==>  Match ==> ]]

*/ 

//(4)
checkentail x::lseg<tx,nn>@M 
  * tx::node<_,p>@M 
 |-  x::lseg<p, qq> & qq = nn+1.
print residue.

//(4)
checkentail x::lseg<tx,nn>@M 
  * tx::node<_,p>@M 
 |-  x::lseg<p, qq> & qq = nn+2.
print residue.


//(4)
checkentail x::lseg<tx,nn>@M 
  * tx::node<_,p>@M 
 |-  [qq] x::lseg<p, qq> & qq = nn+1.
print residue.


//(4)
checkentail x::lseg<tx,nn>@M 
  * tx::node<_,p>@M 
 |-  (exists qq: x::lseg<p, qq> & qq = nn+2).
print residue.
// UNSOUND


//(4)
checkentail x::lseg<tx,nn>@M 
  * tx::node<_,p>@M 
 |-  [qq] x::lseg<p, qq> & qq = nn+2.
print residue.
// UNSOUND

//(4)
checkentail x::lseg<tx,nn>@M 
  * tx::node<_,p>@M 
 |-  (exists qq: x::lseg<p, qq> & qq = nn+1).
print residue.
