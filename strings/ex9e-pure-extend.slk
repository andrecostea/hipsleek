data node {
	int val#VAL;
	node next#REC;
}.

pred ll<> == self=null
  or self::node<_,p> * p::ll<> & self!=null
inv true.

pred lln<n> == self = null & n = 0
	or self::node<_, q> * q::lln<n-1>
  inv n >= 0.

pred ll_one<> == self::node<_, q> * q::ll<>.

pred ll_one_ex<> == self::node<_, q> * q::lln<n>.

pred_extn size[R]<n> ==
      n=0 // base case
   or R::size<m> & n=1+m 
   inv n>=0.


pred llN<n:int> == extends ll<> with size[REC]<n> .


/*
//check duplicate
pred llN1<n:int> == extends llN<> with size[REC]<n> .


# ex9e.slk

# WHere us the base-case?

 view ll_one_exN{}[]<n:int>= 
  view_domains: (size,0,1)
   view ll_one_exN<n:int>= 
    EList
          exists (Expl)[](Impl)[Anon_96; 
         q_97](ex)[](* lbl: *){11}->(exists n_98: (* lbl: *){11}->self::node<Anon_96,q_97>@M * 
                                                                  q_97::lln<n_98>@M&
         n=n_98+1 & 0<=n_98&{FLOW,(1,26)=__flow#E}[]
      
  view vars: n
  ann vars (0 - not a posn): (@M,0),(@M,0)
  cont vars: 
  inv: true
  
  baga over inv: [([], true)]
  baga over inv (unfolded): [([self], 1<=n)]
  


# WHere is the inv n>=0?

*/


pred ll_one_exN<n:int> == extends ll_one_ex<> with size[REC]<n> .



//pred ll_oneN<n:int> == extends ll_one<> with size[REC]<n> .


