=============================================================
/*
# template/t3.slk  uninterpreted relation not working properly
*/
relation R(int a, int b).

checkentail R(a,b) |- R(a,b).
// FAIL but should succeed
// SUCCESS with Z3

infer [R] R(a,b) |- R(a,b).
print residue.
// incorrect:
// inferred rel: [RELDEFN R: ( true) -->  R(a,b)]
=============================================================
# mc91.ss (FIXED)

why did we infer 900-9n instead of simpler 100-n?


# mc91-v.ss
why did the presence of infer[r] leads to:

Starting Omega...oc
trans_prog
WARNING (must fix): Vars from[r]has type UNK
=============================================================
# templ-2.ss --gts (DONE)

To make --term-dis-bnd-pre work properly..

  (* need to perform boundedness check at recursive call *)
  if (!Globals.dis_term_chk || !Globals.dis_bnd_chk 
      || not(!Globals.term_bnd_pre_flag)) then (ctx, [])

 template int r(int x,int y) == r_0+(r_x*x)+(r_y*y).

infer [r]  y=y' & x=x' |-  0<=(r( x, y)).

  this seems to be boundedness check at pre-condition
  I suppose we should have >=0 at recursive call, namely:

  y=y' & x'<y' & xx=x+1 & x'=x |-  0<=(r( xx, y)).
 
infer [r]  y=y' & x=x' & x'<y' & !(v_bool_18_851') & x'<y' & !(v_bool_18_851') & 
v_int_19_850'=1+x' |-  (r( x, y))>(r( v_int_19_850', y')).
template_solve.
=============================================================
# temp-2b.slk  (FIXED)

infer [f] x + 1 <= y & x' = x + 1 & y' = y & r>0 
    |- f(x, y) >= 1 &   y>=x.
print residue.

inferred templ: [(1+x)<=y & x'=1+x & y=y' --> 1<=((a*x)+(b*y)) & x<=y]

However x<=y in consequent is redundant, as it has
already been proven.

New result:
inferred templ: [(1+x)<=y --> (1+(-1*a*x)+(-1*b*y))<=0
=============================================================
# templ-2b1.slk (FIXED)

infer [f] x + 1 <= y & x' = x + 1 & y' = y & Term[f(x,y)] 
   |- Term[f(x', y')].
print residue.

why no inferred templ?

 <1>Base emp&Term[f: f_0+(f_x*x)+(f_y*y)] & y=y' & x'=1+x & (1+x)<=y&{FLOW,(21,22)=__norm}[]
[[empty]]
*/

template_solve {f}.
=============================================================
=============================================================
# templ-2b1.slk (FIXED)

infer [f] x + 1 <= y & x' = x + 1 & y' = y & Term[f(x,y)] 
   |- Term[f(x', y')].
print residue.

------------------
 <1>Base emp&Term[f: f_0+(f_x*x)+(f_y*y)] & y=y' & x'=1+x & (1+x)<=y&{FLOW,(21,22)=__norm}[]
 inferred templ: [y=y' & x'=1+x & (1+x)<=y --> (f: f_0+(f_x*x)+(f_y*
                   y))>(f: f_0+(f_x*x')+(f_y*y'))]
[[empty]]

TEMPLATE INFERENCE RESULT: [ template int f(int x,int y) == 0+(-1*x)+(0*y)]
------------------
Is it better to just print:

 inferred templ[f]: [y=y' & x'=1+x & (1+x)<=y --> f(x,y)>f(x',y')]

I suppose this is how it is being captured internally?
or am I wrong?
=============================================================
# Ack-i3-infer.ss

Split relational assumption phase from template inference phase!

Can we support a lexicographic template?

Can we support relAssumption generation first, and then
to perform solving only during template infer?

=============================================================
# ll-length-r.ss

**** TEMPLATE ASSUMPTION ****
[ n=fr( v_946, n1_948) & n1_948=n_952 --> (r( n))>(r( n_952))
, 0<=n --> 0<=(r( n))
, n=fr( v_897, n1_896) & 0<=n1_896 --> 0<=n
, n=fb() --> 0<=n
]
**** TEMPLATE INFERENCE RESULT ****
[ template int r(int n) == 2+(1*n), 
template int fb() == 2, 
template int fr(int v,int n) == 3+(0*v)+(1*n)]

Looks good, though I was wondering
if we could support a more minimalistic outcome?

   fb() = 0
   fr(v,n) = 1+1*n
   r(n) = 0+1*n
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
