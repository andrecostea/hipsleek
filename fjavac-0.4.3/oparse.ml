(* This file is generated by ocfg.ml from ocfg.g. *)
(* oparse.ml - parser (input tokens to parse stack) *)

open Osyntax
module P = Pda
module C = Cfg
module S = Oscan

let rec _char_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Char x)}]) -> x
  | _ -> Std.assert_false ()

and _ident_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Ident x)}]) -> x
  | _ -> Std.assert_false ()

and _int_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Int x)}]) -> x
  | _ -> Std.assert_false ()

and _float_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Float x)}]) -> x
  | _ -> Std.assert_false ()

and _double_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Double x)}]) -> x
  | _ -> Std.assert_false ()

and _int64_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Int64 x)}]) -> x
  | _ -> Std.assert_false ()

and _int32_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Int32 x)}]) -> x
  | _ -> Std.assert_false ()

and _string_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.String x)}]) -> x
  | _ -> Std.assert_false ()

and g_of = function
  | P.Node (9,z,[x0;x1]) -> (r_plus_of !x0, f_star_of !x1)
  | _ -> Std.assert_false ()

and x_of = function
  | P.Node (10,z,[x0]) -> (_ident_of !x0)
  | _ -> Std.assert_false ()

and q_of = function
  | P.Node (11,z,[x0]) -> (_char_of !x0)
  | _ -> Std.assert_false ()

and r_of = function
  | P.Node (12,z,[x]) -> r_of !x
  | P.Node (14,z,[x0;x1;x2;x3;x4]) -> Alias (x_of !x0, sharp_marker_of !x2, u_plus_of !x3)
  | P.Node (13,z,[x0;x1;x2;x3;x4]) -> Union (x_of !x0, sharp_marker_of !x2, p_plus_of !x3)
  | _ -> Std.assert_false ()

and f_of = function
  | P.Node (15,z,[x0;x1;x2;x3;x4]) -> (x_of !x1, q_of !x3)
  | _ -> Std.assert_false ()

and a_of = function
  | P.Node (16,z,[x]) -> a_of !x
  | P.Node (18,z,[x0]) -> Non 
  | P.Node (17,z,[x0]) -> Left 
  | P.Node (19,z,[x0]) -> Right 
  | _ -> Std.assert_false ()

and p_of = function
  | P.Node (20,z,[x0;x1]) -> (a_of !x0, c_plus_bar_of !x1)
  | _ -> Std.assert_false ()

and c_of = function
  | P.Node (21,z,[x0;x1;x2]) -> (x_of !x0, u_star_of !x2)
  | _ -> Std.assert_false ()

and u_of = function
  | P.Node (22,z,[x]) -> u_of !x
  | P.Node (29,z,[x0]) -> Literal (q_of !x0)
  | P.Node (23,z,[x0]) -> Ident (x_of !x0)
  | P.Node (30,z,[x0;x1]) -> Marker (q_of !x0)
  | P.Node (28,z,[x0;x1]) -> Option (x_of !x0)
  | P.Node (24,z,[x0;x1]) -> Star (x_of !x0)
  | P.Node (26,z,[x0;x1]) -> Plus (x_of !x0)
  | P.Node (25,z,[x0;x1;x2]) -> Sstar (x_of !x0, q_of !x2)
  | P.Node (27,z,[x0;x1;x2]) -> Pplus (x_of !x0, q_of !x2)
  | _ -> Std.assert_false ()

and sharp_marker_of = function
  | P.Node (39,_,[]) -> false
  | _ -> true

and f_star_of = function
  | P.Node (33,_,[]) -> []
  | P.Node (34,_,[a;s]) -> (f_of !a) :: (f_star_of !s)
  | _ -> Std.assert_false ()

and u_star_of = function
  | P.Node (43,_,[]) -> []
  | P.Node (44,_,[a;s]) -> (u_of !a) :: (u_star_of !s)
  | _ -> Std.assert_false ()

and p_plus_of = function
  | P.Node (35,_,[a]) -> [p_of !a]
  | P.Node (36,_,[a;s]) -> (p_of !a) :: (p_plus_of !s)
  | _ -> Std.assert_false ()

and r_plus_of = function
  | P.Node (37,_,[a]) -> [r_of !a]
  | P.Node (38,_,[a;s]) -> (r_of !a) :: (r_plus_of !s)
  | _ -> Std.assert_false ()

and u_plus_of = function
  | P.Node (41,_,[a]) -> [u_of !a]
  | P.Node (42,_,[a;s]) -> (u_of !a) :: (u_plus_of !s)
  | _ -> Std.assert_false ()

and c_plus_bar_of = function
  | P.Node (31,_,[a]) -> [c_of !a]
  | P.Node (32,_,[a;_;s]) -> (c_of !a) :: (c_plus_bar_of !s)
  | _ -> Std.assert_false ()



(*---- Tag of terminal token (ftag). *)

let ftag : S.t -> int = function
  | S.Char _ -> 0
  | S.Double _ -> 1
  | S.Float _ -> 2
  | S.Ident _ -> 3
  | S.Int _ -> 4
  | S.Int32 _ -> 5
  | S.Int64 _ -> 6
  | S.String _ -> 7
  | S.Eof -> 8
  | S.Sharp -> 9
  | S.Star -> 10
  | S.StarStar -> 11
  | S.Plus -> 12
  | S.PlusPlus -> 13
  | S.Minus -> 14
  | S.Colon -> 15
  | S.Semi -> 16
  | S.Langle -> 17
  | S.Eq -> 18
  | S.Rangle -> 19
  | S.Question -> 20
  | S.Bar -> 21


(*---- Show descriptive tags of parsing tree (fshow). *)

let fshow (f:'u Pda.v) : string = match f with
  | P.Node (9,z,_) -> g_tag (g_of f)
  | P.Node (10,z,_) -> x_tag (x_of f)
  | P.Node (11,z,_) -> q_tag (q_of f)
  | P.Node (12,z,_) -> r_tag (r_of f)
  | P.Node (14,z,_) -> r_tag (r_of f)
  | P.Node (13,z,_) -> r_tag (r_of f)
  | P.Node (15,z,_) -> f_tag (f_of f)
  | P.Node (16,z,_) -> a_tag (a_of f)
  | P.Node (18,z,_) -> a_tag (a_of f)
  | P.Node (17,z,_) -> a_tag (a_of f)
  | P.Node (19,z,_) -> a_tag (a_of f)
  | P.Node (20,z,_) -> p_tag (p_of f)
  | P.Node (21,z,_) -> c_tag (c_of f)
  | P.Node (22,z,_) -> u_tag (u_of f)
  | P.Node (29,z,_) -> u_tag (u_of f)
  | P.Node (23,z,_) -> u_tag (u_of f)
  | P.Node (30,z,_) -> u_tag (u_of f)
  | P.Node (28,z,_) -> u_tag (u_of f)
  | P.Node (24,z,_) -> u_tag (u_of f)
  | P.Node (26,z,_) -> u_tag (u_of f)
  | P.Node (25,z,_) -> u_tag (u_of f)
  | P.Node (27,z,_) -> u_tag (u_of f)  
  | _ -> Std.assert_false ()                   (* non-toplevel tree *)


(*---- Disambiguation filters (filter). 
  Raise 'Invalid' exception to filter out unwanted syntax trees. *)

let list_filter = Listx.iter
let bool_filter x = ()
let option_filter = Std.opt_iter

let rec _info_filter x = ()
and _char_filter x = ()
and _ident_filter x = ()
and _int64_filter x = ()
and _int32_filter x = ()
and _int_filter x = ()
and _float_filter x = ()
and _double_filter x = ()
and _string_filter x = ()

and g_filter (x0,x1) = list_filter r_filter x0; list_filter f_filter x1

and x_filter x0 = _ident_filter x0

and q_filter x0 = _char_filter x0

and r_filter = function
  | Alias (x0,x1,x2) -> x_filter x0; bool_filter x1; list_filter u_filter x2
  | Union (x0,x1,x2) -> x_filter x0; bool_filter x1; list_filter p_filter x2

and f_filter (x0,x1) = x_filter x0; q_filter x1

and a_filter = function
  | Non -> ()
  | Left -> ()
  | Right -> ()

and p_filter (x0,x1) = a_filter x0; list_filter c_filter x1

and c_filter (x0,x1) = x_filter x0; list_filter u_filter x1

and u_filter = function
  | Literal x0 -> q_filter x0
  | Ident x0 -> x_filter x0
  | Marker x0 -> q_filter x0
  | Option x0 -> x_filter x0
  | Star x0 -> x_filter x0
  | Plus x0 -> x_filter x0
  | Sstar (x0,x1) -> x_filter x0; q_filter x1
  | Pplus (x0,x1) -> x_filter x0; q_filter x1



(*---- Disambiguation of parsing tree (ffilter). *)

let ffilter (f:'u Pda.v) : unit = match f with
  | P.Node (9,z,_) -> g_filter (g_of f)
  | P.Node (10,z,_) -> x_filter (x_of f)
  | P.Node (11,z,_) -> q_filter (q_of f)
  | P.Node (12,z,_) -> r_filter (r_of f)
  | P.Node (14,z,_) -> r_filter (r_of f)
  | P.Node (13,z,_) -> r_filter (r_of f)
  | P.Node (15,z,_) -> f_filter (f_of f)
  | P.Node (16,z,_) -> a_filter (a_of f)
  | P.Node (18,z,_) -> a_filter (a_of f)
  | P.Node (17,z,_) -> a_filter (a_of f)
  | P.Node (19,z,_) -> a_filter (a_of f)
  | P.Node (20,z,_) -> p_filter (p_of f)
  | P.Node (21,z,_) -> c_filter (c_of f)
  | P.Node (22,z,_) -> u_filter (u_of f)
  | P.Node (29,z,_) -> u_filter (u_of f)
  | P.Node (23,z,_) -> u_filter (u_of f)
  | P.Node (30,z,_) -> u_filter (u_of f)
  | P.Node (28,z,_) -> u_filter (u_of f)
  | P.Node (24,z,_) -> u_filter (u_of f)
  | P.Node (26,z,_) -> u_filter (u_of f)
  | P.Node (25,z,_) -> u_filter (u_of f)
  | P.Node (27,z,_) -> u_filter (u_of f)
  | _ -> Std.assert_false ()                   (* non-toplevel tree *)


(*---- Pushdown automaton. *)
(* let a : S.t P.a = Compat.of_binary "%a" *)
let a : S.t P.a = { 
P.ts = (* terminal sets *) [|
(* 00 *) "Char";
(* 01 *) "Double";
(* 02 *) "Float";
(* 03 *) "Ident";
(* 04 *) "Int";
(* 05 *) "Int32";
(* 06 *) "Int64";
(* 07 *) "String";
(* 08 *) "Eof";
(* 09 *) "#";
(* 10 *) "*";
(* 11 *) "**";
(* 12 *) "+";
(* 13 *) "++";
(* 14 *) "-";
(* 15 *) ":";
(* 16 *) ";";
(* 17 *) "<";
(* 18 *) "=";
(* 19 *) ">";
(* 20 *) "?";
(* 21 *) "|";
|];

P.xs = (* variable sets *) [|
(* 00 *) "_start";
(* 01 *) "_char";
(* 02 *) "_double";
(* 03 *) "_float";
(* 04 *) "_ident";
(* 05 *) "_int";
(* 06 *) "_int32";
(* 07 *) "_int64";
(* 08 *) "_string";
(* 09 *) "g";
(* 10 *) "x";
(* 11 *) "q";
(* 12 *) "r";
(* 13 *) "r/0";
(* 14 *) "f";
(* 15 *) "a";
(* 16 *) "a/0";
(* 17 *) "p";
(* 18 *) "c";
(* 19 *) "u";
(* 20 *) "u/0";
(* 21 *) "c_plus_bar";
(* 22 *) "f_star";
(* 23 *) "p_plus";
(* 24 *) "r_plus";
(* 25 *) "sharp_marker";
(* 26 *) "u_plus";
(* 27 *) "u_star";
|];

P.ps = (* production rules *) [|
(* 00 *) (0, [C.X 9; C.T 8]);
(* 01 *) (1, [C.T 0]);
(* 02 *) (2, [C.T 1]);
(* 03 *) (3, [C.T 2]);
(* 04 *) (4, [C.T 3]);
(* 05 *) (5, [C.T 4]);
(* 06 *) (6, [C.T 5]);
(* 07 *) (7, [C.T 6]);
(* 08 *) (8, [C.T 7]);
(* 09 *) (9, [C.X 24; C.X 22]);
(* 10 *) (10, [C.X 4]);
(* 11 *) (11, [C.X 1]);
(* 12 *) (12, [C.X 13]);
(* 13 *) (13, [C.X 10; C.T 15; C.X 25; C.X 23; C.T 16]);
(* 14 *) (13, [C.X 10; C.T 15; C.X 25; C.X 26; C.T 16]);
(* 15 *) (14, [C.T 14; C.X 10; C.T 15; C.X 11; C.T 16]);
(* 16 *) (15, [C.X 16]);
(* 17 *) (16, [C.T 17]);
(* 18 *) (16, [C.T 18]);
(* 19 *) (16, [C.T 19]);
(* 20 *) (17, [C.X 15; C.X 21]);
(* 21 *) (18, [C.X 10; C.T 15; C.X 27]);
(* 22 *) (19, [C.X 20]);
(* 23 *) (20, [C.X 10]);
(* 24 *) (20, [C.X 10; C.T 10]);
(* 25 *) (20, [C.X 10; C.T 11; C.X 11]);
(* 26 *) (20, [C.X 10; C.T 12]);
(* 27 *) (20, [C.X 10; C.T 13; C.X 11]);
(* 28 *) (20, [C.X 10; C.T 20]);
(* 29 *) (20, [C.X 11]);
(* 30 *) (20, [C.X 11; C.T 20]);
(* 31 *) (21, [C.X 18]);
(* 32 *) (21, [C.X 18; C.T 21; C.X 21]);
(* 33 *) (22, []);
(* 34 *) (22, [C.X 14; C.X 22]);
(* 35 *) (23, [C.X 17]);
(* 36 *) (23, [C.X 17; C.X 23]);
(* 37 *) (24, [C.X 12]);
(* 38 *) (24, [C.X 12; C.X 24]);
(* 39 *) (25, []);
(* 40 *) (25, [C.T 9]);
(* 41 *) (26, [C.X 19]);
(* 42 *) (26, [C.X 19; C.X 26]);
(* 43 *) (27, []);
(* 44 *) (27, [C.X 19; C.X 27]);
|];

P.qs = (* states *) [|
(* 00 *) [];
(* 01 *) [];
(* 02 *) [];
(* 03 *) [];
(* 04 *) [];
(* 05 *) [];
(* 06 *) [];
(* 07 *) [];
(* 08 *) [];
(* 09 *) [];
(* 10 *) [];
(* 11 *) [];
(* 12 *) [];
(* 13 *) [];
(* 14 *) [];
(* 15 *) [];
(* 16 *) [];
(* 17 *) [];
(* 18 *) [];
(* 19 *) [];
(* 20 *) [];
(* 21 *) [];
(* 22 *) [];
(* 23 *) [];
(* 24 *) [];
(* 25 *) [];
(* 26 *) [];
(* 27 *) [];
(* 28 *) [];
(* 29 *) [];
(* 30 *) [];
(* 31 *) [];
(* 32 *) [];
(* 33 *) [];
(* 34 *) [];
(* 35 *) [];
(* 36 *) [];
(* 37 *) [];
(* 38 *) [];
(* 39 *) [];
(* 40 *) [];
(* 41 *) [];
(* 42 *) [];
(* 43 *) [];
(* 44 *) [];
(* 45 *) [];
(* 46 *) [];
(* 47 *) [];
(* 48 *) [];
(* 49 *) [];
(* 50 *) [];
(* 51 *) [];
(* 52 *) [];
(* 53 *) [];
(* 54 *) [];
(* 55 *) [];
|];

P.q0 = (* main start state *) 0;

P.q0s = (* start state set *) [|
|];

P.cs = (* action table *) Hashx.of_array [|
((3, 0), [P.Shift 10]);
((4, 0), [P.Shift 10]);
((5, 0), [P.Shift 10]);
((6, 0), [P.Shift 10]);
((7, 0), [P.Shift 10]);
((8, 0), [P.Shift 10]);
((9, 0), [P.Shift 10]);
((10, 0), [P.Reduce 1]);
((41, 12), [P.Shift 45]);
((15, 0), [P.Reduce 4]);
((18, 0), [P.Reduce 10]);
((19, 0), [P.Reduce 11]);
((22, 0), [P.Reduce 39]);
((15, 11), [P.Reduce 4]);
((18, 11), [P.Reduce 10]);
((39, 0), [P.Reduce 22]);
((40, 0), [P.Reduce 29]);
((41, 0), [P.Reduce 23]);
((42, 0), [P.Reduce 30]);
((43, 0), [P.Reduce 28]);
((44, 0), [P.Reduce 24]);
((45, 0), [P.Reduce 26]);
((46, 0), [P.Reduce 25]);
((47, 0), [P.Reduce 27]);
((41, 11), [P.Shift 8]);
((53, 0), [P.Reduce 40]);
((15, 10), [P.Reduce 4]);
((4, 21), [P.Reduce 43]);
((6, 21), [P.Reduce 43]);
((18, 10), [P.Reduce 10]);
((10, 21), [P.Reduce 1]);
((15, 21), [P.Reduce 4]);
((18, 21), [P.Reduce 10]);
((19, 21), [P.Reduce 11]);
((41, 10), [P.Shift 44]);
((38, 21), [P.Reduce 21]);
((39, 21), [P.Reduce 22]);
((40, 21), [P.Reduce 29]);
((41, 21), [P.Reduce 23]);
((42, 21), [P.Reduce 30]);
((43, 21), [P.Reduce 28]);
((44, 21), [P.Reduce 24]);
((45, 21), [P.Reduce 26]);
((46, 21), [P.Reduce 25]);
((47, 21), [P.Reduce 27]);
((10, 20), [P.Reduce 1]);
((48, 21), [P.Shift 14]);
((22, 9), [P.Shift 53]);
((15, 20), [P.Reduce 4]);
((55, 21), [P.Reduce 44]);
((18, 20), [P.Reduce 10]);
((19, 20), [P.Reduce 11]);
((1, 8), [P.Shift 2]);
((11, 8), [P.Reduce 37]);
((40, 20), [P.Shift 42]);
((41, 20), [P.Shift 43]);
((3, 19), [P.Shift 35]);
((4, 19), [P.Reduce 43]);
((16, 8), [P.Reduce 33]);
((17, 8), [P.Reduce 9]);
((6, 19), [P.Reduce 43]);
((20, 8), [P.Reduce 12]);
((10, 19), [P.Reduce 1]);
((24, 8), [P.Reduce 14]);
((26, 8), [P.Reduce 13]);
((15, 19), [P.Reduce 4]);
((27, 8), [P.Reduce 33]);
((18, 19), [P.Reduce 10]);
((30, 8), [P.Reduce 15]);
((19, 19), [P.Reduce 11]);
((22, 19), [P.Reduce 39]);
((31, 19), [P.Shift 35]);
((36, 19), [P.Reduce 20]);
((38, 19), [P.Reduce 21]);
((50, 8), [P.Reduce 34]);
((39, 19), [P.Reduce 22]);
((40, 19), [P.Reduce 29]);
((3, 18), [P.Shift 33]);
((52, 8), [P.Reduce 38]);
((41, 19), [P.Reduce 23]);
((4, 18), [P.Reduce 43]);
((42, 19), [P.Reduce 30]);
((43, 19), [P.Reduce 28]);
((6, 18), [P.Reduce 43]);
((44, 19), [P.Reduce 24]);
((45, 19), [P.Reduce 26]);
((46, 19), [P.Reduce 25]);
((47, 19), [P.Reduce 27]);
((10, 18), [P.Reduce 1]);
((48, 19), [P.Reduce 31]);
((49, 19), [P.Reduce 32]);
((15, 18), [P.Reduce 4]);
((53, 19), [P.Reduce 40]);
((55, 19), [P.Reduce 44]);
((18, 18), [P.Reduce 10]);
((19, 18), [P.Reduce 11]);
((22, 18), [P.Reduce 39]);
((31, 18), [P.Shift 33]);
((36, 18), [P.Reduce 20]);
((38, 18), [P.Reduce 21]);
((39, 18), [P.Reduce 22]);
((40, 18), [P.Reduce 29]);
((3, 17), [P.Shift 34]);
((41, 18), [P.Reduce 23]);
((4, 17), [P.Reduce 43]);
((42, 18), [P.Reduce 30]);
((43, 18), [P.Reduce 28]);
((6, 17), [P.Reduce 43]);
((44, 18), [P.Reduce 24]);
((45, 18), [P.Reduce 26]);
((46, 18), [P.Reduce 25]);
((47, 18), [P.Reduce 27]);
((10, 17), [P.Reduce 1]);
((48, 18), [P.Reduce 31]);
((49, 18), [P.Reduce 32]);
((15, 17), [P.Reduce 4]);
((53, 18), [P.Reduce 40]);
((55, 18), [P.Reduce 44]);
((18, 17), [P.Reduce 10]);
((19, 17), [P.Reduce 11]);
((22, 17), [P.Reduce 39]);
((31, 17), [P.Shift 34]);
((36, 17), [P.Reduce 20]);
((38, 17), [P.Reduce 21]);
((39, 17), [P.Reduce 22]);
((40, 17), [P.Reduce 29]);
((41, 17), [P.Reduce 23]);
((42, 17), [P.Reduce 30]);
((4, 16), [P.Reduce 43]);
((43, 17), [P.Reduce 28]);
((5, 16), [P.Reduce 41]);
((44, 17), [P.Reduce 24]);
((6, 16), [P.Reduce 43]);
((45, 17), [P.Reduce 26]);
((46, 17), [P.Reduce 25]);
((47, 17), [P.Reduce 27]);
((48, 17), [P.Reduce 31]);
((10, 16), [P.Reduce 1]);
((49, 17), [P.Reduce 32]);
((53, 17), [P.Reduce 40]);
((15, 16), [P.Reduce 4]);
((55, 17), [P.Reduce 44]);
((18, 16), [P.Reduce 10]);
((19, 16), [P.Reduce 11]);
((23, 16), [P.Shift 24]);
((25, 16), [P.Shift 26]);
((29, 16), [P.Shift 30]);
((31, 16), [P.Reduce 35]);
((36, 16), [P.Reduce 20]);
((38, 16), [P.Reduce 21]);
((39, 16), [P.Reduce 22]);
((40, 16), [P.Reduce 29]);
((41, 16), [P.Reduce 23]);
((42, 16), [P.Reduce 30]);
((43, 16), [P.Reduce 28]);
((44, 16), [P.Reduce 24]);
((45, 16), [P.Reduce 26]);
((46, 16), [P.Reduce 25]);
((47, 16), [P.Reduce 27]);
((48, 16), [P.Reduce 31]);
((49, 16), [P.Reduce 32]);
((51, 16), [P.Reduce 36]);
((15, 15), [P.Reduce 4]);
((54, 16), [P.Reduce 42]);
((55, 16), [P.Reduce 44]);
((18, 15), [P.Reduce 10]);
((21, 15), [P.Shift 22]);
((0, 3), [P.Shift 15]);
((28, 15), [P.Shift 7]);
((3, 3), [P.Shift 15]);
((4, 3), [P.Shift 15]);
((5, 3), [P.Shift 15]);
((6, 3), [P.Shift 15]);
((37, 15), [P.Shift 4]);
((10, 3), [P.Reduce 1]);
((11, 3), [P.Shift 15]);
((12, 3), [P.Shift 15]);
((13, 3), [P.Shift 15]);
((14, 3), [P.Shift 15]);
((15, 3), [P.Reduce 4]);
((18, 3), [P.Reduce 10]);
((19, 3), [P.Reduce 11]);
((20, 3), [P.Reduce 12]);
((22, 3), [P.Reduce 39]);
((11, 14), [P.Reduce 37]);
((24, 3), [P.Reduce 14]);
((26, 3), [P.Reduce 13]);
((16, 14), [P.Shift 12]);
((20, 14), [P.Reduce 12]);
((32, 3), [P.Reduce 16]);
((33, 3), [P.Reduce 18]);
((34, 3), [P.Reduce 17]);
((35, 3), [P.Reduce 19]);
((24, 14), [P.Reduce 14]);
((26, 14), [P.Reduce 13]);
((27, 14), [P.Shift 12]);
((39, 3), [P.Reduce 22]);
((40, 3), [P.Reduce 29]);
((41, 3), [P.Reduce 23]);
((30, 14), [P.Reduce 15]);
((42, 3), [P.Reduce 30]);
((43, 3), [P.Reduce 28]);
((44, 3), [P.Reduce 24]);
((45, 3), [P.Reduce 26]);
((46, 3), [P.Reduce 25]);
((47, 3), [P.Reduce 27]);
((53, 3), [P.Reduce 40]);
((52, 14), [P.Reduce 38]);
((15, 13), [P.Reduce 4]);
((18, 13), [P.Reduce 10]);
((41, 13), [P.Shift 9]);
((15, 12), [P.Reduce 4]);
((18, 12), [P.Reduce 10]);
|];

P.go = (* goto table *) Hashx.of_array [|
((3, 20), 39);
((3, 10), 41);
((4, 20), 39);
((4, 10), 41);
((5, 20), 39);
((5, 10), 41);
((6, 20), 39);
((6, 10), 41);
((31, 23), 51);
((11, 10), 21);
((12, 10), 28);
((13, 10), 37);
((14, 10), 37);
((4, 27), 38);
((3, 17), 31);
((6, 27), 55);
((0, 24), 16);
((0, 4), 18);
((3, 4), 18);
((4, 4), 18);
((5, 4), 18);
((6, 4), 18);
((31, 17), 31);
((11, 24), 52);
((11, 4), 18);
((12, 4), 18);
((13, 4), 18);
((14, 4), 18);
((16, 14), 27);
((3, 11), 40);
((4, 11), 40);
((3, 1), 19);
((5, 11), 40);
((27, 14), 27);
((4, 1), 19);
((6, 11), 40);
((5, 1), 19);
((6, 1), 19);
((7, 11), 29);
((8, 11), 46);
((7, 1), 19);
((8, 1), 19);
((9, 11), 47);
((9, 1), 19);
((13, 21), 36);
((14, 21), 49);
((13, 18), 48);
((14, 18), 48);
((3, 15), 13);
((22, 25), 3);
((0, 12), 11);
((31, 15), 13);
((11, 12), 11);
((16, 22), 17);
((0, 9), 1);
((3, 19), 5);
((4, 19), 6);
((5, 19), 5);
((27, 22), 50);
((6, 19), 6);
((3, 26), 23);
((3, 16), 32);
((5, 26), 54);
((0, 13), 20);
((3, 23), 25);
((31, 16), 32);
((11, 13), 20);
((0, 10), 21);
|];

P.tag = (None:(S.t -> C.t) option);
P.show = None;
P.filter = None;
P.errors = [];
}

let _ = a.P.tag <- Some ftag
let _ = a.P.show <- Some fshow
let _ = a.P.filter <- Some ffilter


(* Generate a list of input tokens from lex (with EOF). *)
let rec input lex accum =
  let x = Oscan.token lex in
  let y = (Util.info lex, x) in
  if x = S.Eof then Listx.rev (y::accum) 
  else input lex (y::accum)

let parse (f:string) : Osyntax.g =
  let lex = Util.lex f in
  g_of (Parse.parse a (input lex []))
