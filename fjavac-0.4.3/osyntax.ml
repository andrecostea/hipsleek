(* This file is generated by ocfg.ml from ocfg.g. *)
(* osyntax.ml - syntax definitions and helpers. *)

(*---- Syntax definitions. *)

type _info = string
and _char = string
and _ident = string
and _int64 = int64
and _int32 = int32
and _int = int
and _float = float
and _double = float
and _string = string


and g = r list * f list

and x = _ident

and q = _char

and r =
  | Alias of x * bool * u list
  | Union of x * bool * p list

and f = x * q

and a =
  | Non
  | Left
  | Right

and p = a * c list

and c = x * u list

and u =
  | Literal of q
  | Ident of x
  | Marker of q
  | Option of x
  | Star of x
  | Plus of x
  | Sstar of x * q
  | Pplus of x * q


(* The function [show] below must be defined independently of the rest
of [*_sexp] (ie. do not use [let rec]), or type errors result. *)

(*---- Show as symbolic expressions (sexp). *)

let showf format = Std.showf format
let list_sexp f s = "[" ^ Listx.showz f s ^ "]"
let bool_sexp = Std.bool_show
let option_sexp = Std.opt_sexp
let string_sexp = Strx.code

let rec _info_sexp x = x
and _char_sexp x = x
and _ident_sexp x = string_sexp x
and _int64_sexp x = Int64.to_string x ^ "l"
and _int32_sexp x = Int32.to_string x
and _int_sexp x = string_of_int x
and _float_sexp x = string_of_float x ^ "f"
and _double_sexp x = string_of_float x^ "d"
and _string_sexp x = string_sexp x


and g_sexp (x0,x1) = showf "(g %s %s)" (list_sexp r_sexp x0) (list_sexp f_sexp x1)

and x_sexp x0 = showf "(x %s)" (_ident_sexp x0)

and q_sexp x0 = showf "(q %s)" (_char_sexp x0)

and r_sexp = function
  | Alias (x0,x1,x2) -> showf "(Alias %s %s %s)" (x_sexp x0) (bool_sexp x1) (list_sexp u_sexp x2)
  | Union (x0,x1,x2) -> showf "(Union %s %s %s)" (x_sexp x0) (bool_sexp x1) (list_sexp p_sexp x2)

and f_sexp (x0,x1) = showf "(f %s %s)" (x_sexp x0) (q_sexp x1)

and a_sexp = function
  | Non -> showf "(Non)" 
  | Left -> showf "(Left)" 
  | Right -> showf "(Right)" 

and p_sexp (x0,x1) = showf "(p %s %s)" (a_sexp x0) (list_sexp c_sexp x1)

and c_sexp (x0,x1) = showf "(c %s %s)" (x_sexp x0) (list_sexp u_sexp x1)

and u_sexp = function
  | Literal x0 -> showf "(Literal %s)" (q_sexp x0)
  | Ident x0 -> showf "(Ident %s)" (x_sexp x0)
  | Marker x0 -> showf "(Marker %s)" (q_sexp x0)
  | Option x0 -> showf "(Option %s)" (x_sexp x0)
  | Star x0 -> showf "(Star %s)" (x_sexp x0)
  | Plus x0 -> showf "(Plus %s)" (x_sexp x0)
  | Sstar (x0,x1) -> showf "(Sstar %s %s)" (x_sexp x0) (q_sexp x1)
  | Pplus (x0,x1) -> showf "(Pplus %s %s)" (x_sexp x0) (q_sexp x1)


(*---- Show as tag expressions (tag). *)

let list_tag f s = "[" ^ Listx.showz f s ^ "]"
let bool_tag = Std.bool_show
let option_tag = Std.opt_sexp
let string_tag = Strx.code

let rec _info_tag _ = ""
and _char_tag _ = "char"
and _ident_tag x = "id"
and _int64_tag _ = "int64"
and _int32_tag _ = "int32"
and _int_tag _ = "int"
and _float_tag _ = "float"
and _double_tag _ = "double"
and _string_tag x = "string"


and g_tag (x0,x1) = showf "%s %s" (list_tag r_tag x0) (list_tag f_tag x1)

and x_tag x0 = showf "%s" (_ident_tag x0)

and q_tag x0 = showf "%s" (_char_tag x0)

and r_tag = function
  | Alias (x0,x1,x2) -> showf "(Alias %s %s %s)" (x_tag x0) (bool_tag x1) (list_tag u_tag x2)
  | Union (x0,x1,x2) -> showf "(Union %s %s %s)" (x_tag x0) (bool_tag x1) (list_tag p_tag x2)

and f_tag (x0,x1) = showf "%s %s" (x_tag x0) (q_tag x1)

and a_tag = function
  | Non -> showf "(Non)" 
  | Left -> showf "(Left)" 
  | Right -> showf "(Right)" 

and p_tag (x0,x1) = showf "%s %s" (a_tag x0) (list_tag c_tag x1)

and c_tag (x0,x1) = showf "%s %s" (x_tag x0) (list_tag u_tag x1)

and u_tag = function
  | Literal x0 -> showf "(Literal %s)" (q_tag x0)
  | Ident x0 -> showf "(Ident %s)" (x_tag x0)
  | Marker x0 -> showf "(Marker %s)" (q_tag x0)
  | Option x0 -> showf "(Option %s)" (x_tag x0)
  | Star x0 -> showf "(Star %s)" (x_tag x0)
  | Plus x0 -> showf "(Plus %s)" (x_tag x0)
  | Sstar (x0,x1) -> showf "(Sstar %s %s)" (x_tag x0) (q_tag x1)
  | Pplus (x0,x1) -> showf "(Pplus %s %s)" (x_tag x0) (q_tag x1)


(*---- Show as source code (src). *)

let list_src = Listx.showz
let list_src_sep = Listx.show
let bool_src = Std.bool_src
let option_src = Std.opt_show
let string_src = Strx.code

let rec _info_src x = ""
let rec _char_src x = x
and _ident_src x = x
and _int64_src x = Int64.to_string x ^ "l"
and _int32_src x = Int32.to_string x
and _int_src x = string_of_int x
and _float_src x = string_of_float x ^ "f"
and _double_src x = string_of_float x ^ "d"
and _string_src x = string_src x


and g_src (x0,x1) = showf "%s %s" (list_src r_src x0) (list_src f_src x1)

and x_src x0 = showf "%s" (_ident_src x0)

and q_src x0 = showf "%s" (_char_src x0)

and r_src = function
  | Alias (x0,x1,x2) -> showf "%s : %s %s ;" (x_src x0) (bool_src "#" x1) (list_src u_src x2)
  | Union (x0,x1,x2) -> showf "%s : %s %s ;" (x_src x0) (bool_src "#" x1) (list_src p_src x2)

and f_src (x0,x1) = showf "- %s : %s ;" (x_src x0) (q_src x1)

and a_src = function
  | Non -> showf "=" 
  | Left -> showf "<" 
  | Right -> showf ">" 

and p_src (x0,x1) = showf "%s %s" (a_src x0) (list_src_sep "|"c_src  x1)

and c_src (x0,x1) = showf "%s : %s" (x_src x0) (list_src u_src x1)

and u_src = function
  | Literal x0 -> showf "%s" (q_src x0)
  | Ident x0 -> showf "%s" (x_src x0)
  | Marker x0 -> showf "%s ?" (q_src x0)
  | Option x0 -> showf "%s ?" (x_src x0)
  | Star x0 -> showf "%s *" (x_src x0)
  | Plus x0 -> showf "%s +" (x_src x0)
  | Sstar (x0,x1) -> showf "%s ** %s" (x_src x0) (q_src x1)
  | Pplus (x0,x1) -> showf "%s ++ %s" (x_src x0) (q_src x1)


(*---- Maps (map). *)

let list_map = Listx.map
let bool_map x = x
let option_map = Std.opt_map

let rec _info_map x = x
and _char_map x = x
and _ident_map x = x
and _int64_map x = x
and _int32_map x = x
and _int_map x = x
and _float_map x = x
and _double_map x = x
and _string_map x = x


and g_map (x0,x1) = (list_map r_map x0, list_map f_map x1)

and x_map x0 = (_ident_map x0)

and q_map x0 = (_char_map x0)

and r_map = function
  | Alias (x0,x1,x2) -> Alias (x_map x0, bool_map x1, list_map u_map x2)
  | Union (x0,x1,x2) -> Union (x_map x0, bool_map x1, list_map p_map x2)

and f_map (x0,x1) = (x_map x0, q_map x1)

and a_map = function
  | Non -> Non
  | Left -> Left
  | Right -> Right

and p_map (x0,x1) = (a_map x0, list_map c_map x1)

and c_map (x0,x1) = (x_map x0, list_map u_map x1)

and u_map = function
  | Literal x0 -> Literal (q_map x0)
  | Ident x0 -> Ident (x_map x0)
  | Marker x0 -> Marker (q_map x0)
  | Option x0 -> Option (x_map x0)
  | Star x0 -> Star (x_map x0)
  | Plus x0 -> Plus (x_map x0)
  | Sstar (x0,x1) -> Sstar (x_map x0, q_map x1)
  | Pplus (x0,x1) -> Pplus (x_map x0, q_map x1)


(*---- Iterators (iter). *)

let list_iter = Listx.iter
let bool_iter x = ()
let option_iter = Std.opt_iter

let rec _info_iter x = ()
and _char_iter x = ()
and _ident_iter x = ()
and _int64_iter x = ()
and _int32_iter x = ()
and _int_iter x = ()
and _float_iter x = ()
and _double_iter x = ()
and _string_iter x = ()


and g_iter (x0,x1) = list_iter r_iter x0; list_iter f_iter x1

and x_iter x0 = _ident_iter x0

and q_iter x0 = _char_iter x0

and r_iter = function
  | Alias (x0,x1,x2) -> x_iter x0; bool_iter x1; list_iter u_iter x2
  | Union (x0,x1,x2) -> x_iter x0; bool_iter x1; list_iter p_iter x2

and f_iter (x0,x1) = x_iter x0; q_iter x1

and a_iter = function
  | Non -> ()
  | Left -> ()
  | Right -> ()

and p_iter (x0,x1) = a_iter x0; list_iter c_iter x1

and c_iter (x0,x1) = x_iter x0; list_iter u_iter x1

and u_iter = function
  | Literal x0 -> q_iter x0
  | Ident x0 -> x_iter x0
  | Marker x0 -> q_iter x0
  | Option x0 -> x_iter x0
  | Star x0 -> x_iter x0
  | Plus x0 -> x_iter x0
  | Sstar (x0,x1) -> x_iter x0; q_iter x1
  | Pplus (x0,x1) -> x_iter x0; q_iter x1


