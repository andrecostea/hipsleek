(* scanx.ml - template for parser *)

let f ch = Std.fprintf ch "\
(* This file is generated by ocfg.ml from %s. *)
(* %sparse.ml - parser (input tokens to parse stack) *)

open %ssyntax
module P = Pda
module C = Cfg
module S = %sscan

let rec _char_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Char x)}]) -> x
  | _ -> Std.assert_false ()

and _ident_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Ident x)}]) -> x
  | _ -> Std.assert_false ()

and _int_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Int x)}]) -> x
  | _ -> Std.assert_false ()

and _float_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Float x)}]) -> x
  | _ -> Std.assert_false ()

and _double_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Double x)}]) -> x
  | _ -> Std.assert_false ()

and _int64_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Int64 x)}]) -> x
  | _ -> Std.assert_false ()

and _int32_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.Int32 x)}]) -> x
  | _ -> Std.assert_false ()

and _string_of = function
  | P.Node (_,_,[{contents = P.Leaf (S.String x)}]) -> x
  | _ -> Std.assert_false ()

%a

(*---- Tag of terminal token (ftag). *)

let ftag : S.t -> int = function
%a  | S.Eof -> %d
%a

(*---- Show descriptive tags of parsing tree (fshow). *)

let fshow (f:'u Pda.v) : string = match f with
%a  
  | _ -> Std.assert_false ()                   (* non-toplevel tree *)


(*---- Disambiguation filters (filter). 
  Raise 'Invalid' exception to filter out unwanted syntax trees. *)

let list_filter = Listx.iter
let bool_filter x = ()
let option_filter = Std.opt_iter

let rec _info_filter x = ()
and _char_filter x = ()
and _ident_filter x = ()
and _int64_filter x = ()
and _int32_filter x = ()
and _int_filter x = ()
and _float_filter x = ()
and _double_filter x = ()
and _string_filter x = ()

%a

(*---- Disambiguation of parsing tree (ffilter). *)

let ffilter (f:'u Pda.v) : unit = match f with
%a
  | _ -> Std.assert_false ()                   (* non-toplevel tree *)


(*---- Pushdown automaton. *)
(*let a : S.t P.a = Compat.of_binary \"%%a\"*)
let a : S.t P.a = %a

let _ = a.P.tag <- Some ftag
let _ = a.P.show <- Some fshow
let _ = a.P.filter <- Some ffilter


(* Generate a list of input tokens from lex (with EOF). *)
let rec input lex accum =
  let x = %sscan.token lex in
  let y = (Util.info lex, x) in
  if x = S.Eof then Listx.rev (y::accum) 
  else input lex (y::accum)

let parse (f:string) : %ssyntax.%s =
  let lex = Util.lex f in
  %s_of (Parse.parse a (input lex []))
"
