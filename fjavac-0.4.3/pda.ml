(* pda.ml - pushdown automaton *)

open Std
module A = Arrayx
module C = Cfg
module F = Fa
module H = Hashx
module L = Listx
module X = Setx
module S = Strx


(* Action 'c': shift to the state q, reduce by i-th rule. *)
type c = Shift of F.q | Reduce of int

(* Debug info 'z': file name, line number, column numbers. *)
type info = string                         

(* Abstract syntax tree 'v': node of i-th production rule. *)
type 'u v = Leaf of 'u | Node of int * info * 'u v ref list


(*---- Pushdown automaton 'a'.

Note: Terminals/tokens are tags (integers) instead of 'u (input token
type) because we should ignore information carried inside the tokens
(the string of identifiers, debugging info) when we do comparison and
make transition in the pushdown automaton.

The input grammar must be argumented, that is, we add a special start
symbol '_start' and put a standard end-of-file terminal at the end of
the first production (_start -> start EOF), such that the grammar

1) satisfies the invariant (INV-START) in Cfg module that 
     |production of _start| = 1

2) there is a terminal at the end in the first production, such that
the final state is all reduced.

  Invariant (INV-TBOUND): 0 <= t < size ts.
  Invariant (INV-XBOUND): 0 <= x < size xs.
  Invariant (INV-QBOUND): 0 <= q < A.size qs.

  Invariant (INV-TORDER): The order of the list of terminals (variable
  'ts') must be consistent with the list of terminals in the generated
  parser '?parse.ts' (as generated by 'Ocfg.gen_parse'). Built-in
  terminals are placed at the beginning such that the tag 't' can be
  computed from the terminal 'u' (using the function 't_of_u' below)
  independent of the set of terminals in 'Ocfg'.

  TODO: study the performance of using hashtable for action lookup -
  how dense is the rows and columns; whether to use arrays.
*)

(**** NOTE: delete all ?pda.cache files if this type definition of pda
is modified. Otherwise, 'Segmentation fault' occurs randomly!!! *)

type 'u a = {                           (* pushdown automaton *)
  ts : string array;                    (* terminals *)
  xs : string array;                    (* variables *)
  ps : (C.x * C.s) array;               (* productions *)
  qs : (C.tm list) array;               (* states *)
  q0 : F.q;                             (* main initial state *)
  q0s : F.q array;                      (* TODO: initial state set *)
  cs : (F.q * C.t, c list) H.t;         (* actions *)
  go : (F.q * C.x, F.q) H.t;            (* goto table *)
  mutable tag : ('u -> C.t) option;     (* token to tag *)
  mutable show : ('u v -> string) option; (* show tag expression *)
  mutable filter : ('u v -> unit) option; (* disambiguation filter *)
  mutable errors : (info * C.t * F.q) list;
}

(* Check production invariant INV-PBOUND. *)
let pcheck (ps:(C.x * C.s) array) (p:int) : unit =
  if (p < 0 || p >= A.size ps) then 
    fail "INV-PBOUND (0 <= p < size ps): %d, %d" p (A.size ps)

(* Check action invariant INV-CBOUND. *)
let ccheck (qs:'q array) (ps:(C.x * C.s) array) : c -> unit = function
  | Shift q -> F.qcheck qs q
  | Reduce p -> pcheck ps p

(* Check automaton invariants. *)
let check (a:'u a) : unit =
  C.xcheck a.qs a.q0;
  A.iter (fun (x,s) -> C.xcheck a.xs x; C.scheck a.ts a.xs s) a.ps;
  A.iter (L.iter (C.tm_check a.ts a.xs)) a.qs;
  H.iter (fun ((q,t),cs) -> 
    F.qcheck a.qs q; C.tcheck a.ts t; L.iter (ccheck a.qs a.ps) cs) a.cs;
  H.iter (fun ((q1,x),q2) -> 
    F.qcheck a.qs q1; C.xcheck a.xs x; F.qcheck a.qs q1) a.go

let goto (a:'u a) (q:F.q) (x:C.x) = H.get a.go (q, x)

let actions (a:'u a) (q:F.q) (t:C.t) : c list = H.get_list a.cs (q, t)


(*---- Show. *)

let ashow (a:'u a) : C.a -> string = function
  | C.T t -> "'" ^ a.ts.(t) ^ "'"
  | C.X x -> a.xs.(x)

let tm_show (a:'u a) ((x,s,i):C.tm) : string =
  let s2 = L.insert i "." (L.map (ashow a) s) in
  showf "%s -> %s" a.xs.(x) (S.catz s2)


(*---- Convert cfg to pda. *)

let of_cfg_real ((ts,xs,ps,x0) as g:(string,string) C.g) : 'u a =  
  if debug then C.check g;
  let ((qs,az,dt,q0,qf) as m) = C.ca_make g in (* characteristic automaton *)
  let ps2 = A.sort (A.mapic (fun x p -> L.map (fun s -> (x,s)) p) ps) in
  let pindex = H.index_array ps2 in
  let la = C.la g m in                  (* lookahead sets *)
  let cs = H.make (H.size dt) in        (* actions *)
  let go = H.make (H.size dt) in        (* gotos *)
  H.iter (fun ((q1,a),q2) -> 
    match az.(a) with 
    | C.T t -> H.add_set cs (q1, t) (Shift q2)
    | C.X x -> H.add go (q1,x) q2) dt;
  let f1 q (x,s,i) = 
    if L.size s = i then (* reducing rule *)
    let f2 t = H.add_set cs (q, t) (Reduce (pindex (x,s))) in
    X.iter f2 (la q x s) in
  X.iter (fun q -> X.iter (f1 q) qs.(q)) qf;
  { ts = ts;
    xs = xs;
    ps = ps2;
    qs = A.map X.to_list qs;
    q0 = q0;
    q0s = [||];                         (* TODO *)
    cs = H.map2 identity X.to_list cs;
    go = go;
    tag = None;
    show = None;
    filter = None;
    errors = [];
  } 

let of_cfg (g:(string,string) C.g) (prefix:string): 'u a = (* cached *) 
  let s = 
    try Util.arg_str "--cache"
    with Not_found -> prefix ^ "pda.cache" in 
  try    
    let (g2,a) = Compat.marshal_from_channel (open_in_bin s) in
    if g<>g2 then raise (Failure "invalid cache")
    else (printf "Using precomputed automaton in file %s...\n" s; a)
  with _ ->
    printf_flush "Generating parser automaton in file %s... " s;
    Util.timers_push ();
    let a = of_cfg_real g in
    let c = open_out_bin s in
    Compat.marshal_to_channel c (g,a); close_out c; 
    printf "(took %.01f seconds)\n" (Util.timers_pop ()); a


(*---- Print. *)

let cfprint (f:out_channel) : c -> unit = function
  | Shift q -> fprintf f "shift %d"  q
  | Reduce i -> fprintf f "reduce %d" i

(* pretty-printing *)
let fprint (f:out_channel) (a:'u a) : unit = 
  check a;
  let g1 f (q,t) = fprintf f "(%d, %s)" q (S.code a.ts.(t)) in
  let g2 f (q,x) = fprintf f "(%d, %s)" q (S.code a.xs.(x)) in
  fprintf f "{ 
P.ts = (* terminal sets *) %a;\n
P.xs = (* variable sets *) %a;\n
P.ps = (* production rules *) %a;\n
P.qs = (* states *) %a;\n
P.q0 = (* main start state *) %d;\n
P.q0s = (* start state set *) %a;\n
P.cs = (* action table *) %a;\n
P.go = (* goto table *) %a;\n
P.errors = [];
}" 
  (A.fprint S.fcode) a.ts
  (A.fprint S.fcode) a.xs
  (A.fprint (C.p_fprint a.ts a.xs)) a.ps
  (A.fprint (fun g x -> fprint g (L.show "\n  " (tm_show a) x))) a.qs
  a.q0
  (A.fprint int_fcode) a.q0s
  (H.fprint g1 (L.fprint_sep cfprint ", ")) a.cs
  (H.fprint g2 int_fcode) a.go

let cfcode (f:out_channel) : c -> unit = function
  | Shift q -> fprintf f "P.Shift %d"  q
  | Reduce i -> fprintf f "P.Reduce %d" i

let fcode (f:out_channel) (a:'u a) : unit = 
  let g f (x,y) = fprintf f "(%d, %d)" x y in
  fprintf f "{ 
P.ts = (* terminal sets *) %a;\n
P.xs = (* variable sets *) %a;\n
P.ps = (* production rules *) %a;\n
P.qs = (* states *) %a;\n
P.q0 = (* main start state *) %d;\n
P.q0s = (* start state set *) %a;\n
P.cs = (* action table *) %a;\n
P.go = (* goto table *) %a;\n
P.tag = (None:(S.t -> C.t) option);
P.show = None;
P.filter = None;
P.errors = [];
}" 
  (A.fprint S.fcode) a.ts
  (A.fprint S.fcode) a.xs
  (A.fprint (C.p_fcode a.ts a.xs)) a.ps
  (* TODO: states are too big to compile and run. *)
  (A.fprint (fun g x -> Std.fprint f "[]")) a.qs 
  a.q0
  (A.fprint int_fcode) a.q0s
  (H.fcode g (L.fcode cfcode)) a.cs
  (H.fcode g int_fcode) a.go


(*--- Conventions:

q - states
c - actions
k - stacks
a - pushdown automaton
t - terminal tag
u - input terminal
x - variable
v - abstract syntax tree
z - file line number

n - node
l - leaf
*)

