Problems with Inv Baga 
====================================
#dll-vc05.smt2.slk

../../../sleek dll-vc05.smt2.slk

FAIL

../../../sleek dll-vc05.smt2.slk --inv-baga

VALID

---------
EXPECTED: FAIL

====================================
#nlcl-vc01.smt2.slk --inv-baga

expected: VALID

====================================
#nlcl-vc01.smt2.slk

sleek nlcl-vc01.smt2.slk --lem-gen-unsafe

Valid

sleek nlcl-vc01.smt2.slk --lem-gen-unsafe --inv-baga

Fail

==============
Expect

sleek nlcl-vc01.smt2.slk --lem-gen-unsafe --inv-baga
Valid

====================================
--inv-baga
Starting hip-sleek tests:
Total number of errors: 6 in files:
  baga-test.slk({E15#Fail}) infer/infer16.slk({E2#Valid},{E5#Valid}) lemmas/sort2.slk({L1#Fail},{L2#Valid},{L3#Valid},{L6#Fail},{L8#Valid},{L9#Fail}) lemmas/app-tail.slk({L2#Valid}) lemmas/sll_tailL.slk({L1#Valid}) lemmas/dseg-new.slk({L1#Valid},{L2#Fail},{L3#Valid}).
====================================
# baga-test.slk --inv-baga -dre "is_view_a"

What is view17? why did this have arithmetic?

is_view_arith@1
is_view_arith inp1 : viewl7<q:node>=
  :EBase (* lbl: *){1}->emp&self=null & q=null&{FLOW,(1,24)=__flow}[]
  || :EBase exists (Expl)[](Impl)[r;
            Anon_25](ex)[](* lbl: *){2}->self::node<r> * r::node<Anon_25>&
            r=q&{FLOW,(1,24)=__flow}[]
  cont vars:
  inv: true
  unstructured formula:
   (* lbl: *){1}->emp&self=null & q=null&{FLOW,(1,24)=__flow}[]
   || (* lbl: *){2}->(exists r,Anon_25: self::node<r> * r::node<Anon_25>&r=q&
      {FLOW,(1,24)=__flow})[]
  xform: true
  is_recursive?: false
  view_data_name: node
====================================
bug in /smt/bugs/baga/succ-circuit06.defs.smt2.slk:

(null,null) in INEQ

still run too slow.

====================================
# solver.ml

1. check baga fixpoint first which is using syntactic imply
2. if new baga correct, change below for performance

for using syntactic unsat, need to invoke EPureN ..

(* TODO:EXPURE : need to invoke syn UNSAT ofr --inv-baga *)
and unsat_base_x prog (sat_subno:  int ref) f  : bool=
  let tp_call_wrapper npf = 

need to build and use syntactic imply below
      (* TODO-EXPURE : need to build new expure stuff *)
      let (split_ante1, new_conseq1) as xx = heap_entail_build_mix_formula_check 2 exist_vars tmp3 rhs_p pos in
      let split_ante0, new_conseq0 = 
        if (!Globals.super_smart_xpure) then heap_entail_build_mix_formula_check 3 exist_vars tmp2 rhs_p pos
        else xx

          (* TODO-EXPURE - need to use syntactic imply & move upwards *)
          if !Globals.gen_baga_inv then
            (imply_mix_formula 1 split_ante0 split_ante1 split_conseq imp_no memset) 
          else 
            (imply_mix_formula 1 split_ante0 split_ante1 split_conseq imp_no memset) 

====================================
# cpure.ml & expure.ml

We need to make baga modular so it is easy to switch between the
two versions. We need to add similar methods to EPURE and EPUREN
to make this happen. The three places are:

cprinter.ml
---------
(* new EPURE *)
let string_of_ef_pure = pr_triple (add_str "BAGA" P.string_of_spec_var_list) (add_str "EQ" P.EMapSV.string_of) (add_str "INEQ" (pr_list (pr_pair string_of_spec_var string_of_spec_var)))

(* old EPURE *)
let string_of_ef_pure = pr_pair (add_str "BAGA" P.string_of_spec_var_list) (add_str "pure" string_of_pure_formula)

cpure.ml
--------
(* TODO : this is an abstract type that should not be exposed *)
(* 
   type ef_pure = (spec_var list * var_aset * (spec_var * spec_var) list) 
*)
(* old extended pure formula *)
type ef_pure = (spec_var list * formula )

expure.ml
---------
(* module EPureI = EPUREN(SV) *)
module EPureI = EPURE(SV)

Since it is already working for EPUREN,
let us make the thing compile and run using EPURE.
For a start, I have added the following methods to
both EPURE and EPUREN but they have not been tested.

  (* TODO *)
  let subst_epure sst ((baga,f) as ep) = ep

====================================
# dll-vc05.smt2.slk --inv-baga

smt2014 branch

One of them seems redundant
Why are we computing baga inv at two places?

!!! baga inv(dll):[([], self=nx & bk=pr),([self], self=bk & self!=nx),([bk,self], bk!=nx & self!=nx)]Hello

!!! baga inv(dll):[(BAGA:[],pure: self=nx & bk=pr),(BAGA:[self],pure: self=bk & self!=nx),(BAGA:[bk,self],pure: bk!=nx & self!=nx)]
Starting Omega...oc



Why isn't baga_inv for dll printed in smt2014
branch. There
are 2 print statements here

has baga_inv been disabled permanently?
o
In astsimpl.ml
      let cviews1 = if !Globals.gen_baga_inv then
        List.map (fun cv ->
            let inv = Hashtbl.find CP.map_baga_invs cv.C.view_name in
            let _ = Debug.binfo_hprint (add_str ("baga inv("^cv.C.view_name^")") (Cprinter.string_of_ef_pure_disj)) inv no_pos in
            let _ = print_string_quiet "\n" in
            {cv with C.view_baga_inv = Some inv}

In expure.ml

  let _ = List.iter (fun (vc,inv) ->
      let _ = Debug.dinfo_hprint (add_str ("baga inv("^vc.Cast.view_name^")") (EPureI.string_of_disj)) inv no_pos in
      let _ = print_string "\n" in
      Hashtbl.replace map_baga_invs vc.Cast.view_name (EPureI.to_cpure_disj inv)

====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================

