Problems with Inv Baga 
====================================
#dll-vc05.smt2.slk

../../../sleek dll-vc05.smt2.slk

FAIL

../../../sleek dll-vc05.smt2.slk --inv-baga

VALID

---------
EXPECTED: FAIL

====================================
#nlcl-vc01.smt2.slk --inv-baga

expected: VALID

====================================
#nlcl-vc01.smt2.slk

sleek nlcl-vc01.smt2.slk --lem-gen-unsafe

Valid

sleek nlcl-vc01.smt2.slk --lem-gen-unsafe --inv-baga

Fail

==============
Expect

sleek nlcl-vc01.smt2.slk --lem-gen-unsafe --inv-baga
Valid

====================================
--inv-baga
Starting hip-sleek tests:
Total number of errors: 6 in files:
  baga-test.slk({E15#Fail}) infer/infer16.slk({E2#Valid},{E5#Valid}) lemmas/sort2.slk({L1#Fail},{L2#Valid},{L3#Valid},{L6#Fail},{L8#Valid},{L9#Fail}) lemmas/app-tail.slk({L2#Valid}) lemmas/sll_tailL.slk({L1#Valid}) lemmas/dseg-new.slk({L1#Valid},{L2#Fail},{L3#Valid}).
====================================
# baga-test.slk --inv-baga -dre "is_view_a"

What is view17? why did this have arithmetic?

is_view_arith@1
is_view_arith inp1 : viewl7<q:node>=
  :EBase (* lbl: *){1}->emp&self=null & q=null&{FLOW,(1,24)=__flow}[]
  || :EBase exists (Expl)[](Impl)[r;
            Anon_25](ex)[](* lbl: *){2}->self::node<r> * r::node<Anon_25>&
            r=q&{FLOW,(1,24)=__flow}[]
  cont vars:
  inv: true
  unstructured formula:
   (* lbl: *){1}->emp&self=null & q=null&{FLOW,(1,24)=__flow}[]
   || (* lbl: *){2}->(exists r,Anon_25: self::node<r> * r::node<Anon_25>&r=q&
      {FLOW,(1,24)=__flow})[]
  xform: true
  is_recursive?: false
  view_data_name: node
====================================
bug in /smt/bugs/baga/succ-circuit06.defs.smt2.slk:

(null,null) in INEQ

still run too slow.

====================================
# solver.ml

1. check baga fixpoint first which is using syntactic imply
2. if new baga correct, change below for performance

for using syntactic unsat, need to invoke EPureN ..

(* TODO:EXPURE : need to invoke syn UNSAT ofr --inv-baga *)
and unsat_base_x prog (sat_subno:  int ref) f  : bool=
  let tp_call_wrapper npf = 

need to build and use syntactic imply below
      (* TODO-EXPURE : need to build new expure stuff *)
      let (split_ante1, new_conseq1) as xx = heap_entail_build_mix_formula_check 2 exist_vars tmp3 rhs_p pos in
      let split_ante0, new_conseq0 = 
        if (!Globals.super_smart_xpure) then heap_entail_build_mix_formula_check 3 exist_vars tmp2 rhs_p pos
        else xx

          (* TODO-EXPURE - need to use syntactic imply & move upwards *)
          if !Globals.gen_baga_inv then
            (imply_mix_formula 1 split_ante0 split_ante1 split_conseq imp_no memset) 
          else 
            (imply_mix_formula 1 split_ante0 split_ante1 split_conseq imp_no memset) 

====================================
# cpure.ml & expure.ml & cprinter.ml (DONE)

We need to make baga modular so it is easy to switch between the
two versions. We need to add similar methods to EPURE and EPUREN
to make this happen. The three places are:

cprinter.ml
---------
(* new EPURE *)
let string_of_ef_pure = pr_triple (add_str "BAGA" P.string_of_spec_var_list) (add_str "EQ" P.EMapSV.string_of) (add_str "INEQ" (pr_list (pr_pair string_of_spec_var string_of_spec_var)))

(* old EPURE *)
let string_of_ef_pure = pr_pair (add_str "BAGA" P.string_of_spec_var_list) (add_str "pure" string_of_pure_formula)

cpure.ml
--------
(* TODO : this is an abstract type that should not be exposed *)
(* 
   type ef_pure = (spec_var list * var_aset * (spec_var * spec_var) list) 
*)
(* old extended pure formula *)
type ef_pure = (spec_var list * formula )

expure.ml
---------
(* module EPureI = EPUREN(SV) *)
module EPureI = EPURE(SV)

Since it is already working for EPUREN,
let us make the thing compile and run using EPURE.
For a start, I have added the following methods to
both EPURE and EPUREN but they have not been tested.

  (* TODO *)
  let subst_epure sst ((baga,f) as ep) = ep

====================================
# baga-test-1.slk

pred l6<q:node> == 
  q::node<_> & self=null
  or self::node<r>*r::node<_> & r=q
inv q!=null.

// baga {q}


!!! baga inv(l6):
[(BAGA:[q],EQ:emap[{null,self}],INEQ:[]),
 (BAGA:[q,self],EQ:emap[{q}],INEQ:[])]
Disabling baga inv gen ..

# why disabling baga_inv with l6 pred?

====================================
====================================
# baga-test-4.slk --inv-baga

null is supposed to be captured a "_".
Why was it captured as "null" in emap? Has it
not been captured properly?

!!! baga inv(l7):[(BAGA:[],EQ:emap[{null,q,self}],INEQ:[]),(BAGA:[q,self],EQ:emap[],INEQ:[])]

====================================
# succ-circuit20.defs.smt2.slk --inv-baga

why disable baga called many times.
after first call, we should avoid baga computation totally

Why was simplify called? What caused the time-out.
Is it large formula or wrong format?

Starting Omega...oc
Timeout when checking #simplify  Restarting Omega after ... 12 invocations Stop Omega... 12 invocations Starting Omega...oc
T
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================
====================================

