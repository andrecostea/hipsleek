# elseg.slk

Below seems to have triggered folding and unfolding loop?

pred elseg<p> == self=p
  or (exists a,b: self::node<a> * a::node<b> * b::elseg<p>)
 inv true.

// lemma_safe self::elseg<p> <-> (exists u: self::elseg<u> * u::elseg<p>).

checkentail_exact x::node<a>*a::elseg<p> |- x::elseg<p>.
====================================================================
# smt/acc-fold/nlseg.slk

// below should succeed @L should not be considered
   a residue for --classic reasoning
 <1>p::node<_>@L&p!=x&{FLOW,(21,22)=__norm}[]

checkentail_exact x::node<a>*a::nlseg<p> *  p::node<_>@L
                |- x::nlseg<p>.
print residue.
====================================================================
# nlseg3.slk

 folding with -L not working properly..


pred nlseg<p> == 
  (exists a: self::node<a> * a::node<p>@L)
 inv true.

checkentail x::node<y>*y::node<p> |- x::nlseg<p>.
print residue.


/*
 <1>emp&{FLOW,(21,22)=__norm}[]
[[ SEARCH ==>  Fold ==>  Match ==>  Match ==> ]]
 why @L eaten node up?
*/
====================================================================
# nlseg3d.slk not working for @A (OK - should fail)

checkentail x::node<_>@A * x::node<_>@A   |-  false.
print residue.
// fail but should have aucceeede..

====================================================================
# nlseg3c.slk not working for @A (FIXED)

not working for unfolding..
====================================================================
# inv1.slk --inv (FIXED)

Can we print name of predicate tgt
with the inferred invariant?

!!! new inv: : n>=0

!!! new inv: : n>=1 & self!=null

!!! new inv: : n>=0
====================================================================
# inv3.slk (FIXED)

pred ll<n> == self = null & n=0
    or self::node2<_,r> * r::ll<n-1>
 inv true.

pred ll3<n> == self::node2<_,null> & n=1
    or self::node2<_,r> * r::ll<n-1>
 inv true.

aux recursive but detected as bad mutual recursion??

!!! new inv: : n>=0
fixcalc: bad mutual recursion detected :"ll"
Fatal error: exception Loc.Exc_located(_, _)


// Seems there is no bottom-up processing of predicates
// where aux predicates are processed before parent predicaets

ll3:={[self,n] -> [] -> []:  exists (NODflted_11_18,NODAnon_13: self>0 && (NODflted_11_18<=0 && n=1)) ||  exists (flted_12_19,NODAnon_14,NODr: (self>0 && ll(NODr,flted_12_19)) && flted_12_19+1=n)
};
bottomupgen([ll3], [1], SimHeur);
====================================================================
inv2.slk --inv mutual recursion? (FIXED)

pred ll2<n> == self = null & n=0
    or self::node2<_,r> * r::ll3<n-1>
 inv true.

pred ll3<n> == self::node2<_,null> & n=1
    or self::node2<_,r> * r::ll2<n-1>
 inv true.

Why fixcalc think this is a bad mutual recursion?

WARNING: _0:0_0:0:View definitions [[ll3,ll]] are mutually recursive
fixcalc: bad mutual recursion detected :"ll"
Fatal error: exception Loc.Exc_located(_, _)


// seems there is no identification of mutual-recursive predicates

ll3:={[self,n] -> [] -> []:  exists (NODflted_11_18,NODAnon_13: self>0 && (NODflted_11_18<=0 && n=1)) ||  exists (flted_12_19,NODAnon_14,NODr: (self>0 && ll(NODr,flted_12_19)) && flted_12_19+1=n)
};
bottomupgen([ll3], [1], SimHeur);
====================================================================
# nlseg4.slk (FIXED)

lemma_safe self::nlseg<p> <- 
      (exists u :self::nlseg<u> * u::nlseg<p> * p::node<_>@L).

 rev lemma cannot be proven yet!

====================================================================
# nlseg4e2.slk

// two problems with lemma application

// (1)
checkentail_exact
    (exists u :self::nlseg<u> * u::nlseg<p> * p::node<_>@L)
       |- self::nlseg<uu>.
print residue.
// valid with @L residue
// problem : answers but first one did not have p=uu?.
/*
 <1>p::node<_>@L&{FLOW,(21,22)=__norm}[]
[[ SEARCH ==>  COND ==>  SEARCH ==>  (Lemma <== lem_13) ==>  Match ==>  SEARCH ==>  COND ==>  Match ==>  Match ==> ]]
<2>p::node<_>@L&p=uu&{FLOW,(21,22)=__norm}[]
[[ SEARCH ==>  COND ==>  SEARCH ==>  (Lemma <== lem_13) ==>  Match ==>  SEARCH ==>  (Lemma <== lem_13) ==>  Match ==>  SEARCH ==>  Fold ==>  Match ==>  Match ==> ]]
*/

// (2)
checkentail
    (exists u :self::nlseg<u> * u::nlseg<p> * p::node<_>)
       |- self::nlseg<p>.
print residue.
/*
Why an extra residue?

Entail 5: Valid. 
 <1>p::node<_>&{FLOW,(21,22)=__norm}[]
[[ SEARCH ==>  COND ==>  SEARCH ==>  (Lemma <== lem_13) ==>  COND ==>  Match ==>  COND ==>  Match ==>  SEARCH ==>  COND ==>  Match ==> ]]
<2>u_608::nlseg<p> * p::node<_>&{FLOW,(21,22)=__norm}[]
[[ SEARCH ==>  COND ==>  SEARCH ==>  (Lemma <== lem_13) ==>  COND ==>  Match ==>  COND ==>  Match ==>  SEARCH ==>  (Lemma ==> lem_11) ==> (left: lem_11) ==>  Match ==> ]]
*/
====================================================================
# nlseg3c1.slk --inv

this is non-recursive. why is there a bad mutual
recursion detected

../../sleek nlseg3c1.slk --inv
Starting Omega...oc
fixcalc: bad mutual recursion detected :"node"

ERROR: at _0:0_0:0 
Message: something wrong with fixcalc
 Fatal error: exception Failure("something wrong with fixcalc")
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
