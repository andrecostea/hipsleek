type token =
  | AND
  | ANDAND
  | ASSERT
  | ASSUME
  | AT
  | BIND
  | BOOL
  | BREAK
  | BY
  | CASE
  | CBRACE
  | CHECKENTAIL
  | CAPTURERESIDUE
  | CLASS
  | COERCION
  | COLON
  | COLONCOLON
  | COMMA
  | COMPOSE
  | CONSEQ
  | CONST
  | CONTINUE
  | CPAREN
  | CSQUARE
  | DATA
  | DDEBUG
  | DIFF
  | DISTR
  | DIV
  | DOLLAR
  | DOT
  | DOUBLEQUOTE
  | DERIVE
  | DYNAMIC
  | ELSE
  | ENSURES
  | ENUM
  | EOF
  | EQ
  | EQEQ
  | EQUIV
  | EXISTS
  | EXTENDS
  | FALSE
  | FLOAT
  | FORALL
  | GT
  | GTE
  | HASH
  | IDENTIFIER of (string)
  | IF
  | IMPLIES
  | IMPLY
  | IMPORT
  | IN
  | JAVA of (string)
  | LEFTARROW
  | LEMMA
  | LET
  | LITERAL_FLOAT of (float)
  | LITERAL_INTEGER of (int)
  | NOTIN
  | BAGMAX
  | BAGMIN
  | FOLD
  | INT
  | INTERR
  | INTERSECT
  | INV
  | LT
  | LTE
  | MAX
  | MINUS
  | MIN
  | NEQ
  | NEW
  | NOT
  | NULL
  | OBRACE
  | OFF
  | OPAREN
  | ON
  | OP_ADD_ASSIGN
  | OP_DEC
  | OP_DIV_ASSIGN
  | OP_INC
  | OP_MOD_ASSIGN
  | OP_MULT_ASSIGN
  | OP_SUB_ASSIGN
  | OR
  | OROR
  | ORWORD
  | OSQUARE
  | PERCENT
  | PLUS
  | PRED
  | PRIME
  | PRINT
  | REF
  | REQUIRES
  | RES of (string)
  | RETURN
  | RIGHTARROW
  | SELF of (string)
  | SEMICOLON
  | SPLIT
  | STAR
  | STATIC
  | SUBSET
  | THEN
  | THIS of (string)
  | TO
  | TRUE
  | VIEW
  | VOID
  | UNFOLD
  | UNION
  | WHERE
  | WHILE

open Parsing;;
# 2 "sparser.mly"
  (* Parser for a more expressive language *)

  open Globals
  open Iast
  open Sleekcommons

  module F = Iformula
  module P = Ipure

  type type_decl =
	| Data of data_decl
	| Enum of enum_decl
	| View of view_decl
		
  type decl = 
    | Type of type_decl
    | Proc of proc_decl
	| Coercion of coercion_decl
		
  type member = 
	| Field of (typed_ident * loc)
	| Inv of F.formula
	| Method of proc_decl
		
  type spec_qualifier =
	| Static
	| Dynamic 

  type ann =
	| AnnMode of mode
	| AnnType of typ
		
  let get_pos (i : int) = Parsing.rhs_start_pos i

  let rec get_mode (anns : ann list) : mode = match anns with
	| ann :: rest -> begin
		match ann with
		  | AnnMode m -> m
		  | _ -> get_mode rest
	  end
	| [] -> ModeOut (* default to ModeOut if there is no annotation. *)

  let rec get_modes (anns : ann list list) : mode list = 
	match anns with
	  | alist :: rest ->
		  let m_rest = get_modes rest in
		  let m = get_mode alist in
			m :: m_rest
	| [] -> []

	
  let expand_exp_list mk l r pos =
	let b, oe = l in
	  match oe with
		| Some e ->
			let tmp = P.build_relation mk e r pos in
			let res = P.mkAnd b tmp pos in
			  (res, Some r)
		| None -> report_error pos ("parse error in lhs of relational operator")

  let rec split_members mbrs = match mbrs with
	| mbr :: rest -> begin
		let fields, invs, meths = split_members rest in
		  match mbr with
			| Field f -> (f :: fields, invs, meths)
			| Inv i -> (fields, i :: invs, meths)
			| Method m ->
				(fields, invs, m :: meths)
	  end
	| [] -> ([], [], [])

  let rec split_specs specs = match specs with
	| sp :: rest -> begin
		let sspecs, dspecs = split_specs rest in
		  match sp with
			| (Static, pre, post) -> ((pre, post) :: sspecs, dspecs)
			| (Dynamic, pre, post) -> (sspecs, (pre, post) :: dspecs)
	  end
	| [] -> ([], [])

  let rec remove_spec_qualifier (_, pre, post) = (pre, post)
# 206 "sparser.ml"
let yytransl_const = [|
  257 (* AND *);
  258 (* ANDAND *);
  259 (* ASSERT *);
  260 (* ASSUME *);
  261 (* AT *);
  262 (* BIND *);
  263 (* BOOL *);
  264 (* BREAK *);
  265 (* BY *);
  266 (* CASE *);
  267 (* CBRACE *);
  268 (* CHECKENTAIL *);
  269 (* CAPTURERESIDUE *);
  270 (* CLASS *);
  271 (* COERCION *);
  272 (* COLON *);
  273 (* COLONCOLON *);
  274 (* COMMA *);
  275 (* COMPOSE *);
  276 (* CONSEQ *);
  277 (* CONST *);
  278 (* CONTINUE *);
  279 (* CPAREN *);
  280 (* CSQUARE *);
  281 (* DATA *);
  282 (* DDEBUG *);
  283 (* DIFF *);
  284 (* DISTR *);
  285 (* DIV *);
  286 (* DOLLAR *);
  287 (* DOT *);
  288 (* DOUBLEQUOTE *);
  289 (* DERIVE *);
  290 (* DYNAMIC *);
  291 (* ELSE *);
  292 (* ENSURES *);
  293 (* ENUM *);
    0 (* EOF *);
  294 (* EQ *);
  295 (* EQEQ *);
  296 (* EQUIV *);
  297 (* EXISTS *);
  298 (* EXTENDS *);
  299 (* FALSE *);
  300 (* FLOAT *);
  301 (* FORALL *);
  302 (* GT *);
  303 (* GTE *);
  304 (* HASH *);
  306 (* IF *);
  307 (* IMPLIES *);
  308 (* IMPLY *);
  309 (* IMPORT *);
  310 (* IN *);
  312 (* LEFTARROW *);
  313 (* LEMMA *);
  314 (* LET *);
  317 (* NOTIN *);
  318 (* BAGMAX *);
  319 (* BAGMIN *);
  320 (* FOLD *);
  321 (* INT *);
  322 (* INTERR *);
  323 (* INTERSECT *);
  324 (* INV *);
  325 (* LT *);
  326 (* LTE *);
  327 (* MAX *);
  328 (* MINUS *);
  329 (* MIN *);
  330 (* NEQ *);
  331 (* NEW *);
  332 (* NOT *);
  333 (* NULL *);
  334 (* OBRACE *);
  335 (* OFF *);
  336 (* OPAREN *);
  337 (* ON *);
  338 (* OP_ADD_ASSIGN *);
  339 (* OP_DEC *);
  340 (* OP_DIV_ASSIGN *);
  341 (* OP_INC *);
  342 (* OP_MOD_ASSIGN *);
  343 (* OP_MULT_ASSIGN *);
  344 (* OP_SUB_ASSIGN *);
  345 (* OR *);
  346 (* OROR *);
  347 (* ORWORD *);
  348 (* OSQUARE *);
  349 (* PERCENT *);
  350 (* PLUS *);
  351 (* PRED *);
  352 (* PRIME *);
  353 (* PRINT *);
  354 (* REF *);
  355 (* REQUIRES *);
  357 (* RETURN *);
  358 (* RIGHTARROW *);
  360 (* SEMICOLON *);
  361 (* SPLIT *);
  362 (* STAR *);
  363 (* STATIC *);
  364 (* SUBSET *);
  365 (* THEN *);
  367 (* TO *);
  368 (* TRUE *);
  369 (* VIEW *);
  370 (* VOID *);
  371 (* UNFOLD *);
  372 (* UNION *);
  373 (* WHERE *);
  374 (* WHILE *);
    0|]

let yytransl_block = [|
  305 (* IDENTIFIER *);
  311 (* JAVA *);
  315 (* LITERAL_FLOAT *);
  316 (* LITERAL_INTEGER *);
  356 (* RES *);
  359 (* SELF *);
  366 (* THIS *);
    0|]

let yylhs = "\255\255\
\007\000\007\000\008\000\008\000\006\000\006\000\009\000\009\000\
\009\000\009\000\009\000\009\000\009\000\001\000\014\000\014\000\
\015\000\015\000\016\000\016\000\017\000\017\000\017\000\017\000\
\018\000\020\000\020\000\021\000\021\000\022\000\022\000\023\000\
\023\000\023\000\023\000\002\000\027\000\028\000\029\000\029\000\
\031\000\031\000\030\000\030\000\019\000\032\000\033\000\034\000\
\034\000\035\000\035\000\003\000\003\000\038\000\038\000\036\000\
\041\000\041\000\041\000\041\000\041\000\037\000\042\000\043\000\
\043\000\044\000\046\000\046\000\047\000\047\000\048\000\049\000\
\049\000\050\000\050\000\040\000\040\000\051\000\051\000\052\000\
\053\000\053\000\054\000\054\000\055\000\055\000\005\000\056\000\
\056\000\056\000\057\000\057\000\058\000\058\000\058\000\059\000\
\059\000\060\000\060\000\039\000\039\000\062\000\062\000\061\000\
\061\000\061\000\061\000\061\000\061\000\061\000\061\000\063\000\
\063\000\063\000\063\000\063\000\063\000\063\000\064\000\064\000\
\064\000\064\000\064\000\064\000\064\000\064\000\064\000\064\000\
\064\000\045\000\045\000\045\000\045\000\045\000\045\000\045\000\
\045\000\045\000\045\000\045\000\045\000\045\000\066\000\066\000\
\065\000\067\000\067\000\025\000\025\000\068\000\068\000\026\000\
\026\000\072\000\011\000\012\000\074\000\074\000\013\000\013\000\
\010\000\073\000\073\000\073\000\004\000\077\000\077\000\077\000\
\076\000\076\000\071\000\071\000\078\000\078\000\079\000\079\000\
\079\000\080\000\080\000\080\000\070\000\070\000\081\000\081\000\
\082\000\083\000\084\000\084\000\069\000\024\000\024\000\086\000\
\086\000\086\000\086\000\087\000\087\000\088\000\089\000\089\000\
\090\000\090\000\085\000\091\000\091\000\092\000\092\000\092\000\
\093\000\093\000\094\000\094\000\098\000\096\000\097\000\099\000\
\099\000\101\000\101\000\102\000\100\000\100\000\104\000\095\000\
\095\000\095\000\095\000\095\000\095\000\095\000\095\000\095\000\
\095\000\095\000\095\000\116\000\112\000\112\000\112\000\114\000\
\114\000\113\000\113\000\106\000\115\000\117\000\117\000\075\000\
\075\000\110\000\107\000\118\000\118\000\118\000\118\000\118\000\
\118\000\118\000\108\000\127\000\126\000\126\000\109\000\129\000\
\129\000\111\000\111\000\111\000\131\000\132\000\130\000\133\000\
\133\000\120\000\134\000\136\000\135\000\135\000\137\000\137\000\
\138\000\103\000\103\000\105\000\128\000\121\000\121\000\121\000\
\121\000\121\000\121\000\139\000\139\000\141\000\141\000\142\000\
\142\000\143\000\144\000\145\000\146\000\146\000\146\000\147\000\
\147\000\147\000\147\000\147\000\148\000\149\000\149\000\149\000\
\150\000\150\000\150\000\150\000\140\000\124\000\125\000\122\000\
\123\000\151\000\151\000\151\000\151\000\151\000\153\000\153\000\
\153\000\154\000\154\000\154\000\155\000\155\000\155\000\155\000\
\119\000\119\000\156\000\157\000\158\000\158\000\158\000\158\000\
\161\000\160\000\159\000\159\000\152\000\152\000\162\000\163\000\
\163\000\163\000\163\000\163\000\164\000\164\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000"

let yylen = "\002\000\
\000\000\001\000\001\000\002\000\001\000\000\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\000\000\000\000\001\000\
\001\000\002\000\001\000\001\000\001\000\001\000\001\000\001\000\
\006\000\000\000\002\000\000\000\001\000\001\000\002\000\003\000\
\003\000\001\000\001\000\002\000\002\000\003\000\000\000\002\000\
\000\000\001\000\002\000\004\000\002\000\002\000\003\000\001\000\
\003\000\001\000\003\000\004\000\003\000\000\000\002\000\005\000\
\001\000\002\000\001\000\001\000\001\000\001\000\001\000\001\000\
\003\000\001\000\000\000\001\000\001\000\003\000\003\000\000\000\
\001\000\001\000\003\000\000\000\001\000\001\000\003\000\002\000\
\000\000\001\000\001\000\002\000\002\000\002\000\001\000\001\000\
\003\000\001\000\001\000\006\000\001\000\001\000\003\000\001\000\
\003\000\006\000\006\000\001\000\003\000\003\000\003\000\001\000\
\003\000\006\000\006\000\001\000\001\000\001\000\002\000\001\000\
\003\000\003\000\003\000\003\000\003\000\003\000\003\000\003\000\
\003\000\003\000\003\000\003\000\003\000\003\000\003\000\006\000\
\006\000\001\000\001\000\002\000\003\000\003\000\002\000\006\000\
\006\000\001\000\003\000\004\000\004\000\006\000\000\000\001\000\
\001\000\001\000\003\000\002\000\001\000\006\000\006\000\002\000\
\001\000\005\000\004\000\003\000\009\000\006\000\002\000\003\000\
\005\000\002\000\001\000\001\000\005\000\001\000\001\000\001\000\
\000\000\003\000\000\000\001\000\001\000\002\000\006\000\004\000\
\004\000\000\000\001\000\001\000\000\000\001\000\001\000\003\000\
\001\000\003\000\000\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\002\000\002\000\003\000\000\000\001\000\
\001\000\002\000\003\000\000\000\001\000\001\000\002\000\001\000\
\001\000\001\000\002\000\002\000\001\000\002\000\003\000\001\000\
\003\000\003\000\001\000\001\000\001\000\003\000\003\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\003\000\003\000\004\000\003\000\002\000\
\002\000\002\000\003\000\001\000\008\000\000\000\001\000\001\000\
\003\000\001\000\002\000\001\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\005\000\007\000\001\000\005\000\
\008\000\001\000\001\000\001\000\002\000\002\000\003\000\000\000\
\001\000\001\000\005\000\001\000\000\000\001\000\001\000\003\000\
\001\000\001\000\001\000\001\000\001\000\003\000\003\000\003\000\
\003\000\003\000\003\000\001\000\005\000\001\000\003\000\001\000\
\003\000\001\000\001\000\001\000\001\000\003\000\003\000\001\000\
\003\000\003\000\003\000\003\000\001\000\001\000\003\000\003\000\
\001\000\003\000\003\000\003\000\001\000\002\000\002\000\002\000\
\002\000\001\000\002\000\002\000\001\000\001\000\001\000\002\000\
\001\000\001\000\001\000\001\000\004\000\004\000\004\000\004\000\
\004\000\004\000\003\000\003\000\001\000\001\000\001\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\003\000\001\000\
\001\000\001\000\001\000\001\000\001\000\001\000\002\000\002\000\
\002\000\002\000\002\000\002\000\002\000"

let yydefred = "\000\000\
\014\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\103\001\000\000\104\001\000\000\000\000\105\001\000\000\000\000\
\106\001\090\000\000\000\000\000\109\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\138\000\
\000\000\000\000\059\000\060\000\061\000\108\000\000\000\107\001\
\000\000\000\000\000\000\000\000\088\000\091\000\000\000\096\000\
\100\000\000\000\112\000\000\000\000\000\000\000\000\000\000\000\
\000\000\007\000\008\000\009\000\108\001\005\000\010\000\011\000\
\012\000\013\000\109\001\000\000\003\000\037\000\000\000\036\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\058\000\132\000\000\000\000\000\000\000\000\000\130\000\135\000\
\000\000\111\000\000\000\144\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\163\000\000\000\164\000\000\000\
\000\000\000\000\159\000\004\000\194\000\193\000\195\000\192\000\
\000\000\000\000\000\000\000\000\000\000\000\000\053\000\062\000\
\000\000\000\000\000\000\000\000\074\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\139\000\000\000\000\000\
\105\000\000\000\000\000\101\000\000\000\000\000\000\000\134\000\
\133\000\000\000\089\000\000\000\000\000\097\000\114\000\117\000\
\118\000\115\000\116\000\113\000\123\000\121\000\122\000\119\000\
\120\000\124\000\000\000\000\000\000\000\162\000\000\000\156\000\
\000\000\160\000\043\000\038\000\000\000\040\000\000\000\197\000\
\196\000\000\000\000\000\000\000\078\000\000\000\052\000\170\000\
\167\000\166\000\168\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\141\000\000\000\000\000\000\000\000\000\000\000\
\140\000\000\000\000\000\248\000\000\000\155\000\000\000\000\000\
\201\000\000\000\000\000\056\000\000\000\080\000\000\000\083\000\
\000\000\000\000\165\000\000\000\000\000\075\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\064\000\
\000\000\000\000\000\000\069\000\000\000\000\000\000\000\161\000\
\044\000\198\000\202\000\086\000\085\000\084\000\079\000\142\000\
\106\000\107\000\128\000\129\000\136\000\137\000\092\000\000\000\
\098\000\000\000\099\000\000\000\000\000\249\000\000\000\000\000\
\065\000\000\000\070\000\158\000\000\000\000\000\000\000\157\000"

let yydgoto = "\008\000\
\009\000\058\000\059\000\060\000\125\000\061\000\067\000\068\000\
\062\000\063\000\064\000\065\000\066\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\137\000\
\000\000\000\000\012\000\072\000\138\000\139\000\198\000\000\000\
\000\000\000\000\000\000\015\000\145\000\207\000\041\000\202\000\
\087\000\254\000\255\000\000\001\043\000\002\001\003\001\004\001\
\150\000\151\000\204\000\205\000\238\000\239\000\240\000\044\000\
\045\000\046\000\047\000\048\000\049\000\098\000\050\000\051\000\
\052\000\093\000\053\000\000\000\000\000\000\000\000\000\000\000\
\126\000\127\000\229\000\077\000\212\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\140\000\141\000\200\000\
\234\000\235\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000"

let yysindex = "\085\002\
\000\000\252\254\184\254\226\254\138\003\249\254\249\254\000\000\
\000\000\016\255\000\000\021\255\059\255\000\000\084\255\092\255\
\000\000\000\000\220\254\230\254\000\000\045\255\035\255\058\255\
\053\255\054\255\055\255\056\255\078\255\060\255\058\255\000\000\
\078\255\250\003\000\000\000\000\000\000\000\000\061\255\000\000\
\138\255\250\254\222\254\052\255\000\000\000\000\009\255\000\000\
\000\000\190\255\000\000\238\255\128\255\072\003\117\255\122\255\
\000\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\249\254\000\000\000\000\135\255\000\000\
\085\255\153\255\138\003\114\255\138\003\078\255\058\255\058\255\
\000\000\000\000\058\255\058\255\078\255\078\255\000\000\000\000\
\078\255\000\000\204\254\000\000\154\255\057\255\036\004\003\255\
\248\254\005\255\078\255\036\004\124\255\078\255\078\255\078\255\
\078\255\078\255\078\004\036\004\058\255\078\255\078\255\078\255\
\078\255\078\255\078\255\078\255\078\255\078\255\078\255\078\255\
\078\255\078\255\228\254\131\255\000\000\149\255\000\000\134\255\
\136\255\137\255\000\000\000\000\000\000\000\000\000\000\000\000\
\140\255\176\255\087\255\104\255\104\255\058\255\000\000\000\000\
\129\255\166\255\232\254\246\254\000\000\185\255\187\255\194\255\
\188\255\193\255\189\255\253\254\001\255\000\000\197\255\036\004\
\000\000\036\004\199\255\000\000\156\255\204\254\204\254\000\000\
\000\000\204\254\000\000\138\255\206\255\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\204\254\072\003\180\255\000\000\072\003\000\000\
\192\255\000\000\000\000\000\000\135\255\000\000\214\255\000\000\
\000\000\195\255\233\255\221\255\000\000\036\004\000\000\000\000\
\000\000\000\000\000\000\138\003\078\255\036\004\058\255\036\004\
\058\255\058\255\000\000\078\255\078\255\036\004\138\255\138\255\
\000\000\099\255\141\255\000\000\094\255\000\000\072\003\191\255\
\000\000\218\255\226\255\000\000\067\255\000\000\233\255\000\000\
\058\255\138\255\000\000\242\254\242\255\000\000\243\255\244\255\
\248\255\245\254\255\254\249\255\007\255\215\255\003\000\000\000\
\204\254\232\255\005\000\000\000\072\003\234\255\207\255\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\078\255\
\000\000\078\255\000\000\237\255\009\000\000\000\072\003\204\254\
\000\000\253\255\000\000\000\000\177\255\072\003\019\000\000\000"

let yyrindex = "\000\000\
\000\000\000\000\000\000\000\000\000\000\043\001\044\001\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\208\003\
\000\000\000\000\000\000\000\000\000\000\000\000\001\000\066\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\034\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\139\002\192\000\157\255\191\002\000\000\000\000\169\002\000\000\
\000\000\072\002\000\000\000\000\125\001\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\046\001\000\000\000\000\039\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\037\000\037\000\
\000\000\000\000\000\000\000\000\031\000\000\000\000\000\000\000\
\000\000\000\000\234\000\000\000\000\000\037\000\000\000\000\000\
\129\000\000\000\031\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\049\000\131\255\012\000\017\000\000\000\000\000\
\024\000\000\000\000\000\000\000\000\000\000\000\048\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\177\001\229\001\000\000\
\000\000\053\002\000\000\188\002\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\038\001\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\054\000\000\000\042\000\000\000\
\000\000\000\000\013\255\022\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\011\255\012\255\
\000\000\026\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\050\000\000\000\000\000\000\000\022\255\000\000\
\000\000\114\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\251\254\000\000\040\000\000\000\
\029\255\000\000\041\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\086\255\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000"

let yygindex = "\000\000\
\000\000\074\001\077\001\079\001\251\255\000\000\000\000\000\000\
\030\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\144\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\224\255\000\000\
\002\000\000\000\000\000\062\000\221\003\000\000\000\000\065\000\
\201\255\000\000\000\000\109\000\000\000\000\000\117\000\000\000\
\246\000\135\000\000\000\249\000\159\255\000\000\000\000\000\000\
\136\000\200\255\000\000\000\000\000\000\000\000\000\000\000\000\
\082\255\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\222\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000"

let yytablesize = 1474
let yytable = "\040\000\
\057\000\096\000\164\000\100\000\054\000\055\000\042\000\213\000\
\016\001\108\000\101\000\021\001\057\000\227\000\220\000\209\000\
\230\000\010\000\221\000\104\000\010\000\022\001\013\000\054\000\
\152\000\082\000\016\000\161\000\155\000\130\000\081\000\210\000\
\090\000\102\000\103\000\097\000\069\000\104\000\159\000\082\000\
\057\000\105\000\163\000\078\000\024\001\102\000\066\000\102\000\
\131\000\016\000\056\000\188\000\103\000\079\000\103\000\042\000\
\008\001\104\000\081\000\105\000\104\000\104\000\096\000\189\000\
\070\000\131\000\057\000\082\000\104\000\144\000\104\000\147\000\
\104\000\106\000\066\000\172\000\042\000\211\000\042\000\105\000\
\149\000\149\000\105\000\105\000\153\000\154\000\029\001\013\000\
\057\000\057\000\105\000\160\000\105\000\162\000\105\000\149\000\
\097\000\132\000\071\000\102\000\103\000\097\000\081\000\071\000\
\019\000\023\000\023\000\073\000\042\000\097\000\173\000\006\001\
\037\001\055\000\109\000\012\001\245\000\007\001\247\000\039\001\
\013\001\074\000\075\000\076\000\080\000\019\000\023\000\223\000\
\110\000\224\000\081\000\071\000\083\000\084\000\085\000\086\000\
\079\000\024\000\100\000\089\000\099\000\133\000\107\000\203\000\
\027\000\122\000\128\000\253\000\028\000\029\000\030\000\129\000\
\143\000\142\000\032\000\033\000\035\000\035\000\024\000\036\000\
\036\000\097\000\146\000\097\000\158\000\027\000\037\000\037\000\
\092\000\028\000\029\000\030\000\165\000\242\000\146\000\032\000\
\033\000\035\000\134\000\190\000\036\000\191\000\192\000\135\000\
\193\000\194\000\196\000\037\000\195\000\042\000\197\000\110\000\
\042\000\039\000\146\000\199\000\206\000\208\000\035\000\136\000\
\214\000\036\000\146\000\146\000\215\000\217\000\243\000\097\000\
\037\000\216\000\218\000\219\000\222\000\042\000\039\000\097\000\
\246\000\097\000\248\000\249\000\092\000\225\000\101\000\042\000\
\226\000\146\000\146\000\110\000\228\000\231\000\146\000\233\000\
\042\000\146\000\092\000\111\000\112\000\237\000\241\000\009\001\
\236\000\010\001\203\000\011\001\005\001\175\000\176\000\177\000\
\178\000\179\000\180\000\181\000\182\000\183\000\184\000\185\000\
\186\000\057\000\113\000\114\000\025\001\057\000\042\000\115\000\
\017\001\018\001\019\001\057\000\057\000\057\000\020\001\023\001\
\057\000\057\000\057\000\116\000\026\001\027\001\028\001\057\000\
\038\001\057\000\030\001\117\000\118\000\034\001\031\001\036\001\
\042\000\057\000\024\001\054\000\054\000\147\000\057\000\042\000\
\057\000\040\001\006\000\001\000\143\000\002\000\057\000\057\000\
\054\000\039\000\119\000\120\000\072\000\143\000\057\000\121\000\
\057\000\057\000\057\000\041\000\191\000\057\000\076\000\073\000\
\042\000\199\000\131\000\077\000\057\000\057\000\057\000\067\000\
\057\000\200\000\057\000\011\000\131\000\131\000\131\000\014\000\
\054\000\054\000\017\000\131\000\232\000\063\000\068\000\033\001\
\131\000\057\000\131\000\057\000\035\001\015\001\057\000\057\000\
\171\000\057\000\131\000\014\001\252\000\174\000\057\000\131\000\
\057\000\131\000\201\000\000\000\057\000\000\000\000\000\131\000\
\131\000\000\000\000\000\000\000\000\000\000\000\054\000\000\000\
\054\000\131\000\131\000\131\000\145\000\055\000\055\000\000\000\
\000\000\110\000\000\000\000\000\000\000\131\000\131\000\131\000\
\000\000\131\000\055\000\131\000\110\000\110\000\000\000\000\000\
\000\000\000\000\130\000\000\000\000\000\000\000\000\000\110\000\
\000\000\110\000\131\000\000\000\131\000\000\000\000\000\131\000\
\131\000\110\000\131\000\000\000\000\000\000\000\130\000\131\000\
\110\000\131\000\055\000\055\000\000\000\131\000\130\000\130\000\
\125\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\110\000\110\000\110\000\000\000\000\000\000\000\000\000\000\000\
\110\000\000\000\000\000\000\000\110\000\130\000\130\000\000\000\
\130\000\000\000\130\000\110\000\110\000\000\000\000\000\000\000\
\055\000\130\000\055\000\000\000\000\000\000\000\110\000\000\000\
\110\000\110\000\000\000\110\000\000\000\000\000\130\000\110\000\
\110\000\110\000\000\000\000\000\126\000\130\000\110\000\110\000\
\110\000\000\000\146\000\000\000\130\000\130\000\130\000\000\000\
\000\000\000\000\000\000\000\000\146\000\146\000\146\000\110\000\
\110\000\110\000\000\000\146\000\000\000\000\000\000\000\000\000\
\146\000\000\000\146\000\110\000\130\000\130\000\000\000\130\000\
\000\000\130\000\146\000\000\000\000\000\000\000\000\000\146\000\
\000\000\146\000\000\000\000\000\000\000\000\000\000\000\146\000\
\146\000\000\000\110\000\000\000\000\000\130\000\110\000\000\000\
\110\000\146\000\146\000\146\000\000\000\110\000\147\000\110\000\
\000\000\000\000\000\000\130\000\000\000\146\000\146\000\146\000\
\147\000\147\000\147\000\146\000\127\000\000\000\000\000\147\000\
\000\000\000\000\000\000\000\000\147\000\000\000\147\000\000\000\
\000\000\000\000\146\000\000\000\146\000\000\000\147\000\104\000\
\146\000\000\000\146\000\147\000\000\000\147\000\000\000\146\000\
\000\000\146\000\000\000\147\000\147\000\001\000\002\000\003\000\
\004\000\005\000\006\000\007\000\000\000\147\000\147\000\147\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\147\000\147\000\147\000\000\000\000\000\000\000\147\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\145\000\147\000\000\000\
\147\000\000\000\000\000\000\000\147\000\000\000\147\000\145\000\
\145\000\145\000\094\000\147\000\000\000\147\000\000\000\000\000\
\000\000\000\000\000\000\145\000\000\000\145\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\145\000\000\000\000\000\
\000\000\000\000\145\000\000\000\145\000\000\000\000\000\000\000\
\093\000\000\000\145\000\145\000\000\000\000\000\000\000\000\000\
\000\000\125\000\000\000\000\000\145\000\145\000\145\000\000\000\
\000\000\000\000\000\000\095\000\125\000\125\000\087\000\000\000\
\145\000\145\000\145\000\000\000\000\000\000\000\145\000\125\000\
\000\000\125\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\125\000\000\000\000\000\000\000\145\000\125\000\145\000\
\125\000\000\000\000\000\145\000\000\000\145\000\125\000\125\000\
\000\000\000\000\145\000\000\000\145\000\126\000\000\000\000\000\
\125\000\125\000\125\000\000\000\000\000\000\000\000\000\000\000\
\126\000\126\000\000\000\000\000\125\000\125\000\125\000\000\000\
\000\000\000\000\125\000\126\000\000\000\126\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\126\000\000\000\000\000\
\000\000\125\000\126\000\125\000\126\000\000\000\000\000\125\000\
\000\000\125\000\126\000\126\000\000\000\000\000\125\000\000\000\
\125\000\000\000\000\000\000\000\126\000\126\000\126\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\126\000\126\000\126\000\000\000\000\000\000\000\126\000\000\000\
\000\000\000\000\000\000\000\000\000\000\127\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\126\000\000\000\126\000\
\127\000\127\000\000\000\126\000\000\000\126\000\000\000\000\000\
\104\000\000\000\126\000\127\000\126\000\127\000\000\000\000\000\
\000\000\000\000\000\000\104\000\104\000\127\000\000\000\000\000\
\000\000\000\000\127\000\000\000\127\000\000\000\104\000\000\000\
\104\000\000\000\127\000\127\000\000\000\000\000\000\000\000\000\
\104\000\000\000\000\000\000\000\127\000\127\000\127\000\104\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\127\000\127\000\127\000\000\000\000\000\000\000\127\000\104\000\
\104\000\104\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\104\000\000\000\127\000\000\000\127\000\
\000\000\000\000\000\000\127\000\000\000\127\000\094\000\094\000\
\000\000\000\000\127\000\000\000\127\000\000\000\000\000\000\000\
\104\000\094\000\104\000\094\000\000\000\000\000\104\000\000\000\
\104\000\000\000\000\000\094\000\000\000\104\000\000\000\104\000\
\000\000\000\000\094\000\000\000\093\000\093\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\093\000\
\000\000\093\000\094\000\094\000\094\000\000\000\000\000\095\000\
\095\000\093\000\087\000\087\000\000\000\000\000\094\000\000\000\
\093\000\000\000\095\000\000\000\095\000\087\000\000\000\087\000\
\000\000\000\000\000\000\000\000\095\000\000\000\000\000\087\000\
\093\000\093\000\093\000\095\000\000\000\094\000\087\000\000\000\
\000\000\094\000\000\000\094\000\093\000\000\000\000\000\000\000\
\094\000\000\000\094\000\095\000\095\000\095\000\087\000\087\000\
\087\000\088\000\000\000\000\000\000\000\091\000\000\000\095\000\
\000\000\000\000\087\000\093\000\000\000\000\000\000\000\093\000\
\000\000\093\000\000\000\000\000\000\000\000\000\093\000\000\000\
\093\000\000\000\000\000\000\000\000\000\000\000\095\000\000\000\
\000\000\000\000\095\000\000\000\095\000\087\000\000\000\087\000\
\000\000\095\000\000\000\095\000\087\000\000\000\087\000\000\000\
\000\000\000\000\148\000\000\000\000\000\000\000\000\000\000\000\
\000\000\091\000\156\000\000\000\000\000\157\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\091\000\
\000\000\000\000\166\000\167\000\168\000\169\000\170\000\018\000\
\000\000\000\000\091\000\091\000\091\000\091\000\091\000\091\000\
\091\000\091\000\091\000\091\000\091\000\091\000\187\000\000\000\
\000\000\000\000\123\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\019\000\000\000\000\000\124\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\020\000\000\000\021\000\000\000\022\000\000\000\000\000\000\000\
\023\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\024\000\000\000\025\000\026\000\000\000\
\000\000\018\000\027\000\000\000\000\000\000\000\028\000\029\000\
\030\000\000\000\000\000\031\000\032\000\033\000\000\000\034\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\019\000\000\000\000\000\000\000\
\000\000\000\000\000\000\035\000\000\000\000\000\036\000\000\000\
\000\000\244\000\020\000\000\000\021\000\037\000\022\000\038\000\
\250\000\251\000\023\000\039\000\000\000\000\000\001\001\000\000\
\000\000\000\000\000\000\000\000\000\000\024\000\000\000\025\000\
\026\000\000\000\000\000\000\000\027\000\000\000\000\000\169\000\
\028\000\029\000\030\000\000\000\000\000\031\000\032\000\033\000\
\000\000\034\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\169\000\000\000\000\000\035\000\000\000\000\000\
\036\000\000\000\000\000\000\000\032\001\000\000\001\001\037\000\
\169\000\038\000\169\000\000\000\169\000\039\000\000\000\000\000\
\169\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\169\000\000\000\169\000\169\000\000\000\
\000\000\000\000\169\000\000\000\019\000\000\000\169\000\169\000\
\169\000\000\000\000\000\169\000\169\000\169\000\000\000\169\000\
\000\000\000\000\094\000\000\000\021\000\000\000\022\000\000\000\
\000\000\000\000\023\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\169\000\000\000\024\000\169\000\025\000\
\026\000\000\000\000\000\000\000\027\000\169\000\019\000\169\000\
\028\000\029\000\030\000\169\000\000\000\031\000\032\000\033\000\
\000\000\095\000\000\000\000\000\020\000\000\000\021\000\000\000\
\022\000\000\000\000\000\000\000\023\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\035\000\000\000\024\000\
\036\000\025\000\026\000\000\000\000\000\000\000\027\000\037\000\
\019\000\038\000\028\000\029\000\030\000\039\000\000\000\031\000\
\032\000\033\000\000\000\095\000\000\000\000\000\020\000\000\000\
\021\000\000\000\022\000\000\000\000\000\000\000\023\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\035\000\
\000\000\024\000\036\000\025\000\026\000\000\000\000\000\000\000\
\027\000\037\000\000\000\038\000\028\000\029\000\030\000\039\000\
\000\000\031\000\032\000\033\000\000\000\034\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\
\000\000\035\000\000\000\000\000\036\000\000\000\000\000\000\000\
\000\000\000\000\000\000\037\000\000\000\038\000\000\000\000\000\
\000\000\039\000"

let yycheck = "\005\000\
\000\000\034\000\100\000\001\001\012\001\013\001\005\000\018\001\
\023\001\001\001\017\001\023\001\018\001\188\000\018\001\040\001\
\191\000\025\001\018\001\072\001\025\001\023\001\095\001\000\000\
\080\000\024\000\057\001\023\001\085\000\030\001\018\001\056\001\
\031\000\023\001\023\001\034\000\007\000\072\001\094\000\018\001\
\046\001\094\001\099\000\080\001\038\001\054\001\018\001\054\001\
\049\001\057\001\058\001\080\001\061\001\080\001\061\001\054\000\
\231\000\072\001\046\001\094\001\072\001\072\001\095\000\092\001\
\049\001\000\000\072\001\046\001\072\001\075\000\072\001\077\000\
\072\001\108\001\046\001\108\000\075\000\102\001\077\000\094\001\
\079\000\080\000\094\001\094\001\083\000\084\000\005\001\095\001\
\094\001\097\001\094\001\089\001\094\001\089\001\094\001\094\000\
\095\000\068\000\078\001\089\001\089\001\100\000\096\001\018\001\
\027\001\049\001\049\001\049\001\107\000\108\000\109\000\018\001\
\031\001\000\000\106\001\049\001\214\000\024\001\216\000\038\001\
\054\001\038\001\039\001\032\001\080\001\027\001\049\001\160\000\
\000\000\162\000\096\001\046\001\080\001\080\001\080\001\080\001\
\080\001\060\001\001\001\080\001\080\001\007\001\091\001\142\000\
\067\001\018\001\030\001\049\001\071\001\072\001\073\001\030\001\
\000\001\069\001\077\001\078\001\100\001\100\001\060\001\103\001\
\103\001\160\000\049\001\162\000\011\001\067\001\110\001\110\001\
\033\000\071\001\072\001\073\001\049\001\206\000\018\001\077\001\
\078\001\100\001\044\001\049\001\103\001\033\001\049\001\049\001\
\049\001\049\001\011\001\110\001\049\001\188\000\104\001\000\000\
\191\000\116\001\038\001\092\001\068\001\032\001\100\001\065\001\
\016\001\103\001\046\001\047\001\018\001\018\001\212\000\206\000\
\110\001\016\001\018\001\023\001\016\001\212\000\116\001\214\000\
\215\000\216\000\217\000\218\000\085\000\023\001\017\001\222\000\
\069\001\069\001\070\001\038\001\049\001\038\001\074\001\018\001\
\231\000\000\000\099\000\046\001\047\001\005\001\018\001\049\001\
\046\001\024\001\241\000\018\001\104\001\110\000\111\000\112\000\
\113\000\114\000\115\000\116\000\117\000\118\000\119\000\120\000\
\121\000\001\001\069\001\070\001\046\001\005\001\005\001\074\001\
\023\001\023\001\023\001\011\001\012\001\013\001\023\001\023\001\
\016\001\017\001\018\001\038\001\018\001\046\001\018\001\023\001\
\104\001\025\001\049\001\046\001\047\001\049\001\080\001\023\001\
\031\001\033\001\038\001\012\001\013\001\000\000\038\001\038\001\
\040\001\023\001\000\000\000\000\011\001\000\000\046\001\047\001\
\025\001\011\001\069\001\070\001\016\001\023\001\054\001\074\001\
\056\001\057\001\058\001\011\001\049\001\061\001\046\001\016\001\
\011\001\024\001\001\001\046\001\068\001\069\001\070\001\046\001\
\072\001\024\001\074\001\002\000\011\001\012\001\013\001\003\000\
\057\001\058\001\004\000\018\001\197\000\046\001\046\001\026\001\
\023\001\089\001\025\001\091\001\028\001\241\000\094\001\095\001\
\107\000\097\001\033\001\239\000\222\000\109\000\102\001\038\001\
\104\001\040\001\141\000\255\255\108\001\255\255\255\255\046\001\
\047\001\255\255\255\255\255\255\255\255\255\255\095\001\255\255\
\097\001\056\001\057\001\058\001\000\000\012\001\013\001\255\255\
\255\255\001\001\255\255\255\255\255\255\068\001\069\001\070\001\
\255\255\072\001\025\001\074\001\012\001\013\001\255\255\255\255\
\255\255\255\255\018\001\255\255\255\255\255\255\255\255\023\001\
\255\255\025\001\089\001\255\255\091\001\255\255\255\255\094\001\
\095\001\033\001\097\001\255\255\255\255\255\255\038\001\102\001\
\040\001\104\001\057\001\058\001\255\255\108\001\046\001\047\001\
\000\000\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\056\001\057\001\058\001\255\255\255\255\255\255\255\255\255\255\
\001\001\255\255\255\255\255\255\068\001\069\001\070\001\255\255\
\072\001\255\255\074\001\012\001\013\001\255\255\255\255\255\255\
\095\001\018\001\097\001\255\255\255\255\255\255\023\001\255\255\
\025\001\089\001\255\255\091\001\255\255\255\255\094\001\095\001\
\033\001\097\001\255\255\255\255\000\000\038\001\102\001\040\001\
\104\001\255\255\001\001\255\255\108\001\046\001\047\001\255\255\
\255\255\255\255\255\255\255\255\011\001\012\001\013\001\056\001\
\057\001\058\001\255\255\018\001\255\255\255\255\255\255\255\255\
\023\001\255\255\025\001\068\001\069\001\070\001\255\255\072\001\
\255\255\074\001\033\001\255\255\255\255\255\255\255\255\038\001\
\255\255\040\001\255\255\255\255\255\255\255\255\255\255\046\001\
\047\001\255\255\091\001\255\255\255\255\094\001\095\001\255\255\
\097\001\056\001\057\001\058\001\255\255\102\001\001\001\104\001\
\255\255\255\255\255\255\108\001\255\255\068\001\069\001\070\001\
\011\001\012\001\013\001\074\001\000\000\255\255\255\255\018\001\
\255\255\255\255\255\255\255\255\023\001\255\255\025\001\255\255\
\255\255\255\255\089\001\255\255\091\001\255\255\033\001\000\000\
\095\001\255\255\097\001\038\001\255\255\040\001\255\255\102\001\
\255\255\104\001\255\255\046\001\047\001\001\000\002\000\003\000\
\004\000\005\000\006\000\007\000\255\255\056\001\057\001\058\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\068\001\069\001\070\001\255\255\255\255\255\255\074\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\001\001\089\001\255\255\
\091\001\255\255\255\255\255\255\095\001\255\255\097\001\011\001\
\012\001\013\001\000\000\102\001\255\255\104\001\255\255\255\255\
\255\255\255\255\255\255\023\001\255\255\025\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\033\001\255\255\255\255\
\255\255\255\255\038\001\255\255\040\001\255\255\255\255\255\255\
\000\000\255\255\046\001\047\001\255\255\255\255\255\255\255\255\
\255\255\001\001\255\255\255\255\056\001\057\001\058\001\255\255\
\255\255\255\255\255\255\000\000\012\001\013\001\000\000\255\255\
\068\001\069\001\070\001\255\255\255\255\255\255\074\001\023\001\
\255\255\025\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\033\001\255\255\255\255\255\255\089\001\038\001\091\001\
\040\001\255\255\255\255\095\001\255\255\097\001\046\001\047\001\
\255\255\255\255\102\001\255\255\104\001\001\001\255\255\255\255\
\056\001\057\001\058\001\255\255\255\255\255\255\255\255\255\255\
\012\001\013\001\255\255\255\255\068\001\069\001\070\001\255\255\
\255\255\255\255\074\001\023\001\255\255\025\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\033\001\255\255\255\255\
\255\255\089\001\038\001\091\001\040\001\255\255\255\255\095\001\
\255\255\097\001\046\001\047\001\255\255\255\255\102\001\255\255\
\104\001\255\255\255\255\255\255\056\001\057\001\058\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\068\001\069\001\070\001\255\255\255\255\255\255\074\001\255\255\
\255\255\255\255\255\255\255\255\255\255\001\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\089\001\255\255\091\001\
\012\001\013\001\255\255\095\001\255\255\097\001\255\255\255\255\
\001\001\255\255\102\001\023\001\104\001\025\001\255\255\255\255\
\255\255\255\255\255\255\012\001\013\001\033\001\255\255\255\255\
\255\255\255\255\038\001\255\255\040\001\255\255\023\001\255\255\
\025\001\255\255\046\001\047\001\255\255\255\255\255\255\255\255\
\033\001\255\255\255\255\255\255\056\001\057\001\058\001\040\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\068\001\069\001\070\001\255\255\255\255\255\255\074\001\056\001\
\057\001\058\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\068\001\255\255\089\001\255\255\091\001\
\255\255\255\255\255\255\095\001\255\255\097\001\012\001\013\001\
\255\255\255\255\102\001\255\255\104\001\255\255\255\255\255\255\
\089\001\023\001\091\001\025\001\255\255\255\255\095\001\255\255\
\097\001\255\255\255\255\033\001\255\255\102\001\255\255\104\001\
\255\255\255\255\040\001\255\255\012\001\013\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\023\001\
\255\255\025\001\056\001\057\001\058\001\255\255\255\255\012\001\
\013\001\033\001\012\001\013\001\255\255\255\255\068\001\255\255\
\040\001\255\255\023\001\255\255\025\001\023\001\255\255\025\001\
\255\255\255\255\255\255\255\255\033\001\255\255\255\255\033\001\
\056\001\057\001\058\001\040\001\255\255\091\001\040\001\255\255\
\255\255\095\001\255\255\097\001\068\001\255\255\255\255\255\255\
\102\001\255\255\104\001\056\001\057\001\058\001\056\001\057\001\
\058\001\029\000\255\255\255\255\255\255\033\000\255\255\068\001\
\255\255\255\255\068\001\091\001\255\255\255\255\255\255\095\001\
\255\255\097\001\255\255\255\255\255\255\255\255\102\001\255\255\
\104\001\255\255\255\255\255\255\255\255\255\255\091\001\255\255\
\255\255\255\255\095\001\255\255\097\001\095\001\255\255\097\001\
\255\255\102\001\255\255\104\001\102\001\255\255\104\001\255\255\
\255\255\255\255\078\000\255\255\255\255\255\255\255\255\255\255\
\255\255\085\000\086\000\255\255\255\255\089\000\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\099\000\
\255\255\255\255\102\000\103\000\104\000\105\000\106\000\000\001\
\255\255\255\255\110\000\111\000\112\000\113\000\114\000\115\000\
\116\000\117\000\118\000\119\000\120\000\121\000\122\000\255\255\
\255\255\255\255\019\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\255\255\030\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\041\001\255\255\043\001\255\255\045\001\255\255\255\255\255\255\
\049\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\060\001\255\255\062\001\063\001\255\255\
\255\255\000\001\067\001\255\255\255\255\255\255\071\001\072\001\
\073\001\255\255\255\255\076\001\077\001\078\001\255\255\080\001\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\027\001\255\255\255\255\255\255\
\255\255\255\255\255\255\100\001\255\255\255\255\103\001\255\255\
\255\255\213\000\041\001\255\255\043\001\110\001\045\001\112\001\
\220\000\221\000\049\001\116\001\255\255\255\255\226\000\255\255\
\255\255\255\255\255\255\255\255\255\255\060\001\255\255\062\001\
\063\001\255\255\255\255\255\255\067\001\255\255\255\255\000\001\
\071\001\072\001\073\001\255\255\255\255\076\001\077\001\078\001\
\255\255\080\001\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\027\001\255\255\255\255\100\001\255\255\255\255\
\103\001\255\255\255\255\255\255\024\001\255\255\026\001\110\001\
\041\001\112\001\043\001\255\255\045\001\116\001\255\255\255\255\
\049\001\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\060\001\255\255\062\001\063\001\255\255\
\255\255\255\255\067\001\255\255\027\001\255\255\071\001\072\001\
\073\001\255\255\255\255\076\001\077\001\078\001\255\255\080\001\
\255\255\255\255\041\001\255\255\043\001\255\255\045\001\255\255\
\255\255\255\255\049\001\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\100\001\255\255\060\001\103\001\062\001\
\063\001\255\255\255\255\255\255\067\001\110\001\027\001\112\001\
\071\001\072\001\073\001\116\001\255\255\076\001\077\001\078\001\
\255\255\080\001\255\255\255\255\041\001\255\255\043\001\255\255\
\045\001\255\255\255\255\255\255\049\001\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\100\001\255\255\060\001\
\103\001\062\001\063\001\255\255\255\255\255\255\067\001\110\001\
\027\001\112\001\071\001\072\001\073\001\116\001\255\255\076\001\
\077\001\078\001\255\255\080\001\255\255\255\255\041\001\255\255\
\043\001\255\255\045\001\255\255\255\255\255\255\049\001\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\100\001\
\255\255\060\001\103\001\062\001\063\001\255\255\255\255\255\255\
\067\001\110\001\255\255\112\001\071\001\072\001\073\001\116\001\
\255\255\076\001\077\001\078\001\255\255\080\001\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\255\
\255\255\100\001\255\255\255\255\103\001\255\255\255\255\255\255\
\255\255\255\255\255\255\110\001\255\255\112\001\255\255\255\255\
\255\255\116\001"

let yynames_const = "\
  AND\000\
  ANDAND\000\
  ASSERT\000\
  ASSUME\000\
  AT\000\
  BIND\000\
  BOOL\000\
  BREAK\000\
  BY\000\
  CASE\000\
  CBRACE\000\
  CHECKENTAIL\000\
  CAPTURERESIDUE\000\
  CLASS\000\
  COERCION\000\
  COLON\000\
  COLONCOLON\000\
  COMMA\000\
  COMPOSE\000\
  CONSEQ\000\
  CONST\000\
  CONTINUE\000\
  CPAREN\000\
  CSQUARE\000\
  DATA\000\
  DDEBUG\000\
  DIFF\000\
  DISTR\000\
  DIV\000\
  DOLLAR\000\
  DOT\000\
  DOUBLEQUOTE\000\
  DERIVE\000\
  DYNAMIC\000\
  ELSE\000\
  ENSURES\000\
  ENUM\000\
  EOF\000\
  EQ\000\
  EQEQ\000\
  EQUIV\000\
  EXISTS\000\
  EXTENDS\000\
  FALSE\000\
  FLOAT\000\
  FORALL\000\
  GT\000\
  GTE\000\
  HASH\000\
  IF\000\
  IMPLIES\000\
  IMPLY\000\
  IMPORT\000\
  IN\000\
  LEFTARROW\000\
  LEMMA\000\
  LET\000\
  NOTIN\000\
  BAGMAX\000\
  BAGMIN\000\
  FOLD\000\
  INT\000\
  INTERR\000\
  INTERSECT\000\
  INV\000\
  LT\000\
  LTE\000\
  MAX\000\
  MINUS\000\
  MIN\000\
  NEQ\000\
  NEW\000\
  NOT\000\
  NULL\000\
  OBRACE\000\
  OFF\000\
  OPAREN\000\
  ON\000\
  OP_ADD_ASSIGN\000\
  OP_DEC\000\
  OP_DIV_ASSIGN\000\
  OP_INC\000\
  OP_MOD_ASSIGN\000\
  OP_MULT_ASSIGN\000\
  OP_SUB_ASSIGN\000\
  OR\000\
  OROR\000\
  ORWORD\000\
  OSQUARE\000\
  PERCENT\000\
  PLUS\000\
  PRED\000\
  PRIME\000\
  PRINT\000\
  REF\000\
  REQUIRES\000\
  RETURN\000\
  RIGHTARROW\000\
  SEMICOLON\000\
  SPLIT\000\
  STAR\000\
  STATIC\000\
  SUBSET\000\
  THEN\000\
  TO\000\
  TRUE\000\
  VIEW\000\
  VOID\000\
  UNFOLD\000\
  UNION\000\
  WHERE\000\
  WHILE\000\
  "

let yynames_block = "\
  IDENTIFIER\000\
  JAVA\000\
  LITERAL_FLOAT\000\
  LITERAL_INTEGER\000\
  RES\000\
  SELF\000\
  THIS\000\
  "

let yyact = [|
  (fun _ -> failwith "parser")
; (fun __caml_parser_env ->
    Obj.repr(
# 233 "sparser.mly"
   ([])
# 1097 "sparser.ml"
               : command list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'command_list) in
    Obj.repr(
# 234 "sparser.mly"
                (List.rev _1)
# 1104 "sparser.ml"
               : command list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'non_empty_command) in
    Obj.repr(
# 238 "sparser.mly"
                      ( [_1] )
# 1111 "sparser.ml"
               : 'command_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'command_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'non_empty_command) in
    Obj.repr(
# 239 "sparser.mly"
                                   ( _2 :: _1 )
# 1119 "sparser.ml"
               : 'command_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'non_empty_command) in
    Obj.repr(
# 243 "sparser.mly"
                    (_1)
# 1126 "sparser.ml"
               : command))
; (fun __caml_parser_env ->
    Obj.repr(
# 244 "sparser.mly"
    ( EmptyCmd )
# 1132 "sparser.ml"
               : command))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : data_decl) in
    Obj.repr(
# 247 "sparser.mly"
              (
	DataDef _1
  )
# 1141 "sparser.ml"
               : 'non_empty_command))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : view_decl) in
    Obj.repr(
# 250 "sparser.mly"
              (
	  PredDef _1
	)
# 1150 "sparser.ml"
               : 'non_empty_command))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : coercion_decl) in
    Obj.repr(
# 253 "sparser.mly"
                  (
	  LemmaDef _1
	)
# 1159 "sparser.ml"
               : 'non_empty_command))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'let_decl) in
    Obj.repr(
# 256 "sparser.mly"
             (
	  _1
	)
# 1168 "sparser.ml"
               : 'non_empty_command))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'checkentail_cmd) in
    Obj.repr(
# 259 "sparser.mly"
                    (
	  EntailCheck _1
	)
# 1177 "sparser.ml"
               : 'non_empty_command))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'captureresidue_cmd) in
    Obj.repr(
# 262 "sparser.mly"
                      (
	  CaptureResidue _1
	)
# 1186 "sparser.ml"
               : 'non_empty_command))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'print_cmd) in
    Obj.repr(
# 265 "sparser.mly"
              (
	  PrintCmd _1
	)
# 1195 "sparser.ml"
               : 'non_empty_command))
; (fun __caml_parser_env ->
    Obj.repr(
# 309 "sparser.mly"
          (
  { prog_data_decls = [];
	prog_enum_decls = [];
	prog_view_decls = [];
	prog_proc_decls = [];
	prog_coercion_decls = []; }
)
# 1207 "sparser.ml"
               : prog_decl))
; (fun __caml_parser_env ->
    Obj.repr(
# 319 "sparser.mly"
    ( [] )
# 1213 "sparser.ml"
               : 'opt_decl_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'decl_list) in
    Obj.repr(
# 320 "sparser.mly"
              ( List.rev _1 )
# 1220 "sparser.ml"
               : 'opt_decl_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'decl) in
    Obj.repr(
# 324 "sparser.mly"
         ( [_1] )
# 1227 "sparser.ml"
               : 'decl_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'decl_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'decl) in
    Obj.repr(
# 325 "sparser.mly"
                   ( _2 :: _1 )
# 1235 "sparser.ml"
               : 'decl_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'type_decl) in
    Obj.repr(
# 329 "sparser.mly"
              ( Type _1 )
# 1242 "sparser.ml"
               : 'decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : coercion_decl) in
    Obj.repr(
# 331 "sparser.mly"
                  ( Coercion _1 )
# 1249 "sparser.ml"
               : 'decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : data_decl) in
    Obj.repr(
# 335 "sparser.mly"
              ( Data _1 )
# 1256 "sparser.ml"
               : 'type_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'class_decl) in
    Obj.repr(
# 336 "sparser.mly"
               ( Data _1 )
# 1263 "sparser.ml"
               : 'type_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'enum_decl) in
    Obj.repr(
# 337 "sparser.mly"
              ( Enum _1 )
# 1270 "sparser.ml"
               : 'type_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : view_decl) in
    Obj.repr(
# 338 "sparser.mly"
              ( View _1 )
# 1277 "sparser.ml"
               : 'type_decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'extends_opt) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'member_list_opt) in
    Obj.repr(
# 342 "sparser.mly"
                                                               (
	let t1, t2, t3 = split_members _5 in
	let cdef = { data_name = _2;
				 data_parent_name = _3;
				 data_fields = t1;
				 data_invs = t2; (*List.fold_left 
							   (fun f1 -> fun f2 -> F.mkAnd f1 f2 (F.pos_of_formula f2)) (F.mkTrue (get_pos 1)) *) 
				 data_methods = t3 } in
	let _ = List.map (fun d -> set_proc_data_decl d cdef) t3 in
	  cdef
  )
# 1296 "sparser.ml"
               : 'class_decl))
; (fun __caml_parser_env ->
    Obj.repr(
# 356 "sparser.mly"
    ( "Object" )
# 1302 "sparser.ml"
               : 'extends_opt))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 357 "sparser.mly"
                       ( _2 )
# 1309 "sparser.ml"
               : 'extends_opt))
; (fun __caml_parser_env ->
    Obj.repr(
# 361 "sparser.mly"
    ( [] )
# 1315 "sparser.ml"
               : 'member_list_opt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'member_list) in
    Obj.repr(
# 362 "sparser.mly"
                ( List.rev _1 )
# 1322 "sparser.ml"
               : 'member_list_opt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'member) in
    Obj.repr(
# 366 "sparser.mly"
           ( [_1] )
# 1329 "sparser.ml"
               : 'member_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'member_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'member) in
    Obj.repr(
# 367 "sparser.mly"
                       ( _2 :: _1 )
# 1337 "sparser.ml"
               : 'member_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'typ) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 371 "sparser.mly"
                             ( Field ((_1, _2), get_pos 2) )
# 1345 "sparser.ml"
               : 'member))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : F.formula) in
    Obj.repr(
# 372 "sparser.mly"
                         ( Inv _2 )
# 1352 "sparser.ml"
               : 'member))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'proc_decl) in
    Obj.repr(
# 373 "sparser.mly"
              ( Method _1 )
# 1359 "sparser.ml"
               : 'member))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_decl) in
    Obj.repr(
# 374 "sparser.mly"
                     ( Method _1 )
# 1366 "sparser.ml"
               : 'member))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'data_header) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'data_body) in
    Obj.repr(
# 378 "sparser.mly"
                          (
	  { data_name = _1;
		data_fields = _2;
		data_parent_name = "Object";
		data_invs = []; (* F.mkTrue (get_pos 1); *)
		data_methods = [] }
	)
# 1380 "sparser.ml"
               : data_decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 388 "sparser.mly"
                    ( _2 )
# 1387 "sparser.ml"
               : 'data_header))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'opt_field_list) in
    Obj.repr(
# 392 "sparser.mly"
                                 ( _2 )
# 1394 "sparser.ml"
               : 'data_body))
; (fun __caml_parser_env ->
    Obj.repr(
# 396 "sparser.mly"
    ( [] )
# 1400 "sparser.ml"
               : 'opt_field_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'field_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'opt_semicolon) in
    Obj.repr(
# 397 "sparser.mly"
                             ( List.rev _1 )
# 1408 "sparser.ml"
               : 'opt_field_list))
; (fun __caml_parser_env ->
    Obj.repr(
# 401 "sparser.mly"
    ()
# 1414 "sparser.ml"
               : 'opt_semicolon))
; (fun __caml_parser_env ->
    Obj.repr(
# 402 "sparser.mly"
              ()
# 1420 "sparser.ml"
               : 'opt_semicolon))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'typ) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 406 "sparser.mly"
                   ( [((_1, _2), get_pos 1)] )
# 1428 "sparser.ml"
               : 'field_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'field_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'typ) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 407 "sparser.mly"
                                        ( 
			if List.mem _4 (List.map (fun f -> snd (fst f)) _1) then
				report_error (get_pos 4) (_4 ^ " is duplicated")
			else
				((_3, _4), get_pos 3) :: _1 
		)
# 1442 "sparser.ml"
               : 'field_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'enum_header) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'enum_body) in
    Obj.repr(
# 416 "sparser.mly"
                          (
	{ enum_name = _1;
	  enum_fields = _2 }
  )
# 1453 "sparser.ml"
               : 'enum_decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 423 "sparser.mly"
                    ( _2 )
# 1460 "sparser.ml"
               : 'enum_header))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'enum_list) in
    Obj.repr(
# 427 "sparser.mly"
                            ( List.rev _2 )
# 1467 "sparser.ml"
               : 'enum_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'enumerator) in
    Obj.repr(
# 431 "sparser.mly"
               ( [_1] )
# 1474 "sparser.ml"
               : 'enum_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'enum_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'enumerator) in
    Obj.repr(
# 432 "sparser.mly"
                               ( _3 :: _1 )
# 1482 "sparser.ml"
               : 'enum_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 436 "sparser.mly"
               ( (_1, None) )
# 1489 "sparser.ml"
               : 'enumerator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 437 "sparser.mly"
                                  ( (_1, Some _3) )
# 1497 "sparser.ml"
               : 'enumerator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'view_header) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'view_body) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'opt_inv) in
    Obj.repr(
# 443 "sparser.mly"
                                       (
	{ _1 with view_formula = _3; view_invariant = _4 }
  )
# 1508 "sparser.ml"
               : view_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'view_header) in
    Obj.repr(
# 446 "sparser.mly"
                         (
	  report_error (get_pos 2) ("use == to define a view")
	)
# 1517 "sparser.ml"
               : view_decl))
; (fun __caml_parser_env ->
    Obj.repr(
# 452 "sparser.mly"
    ( P.mkTrue no_pos )
# 1523 "sparser.ml"
               : 'opt_inv))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pure_constr) in
    Obj.repr(
# 453 "sparser.mly"
                    ( _2 )
# 1530 "sparser.ml"
               : 'opt_inv))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_ann_cid_list) in
    Obj.repr(
# 457 "sparser.mly"
                                           (
	let cids, anns = List.split _4 in
	  if List.exists 
		(fun x -> match snd x with | Primed -> true | Unprimed -> false) cids 
	  then
		report_error (get_pos 1) 
		  ("variables in view header are not allowed to be primed")
	  else
		let modes = get_modes anns in
		  { view_name = _2;
			view_data_name = "";
			view_vars = List.map fst cids;
			view_modes = modes;
			view_typed_vars = [];
			view_formula = F.mkTrue (get_pos 1);
			view_invariant = P.mkTrue (get_pos 1) }
  )
# 1554 "sparser.ml"
               : 'view_header))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 477 "sparser.mly"
               ( (_1, Unprimed) )
# 1561 "sparser.ml"
               : 'cid))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 478 "sparser.mly"
                     ( (_1, Primed) )
# 1568 "sparser.ml"
               : 'cid))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 479 "sparser.mly"
        ( (res, Unprimed) )
# 1575 "sparser.ml"
               : 'cid))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 480 "sparser.mly"
         ( (self, Unprimed) )
# 1582 "sparser.ml"
               : 'cid))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 481 "sparser.mly"
         ( (this, Unprimed) )
# 1589 "sparser.ml"
               : 'cid))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : F.formula) in
    Obj.repr(
# 485 "sparser.mly"
           ( _1 )
# 1596 "sparser.ml"
               : 'view_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'heap_arg_list_aux) in
    Obj.repr(
# 498 "sparser.mly"
                      ( List.rev _1 )
# 1603 "sparser.ml"
               : 'heap_arg_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'heap_arg) in
    Obj.repr(
# 502 "sparser.mly"
             ( [_1] )
# 1610 "sparser.ml"
               : 'heap_arg_list_aux))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'heap_arg_list_aux) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'heap_arg) in
    Obj.repr(
# 503 "sparser.mly"
                                     ( _3 :: _1)
# 1618 "sparser.ml"
               : 'heap_arg_list_aux))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'cexp) in
    Obj.repr(
# 507 "sparser.mly"
         ( _1 (* including variables. to be resolved later *) )
# 1625 "sparser.ml"
               : 'heap_arg))
; (fun __caml_parser_env ->
    Obj.repr(
# 511 "sparser.mly"
    ( [] )
# 1631 "sparser.ml"
               : 'opt_heap_arg_list2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'heap_arg_list2) in
    Obj.repr(
# 512 "sparser.mly"
                   ( List.rev _1 )
# 1638 "sparser.ml"
               : 'opt_heap_arg_list2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'heap_arg2) in
    Obj.repr(
# 516 "sparser.mly"
             ( [_1] )
# 1645 "sparser.ml"
               : 'heap_arg_list2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'heap_arg_list2) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'heap_arg2) in
    Obj.repr(
# 517 "sparser.mly"
                                  ( 
			if List.mem (fst _3) (List.map fst _1) then
				report_error (get_pos 3) ((fst _3) ^ " is duplicated")
			else 
				_3 :: _1 
		)
# 1658 "sparser.ml"
               : 'heap_arg_list2))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp) in
    Obj.repr(
# 526 "sparser.mly"
                      ( (_1, _3) )
# 1666 "sparser.ml"
               : 'heap_arg2))
; (fun __caml_parser_env ->
    Obj.repr(
# 530 "sparser.mly"
    ( 
	[] : (ident * primed) list 
  )
# 1674 "sparser.ml"
               : 'opt_cid_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'cid_list) in
    Obj.repr(
# 533 "sparser.mly"
             (
	  List.rev _1 : (ident * primed) list 
	)
# 1683 "sparser.ml"
               : 'opt_cid_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'cid) in
    Obj.repr(
# 539 "sparser.mly"
        ( 
	([_1]) : (ident * primed) list 
  )
# 1692 "sparser.ml"
               : 'cid_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'cid_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cid) in
    Obj.repr(
# 542 "sparser.mly"
                       (
	  if List.mem (fst _3) (List.map fst _1) then
		report_error (get_pos 3) ("identifier " ^ (fst _3) ^ " is duplicated")
	  else
		(_3 :: _1) : (ident * primed) list
	)
# 1705 "sparser.ml"
               : 'cid_list))
; (fun __caml_parser_env ->
    Obj.repr(
# 553 "sparser.mly"
    ( [] )
# 1711 "sparser.ml"
               : 'opt_ann_cid_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ann_cid_list) in
    Obj.repr(
# 554 "sparser.mly"
                 (
	  List.rev _1
	)
# 1720 "sparser.ml"
               : 'opt_ann_cid_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ann_cid) in
    Obj.repr(
# 559 "sparser.mly"
            (
	[_1]
  )
# 1729 "sparser.ml"
               : 'ann_cid_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'ann_cid_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'ann_cid) in
    Obj.repr(
# 562 "sparser.mly"
                               (
	  _3 :: _1
	)
# 1739 "sparser.ml"
               : 'ann_cid_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'cid) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'opt_ann_list) in
    Obj.repr(
# 568 "sparser.mly"
                     (
	(_1, _2)
  )
# 1749 "sparser.ml"
               : 'ann_cid))
; (fun __caml_parser_env ->
    Obj.repr(
# 574 "sparser.mly"
    ( 
	[] 
  )
# 1757 "sparser.ml"
               : 'opt_ann_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ann_list) in
    Obj.repr(
# 577 "sparser.mly"
             ( 
	  List.rev _1 
	)
# 1766 "sparser.ml"
               : 'opt_ann_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'ann) in
    Obj.repr(
# 583 "sparser.mly"
        (
	[_1]
  )
# 1775 "sparser.ml"
               : 'ann_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'ann_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'ann) in
    Obj.repr(
# 586 "sparser.mly"
                 (
	  _2 :: _1
	)
# 1785 "sparser.ml"
               : 'ann_list))
; (fun __caml_parser_env ->
    Obj.repr(
# 592 "sparser.mly"
          (
	AnnMode ModeIn
  )
# 1793 "sparser.ml"
               : 'ann))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 595 "sparser.mly"
                  (
	if _2 = "out" then AnnMode ModeOut
	else report_error (get_pos 2) ("unrecognized mode: " ^ _2)
  )
# 1803 "sparser.ml"
               : 'ann))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'disjunctive_constr) in
    Obj.repr(
# 602 "sparser.mly"
                       ( _1 )
# 1810 "sparser.ml"
               : F.formula))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'case_constr) in
    Obj.repr(
# 606 "sparser.mly"
                ( (* each case of a view definition *)
	_1
  )
# 1819 "sparser.ml"
               : 'disjunctive_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'disjunctive_constr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'case_constr) in
    Obj.repr(
# 609 "sparser.mly"
                                          (
	  F.mkOr _1 _3 (get_pos 2)
	)
# 1829 "sparser.ml"
               : 'disjunctive_constr))
; (fun __caml_parser_env ->
    Obj.repr(
# 612 "sparser.mly"
          (
	  report_error (get_pos 1) ("parse error in constraints")
	)
# 1837 "sparser.ml"
               : 'disjunctive_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'core_constr) in
    Obj.repr(
# 618 "sparser.mly"
                ( _1 )
# 1844 "sparser.ml"
               : 'case_constr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'opt_cid_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'core_constr) in
    Obj.repr(
# 619 "sparser.mly"
                                                         (
	  match _5 with
		| F.Base ({F.formula_base_heap = h;
				   F.formula_base_pure = p}) ->
			F.mkExists _3 h p (get_pos 1)
		| _ -> report_error (get_pos 4) ("only Base is expected here.")
	)
# 1858 "sparser.ml"
               : 'case_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'heap_constr) in
    Obj.repr(
# 629 "sparser.mly"
                ( F.formula_of_heap _1 (get_pos 1) )
# 1865 "sparser.ml"
               : 'core_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pure_constr) in
    Obj.repr(
# 630 "sparser.mly"
                ( F.formula_of_pure _1 (get_pos 1) )
# 1872 "sparser.ml"
               : 'core_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'heap_constr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pure_constr) in
    Obj.repr(
# 631 "sparser.mly"
                                ( F.mkBase _1 _3 (get_pos 2) )
# 1880 "sparser.ml"
               : 'core_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_heap_constr) in
    Obj.repr(
# 635 "sparser.mly"
                       ( _1 )
# 1887 "sparser.ml"
               : 'heap_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'heap_constr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_heap_constr) in
    Obj.repr(
# 636 "sparser.mly"
                                        ( F.mkStar _1 _3 (get_pos 2) )
# 1895 "sparser.ml"
               : 'heap_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'cid) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'heap_arg_list) in
    Obj.repr(
# 640 "sparser.mly"
                                                  (
	let h = F.HeapNode { F.h_formula_heap_node = _1;
						 F.h_formula_heap_name = _3;
						 F.h_formula_heap_full = false;
						 F.h_formula_heap_with_inv = false;
						 F.h_formula_heap_pseudo_data = false;
						 F.h_formula_heap_arguments = _5;
						 F.h_formula_heap_pos = get_pos 2 } in
	  h
  )
# 1913 "sparser.ml"
               : 'simple_heap_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'cid) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'opt_heap_arg_list2) in
    Obj.repr(
# 650 "sparser.mly"
                                                       (
	  let h = F.HeapNode2 { F.h_formula_heap2_node = _1;
							F.h_formula_heap2_name = _3;
							F.h_formula_heap2_full = false;
							F.h_formula_heap2_with_inv = false;
							F.h_formula_heap2_pseudo_data = false;
							F.h_formula_heap2_arguments = _5;
							F.h_formula_heap2_pos = get_pos 2 } in
		h
	)
# 1931 "sparser.ml"
               : 'simple_heap_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pure_constr) in
    Obj.repr(
# 695 "sparser.mly"
                       ( _1 )
# 1938 "sparser.ml"
               : 'pure_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pure_constr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'simple_pure_constr) in
    Obj.repr(
# 696 "sparser.mly"
                                       ( P.mkAnd _1 _3 (get_pos 2) )
# 1946 "sparser.ml"
               : 'pure_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'pure_constr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pure_constr) in
    Obj.repr(
# 700 "sparser.mly"
                               ( P.mkOr _1 _3 (get_pos 2) )
# 1954 "sparser.ml"
               : 'disjunctive_pure_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'disjunctive_pure_constr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'pure_constr) in
    Obj.repr(
# 701 "sparser.mly"
                                           ( P.mkOr _1 _3 (get_pos 2) )
# 1962 "sparser.ml"
               : 'disjunctive_pure_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'lbconstr) in
    Obj.repr(
# 705 "sparser.mly"
             (
	fst _1
  )
# 1971 "sparser.ml"
               : 'simple_pure_constr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'disjunctive_pure_constr) in
    Obj.repr(
# 708 "sparser.mly"
                                          ( 
	  _2 
	)
# 1980 "sparser.ml"
               : 'simple_pure_constr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'opt_cid_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'simple_pure_constr) in
    Obj.repr(
# 711 "sparser.mly"
                                                               (
	  let qf f v = P.mkExists [v] f (get_pos 1) in
	  let res = List.fold_left qf _5 _3 in
		res
	)
# 1992 "sparser.ml"
               : 'simple_pure_constr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'opt_cid_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'simple_pure_constr) in
    Obj.repr(
# 716 "sparser.mly"
                                                               (
	  let qf f v = P.mkForall [v] f (get_pos 1) in
	  let res = List.fold_left qf _5 _3 in
		res
	)
# 2004 "sparser.ml"
               : 'simple_pure_constr))
; (fun __caml_parser_env ->
    Obj.repr(
# 721 "sparser.mly"
         (
	  P.mkTrue (get_pos 1)
	)
# 2012 "sparser.ml"
               : 'simple_pure_constr))
; (fun __caml_parser_env ->
    Obj.repr(
# 724 "sparser.mly"
          (
	  P.mkFalse (get_pos 1)
	)
# 2020 "sparser.ml"
               : 'simple_pure_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'cid) in
    Obj.repr(
# 727 "sparser.mly"
        (
	  P.BForm (P.mkBVar _1 (get_pos 1))
	)
# 2029 "sparser.ml"
               : 'simple_pure_constr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'cid) in
    Obj.repr(
# 730 "sparser.mly"
            (
	  P.mkNot (P.BForm (P.mkBVar _2 (get_pos 2))) (get_pos 1)
	)
# 2038 "sparser.ml"
               : 'simple_pure_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bconstr) in
    Obj.repr(
# 736 "sparser.mly"
            (
	(fst _1, snd _1)
  )
# 2047 "sparser.ml"
               : 'lbconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'lbconstr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list) in
    Obj.repr(
# 739 "sparser.mly"
                           (
	  expand_exp_list P.mkNeq _1 _3 (get_pos 2)
	)
# 2057 "sparser.ml"
               : 'lbconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'lbconstr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list) in
    Obj.repr(
# 742 "sparser.mly"
                          (
	  expand_exp_list P.mkEq _1 _3 (get_pos 2)
	)
# 2067 "sparser.ml"
               : 'lbconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'lbconstr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list) in
    Obj.repr(
# 745 "sparser.mly"
                          (
	  expand_exp_list P.mkLt _1 _3 (get_pos 2)
	)
# 2077 "sparser.ml"
               : 'lbconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'lbconstr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list) in
    Obj.repr(
# 748 "sparser.mly"
                           (
	  expand_exp_list P.mkLte _1 _3 (get_pos 2)
	)
# 2087 "sparser.ml"
               : 'lbconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'lbconstr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list) in
    Obj.repr(
# 751 "sparser.mly"
                          (
	  expand_exp_list P.mkGt _1 _3 (get_pos 2)
	)
# 2097 "sparser.ml"
               : 'lbconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'lbconstr) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list) in
    Obj.repr(
# 754 "sparser.mly"
                           (
	  expand_exp_list P.mkGte _1 _3 (get_pos 2)
	)
# 2107 "sparser.ml"
               : 'lbconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'cexp_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list) in
    Obj.repr(
# 760 "sparser.mly"
                           (
	let p = P.build_relation P.mkLt _1 _3 (get_pos 2) in
	  (p, Some _3)
  )
# 2118 "sparser.ml"
               : 'bconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'cexp_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list) in
    Obj.repr(
# 764 "sparser.mly"
                            (
	  let p = P.build_relation P.mkLte _1 _3 (get_pos 2) in
		(p, Some _3)
	)
# 2129 "sparser.ml"
               : 'bconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'cexp_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list) in
    Obj.repr(
# 768 "sparser.mly"
                           ( 
	  let p = P.build_relation P.mkGt _1 _3 (get_pos 2) in
		(p, Some _3)
	)
# 2140 "sparser.ml"
               : 'bconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'cexp_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list) in
    Obj.repr(
# 772 "sparser.mly"
                            ( 
	  let p = P.build_relation P.mkGte _1 _3 (get_pos 2) in
		(p, Some _3)
	)
# 2151 "sparser.ml"
               : 'bconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'cexp_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list) in
    Obj.repr(
# 776 "sparser.mly"
                           ( 
	  let p = P.build_relation P.mkEq _1 _3 (get_pos 2) in
		(p, Some _3)
	)
# 2162 "sparser.ml"
               : 'bconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'cexp_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list) in
    Obj.repr(
# 780 "sparser.mly"
                            (
	  let p = P.build_relation P.mkNeq _1 _3 (get_pos 2) in
		(p, Some _3)
	)
# 2173 "sparser.ml"
               : 'bconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'cid) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp) in
    Obj.repr(
# 785 "sparser.mly"
                (
	  (P.BForm (P.BagIn (_1, _3, get_pos 2)), None)
	)
# 2183 "sparser.ml"
               : 'bconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'cid) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp) in
    Obj.repr(
# 788 "sparser.mly"
                   (
	  (P.BForm (P.BagNotIn (_1, _3, get_pos 2)), None)
	)
# 2193 "sparser.ml"
               : 'bconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'cexp) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp) in
    Obj.repr(
# 791 "sparser.mly"
                     (
	  (P.BForm (P.BagSub (_1, _3, get_pos 2)), None)
	)
# 2203 "sparser.ml"
               : 'bconstr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'cid) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'cid) in
    Obj.repr(
# 794 "sparser.mly"
                                       (
	  (P.BForm (P.BagMax (_3, _5, get_pos 2)), None)
	)
# 2213 "sparser.ml"
               : 'bconstr))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'cid) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'cid) in
    Obj.repr(
# 797 "sparser.mly"
                                       (
	  (P.BForm (P.BagMin (_3, _5, get_pos 2)), None)
	)
# 2223 "sparser.ml"
               : 'bconstr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'cid) in
    Obj.repr(
# 805 "sparser.mly"
        (
		P.Var (_1, get_pos 1)
  )
# 2232 "sparser.ml"
               : 'cexp))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 808 "sparser.mly"
                    (
	  P.IConst (_1, get_pos 1)
	)
# 2241 "sparser.ml"
               : 'cexp))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : int) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'cid) in
    Obj.repr(
# 811 "sparser.mly"
                        (
	  P.mkMult _1 (P.Var (_2, get_pos 2)) (get_pos 1)
	)
# 2251 "sparser.ml"
               : 'cexp))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'cexp) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp) in
    Obj.repr(
# 814 "sparser.mly"
                   (
	  P.mkAdd _1 _3 (get_pos 2)
	)
# 2261 "sparser.ml"
               : 'cexp))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'cexp) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp) in
    Obj.repr(
# 817 "sparser.mly"
                    (
	  P.mkSubtract _1 _3 (get_pos 2)
	)
# 2271 "sparser.ml"
               : 'cexp))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'cexp) in
    Obj.repr(
# 820 "sparser.mly"
                            (
	  P.mkSubtract (P.IConst (0, get_pos 1)) _2 (get_pos 1)
	)
# 2280 "sparser.ml"
               : 'cexp))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'cexp) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'cexp) in
    Obj.repr(
# 823 "sparser.mly"
                                      (
	  P.mkMax _3 _5 (get_pos 1)
	)
# 2290 "sparser.ml"
               : 'cexp))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'cexp) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'cexp) in
    Obj.repr(
# 826 "sparser.mly"
                                      (
	  P.mkMin _3 _5 (get_pos 1)
	)
# 2300 "sparser.ml"
               : 'cexp))
; (fun __caml_parser_env ->
    Obj.repr(
# 829 "sparser.mly"
         (
	  P.Null (get_pos 1)
	)
# 2308 "sparser.ml"
               : 'cexp))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'opt_cexp_list) in
    Obj.repr(
# 833 "sparser.mly"
                                (
	  P.Bag (_2, get_pos 1)
	)
# 2317 "sparser.ml"
               : 'cexp))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_cexp_list) in
    Obj.repr(
# 836 "sparser.mly"
                                      (
	  P.BagUnion (_3, get_pos 1)
	)
# 2326 "sparser.ml"
               : 'cexp))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_cexp_list) in
    Obj.repr(
# 839 "sparser.mly"
                                          (
	  P.BagIntersect (_3, get_pos 1)
	)
# 2335 "sparser.ml"
               : 'cexp))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'cexp) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'cexp) in
    Obj.repr(
# 842 "sparser.mly"
                                       (
	  P.BagDiff (_3, _5, get_pos 1)
	)
# 2345 "sparser.ml"
               : 'cexp))
; (fun __caml_parser_env ->
    Obj.repr(
# 849 "sparser.mly"
    ( [] )
# 2351 "sparser.ml"
               : 'opt_cexp_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list) in
    Obj.repr(
# 850 "sparser.mly"
              ( _1 )
# 2358 "sparser.ml"
               : 'opt_cexp_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'cexp_list_rec) in
    Obj.repr(
# 854 "sparser.mly"
                  ( 
	List.rev _1
  )
# 2367 "sparser.ml"
               : 'cexp_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'cexp) in
    Obj.repr(
# 860 "sparser.mly"
         (
	[_1]
  )
# 2376 "sparser.ml"
               : 'cexp_list_rec))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'cexp_list_rec) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'cexp) in
    Obj.repr(
# 863 "sparser.mly"
                             ( 
	  _3 :: _1
	)
# 2386 "sparser.ml"
               : 'cexp_list_rec))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'proc_header) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'proc_body) in
    Obj.repr(
# 871 "sparser.mly"
                          (
	{ _1 with proc_body = Some _2 }
  )
# 2396 "sparser.ml"
               : 'proc_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'proc_header) in
    Obj.repr(
# 874 "sparser.mly"
                ( _1 )
# 2403 "sparser.ml"
               : 'proc_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'typ) in
    let _2 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'opt_formal_parameter_list) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'opt_pre_post_list) in
    Obj.repr(
# 878 "sparser.mly"
                                                                             (
	  let static_specs, dynamic_specs = split_specs _6 in
		{ proc_name = _2;
		  proc_mingled_name = ""; (* mingle_name $2 (List.map (fun p -> p.param_type) $4); *)
		  proc_data_decl = None;
		  proc_constructor = false;
		  proc_args = _4;
		  proc_return = _1;
		  proc_static_specs = static_specs;
		  proc_dynamic_specs = dynamic_specs;
		  proc_loc = get_pos 1;
		  proc_body = None }
	)
# 2425 "sparser.ml"
               : 'proc_header))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 2 : 'opt_formal_parameter_list) in
    let _6 = (Parsing.peek_val __caml_parser_env 0 : 'opt_pre_post_list) in
    Obj.repr(
# 891 "sparser.mly"
                                                                              (
		let static_specs, dynamic_specs = split_specs _6 in
		  { proc_name = _2;
			proc_mingled_name = ""; (* mingle_name $2 (List.map (fun p -> p.param_type) $4); *)
			proc_data_decl = None;
			proc_constructor = false;
			proc_args = _4;
			proc_return = void_type;
			proc_static_specs = static_specs;
			proc_dynamic_specs = dynamic_specs;
			proc_loc = get_pos 1;
			proc_body = None }
  )
# 2446 "sparser.ml"
               : 'proc_header))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'constructor_header) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'proc_body) in
    Obj.repr(
# 907 "sparser.mly"
                                 (
	  { _1 with proc_body = Some _2 }
	)
# 2456 "sparser.ml"
               : 'constructor_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constructor_header) in
    Obj.repr(
# 910 "sparser.mly"
                       ( _1 )
# 2463 "sparser.ml"
               : 'constructor_decl))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'opt_formal_parameter_list) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'opt_pre_post_list) in
    Obj.repr(
# 914 "sparser.mly"
                                                                         (
	  let static_specs, dynamic_specs = split_specs _5 in
		if Util.empty dynamic_specs then
		  { proc_name = _1;
			proc_mingled_name = ""; (* mingle_name $2 (List.map (fun p -> p.param_type) $4); *)
			proc_data_decl = None;
			proc_constructor = true;
			proc_args = _3;
			proc_return = Named _1;
			proc_static_specs = static_specs;
			proc_dynamic_specs = dynamic_specs;
			proc_loc = get_pos 1;
			proc_body = None }
		else
		  report_error (get_pos 1) ("constructors have only static speficiations");
	)
# 2487 "sparser.ml"
               : 'constructor_header))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'meta_constr) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'meta_constr) in
    Obj.repr(
# 933 "sparser.mly"
                                               (
	(_2, _4)
  )
# 2497 "sparser.ml"
               : 'checkentail_cmd))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 939 "sparser.mly"
                                     (
	(_3)
  )
# 2506 "sparser.ml"
               : 'captureresidue_cmd))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 6 : 'id_list) in
    let _6 = (Parsing.peek_val __caml_parser_env 3 : 'meta_constr) in
    let _8 = (Parsing.peek_val __caml_parser_env 1 : 'meta_constr) in
    Obj.repr(
# 945 "sparser.mly"
                                                                                    (
	(_3, _6, _8)
  )
# 2517 "sparser.ml"
               : 'compose_cmd))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 3 : 'meta_constr) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : 'meta_constr) in
    Obj.repr(
# 948 "sparser.mly"
                                                            (
	  ([], _3, _5)
	)
# 2527 "sparser.ml"
               : 'compose_cmd))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 954 "sparser.mly"
                     (
		PCmd _2
  )
# 2536 "sparser.ml"
               : 'print_cmd))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 957 "sparser.mly"
                            (
	  PVar _3
	)
# 2545 "sparser.ml"
               : 'print_cmd))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'meta_constr) in
    Obj.repr(
# 963 "sparser.mly"
                                         (
	LetDef (_3, _5)
  )
# 2555 "sparser.ml"
               : 'let_decl))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 969 "sparser.mly"
                      (
	MetaVar _2
  )
# 2564 "sparser.ml"
               : 'meta_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : F.formula) in
    Obj.repr(
# 972 "sparser.mly"
           (
	  MetaForm _1
	)
# 2573 "sparser.ml"
               : 'meta_constr))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'compose_cmd) in
    Obj.repr(
# 975 "sparser.mly"
                (
	  MetaCompose _1
	)
# 2582 "sparser.ml"
               : 'meta_constr))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : 'opt_name) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : F.formula) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'coercion_direction) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : F.formula) in
    Obj.repr(
# 981 "sparser.mly"
                                                    (  
	{ coercion_type = _4;
	  coercion_name = _2;
	  coercion_head = _3;
	  coercion_body = _5;
	  coercion_proof = Return ({ exp_return_val = None;
								 exp_return_pos = get_pos 1 })
	}
  )
# 2600 "sparser.ml"
               : coercion_decl))
; (fun __caml_parser_env ->
    Obj.repr(
# 1002 "sparser.mly"
              ( Left )
# 2606 "sparser.ml"
               : 'coercion_direction))
; (fun __caml_parser_env ->
    Obj.repr(
# 1003 "sparser.mly"
          ( Equiv )
# 2612 "sparser.ml"
               : 'coercion_direction))
; (fun __caml_parser_env ->
    Obj.repr(
# 1004 "sparser.mly"
               ( Right )
# 2618 "sparser.ml"
               : 'coercion_direction))
; (fun __caml_parser_env ->
    Obj.repr(
# 1028 "sparser.mly"
    ( "" )
# 2624 "sparser.ml"
               : 'opt_name))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 1029 "sparser.mly"
                                       ( _2 )
# 2631 "sparser.ml"
               : 'opt_name))
; (fun __caml_parser_env ->
    Obj.repr(
# 1033 "sparser.mly"
    ( [] )
# 2637 "sparser.ml"
               : 'opt_pre_post_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pre_post_list) in
    Obj.repr(
# 1034 "sparser.mly"
                                                 ( List.rev _1 )
# 2644 "sparser.ml"
               : 'opt_pre_post_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pre_post_pair) in
    Obj.repr(
# 1038 "sparser.mly"
                  ( [_1] )
# 2651 "sparser.ml"
               : 'pre_post_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'pre_post_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'pre_post_pair) in
    Obj.repr(
# 1039 "sparser.mly"
                                ( _2 :: _1 )
# 2659 "sparser.ml"
               : 'pre_post_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 5 : 'spec_qualifier_opt) in
    let _3 = (Parsing.peek_val __caml_parser_env 3 : F.formula) in
    let _5 = (Parsing.peek_val __caml_parser_env 1 : F.formula) in
    Obj.repr(
# 1043 "sparser.mly"
                                                                ( (_1, _3, _5) )
# 2668 "sparser.ml"
               : 'pre_post_pair))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'spec_qualifier_opt) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : F.formula) in
    Obj.repr(
# 1044 "sparser.mly"
                                                ( (_1, F.mkTrue (get_pos 1), _3) )
# 2676 "sparser.ml"
               : 'pre_post_pair))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'spec_qualifier_opt) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : F.formula) in
    Obj.repr(
# 1045 "sparser.mly"
                                                 ( (_1, _3, F.mkTrue (get_pos 1)) )
# 2684 "sparser.ml"
               : 'pre_post_pair))
; (fun __caml_parser_env ->
    Obj.repr(
# 1049 "sparser.mly"
    ( Static )
# 2690 "sparser.ml"
               : 'spec_qualifier_opt))
; (fun __caml_parser_env ->
    Obj.repr(
# 1050 "sparser.mly"
           ( Static )
# 2696 "sparser.ml"
               : 'spec_qualifier_opt))
; (fun __caml_parser_env ->
    Obj.repr(
# 1051 "sparser.mly"
            ( Dynamic )
# 2702 "sparser.ml"
               : 'spec_qualifier_opt))
; (fun __caml_parser_env ->
    Obj.repr(
# 1055 "sparser.mly"
    ( [] )
# 2708 "sparser.ml"
               : 'opt_formal_parameter_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'formal_parameter_list) in
    Obj.repr(
# 1056 "sparser.mly"
                          ( List.rev _1 )
# 2715 "sparser.ml"
               : 'opt_formal_parameter_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'formal_parameter) in
    Obj.repr(
# 1060 "sparser.mly"
                     ( [_1] )
# 2722 "sparser.ml"
               : 'formal_parameter_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'formal_parameter_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'formal_parameter) in
    Obj.repr(
# 1061 "sparser.mly"
                                                 ( _3 :: _1 )
# 2730 "sparser.ml"
               : 'formal_parameter_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'fixed_parameter) in
    Obj.repr(
# 1065 "sparser.mly"
                    ( _1 )
# 2737 "sparser.ml"
               : 'formal_parameter))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'opt_parameter_modifier) in
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'typ) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1069 "sparser.mly"
                                          (
	{ param_mod = _1;
	  param_type = _2;
	  param_loc = get_pos 3;
	  param_name = _3 }
  )
# 2751 "sparser.ml"
               : 'fixed_parameter))
; (fun __caml_parser_env ->
    Obj.repr(
# 1078 "sparser.mly"
    ( NoMod )
# 2757 "sparser.ml"
               : 'opt_parameter_modifier))
; (fun __caml_parser_env ->
    Obj.repr(
# 1079 "sparser.mly"
        ( RefMod )
# 2763 "sparser.ml"
               : 'opt_parameter_modifier))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'block) in
    Obj.repr(
# 1083 "sparser.mly"
          ( _1 )
# 2770 "sparser.ml"
               : 'proc_body))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'non_array_type) in
    Obj.repr(
# 1096 "sparser.mly"
                   ( _1 )
# 2777 "sparser.ml"
               : 'typ))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'array_type) in
    Obj.repr(
# 1097 "sparser.mly"
               ( _1 )
# 2784 "sparser.ml"
               : 'typ))
; (fun __caml_parser_env ->
    Obj.repr(
# 1101 "sparser.mly"
        ( int_type )
# 2790 "sparser.ml"
               : 'non_array_type))
; (fun __caml_parser_env ->
    Obj.repr(
# 1102 "sparser.mly"
          ( float_type )
# 2796 "sparser.ml"
               : 'non_array_type))
; (fun __caml_parser_env ->
    Obj.repr(
# 1103 "sparser.mly"
         ( bool_type )
# 2802 "sparser.ml"
               : 'non_array_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1104 "sparser.mly"
               ( Named _1 )
# 2809 "sparser.ml"
               : 'non_array_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'array_type) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'rank_specifier) in
    Obj.repr(
# 1108 "sparser.mly"
                              ( Array (int_type, None) )
# 2817 "sparser.ml"
               : 'array_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'non_array_type) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'rank_specifier) in
    Obj.repr(
# 1109 "sparser.mly"
                                  ( Array (int_type, None) )
# 2825 "sparser.ml"
               : 'array_type))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'comma_list_opt) in
    Obj.repr(
# 1113 "sparser.mly"
                                   ()
# 2832 "sparser.ml"
               : 'rank_specifier))
; (fun __caml_parser_env ->
    Obj.repr(
# 1117 "sparser.mly"
    ()
# 2838 "sparser.ml"
               : 'comma_list_opt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'comma_list) in
    Obj.repr(
# 1118 "sparser.mly"
               ()
# 2845 "sparser.ml"
               : 'comma_list_opt))
; (fun __caml_parser_env ->
    Obj.repr(
# 1122 "sparser.mly"
          ()
# 2851 "sparser.ml"
               : 'comma_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'comma_list) in
    Obj.repr(
# 1123 "sparser.mly"
                     ()
# 2858 "sparser.ml"
               : 'comma_list))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'opt_statement_list) in
    Obj.repr(
# 1129 "sparser.mly"
                                     (
	match _2 with
	  | Empty _ -> Block { exp_block_body = Empty (get_pos 1);
						   exp_block_pos = get_pos 1 }
	  | _ -> Block { exp_block_body = _2;
					 exp_block_pos = get_pos 1 }
  )
# 2871 "sparser.ml"
               : 'block))
; (fun __caml_parser_env ->
    Obj.repr(
# 1139 "sparser.mly"
    ( Empty no_pos )
# 2877 "sparser.ml"
               : 'opt_statement_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'statement_list) in
    Obj.repr(
# 1140 "sparser.mly"
                   ( _1 )
# 2884 "sparser.ml"
               : 'opt_statement_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'statement) in
    Obj.repr(
# 1144 "sparser.mly"
              ( _1 )
# 2891 "sparser.ml"
               : 'statement_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'statement_list) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'statement) in
    Obj.repr(
# 1145 "sparser.mly"
                             ( Seq { exp_seq_exp1 = _1;
									 exp_seq_exp2 = _2;
									 exp_seq_pos = get_pos 1 } )
# 2901 "sparser.ml"
               : 'statement_list))
; (fun __caml_parser_env ->
    Obj.repr(
# 1148 "sparser.mly"
          ( report_error (get_pos 1) ("parse error") )
# 2907 "sparser.ml"
               : 'statement_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'declaration_statement) in
    Obj.repr(
# 1152 "sparser.mly"
                          ( _1 )
# 2914 "sparser.ml"
               : 'statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'valid_declaration_statement) in
    Obj.repr(
# 1153 "sparser.mly"
                                ( _1 )
# 2921 "sparser.ml"
               : 'statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'local_variable_declaration) in
    Obj.repr(
# 1157 "sparser.mly"
                                         ( _1 )
# 2928 "sparser.ml"
               : 'declaration_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'local_constant_declaration) in
    Obj.repr(
# 1158 "sparser.mly"
                                         ( _1 )
# 2935 "sparser.ml"
               : 'declaration_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'typ) in
    Obj.repr(
# 1162 "sparser.mly"
        ( _1 )
# 2942 "sparser.ml"
               : 'local_variable_type))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'local_variable_type) in
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'variable_declarators) in
    Obj.repr(
# 1166 "sparser.mly"
                                             (
	let var_decls = List.rev _2 in
	  mkVarDecl _1 var_decls (get_pos 1)
  )
# 2953 "sparser.ml"
               : 'local_variable_declaration))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'local_variable_type) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'constant_declarators) in
    Obj.repr(
# 1173 "sparser.mly"
                                                   (
	let const_decls = List.rev _3  in
	  mkConstDecl _2 const_decls (get_pos 1)
  )
# 2964 "sparser.ml"
               : 'local_constant_declaration))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'variable_declarator) in
    Obj.repr(
# 1180 "sparser.mly"
                        ( [_1] )
# 2971 "sparser.ml"
               : 'variable_declarators))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'variable_declarators) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'variable_declarator) in
    Obj.repr(
# 1181 "sparser.mly"
                                                   ( _3 :: _1 )
# 2979 "sparser.ml"
               : 'variable_declarators))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'variable_initializer) in
    Obj.repr(
# 1185 "sparser.mly"
                                       ( (_1, Some _3, get_pos 1) )
# 2987 "sparser.ml"
               : 'variable_declarator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1186 "sparser.mly"
               ( (_1, None, get_pos 1) )
# 2994 "sparser.ml"
               : 'variable_declarator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expression) in
    Obj.repr(
# 1190 "sparser.mly"
               ( _1 )
# 3001 "sparser.ml"
               : 'variable_initializer))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'constant_declarator) in
    Obj.repr(
# 1194 "sparser.mly"
                        ( [_1] )
# 3008 "sparser.ml"
               : 'constant_declarators))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'constant_declarators) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'constant_declarator) in
    Obj.repr(
# 1195 "sparser.mly"
                                                   ( _3 :: _1 )
# 3016 "sparser.ml"
               : 'constant_declarators))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'constant_expression) in
    Obj.repr(
# 1199 "sparser.mly"
                                      ( (_1, _3, get_pos 1) )
# 3024 "sparser.ml"
               : 'constant_declarator))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'block) in
    Obj.repr(
# 1203 "sparser.mly"
          ( _1 )
# 3031 "sparser.ml"
               : 'valid_declaration_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'empty_statement) in
    Obj.repr(
# 1204 "sparser.mly"
                    ( _1 )
# 3038 "sparser.ml"
               : 'valid_declaration_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expression_statement) in
    Obj.repr(
# 1205 "sparser.mly"
                         ( _1 )
# 3045 "sparser.ml"
               : 'valid_declaration_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'selection_statement) in
    Obj.repr(
# 1206 "sparser.mly"
                        ( _1 )
# 3052 "sparser.ml"
               : 'valid_declaration_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'iteration_statement) in
    Obj.repr(
# 1207 "sparser.mly"
                        ( _1 )
# 3059 "sparser.ml"
               : 'valid_declaration_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'java_statement) in
    Obj.repr(
# 1208 "sparser.mly"
                   ( _1 )
# 3066 "sparser.ml"
               : 'valid_declaration_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'jump_statement) in
    Obj.repr(
# 1209 "sparser.mly"
                   ( _1 )
# 3073 "sparser.ml"
               : 'valid_declaration_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'assert_statement) in
    Obj.repr(
# 1210 "sparser.mly"
                     ( _1 )
# 3080 "sparser.ml"
               : 'valid_declaration_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'dprint_statement) in
    Obj.repr(
# 1211 "sparser.mly"
                     ( _1 )
# 3087 "sparser.ml"
               : 'valid_declaration_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'debug_statement) in
    Obj.repr(
# 1212 "sparser.mly"
                    ( _1 )
# 3094 "sparser.ml"
               : 'valid_declaration_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'bind_statement) in
    Obj.repr(
# 1213 "sparser.mly"
                   ( _1 )
# 3101 "sparser.ml"
               : 'valid_declaration_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'unfold_statement) in
    Obj.repr(
# 1214 "sparser.mly"
                     ( _1 )
# 3108 "sparser.ml"
               : 'valid_declaration_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'cid) in
    Obj.repr(
# 1230 "sparser.mly"
                         ( 
	Unfold { exp_unfold_var = _2;
			 exp_unfold_pos = get_pos 1 } )
# 3117 "sparser.ml"
               : 'unfold_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : F.formula) in
    Obj.repr(
# 1247 "sparser.mly"
                            (
	Assert { exp_assert_asserted_formula = Some _2;
			 exp_assert_assumed_formula = None;
			 exp_assert_pos = get_pos 1 }
  )
# 3128 "sparser.ml"
               : 'assert_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : F.formula) in
    Obj.repr(
# 1252 "sparser.mly"
                                   (
	  Assert { exp_assert_asserted_formula = Some _2;
			   exp_assert_assumed_formula = Some _2;
			   exp_assert_pos = get_pos 1 }
	)
# 3139 "sparser.ml"
               : 'assert_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : F.formula) in
    Obj.repr(
# 1257 "sparser.mly"
                            (
	  Assert { exp_assert_asserted_formula = None;
			   exp_assert_assumed_formula = Some _2;
			   exp_assert_pos = get_pos 1 }
	)
# 3150 "sparser.ml"
               : 'assert_statement))
; (fun __caml_parser_env ->
    Obj.repr(
# 1265 "sparser.mly"
              (
	Debug { exp_debug_flag = true;
			exp_debug_pos = get_pos 2 }
  )
# 3159 "sparser.ml"
               : 'debug_statement))
; (fun __caml_parser_env ->
    Obj.repr(
# 1269 "sparser.mly"
               (
	  Debug { exp_debug_flag = false;
			  exp_debug_pos = get_pos 2 }
	)
# 3168 "sparser.ml"
               : 'debug_statement))
; (fun __caml_parser_env ->
    Obj.repr(
# 1276 "sparser.mly"
                    ( Dprint ({exp_dprint_string = "";
							   exp_dprint_pos = (get_pos 1)}) )
# 3175 "sparser.ml"
               : 'dprint_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : string) in
    Obj.repr(
# 1278 "sparser.mly"
                               ( Dprint ({exp_dprint_string = _2;
							   exp_dprint_pos = (get_pos 1)}) )
# 3183 "sparser.ml"
               : 'dprint_statement))
; (fun __caml_parser_env ->
    Obj.repr(
# 1283 "sparser.mly"
              ( Empty (get_pos 1) )
# 3189 "sparser.ml"
               : 'empty_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 6 : string) in
    let _5 = (Parsing.peek_val __caml_parser_env 3 : 'id_list_opt) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'block) in
    Obj.repr(
# 1287 "sparser.mly"
                                                          ( 
	Bind { exp_bind_bound_var = _2;
		   exp_bind_fields = _5;
		   exp_bind_body = _8;
		   exp_bind_pos = get_pos 1 }
  )
# 3203 "sparser.ml"
               : 'bind_statement))
; (fun __caml_parser_env ->
    Obj.repr(
# 1296 "sparser.mly"
    ( [] )
# 3209 "sparser.ml"
               : 'id_list_opt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'id_list) in
    Obj.repr(
# 1297 "sparser.mly"
            ( List.rev _1 )
# 3216 "sparser.ml"
               : 'id_list_opt))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1301 "sparser.mly"
               ( [_1] )
# 3223 "sparser.ml"
               : 'id_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'id_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1302 "sparser.mly"
                             ( _3 :: _1 )
# 3231 "sparser.ml"
               : 'id_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1306 "sparser.mly"
         (
	Java { exp_java_code = _1;
		   exp_java_pos = get_pos 1 }
  )
# 3241 "sparser.ml"
               : 'java_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'statement_expression) in
    Obj.repr(
# 1312 "sparser.mly"
                                   ( _1 )
# 3248 "sparser.ml"
               : 'expression_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'invocation_expression) in
    Obj.repr(
# 1316 "sparser.mly"
                          ( _1 )
# 3255 "sparser.ml"
               : 'statement_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'object_creation_expression) in
    Obj.repr(
# 1317 "sparser.mly"
                               ( _1 )
# 3262 "sparser.ml"
               : 'statement_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'assignment_expression) in
    Obj.repr(
# 1318 "sparser.mly"
                          ( _1 )
# 3269 "sparser.ml"
               : 'statement_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'post_increment_expression) in
    Obj.repr(
# 1319 "sparser.mly"
                              ( _1 )
# 3276 "sparser.ml"
               : 'statement_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'post_decrement_expression) in
    Obj.repr(
# 1320 "sparser.mly"
                              ( _1 )
# 3283 "sparser.ml"
               : 'statement_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pre_increment_expression) in
    Obj.repr(
# 1321 "sparser.mly"
                             ( _1 )
# 3290 "sparser.ml"
               : 'statement_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pre_decrement_expression) in
    Obj.repr(
# 1322 "sparser.mly"
                             ( _1 )
# 3297 "sparser.ml"
               : 'statement_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'if_statement) in
    Obj.repr(
# 1326 "sparser.mly"
                 ( _1 )
# 3304 "sparser.ml"
               : 'selection_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'valid_declaration_statement) in
    Obj.repr(
# 1330 "sparser.mly"
                                ( _1 )
# 3311 "sparser.ml"
               : 'embedded_statement))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'boolean_expression) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'embedded_statement) in
    Obj.repr(
# 1334 "sparser.mly"
                                                                                 (
	  Cond { exp_cond_condition = _3;
			 exp_cond_then_arm = _5;
			 exp_cond_else_arm = Empty (get_pos 1);
			 exp_cond_pos = get_pos 1 }
	)
# 3324 "sparser.ml"
               : 'if_statement))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 4 : 'boolean_expression) in
    let _5 = (Parsing.peek_val __caml_parser_env 2 : 'embedded_statement) in
    let _7 = (Parsing.peek_val __caml_parser_env 0 : 'embedded_statement) in
    Obj.repr(
# 1340 "sparser.mly"
                                                                                   (
		Cond { exp_cond_condition = _3;
			   exp_cond_then_arm = _5;
			   exp_cond_else_arm = _7;
			   exp_cond_pos = get_pos 1 }
	  )
# 3338 "sparser.ml"
               : 'if_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'while_statement) in
    Obj.repr(
# 1349 "sparser.mly"
                    ( _1 )
# 3345 "sparser.ml"
               : 'iteration_statement))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'boolean_expression) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'embedded_statement) in
    Obj.repr(
# 1353 "sparser.mly"
                                                              (
	  While { exp_while_condition = _3;
			  exp_while_body = _5;
			  exp_while_specs = [(F.mkTrue no_pos, F.mkTrue no_pos)];
			  exp_while_pos = get_pos 1 }
	)
# 3358 "sparser.ml"
               : 'while_statement))
; (fun __caml_parser_env ->
    let _3 = (Parsing.peek_val __caml_parser_env 5 : 'boolean_expression) in
    let _6 = (Parsing.peek_val __caml_parser_env 2 : 'pre_post_list) in
    let _8 = (Parsing.peek_val __caml_parser_env 0 : 'embedded_statement) in
    Obj.repr(
# 1359 "sparser.mly"
                                                                                            (
		While { exp_while_condition = _3;
				exp_while_body = _8;
				exp_while_specs = List.map remove_spec_qualifier _6;
				exp_while_pos = get_pos 1 }
	  )
# 3372 "sparser.ml"
               : 'while_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'return_statement) in
    Obj.repr(
# 1368 "sparser.mly"
                     ( _1 )
# 3379 "sparser.ml"
               : 'jump_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'break_statement) in
    Obj.repr(
# 1369 "sparser.mly"
                    ( _1 )
# 3386 "sparser.ml"
               : 'jump_statement))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'continue_statement) in
    Obj.repr(
# 1370 "sparser.mly"
                       ( _1 )
# 3393 "sparser.ml"
               : 'jump_statement))
; (fun __caml_parser_env ->
    Obj.repr(
# 1374 "sparser.mly"
                    ( Break (get_pos 1) )
# 3399 "sparser.ml"
               : 'break_statement))
; (fun __caml_parser_env ->
    Obj.repr(
# 1378 "sparser.mly"
                       ( Continue (get_pos 1) )
# 3405 "sparser.ml"
               : 'continue_statement))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'opt_expression) in
    Obj.repr(
# 1382 "sparser.mly"
                                    ( Return { exp_return_val = _2;
											   exp_return_pos = get_pos 1 } )
# 3413 "sparser.ml"
               : 'return_statement))
; (fun __caml_parser_env ->
    Obj.repr(
# 1387 "sparser.mly"
    ( None )
# 3419 "sparser.ml"
               : 'opt_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expression) in
    Obj.repr(
# 1388 "sparser.mly"
               ( Some _1 )
# 3426 "sparser.ml"
               : 'opt_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'object_or_delegate_creation_expression) in
    Obj.repr(
# 1394 "sparser.mly"
                                           ( _1 )
# 3433 "sparser.ml"
               : 'object_creation_expression))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _4 = (Parsing.peek_val __caml_parser_env 1 : 'opt_argument_list) in
    Obj.repr(
# 1398 "sparser.mly"
                                                   (
	New { exp_new_class_name = _2;
		  exp_new_arguments = _4;
		  exp_new_pos = get_pos 1 }
  )
# 3445 "sparser.ml"
               : 'object_or_delegate_creation_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'object_or_delegate_creation_expression) in
    Obj.repr(
# 1406 "sparser.mly"
                                           ( _1 )
# 3452 "sparser.ml"
               : 'new_expression))
; (fun __caml_parser_env ->
    Obj.repr(
# 1410 "sparser.mly"
    ( [] )
# 3458 "sparser.ml"
               : 'opt_argument_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'argument_list) in
    Obj.repr(
# 1411 "sparser.mly"
                  ( List.rev _1 )
# 3465 "sparser.ml"
               : 'opt_argument_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'argument) in
    Obj.repr(
# 1415 "sparser.mly"
             ( [_1] )
# 3472 "sparser.ml"
               : 'argument_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'argument_list) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'argument) in
    Obj.repr(
# 1416 "sparser.mly"
                                 ( _3 :: _1 )
# 3480 "sparser.ml"
               : 'argument_list))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expression) in
    Obj.repr(
# 1420 "sparser.mly"
               ( _1 )
# 3487 "sparser.ml"
               : 'argument))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'conditional_expression) in
    Obj.repr(
# 1424 "sparser.mly"
                           ( _1 )
# 3494 "sparser.ml"
               : 'expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'assignment_expression) in
    Obj.repr(
# 1425 "sparser.mly"
                          ( _1 )
# 3501 "sparser.ml"
               : 'expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expression) in
    Obj.repr(
# 1429 "sparser.mly"
               (
	_1
  )
# 3510 "sparser.ml"
               : 'constant_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'expression) in
    Obj.repr(
# 1435 "sparser.mly"
               (
	(* check type *)
	_1
  )
# 3520 "sparser.ml"
               : 'boolean_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'prefixed_unary_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expression) in
    Obj.repr(
# 1442 "sparser.mly"
                                            (
	  mkAssign OpAssign _1 _3 (get_pos 2)
	)
# 3530 "sparser.ml"
               : 'assignment_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'prefixed_unary_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expression) in
    Obj.repr(
# 1445 "sparser.mly"
                                                        (
		mkAssign OpMultAssign _1 _3 (get_pos 2)
	  )
# 3540 "sparser.ml"
               : 'assignment_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'prefixed_unary_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expression) in
    Obj.repr(
# 1448 "sparser.mly"
                                                       (
		mkAssign OpDivAssign _1 _3 (get_pos 2)
	  )
# 3550 "sparser.ml"
               : 'assignment_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'prefixed_unary_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expression) in
    Obj.repr(
# 1451 "sparser.mly"
                                                       (
		mkAssign OpModAssign _1 _3 (get_pos 2)
	  )
# 3560 "sparser.ml"
               : 'assignment_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'prefixed_unary_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expression) in
    Obj.repr(
# 1454 "sparser.mly"
                                                       (
		mkAssign OpPlusAssign _1 _3 (get_pos 2)
	  )
# 3570 "sparser.ml"
               : 'assignment_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'prefixed_unary_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'expression) in
    Obj.repr(
# 1457 "sparser.mly"
                                                       (
		mkAssign OpMinusAssign _1 _3 (get_pos 2)
	  )
# 3580 "sparser.ml"
               : 'assignment_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'conditional_or_expression) in
    Obj.repr(
# 1463 "sparser.mly"
                              ( _1 )
# 3587 "sparser.ml"
               : 'conditional_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 4 : 'conditional_or_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 2 : 'expression) in
    let _5 = (Parsing.peek_val __caml_parser_env 0 : 'expression) in
    Obj.repr(
# 1464 "sparser.mly"
                                                                 (
	  Cond { exp_cond_condition = _1;
			 exp_cond_then_arm = _3;
			 exp_cond_else_arm = _5;
			 exp_cond_pos = get_pos 2 }
	)
# 3601 "sparser.ml"
               : 'conditional_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'conditional_and_expression) in
    Obj.repr(
# 1473 "sparser.mly"
                               ( _1 )
# 3608 "sparser.ml"
               : 'conditional_or_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'conditional_or_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'conditional_and_expression) in
    Obj.repr(
# 1474 "sparser.mly"
                                                              (
	  mkBinary OpLogicalOr _1 _3 (get_pos 2)
	)
# 3618 "sparser.ml"
               : 'conditional_or_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'inclusive_or_expression) in
    Obj.repr(
# 1480 "sparser.mly"
                            ( _1 )
# 3625 "sparser.ml"
               : 'conditional_and_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'conditional_and_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'inclusive_or_expression) in
    Obj.repr(
# 1481 "sparser.mly"
                                                              (
		mkBinary OpLogicalAnd _1 _3 (get_pos 2)
	  )
# 3635 "sparser.ml"
               : 'conditional_and_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'exclusive_or_expression) in
    Obj.repr(
# 1487 "sparser.mly"
                            ( _1 )
# 3642 "sparser.ml"
               : 'inclusive_or_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'and_expression) in
    Obj.repr(
# 1491 "sparser.mly"
                   ( _1 )
# 3649 "sparser.ml"
               : 'exclusive_or_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'equality_expression) in
    Obj.repr(
# 1495 "sparser.mly"
                        ( _1 )
# 3656 "sparser.ml"
               : 'and_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'relational_expression) in
    Obj.repr(
# 1499 "sparser.mly"
                          ( _1 )
# 3663 "sparser.ml"
               : 'equality_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'equality_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'relational_expression) in
    Obj.repr(
# 1500 "sparser.mly"
                                                   (
		mkBinary OpEq _1 _3 (get_pos 2)
	  )
# 3673 "sparser.ml"
               : 'equality_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'equality_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'relational_expression) in
    Obj.repr(
# 1503 "sparser.mly"
                                                  (
		mkBinary OpNeq _1 _3 (get_pos 2)
	  )
# 3683 "sparser.ml"
               : 'equality_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'shift_expression) in
    Obj.repr(
# 1509 "sparser.mly"
                     ( _1 )
# 3690 "sparser.ml"
               : 'relational_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'relational_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'shift_expression) in
    Obj.repr(
# 1510 "sparser.mly"
                                              (
		mkBinary OpLt _1 _3 (get_pos 2)
	  )
# 3700 "sparser.ml"
               : 'relational_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'relational_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'shift_expression) in
    Obj.repr(
# 1513 "sparser.mly"
                                              (
		mkBinary OpGt _1 _3 (get_pos 2)
	  )
# 3710 "sparser.ml"
               : 'relational_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'relational_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'shift_expression) in
    Obj.repr(
# 1516 "sparser.mly"
                                               (
		mkBinary OpLte _1 _3 (get_pos 2)
	  )
# 3720 "sparser.ml"
               : 'relational_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'relational_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'shift_expression) in
    Obj.repr(
# 1519 "sparser.mly"
                                               (
		mkBinary OpGte _1 _3 (get_pos 2)
	  )
# 3730 "sparser.ml"
               : 'relational_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'additive_expression) in
    Obj.repr(
# 1525 "sparser.mly"
                        ( _1 )
# 3737 "sparser.ml"
               : 'shift_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'multiplicative_expression) in
    Obj.repr(
# 1529 "sparser.mly"
                              ( _1 )
# 3744 "sparser.ml"
               : 'additive_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'additive_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'multiplicative_expression) in
    Obj.repr(
# 1530 "sparser.mly"
                                                       (
	  mkBinary OpPlus _1 _3 (get_pos 2)
	)
# 3754 "sparser.ml"
               : 'additive_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'additive_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'multiplicative_expression) in
    Obj.repr(
# 1533 "sparser.mly"
                                                        (
	  mkBinary OpMinus _1 _3 (get_pos 2)
	)
# 3764 "sparser.ml"
               : 'additive_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'unary_expression) in
    Obj.repr(
# 1539 "sparser.mly"
                     ( _1 )
# 3771 "sparser.ml"
               : 'multiplicative_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'multiplicative_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'prefixed_unary_expression) in
    Obj.repr(
# 1540 "sparser.mly"
                                                             (
	  mkBinary OpMult _1 _3 (get_pos 2)
	)
# 3781 "sparser.ml"
               : 'multiplicative_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'multiplicative_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'prefixed_unary_expression) in
    Obj.repr(
# 1543 "sparser.mly"
                                                            (
	  mkBinary OpDiv _1 _3 (get_pos 2)
	)
# 3791 "sparser.ml"
               : 'multiplicative_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'multiplicative_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : 'prefixed_unary_expression) in
    Obj.repr(
# 1546 "sparser.mly"
                                                                (
	  mkBinary OpMod _1 _3 (get_pos 2)
	)
# 3801 "sparser.ml"
               : 'multiplicative_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'unary_expression) in
    Obj.repr(
# 1552 "sparser.mly"
                     ( _1 )
# 3808 "sparser.ml"
               : 'prefixed_unary_expression))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'prefixed_unary_expression) in
    Obj.repr(
# 1562 "sparser.mly"
                                     (
	  mkUnary OpPreInc _2 (get_pos 1)
	)
# 3817 "sparser.ml"
               : 'pre_increment_expression))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'prefixed_unary_expression) in
    Obj.repr(
# 1568 "sparser.mly"
                                     (
	  mkUnary OpPreDec _2 (get_pos 1)
	)
# 3826 "sparser.ml"
               : 'pre_decrement_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'primary_expression) in
    Obj.repr(
# 1574 "sparser.mly"
                              (
	  mkUnary OpPostInc _1 (get_pos 2)
	)
# 3835 "sparser.ml"
               : 'post_increment_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 1 : 'primary_expression) in
    Obj.repr(
# 1580 "sparser.mly"
                              (
	  mkUnary OpPostDec _1 (get_pos 2)
	)
# 3844 "sparser.ml"
               : 'post_decrement_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'unary_expression_not_plusminus) in
    Obj.repr(
# 1586 "sparser.mly"
                                   ( _1 )
# 3851 "sparser.ml"
               : 'unary_expression))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'unary_expression) in
    Obj.repr(
# 1587 "sparser.mly"
                          ( 
		let zero = IntLit { exp_int_lit_val = 0;
							exp_int_lit_pos = get_pos 1 }
		in
		  mkBinary OpPlus zero _2 (get_pos 1)
	  
	  )
# 3864 "sparser.ml"
               : 'unary_expression))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'unary_expression) in
    Obj.repr(
# 1594 "sparser.mly"
                           (
		let zero = IntLit { exp_int_lit_val = 0;
							exp_int_lit_pos = get_pos 1 }
		in
		  mkBinary OpMinus zero _2 (get_pos 1)
	  )
# 3876 "sparser.ml"
               : 'unary_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pre_increment_expression) in
    Obj.repr(
# 1600 "sparser.mly"
                             ( _1 )
# 3883 "sparser.ml"
               : 'unary_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'pre_decrement_expression) in
    Obj.repr(
# 1601 "sparser.mly"
                             ( _1 )
# 3890 "sparser.ml"
               : 'unary_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'postfix_expression) in
    Obj.repr(
# 1605 "sparser.mly"
                       ( _1 )
# 3897 "sparser.ml"
               : 'unary_expression_not_plusminus))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 0 : 'prefixed_unary_expression) in
    Obj.repr(
# 1606 "sparser.mly"
                                  (
		mkUnary OpNot _2 (get_pos 1)
	  )
# 3906 "sparser.ml"
               : 'unary_expression_not_plusminus))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'cast_expression) in
    Obj.repr(
# 1609 "sparser.mly"
                    ( _1 )
# 3913 "sparser.ml"
               : 'unary_expression_not_plusminus))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'primary_expression) in
    Obj.repr(
# 1613 "sparser.mly"
                       ( _1 )
# 3920 "sparser.ml"
               : 'postfix_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'post_increment_expression) in
    Obj.repr(
# 1614 "sparser.mly"
                              ( _1 )
# 3927 "sparser.ml"
               : 'postfix_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'post_decrement_expression) in
    Obj.repr(
# 1615 "sparser.mly"
                              ( _1)
# 3934 "sparser.ml"
               : 'postfix_expression))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 2 : 'expression) in
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'unary_expression_not_plusminus) in
    Obj.repr(
# 1619 "sparser.mly"
                                                            ( 
	  match _2 with
		| Var v -> Cast { exp_cast_target_type = Named v.exp_var_name; (*TODO: fix this *)
						  exp_cast_body = _4;
						  exp_cast_pos = get_pos 1 }
		| _ -> report_error (get_pos 2) ("Expecting a type")
	)
# 3948 "sparser.ml"
               : 'cast_expression))
; (fun __caml_parser_env ->
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'unary_expression) in
    Obj.repr(
# 1626 "sparser.mly"
                                       ( 
		Cast { exp_cast_target_type = Prim Int;
			   exp_cast_body = _4;
			   exp_cast_pos = get_pos 1 }
	  )
# 3959 "sparser.ml"
               : 'cast_expression))
; (fun __caml_parser_env ->
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'unary_expression) in
    Obj.repr(
# 1631 "sparser.mly"
                                        ( 
		Cast { exp_cast_target_type = Prim Bool;
			   exp_cast_body = _4;
			   exp_cast_pos = get_pos 1 }
	  )
# 3970 "sparser.ml"
               : 'cast_expression))
; (fun __caml_parser_env ->
    let _4 = (Parsing.peek_val __caml_parser_env 0 : 'unary_expression) in
    Obj.repr(
# 1636 "sparser.mly"
                                         ( 
		Cast { exp_cast_target_type = Prim Float;
			   exp_cast_body = _4;
			   exp_cast_pos = get_pos 1 }
	  )
# 3981 "sparser.ml"
               : 'cast_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : 'qualified_identifier) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_argument_list) in
    Obj.repr(
# 1644 "sparser.mly"
                                                         (
	  CallRecv { exp_call_recv_receiver = fst _1;
				 exp_call_recv_method = snd _1;
				 exp_call_recv_arguments = _3;
				 exp_call_recv_pos = get_pos 1 }
	)
# 3994 "sparser.ml"
               : 'invocation_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 3 : string) in
    let _3 = (Parsing.peek_val __caml_parser_env 1 : 'opt_argument_list) in
    Obj.repr(
# 1650 "sparser.mly"
                                               (
		CallNRecv { exp_call_nrecv_method = _1;
					exp_call_nrecv_arguments = _3;
					exp_call_nrecv_pos = get_pos 1 }
	  )
# 4006 "sparser.ml"
               : 'invocation_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'primary_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1658 "sparser.mly"
                                      ( (_1, _3) )
# 4014 "sparser.ml"
               : 'qualified_identifier))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 2 : 'primary_expression) in
    let _3 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1662 "sparser.mly"
                                      (
	Member { exp_member_base = _1;
			 exp_member_fields = [_3];
			 exp_member_pos = get_pos 3 }
  )
# 4026 "sparser.ml"
               : 'member_access))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'boolean_literal) in
    Obj.repr(
# 1670 "sparser.mly"
                    ( BoolLit { exp_bool_lit_val = _1;
								exp_bool_lit_pos = get_pos 1 } )
# 4034 "sparser.ml"
               : 'literal))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'integer_literal) in
    Obj.repr(
# 1672 "sparser.mly"
                    ( IntLit { exp_int_lit_val = _1;
							   exp_int_lit_pos = get_pos 1 } )
# 4042 "sparser.ml"
               : 'literal))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'real_literal) in
    Obj.repr(
# 1674 "sparser.mly"
                 ( FloatLit { exp_float_lit_val = _1;
							  exp_float_lit_pos = get_pos 1 } )
# 4050 "sparser.ml"
               : 'literal))
; (fun __caml_parser_env ->
    Obj.repr(
# 1676 "sparser.mly"
         ( Null (get_pos 1) )
# 4056 "sparser.ml"
               : 'literal))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : float) in
    Obj.repr(
# 1680 "sparser.mly"
                  ( _1 )
# 4063 "sparser.ml"
               : 'real_literal))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : int) in
    Obj.repr(
# 1684 "sparser.mly"
                    ( _1 )
# 4070 "sparser.ml"
               : 'integer_literal))
; (fun __caml_parser_env ->
    Obj.repr(
# 1688 "sparser.mly"
         ( true )
# 4076 "sparser.ml"
               : 'boolean_literal))
; (fun __caml_parser_env ->
    Obj.repr(
# 1689 "sparser.mly"
          ( false )
# 4082 "sparser.ml"
               : 'boolean_literal))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'parenthesized_expression) in
    Obj.repr(
# 1693 "sparser.mly"
                             ( _1 )
# 4089 "sparser.ml"
               : 'primary_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'primary_expression_no_parenthesis) in
    Obj.repr(
# 1694 "sparser.mly"
                                      ( _1 )
# 4096 "sparser.ml"
               : 'primary_expression))
; (fun __caml_parser_env ->
    let _2 = (Parsing.peek_val __caml_parser_env 1 : 'expression) in
    Obj.repr(
# 1698 "sparser.mly"
                             ( _2 )
# 4103 "sparser.ml"
               : 'parenthesized_expression))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'literal) in
    Obj.repr(
# 1702 "sparser.mly"
            ( _1 )
# 4110 "sparser.ml"
               : 'primary_expression_no_parenthesis))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'member_name) in
    Obj.repr(
# 1703 "sparser.mly"
                ( _1 )
# 4117 "sparser.ml"
               : 'primary_expression_no_parenthesis))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'member_access) in
    Obj.repr(
# 1704 "sparser.mly"
                  ( _1 )
# 4124 "sparser.ml"
               : 'primary_expression_no_parenthesis))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'invocation_expression) in
    Obj.repr(
# 1705 "sparser.mly"
                          ( _1 )
# 4131 "sparser.ml"
               : 'primary_expression_no_parenthesis))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : 'new_expression) in
    Obj.repr(
# 1706 "sparser.mly"
                   ( _1)
# 4138 "sparser.ml"
               : 'primary_expression_no_parenthesis))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1710 "sparser.mly"
               ( Var { exp_var_name = _1;
					   exp_var_pos = get_pos 1 } )
# 4146 "sparser.ml"
               : 'member_name))
; (fun __caml_parser_env ->
    let _1 = (Parsing.peek_val __caml_parser_env 0 : string) in
    Obj.repr(
# 1712 "sparser.mly"
         ( This ({exp_this_pos = get_pos 1}) )
# 4153 "sparser.ml"
               : 'member_name))
(* Entry program *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry data_decl *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry view_decl *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry coercion_decl *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry constr *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry command *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
(* Entry opt_command_list *)
; (fun __caml_parser_env -> raise (Parsing.YYexit (Parsing.peek_val __caml_parser_env 0)))
|]
let yytables =
  { Parsing.actions=yyact;
    Parsing.transl_const=yytransl_const;
    Parsing.transl_block=yytransl_block;
    Parsing.lhs=yylhs;
    Parsing.len=yylen;
    Parsing.defred=yydefred;
    Parsing.dgoto=yydgoto;
    Parsing.sindex=yysindex;
    Parsing.rindex=yyrindex;
    Parsing.gindex=yygindex;
    Parsing.tablesize=yytablesize;
    Parsing.table=yytable;
    Parsing.check=yycheck;
    Parsing.error_function=parse_error;
    Parsing.names_const=yynames_const;
    Parsing.names_block=yynames_block }
let program (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 1 lexfun lexbuf : prog_decl)
let data_decl (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 2 lexfun lexbuf : data_decl)
let view_decl (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 3 lexfun lexbuf : view_decl)
let coercion_decl (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 4 lexfun lexbuf : coercion_decl)
let constr (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 5 lexfun lexbuf : F.formula)
let command (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 6 lexfun lexbuf : command)
let opt_command_list (lexfun : Lexing.lexbuf -> token) (lexbuf : Lexing.lexbuf) =
   (Parsing.yyparse yytables 7 lexfun lexbuf : command list)
;;
