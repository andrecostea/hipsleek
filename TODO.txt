12Feb : run_fast_test.pl should detect False from
WN      xpure_heap_symbolic. This seems not to be
        captured by xpure_heap?


SLEEK:
------

Introduce variables:
  let <ident> = <formula>

Reserved variable names:
 residue := reserve for residue from entailment
 res : reserve for result (true/false)
 just add them to the normal variable map, redefine them every time

Experiments:
------------
- Finish the file manager
- Remove the redundant existential from XPure, re-run the benchmarks
- One more application!!! (HTTP Server: tree of documents)

Known issues in RTC:
-------------------
- predicate parameters with same name as object fields confuse has_partially_bound_field

TODO.txt
entailment with classes:
- matching: proceed normally
- unmatching class names (lhs name: c1, rhs name: c2)
  + if c1 <: c2 or c2 <: c1 : find the sequence of classes from
    c1 up to c2, inclusive of c1, c2. Generate all extensions
    needed and replace the view in the rhs (c1 <: c2) or view
    in lhs (c2 <: c1) with the sequence of extensions and let
    the entailment continue.

=======
Try some more example: process scheduler with priority queue?

1. Entailment tracing/proof generation/disproof generation


2. Error reporting:
-------------------
   - what information would I like to know when an assertion fails?
	 split the assertion to several parts and check if any of them fails?

	 What constraint fails? How is that constraint derived?


 - what kinds of errors?
   . too weak context
   . contradictory context

 - now let's deal with too weak context: what to be proven
   is like a subgoal.


tx::node<_,_> |- ex f84. f84::node<_,_> & f84=tx

start from f84, calculate aliases, where a=b can be used
if at least one of them is existential variable. 
  --- no ... ex ev1, ev2, ev3. ev1=ev2=ev3 & ev2=x & ev3=y
            --> x=y

What do I want to add in:
-------------------------
1. Coercion
   . coercion proofs
   . coercion applications

2. Error reporting
   . If an entailment fails, report why it fails

3. Reaching a node from multiple pointers

4. Field list: <field_name>=<exp> (just syntactic sugar)

5. Read TinyOS for examples (concurrency...)

6. Add description of these into the technical report

typechecker.ml:
- assignment, parameter passing, --> change to subtype check
- new/method call
- cast -> call?

>>>>>>> 1.45
- syntax:
  + class
  + array
  + exception

- revise field flattening: make it a sequence, not nested

Error checking:
---------------
- Command line option for converting variables to existential vars or
  report as errors




What if:
 + multiple coercion rules convert the same pair of views
 + 

------------------------------------------------------------
------------------------------------------------------------

Additions to cpure.ml:
 + Add BagIn and BagSub to b_formula
   BagIn (spec_var, exp, loc)
   BagSub (exp, exp, loc)

 + Add to exp:
   BagEmpty, Bag (exp, loc), 
   BagUnion (exp, exp, loc), BagIntersect (exp, exp, loc)
   BagDiff (exp, exp, loc)

 + modify functions like fv (free variables), subst, ...

Additions to astsimp.ml
 + collect_type_info to collqect set type information
 + trans_pure_formula, trans_pure_b_formula to use the
   collected type information to (mainly) create spec_var


------------------------------------------------------------
------------------------------------------------------------

debug double_left_child:
	  try xpure_symbolic


How should I verify avl insert with BST and AVL properties:





View invariants:

v1<n> == self=null & n=0
	or	 self::node<_, r> * r::v1<n-1> 
	inv	 ex i. self=0 & n=0 or self=i & i>0 & n>0

	inv	 ex i, j. self=0 & n=j & j=0 or self=i & i>0 & n=j & j>0


lseg<n, p> == self=p & n=0
		or	  self::node<_, r> * r::lseg<n-1, p> & self!=p
		inv	  ex i. self=p & n=0 or self=i & i>0 & n>0 & self!=p


Two lseg's can have the same p. But what if I provide an invariant
like this

ex i, j. self=p & p=j & n=0  or  self=i & i>0 & n>0 & self!=p & p=j


-- SAT checks

   + Conditional: perform SAT checks
   + Unfolding: perform SAT checks
   + After method call: perform SAT checks

   + field accesses: no SAT checks (except for those performed by unfolding)


   ** existing scheme: SAT checks are performed by heap_entail
	  - spurious SAT checks at field accesses (always check when there are more than one branch)

-- xpure for views: don't quantify symbolic addresses for data nodes,
   as they can be instantiated differently. Keeps them as variables,
   when combining xpure'd formulae arising from * connective, we need
   to assert that addresses coming from subformulae of * are different.

   But then the formula can hardly be simplified.

ll<n> = self=null & n=0
	  or self::node<_, r> * r::ll<n-1>
	  inv ex i. (self=null & n=0 or self=i & i>0 & n>0)

The trouble is there's nothing to prevent the user to write
	self=null & n=0 | self>0 & n>0

These two formulae are logically equivalent, hence the typechecker
is unable to detect the problem...


-- xpure and equisatisfiability

v<> == ex r. (self::node<_, r> * r::node<_, _>)

xpure(ex r. (self::node<_, r> * r::node<_, _>)) 
= ex r, i, j. self=i & i > 0 & r = j & j>0 & i<>j
= self>0


put back explicit bind

check if x::node<x> is linearized correctly


What are the possible base cases:
- self=null
- self=p
- self::data_node<...>

... |= x::view_node<...>


What could happen in the lhs?
- x is null (and at the same time could be pointing to some view node)

 --> fold

- x is pointing to a data node (can't be null)
 
 --> fold

- x is not null but not pointing to any data node nor view node

 --> fold



- x is pointing to a view (and can be null or not null at the same time)

  x::lseg<p> & x=p 

  When should I do a match, a folding?

  What to do if I have x::lseg<p, n> & x=p |= x::lseg<q, m> & x=q





what to do if in this scenario:

x::view<...> & x=null

x::view<...> 

choosing x=null gives more information...


trans_arg should use declared types instead of types inferred from
arguments to avoid problem with null (no data name is obtained)

what to do with bind in this statement?
x.next = x.next.next 


only ref variables are allowed to have primed versions in postcondition

check loops, nested loops

no primed variable is allowed in precondition and view definition

simplification of pure formulae to be used in folding (just call Omega, but then
all variables loose their type (get converted to int_type))

re-introduced the mapped formula

can alias sets be generated incrementally? Note that if we make variables nodes
and equalities edges, alias sets are just connnected components of the (undirected)
graph thus formed.

exceptions:

  {D} e1 {D1}
  {D1/\flow=normal} e2 {D2}
  D1esc = D1 /\ not(flow=normal)
   -----------------------------
  {D} e1;e2 {D2 \/ D1esc}

  type(v)=c
  D |= v::c<...> * D1
  D2 = D1 * exc::c<...>
  ------------------------------
  {D} raise v { D2 /\ flow=raised}

  {D} e1 {D1}
  D1/\flow=raised |= exc::c<...> * D2
  {D2 * v::c<...>} |= e2 {D3}
  D1esc = D1/\flow=normal
   -------------------------------
  {D} try e1 catch (c v) e2 {D1esc \/ D3}
  

exception(c)
D1 |= v::c<...> * D
D_lbl = D * excptn::c<...>
-----------------------------
|- { D1 } lbl:throw v { false }

excptn is a reserved identifier (like res or self).
lbl is a unique lable for this throw statement.

exception(c)
D_li |= excptn::c<...> * D1
|- { D1 * w::c<...> } e { D'_li }
D = \/ D'_li    forall li
--------------------------------------
|- catch (c w) in e [{l1, l2,... ,ln}] { D }


Exceptions are may-information.

int f() requires true ensures res>0 or excptn::e1<>



l1, l2,... ,ln are program point thrown exceptions may be caught by this catch block.
Some exception analysis computes this.


- nested loops???
- Associate a list of local variables with each block so that they can be
  quantified away upon exit from the block.
  This list of variables are all the variables from the top scope.

sanity checks:

- uniqueness of method names, view names, data names
- self can only appear in view definitions
- res can only appear in method with non-void return type



Why did I split pure pointer constraints and arithmetic constraint in pure constraints?

What if I merge them . Nothing wrong can happen, right?

What do I have to do with pure pointer terms?
 - aliasing
 - equalities for existential quantifier elimination
 --> both of these can be done uniformly for pure pointer and arithmetic constraints

Do I ever really need to distinguish them?
If I merge them, the alias sets may get bigger. Can be solved if I know the variable types.
Then I need to maintain the variable types somewhere... by modifying the Ipure formulae so that
variables are associated with types... the trouble is during parsing, types are not known



- null in binary operators
  + check if the operands is null, if so use is_null, non_null instead of eq, neq

- type checking for binary operators

- Multiple assignment doens't work yet.

- haven't checked that procedure names are unique (modulo overloading)



----------------
if no alias node is found then
   if data then fail
   else fold (against a base case of the view)
else
   if two aliased nodes have same name then match
   else unfold/fold


if no alias node & data on lhs then fail
else if view
