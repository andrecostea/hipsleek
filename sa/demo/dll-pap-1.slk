data node{
	node next;
	node prev;
}.


PostPred G(node a,node b).
HeapPred H(node a,node b).
HeapPred HP_9(node a,node@NI b).
HeapPred HP_0(node a,node@NI b).
HeapPred HP_1(node a,node@NI b).
HeapPred HP_2(node a,node@NI b).
HeapPred HP_3(node a,node@NI b).

Declare_Unknown [HP_2].
Declare_Unknown [HP_3].
Declare_Unknown [HP_0].

relAssume H
  H(x,y)&true --> x::node<next_15_797,prev_15_798>@M * 
  HP_9(next_15_797,y) * HP_0(prev_15_798,y) * HP_1(y,x).

relAssume H
 HP_9(next_15_797,y) * HP_1(y,x)&
  next_15_797!=null --> H(next_15_797,y).

relAssume HP_1
 HP_1(y,x) --> y::node<next_21_820,prev_21_821>@M * 
  HP_2(next_21_820,x) * HP_3(prev_21_821,x).

shape_infer [H,HP_1,HP_9][].

/*

[ H(x_81,y_82) ::=  y_82::node<next_21_820,prev_21_821>@M * 
    HP_2(next_21_820,x_81) *  HP_3(prev_21_821,x_81) 
   * x_81::node<next_15_62,prev_15_63>@M * HP_9(next_15_62,y_82) 
   * HP_0(prev_15_63,y_82)&true, 
   // refrain from unrolling HP_9 & HP_1 unless strictly needed

 HP_1(y_83,x_84) ::=  y_83::node<next_21_820,prev_21_821>@M 
    * HP_2(next_21_820,x_84) * HP_3(prev_21_821,x_84)&true,

 HP_9(next_15_70,y_68) ::=  y_68::node<next_21_820,prev_21_821>@M * HP_2(next_21_820,next_15_70) * HP_3(prev_21_821,next_15_70) 
 * next_15_70::node<next_15_66,prev_15_67>@M 
 * HP_9(next_15_66,y_68) * HP_0(prev_15_67,y_68)&true, 
   // HP_9 is wrong...

 HP_2(a,b) ::= NONE,
 HP_3(a,b) ::= NONE,
 HP_0(a,b) ::= NONE]

POSSIBLE ALGORITM
=================

Confirm Equality:
  H(x,y)&true <--> x::node<next_15_797,prev_15_798>@M * 
      HP_9(next_15_797,y) * HP_0(prev_15_798,y) * HP_1(y,x).
  HP_1(y,x) <--> y::node<next_21_820,prev_21_821>@M * 
     HP_2(next_21_820,x) * HP_3(prev_21_821,x).

Trasform HP_9 with complex LHS
  HP_9(n,y) * HP_1(y,x)&
    n!=null --> H(n,y).
  //replace H(..)
  HP_9(n,y) * HP_1(y,x) & n!=null --> 
     n::node<next_15_797,prev_15_798>@M * 
      HP_9(next_15_797,y) * HP_0(prev_15_798,y) * HP_1(y,n).
  Drop HP_1(y,_) on both sides assummig that parameter is useless on x.
  //abstract commom HP_1(..)
  // this can be confirmed by the definition of HP_1 itself
  // where x is not accessed
  HP_9(n,y) & n!=null --> 
     n::node<nexts_15_797,prev_15_798>@M * 
      HP_9(next_15_797,y) * HP_0(prev_15_798,y).
  // add missing base-case (missed by post-cond proving)
  HP_9(n,y) & n=null --> emp
  // Can now transform HP_9 into ll list.
--------
relAssume G
 HP_0(prev_15_798,y) * x::node<next_15_797,prev_15_798>@M * 
  G(next_15_797,y)&next_15_797!=null --> G(x,y).

relAssume G
 HP_0(prev_15_798,y) * x::node<y,prev_15_798>@M * 
  HP_2(next_21_820,x) * y::node<next_21_820,x>@M&true --> G(x,y).

*/
