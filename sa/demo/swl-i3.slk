data node{
	int val;
	node next;
}.


HeapPred H(node a, node b, node@NI c).
HeapPred H_3(node prev, node@NI cur, node@NI sent).
HeapPred H_2(node next_1, node@NI prev, node@NI sent).
HeapPred G(node a, node ra, node b, node rb, node@NI c).

/*
relAssume
 (1;2;0)H_3(prev,cur,sent) * cur::node<val_0,prev>@M&
  cur_920=null & next_1=null & cur=cur_909 & cur_920=next_1 & 
  cur'=cur_909 & prev'=null --> H(cur',prev',sent).
*/

relAssume
 (0)H(cur,prev,sent) --> cur::node<val_0,next_1>@M * 
  H_2(next_1,prev,sent) * H_3(prev,cur,sent).

relAssume
 (2;2;0)H_2(next_1,prev,sent) * H_3(prev,cur,sent) * 
  cur::node<val_0,prev>@M&cur=cur_909 & cur'=next_1 & cur'!=sent & 
  cur'!=null --> H(cur',cur_909,sent).

relAssume (1;0)
   H_2(cur',prev,sent) & cur'=sent --> emp.

shape_infer [H,H_1,H_2][].

/*
# swl-i3.slk --pred-en-oblg

GOT
!!!  synthesize: [H_2]
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!! >>>>>> step 3a: simplification <<<<<<
!!!  synthesize: [H]
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!! >>>>>> step 3a: simplification <<<<<<
!!! pre-obligation:
[ H_2(next_53,prev_52,sent_54) * cur_50::node<val_51,prev_52>@M&
  next_53!=null & next_53!=sent_54 --> next_53::node<val_0,next_1>@M * 
  H_2(next_1,cur_50,sent_54)]

Two problems:
 (i)  H_2 must be scheduled after pre-obligation 
 (ii) view not properly formed:
!!! >>>>>> post-predicates: step post-61: weaken<<<<<<
ERROR: at _0:0_0:0 
Message: self of H_2 cannot have its type determined
 Fatal error: exception Failure("self of H_2 cannot have its type determined")


-----------------------

HeapPred H(node a, node b, node@NI c).
HeapPred H_3(node prev, node@NI cur, node@NI sent).
HeapPred H_2(node next_1, node@NI prev, node@NI sent).
HeapPred G(node a, node ra, node b, node rb, node@NI c).



-----------

 (0)H(cur,prev,sent) --> cur::node<val_0,next_1>@M * 
  H_2(next_1,prev,sent) * H_3(prev,cur,sent).

 (1;2;0)H_3(prev,cur,sent) * cur::node<val_0,prev>@M&
  cur_920=null & next_1=null & cur=cur_909 & cur_920=next_1 & 
  cur'=cur_909 & prev'=null --> H(cur',prev',sent).

 (2;2;0)H_2(next_1,prev,sent) * H_3(prev,cur,sent) * 
  cur::node<val_0,prev>@M&cur=cur_909 & cur'=next_1 & cur'!=sent & 
  cur'!=null --> H(cur',cur_909,sent).

 (1;0)H_2(next_1,prev,sent) * H_3(prev,cur,sent) * 
  cur::node<val_0,prev>@M&cur=prev' & cur'=next_1 & 
  cur'=sent --> G(cur,cur',prev,prev',sent).

 (1;0)H_2(next_1,prev,sent) * H_3(prev,cur,sent) * 
  cur::node<val_0,prev>@M&cur=prev' & cur'=next_1 & 
  cur'=sent --> G(cur,cur',prev,prev',sent).

 (1;2;0)H_2(next_1,prev,sent) * 
  G(prev_921,cur',prev_933,prev',sent)&cur=prev_921 & next_1!=sent & 
  prev_933=null & next_1=null --> G(cur,cur',prev,prev',sent).

 (2;2;0)G(next_1,cur',cur,prev',sent)&next_1!=sent & 
  next_1!=null --> G(cur,cur',prev,prev',sent).




*/



