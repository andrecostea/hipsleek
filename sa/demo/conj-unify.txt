

     H(vs) & p1 --> D1
     H(vs) & p2 --> D2
     p1/\p2!=false
 ---------------------------------------
  H(vs) & p1 & not(p2) --> D1
  H(vs) & p2 & not(p1) --> D1
  H(vs) & p1 & p2 --> conj-unify[vs](D1,D2)


     H(vs) & p1 --> D1
     H(vs) & p1 --> D2
 ---------------------------------------
  H(vs) & p1 --> conj-unify[vs](D1,D2)

==================================================


 conj-unify[vs](pure,D) --> D & pure

 conj-unify[vs](D,pure) --> D & pure


      x in vs
    \rho = [ys->xs]
 conj_unify[vs+xs](D1,\rho D2) --> D3
---------------------------------------------------------
conj-unify[vs](x::P(xs)*D1,x::P(ys)*D2) --> x::P(xs)*D3


   conj_unify[vs](D1,D3) --> D4
   conj_unify[vs](D2,D4) --> D6
--------------------------------------------------
conj-unify[vs](D1 or D2, D3 or D4) --> D4 or D6

=============================================================

// post-pred

 ex1 = vars(p1)-vs
 ex2 = vars(p2)-vs
 exists ex1. p1 <-> exists ex2.p2
-----------------------------------
 equiv-unify[vs](p1, p2) --> p1


 equiv-unify[vs](pure,D) --> fail

 equiv-unify[vs](D,pure) --> fail

      x in vs
    \rho = [ys->xs]
 equiv_unify[vs+xs](D1,\rho D2) --> D3
---------------------------------------------------------
equiv-unify[vs](x::P(xs)*D1,x::P(ys)*D2) --> x::P(xs)*D3


 equiv-unify[vs](D1,D2) ---> D3
---------------------------------
        D1 or D2 ---> D3


  equiv-unify[x,b](x::node<a2,b>,x::node<a1,b>) 
     ==> x::node<a1,b>
-----------------------------------------
       x::node<a2,b>
    or x::node<a1,b>  ==> x::node<a1,b>

