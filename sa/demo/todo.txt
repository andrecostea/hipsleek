# dll-append3.ss

fails during assumption collection, does not infer l2::node ....
!!! >>>>>> mismatch ptr is not found (or inst) in the lhs <<<<<<
( [(,1 ); (,1 )]) :dll-append3.ss:22: 3: bind: node  l2'::node<next_22_776',prev_22_777'>@M[Orig] cannot be derived from context
 

# dll-app-bug3.ss  (WN : FIXED, I think)

  should not allow me to prove false, seems like a substitution problem


# dll-app-bug2.slk

relAssume G3
 l1::node<l2,p> * HP_844(n3,l1) * HP_845(p,l1) * l2::node<n3,l1> --> G3(l1,l2).
 
shape_infer [HP_844,HP_845][G3].

/*
# dll-app-bug2.slk

The input is circular but
WHY is there an exception??

ERROR: at _0:0_0:0 
Message: sau.find_root_x: dont have a root. what next?
 Fatal error: exception Failure("sau.find_root_x: dont have a root. what next?")
*/

# app.ss: FIXED

Problem with hip invoking shape_infer...

[ H1(c,y)&true --> c::node<val_16_787,next_16_788>@M * 
  (HP_789(next_16_788,y))&true,
 HP_789(next_16_788,y)&next_16_788!=null --> H1(next_16_788,y)&true,
 c::node<val_16_787,next_16_788>@M * (G1(next_16_788,y))&
  next_16_788!=null --> G1(c,y)&true,
 (HP_789(next_16_788,y)) * c::node<val_16_787,y>@M&
  next_16_788=null --> G1(c,y)&true]

Dangling predicate derived is wrong...

[ H1(c_836,y_837) ::= c_836::node<val_16_787,next_16_788>@M
    & XPURE(HP_789(next_16_788,y_837)),
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 G1(c_838,y_839) ::= c_838::node<val_16_787,y_840>@M * (HP_841(y_840,y_839))&true,
 HP_841(y_840,y_839) ::= 
 emp& XPURE(HP_789(next_16_788,y_839)) & y_839=y_840 & next_16_788=null
 or y_840::node<val_16_787,y_842>@M * (HP_841(y_842,y_839))&true
 ]

However, app.slk is OK it produced the correct result.
How come hip did not invoke shape_infer correctly?


[ H1(c_87,y_88) ::= c_87::node<val_16_751',next_16_752'>@M * (HP_4(next_16_752',y_88))&true,
 HP_4(next_16_89,y_90) ::= 
 emp&next_16_89=null
 or next_16_89::node<val_16_751',next_16_752'>@M * (HP_4(next_16_752',y_90))&
    true
 ,
 G1(c_91,y_92) ::= c_91::node<Anon_11,t>@M * (HP_93(t,y_92))&true,
 HP_93(t,y_92) ::= 
 emp&t=y_92
 or t::node<Anon_11,t_94>@M * (HP_93(t_94,y_92))&true
 ]

===================================================================
# sll-dll-bug2.slk: FIXED

infer [H1,HP_2,HP_3,G1]
 HP_2(pp,p) * HP_3(nn,p) * c::node<_,p,nn>@M 
  |-  H1(nn,c).

print residue.
/*
GOT:
====
 <1>emp&true&{FLOW,(19,20)=__norm}[]
 inferred hprel: [(HP_2(pp,p)) * (HP_3(nn,p)) * c::node<Anon_11,p,nn>@M&
                   true --> H1(nn,c)&true]
Expecting:
==========
   HP_3(nn,p) --> H1(nn,c)
   residue: HP_2(pp,p) * c::node<_,p,nn>@M


=====================================================================
# tree.slk

(H is both pre and post: not supported yet)
/* 

Why got two definitions for H?
Got: 
[ H(x) ::= x::node<l,r>@M& XPURE(HP_2(r)) &  XPURE(HP_1(l)),
 H(l_48) ::= l_48::node<l,r>@M * (H(l)) * (H(r))&true]


Expecting: [ H(x_119) ::= 
 emp&x_119=null
 or (H(r_63)) * (H(l_62)) * x_119::node<l_62,r_63>@M&true ]

*/


=====================================================================
# dll-append2.slk


 /* error during shape inference
 
 !!! >>>>>> pre-predicates: step pre-6: combine<<<<<<Fatal error: exception Failure("tl")

*/

similarly obtained for dll-append and dll_append2 and simpl-tree-trav




=====================================================================
# tll.ss

Why got two definitions for G?

got: 
[ H(x_980,r_981) ::= x_980::node<l,r,n>@M * HP_849(r,r_981)


 G(r,rr,l_47') ::=  H(l,l_47') & r!=null
 or HP_849(r,l_47') & r!=null
 
 G(x_984,r_985,res_986) ::= x_984::node<l,r,r_987> * HP_988(l,r,r_987,r_985,res_986)


 HP_849(r2,r_983) ::=  emp&r2=null
 or r2::node<l,r,n>@M * HP_849(r,r_983) & r!=null



 HP_988(l,r,r_987,r_995,res_986) ::= emp & r=null
 or l::node<l1,r2,r_991>@M * HP_988(l1,r2,r_991,l_879,res_986) & r!=null ]

=========================================================================
# sll-dll.ss FIXED (test with hip/ll-append10.ss)

GOT
===
[ H1(c,p)&c!=null --> c::node<val_20_807,prev_20_808,next_20_809>@M * 
  (HP_810(prev_20_808,p)) * (HP_811(next_20_809,p))&true,

 HP_811(next_20_809,p)&true --> H1(next_20_809,c')&true,

 (HP_810(prev_20_808,p)) * c::node<val_20_807,p,next_20_809>@M * 
  (G1(next_20_809,c))&true --> G1(c,p)&true,

 H1(c,p)& XPURE(H1(c,p)) & c=null --> G1(c,p)&true]
         ^^^^^^^^^^^^^^^
EXPECT:
=======
 H1(c,p)&c!=null --> c::node<val_21_809,prev_21_810,next_21_811>@M * 
  HP_2(prev_21_810,p) * HP_3(next_21_811,p)&true.
relAssume H1
 HP_3(next_20_809,p)&true --> H1(next_20_809,c')&true.
relAssume G1
 HP_2(prev_20_808,p) * c::node<val_20_807,p,next_20_809>@M * 
  G1(next_20_809,c)&true --> G1(c,p).
relAssume G1
 H1(c,p) & c=null --> G1(c,p).

--en-sleek-logging-txt

 checkentail H1(c,p)&c=null & !(v_bool_18_784') & c=null & !(v_bool_18_784')&
{FLOW,(22,23)=__norm}[]
 |-  G1(c,p)&true&{FLOW,(22,23)=__norm}[]. 
hprel_ass: [ H1(c,p)& XPURE(H1(c,p)) & c=null --> G1(c,p)&true]
                      ^^^^^^^^^^^^^^
res:  [
  emp&c=null & !(v_bool_18_784') & c=null & !(v_bool_18_784')&{FLOW,(22,23)=__norm}[]
  ]

This problem seems to be caused in "hip" as I was not
able to reproduce the same bug in sll-dll-bug3.slk.

FINAL expected:
===============
 HP_3(next_20_93,p_94) ::= H1(next_20_93,c')&true,
 H1(c_95,p_97) ::= 
 emp&c_95=null
 or (H1(next_21_54,c')) * c_95::node<val_21_52,prev_21_53,next_21_54>@M&
     XPURE(HP_2(prev_21_53,p_96))
 ,
 G1(c_98,p_99) ::= 
 emp&c_98=null
 or c_98::node<val_20_807,p_99,next_20_809>@M * (G1(next_20_809,c_98))&
     XPURE(HP_2(prev_20_808,p_99))
 ]

--sa-inlining

[ HP_3(next_20_93,p_94) ::= H1(next_20_93,c')&true,
 H1(c_95,p_97) ::= 
 (H1(next_21_54,c')) * c_95::node<val_21_52,UU_HP_2_UU,next_21_54>@M&true
 or emp&c_95=null
 ,
 G1(c_98,p_99) ::= 
 c_98::node<val_20_807,p_99,next_20_809>@M * (G1(next_20_809,c_98))&true
 or emp&c_98=null
 ]


=========================================================================
# tree.ss FIXED (test with hip/ll-append10.ss)

infer [H,G] requires H(x) ensures G(x);

PROBLEM with spurious XPURE
---------------------------
[ H(x)&x!=null --> x::node<left_24_795,right_24_796>@M * 
  (HP_797(left_24_795)) * (HP_798(right_24_796))&true,
 HP_797(left_24_795)&true --> H(left_24_795)&true,
 HP_798(right_24_796)&true --> H(right_24_796)&true,
 H(x)& XPURE(H(x)) & x=null --> G(x)&true,
       ^^^^^^^^^^^
 x::node<left_24_795,right_24_796>@M * (G(left_24_795)) * (G(right_24_796))&
  true --> G(x)&true]

=========================================================================
# pair-bug2.slk: FIXED

HeapPred G1(cell a, cell b).

infer [G1] x::cell<a> * y::cell<b> |-  G1(x,y). 
print residue.
/*
<1>y::cell<b>@M[Orig]&true&{FLOW,(19,20)=__norm}[]
 inferred hprel: [x::cell<a>@M&true --> G1(x,y)&true]

which seems to have lost y::cell<a>. I suppose, we may need to
try capture both sets of links from x,y for folding; so that we
will have:

 x::cell<a>@M * y::cell<b> --> G1(x,y)&true]

We probably can try to traverse separately, each parameter
that can be instantiated. Thus, for post-pred, we also determine
the parameters that can be instantiated to pick set of heap state
from that parameter.

For non-instantiation annotation, I suggest:

 HeapPred G1(cell@NI a, cell b).
 HeapPred G1(cell a, cell@NI b).

============================================================
# zip-bug2.slk  FIXED


pred ltwo<p:node> == 
   p::node<_,null> & self = null  or 
   self::node<_, q> * p::node<_,r> * q::ltwo<r>.

/*
  why isn't p a materialized var?
  materialized vars: 
  addr vars: 
*/


checkentail 
 x::ltwo<y>
 & x=null 
 |-  y::ll<>.
print residue.

/*
 why did the above fail? why didn't
 we unfold x::ltwo<y>? when we detect some materialized var?
*/

============================================================
# zip.ss FIXED

weird bug here..

 id: 10; caller: []; line: 22; classic: false; kind: POST; hec_num: 4; evars: []; infer_vars: []; c_heap: y_820::ll@M[1][Orig]
 checkentail emp&x=null & y=y_820 & x=null & v_bool_24_800' & x=null & v_bool_24_800' & 
v_null_24_781'=null & res=v_null_24_781'&{FLOW,(22,23)=__norm}[]
 |-  emp&res=x&{FLOW,(22,23)=__norm}[]. 
res:  failctx
         fe_kind: MAY
         fe_name: logical bug
         fe_locs: {
                   fc_message: failed in entailing pure formula(s) in conseq
                   fc_current_lhs_flow: {FLOW,(22,23)=__norm}}

============================================================
# zip-bug1c.slk FIXED

checkentail  x=null & res=null
 |-  res=x. 

/*
 above currently fails due to our translation:
    x=null --> x<=0
 I guess the solution to this problem is to explicitly
 add x=res is to collect the set of vars {x,res} which are
 v=null and then to explicitly add their equality
 using x=res on the LHS.

 For example, if we have:
 x=null & res=null & y=null
 |-  x=y. 

 We should transform antecedent to:
 x=null & res=null & y=null & x=res & res=y
 and then prove:

 x=null & res=null & y=null & x=res & res=y
 |- x=y


*/

============================================================
# dll-app-bug1d.slk: FIXED

infer [HP_7] // (1)
HP_7(x,l2) & x!=null |-  x::node<_,_>@M.
print residue.
// should fail
/*
GOT:
 <1>(HP_28(Anon_26,l2)) * (HP_29(Anon_27,l2))&x!=null & Anon_11=Anon_26 & Anon_1
2=Anon_27&{FLOW,(19,20)=__norm}[]
 inferred hprel: [HP_7(x,l2)&x!=null --> x::node<Anon_26,Anon_27>@M * 
                   (HP_28(Anon_26,l2)) * (HP_29(Anon_27,l2))&true]

but should FAIL since x is @NI (non-instantiating)
*/

infer [HP_7] //(2)
HP_7(x,l2) & x!=null |-  l2::node<_,_>@M.
print residue.
// should succeed
// HP_7(x,l2) --> l2::node<p,q>*HP_10(p,x#)*HP_11(q,x#)
/*
GOT:
====
 <1>(HP_39(Anon_37,x)) * (HP_40(Anon_38,x))&x!=null & Anon_13=Anon_37 & Anon_14=Anon_38&{FLOW,(19,20)=__norm}[]
 inferred hprel: [HP_7(x,l2)&x!=null --> (HP_39(Anon_37,x)) * 
                   (HP_40(Anon_38,x))&true]
BUI instantiation is WRONG. Should have been:
 HP_7(x,l2) & x!=null --> l2::node<p,q>*HP_10(p,x#)*HP_11(q,x#)

*/

============================================================
# dll-app-bug1d1.slk: FIXED

HeapPred HP_9(node a,node b).

infer [HP_9] //(3)
HP_9(x,l2) & x!=null |-  l2::node<_,_>@M.
print residue.
// should succeed
/*
GOT:
 inferred hprel: [HP_9(x,l2)&x!=null --> l2::node<Anon_24,Anon_25>@M * 
                   (HP_26(Anon_24,x)) * (HP_27(Anon_25,x))&true]

EXPECTING:

 HP_9(x,l2)  & x!=null
  --> l2::node<p,q>*HP_10(p,x@NI)*HP_11(q,x@NI)*HP_12(x,l2@NI)

Please use the above instead of:
 HP_9(x,l2)  & x!=null
  --> l2::node<p,q>*HP_10(p,x)*HP_11(q,x)*HP_12(x,l2)

*/

============================================================
# dll-app-bug1d2.slk: FIXED
HeapPred HP_7(node@NI a,node b).

infer [HP_7] //(2)
HP_7(x,l2) & x!=null |-  l2::node<_,_>@M.
print residue.
// should succeed

/*

GOT:
====
 inferred hprel: [HP_7(x,l2)&x!=null --> l2::node<Anon_22,Anon_23>@M * 
                   (HP_24(Anon_22,x)) * (HP_25(Anon_23,x))&true]

Can you print it as:

 HP_7(x@NI,l2)&x!=null --> l2::node<Anon_22,Anon_23>@M * 
         HP_24(Anon_22,x@NI) * HP_25(Anon_23,x@NI)

*/
============================================================
# pair2-bug1.slk  FIXED

HeapPred H1(cell a, cell b).

infer [H1] H1(x,y) |- x::cell<a>.
print residue.

/*


GOT
===
 <1>emp&a=a_18&{FLOW,(19,20)=__norm}[]
 inferred hprel: [H1(x,y)&true --> x::cell<a_18>@M&true]

SHOULD BE
=========
 H1(x,y)&true --> x::cell<a_18>@M * HP_2(y,x@NI)

*/

============================================================
# pair2.ss FIXED


[ H1(x,y)&true --> x::cell<val_20_783>@M * (HP_784(y,x))&true,
 HP_784(y,x)&true --> y::cell<val_21_788>@M&true,
 x::cell<val_20_783>@M * y::cell<val_21_788>@M&true --> G1(x,y)&true]

GOT
 H1(x_828,y_829) ::= y_829::cell<val_21_788>@M&true,
 G1(x_832,y_833) ::= x_832::cell<val_20_783>@M * y_833::cell<val_21_788>@M&true]

EXPECTING:
 H1(x_828,y_829) ::= 
   x::cell<val_20_783>@M * y_829::cell<val_21_788>@M&true,
 G1(x_832,y_833) ::= x_832::cell<val_20_783>@M * y_833::cell<val_21_788>@M&t
*/


============================================================
# pair2-bug2.slk FIXED

relAssume H1
 H1(x,y) --> x::cell<val_20_783> * HP_4(y,x).
relAssume HP_4
 HP_4(y,x) --> y::cell<val_21_788> .
relAssume G1
 x::cell<val_20_783> * y::cell<val_21_788> --> G1(x,y).
shape_infer [H1,HP_4][G1].

GOT
===
[ H1(x_64,y_65) ::= y_65::cell<val_21_788>@M&true,
 HP_4(y_66,x_67) ::= y_66::cell<val_21_788>@M&true,
 G1(x_68,y_69) ::= x_68::cell<val_20_783>@M * y_69::cell<val_21_788>@M&true]

WRONG H1 defn:
===============
Missing:
 H1(x_64,y_65) ::= x::cell<val_20_783> * y_65::cell<val_21_788>@M&true,


Steps
=====
Confirm HP_4 as an equation:
 HP_4(y,x) --> y::cell<val_21_788> .
to:
 HP_4(y,x) <--> y::cell<val_21_788> .

Strengthen consequent of H1:
 H1(x,y) --> x::cell<val_20_783> * y::cell<val_21_788>

Confirm H1 as an equation:
 H1(x,y) <--> x::cell<val_20_783> * y::cell<val_21_788>

Confirm G1 as an equation:
 x::cell<val_20_783> * y::cell<val_21_788> <--> G1(x,y).


*/

infer [HP_7] //(2)
HP_7(x,l2) & x=null |-  x::node<_,_>@M.
print residue.
// should succeed

/*

============================================================
# dll-app-bug1d3.slk    FIXED (by Cristian)

GOT
==
 <1>(HP_24(Anon_22,l2)) * (HP_25(Anon_23,l2)) * (HP_26(l2,x))&x=null & Anon_11=Anon_22 & Anon_12=Anon_23&{FLOW,(19,20)=__norm}[]
 inferred hprel: [HP_7(x,l2)&x=null --> x::node<Anon_22,Anon_23>@M * 
                   (HP_24(Anon_22,l2@NI)) * (HP_25(Anon_23,l2@NI)) * 
                   (HP_26(l2,x@NI))&true]

Should have been a contradiction lemma of the form instead.
It was working before.

  HP_7(x,l) --> x!=null

============================================================
#foo.ss: FIXED

GOT:
  H(x)&true --> x::node<val_19_788,next_19_789>@M * (HP_790(next_19_789))&true,
 HP_790(next_19_789)&next_19_789!=null --> H(next_19_789)&true,
 x::node<val_19_788,v_node_20_807>@M&true --> G(x)&true,
 (HP_790(next_19_789)) * x::node<val_19_788,next_19_789>@M&
  next_19_789=null --> G(x)&true]

EXPECTED:

  H(x)&true --> x::node<val_19_788,next_19_789>@M * (HP_790(next_19_789))&true,
 HP_790(next_19_789)&next_19_789!=null --> H(next_19_789)&true,
 x::node<val_19_788,v_node_20_807>@M * G(v_node_20_807) &true --> G(x)&true,
                                       ^^^^^^^^^^^^^^^^
 (HP_790(next_19_789)) * x::node<val_19_788,next_19_789>@M&
  next_19_789=null --> G(x)&true]

When G has two parameters:
===========================
[ H(x)&true --> x::node<val_22_792,next_22_793>@M * (HP_794(next_22_793))&true,
 HP_794(next_22_793)&next_22_793!=null --> H(next_22_793)&true,
 (G(next_22_793,r_812)) * x::node<val_22_792,next_22_793>@M&
  next_22_793!=null --> G(x,r_814)&true,
 (HP_794(next_22_793)) * x::node<val_22_792,next_22_793>@M&
  next_22_793=null --> G(x,r_815)&true]

============================================================
#zip-bug4.slk


============================================================
# zip-1.ss

going into a LOOP!

!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!! >>>>>> step 3a: simplification <<<<<<
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!! >>>>>> step 3a: simplification <<<<<<
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!! >>>>>> step 3a: simplification <<<<<<
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!! >>>>>> step 3a: simplification <<<<<<
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<^C
l

============================================================
# foo.slk: FIXED

  Need to include res=x below!
*/

infer [G] G(next_22_793,r_812) * x::node<val_22_792,next_22_793>&
next_22_793!=null 
//& v_bool_22_771' & next_22_793!=null & v_bool_22_771' 
//& next_22_793=next_22_793 
& res=x
 |-  G(x,r). 
print residue.
/*
 <1>emp&next_22_793!=null & res=x & r=r_24&{FLOW,(19,20)=__norm}[]
 inferred hprel: [(G(next_22_793,r_812)) * x::node<val_22_792,next_22_793>@M&
                   next_22_793!=null --> G(x,r_24)&true]
*/



infer [G,H4] H4(next_22_793) * x::node<val_22_792,next_22_793> &
next_22_793=null 
//& !(v_bool_22_771') & next_22_793=null & !(v_bool_22_771') 
& res=x
 |-  G(x,r). 

print residue.
/*
 <1>emp&next_22_793=null & res=x & r=r_34&{FLOW,(19,20)=__norm}[]
 inferred hprel: [(H4(next_22_793)) * x::node<val_22_792,next_22_793>@M&
                   next_22_793=null --> G(x,r_34)&true]
*/

===============================================================
# zip.ss

Problems, 
 (i) why ins't @NI printing?
 (ii) Why did we have:
            H1(x,y) x=null?


[ H1(x,y)&x!=null --> x::node<val_24_819,next_24_820>@M * 
  (HP_821(next_24_820,y)) * (HP_822(y,x))&true,
 (HP_821(next_24_820,y)) * (HP_822(y,x))&
  true --> y::node<val_25_826,next_25_827>@M * (HP_828(next_25_827,x))&true,
 HP_828(next_25_827,x)&true --> H1(next_24_820,next_25_827)&true,
 H1(x,y)&x=null & res=null --> G1(x,y,res)&true,
 y::node<val_25_826,next_25_827>@M * x::node<val_24_819,next_24_820>@M&
  res=x --> G1(x,y,res)&true]

======>

[ H1(x_1059,y_1060) ::= emp&x_1059=null,
 G1(x_1061,y_1062,res_1063) ::= 
 emp&res_1063=null & x_1061=null
 or y_1062::node<val_25_826,next_25_827>@M * 
    x_1061::node<val_24_819,next_24_820>@M&res_1063=x_1061
 ]


*/

===============================================================
# zip-bug5.slk: FIXED

infer [HP_1,HP_2] HP_1(next_24_820,y) * HP_2(y,x) * 
x::node<val_24_819,next_24_820> 
& x!=null 
 |-  y::node<val_25_781',next_25_782'>@L. 
print residue.

/*

GOT below but HP_1(..) not needed: We need to traverse from
y but we should not pick from HP_1 since it has y@NI

 inferred hprel: [(HP_1(next_24_820,y@NI)) * (HP_2(y,x@NI))&
                   true --> y::node<val_25_33,next_25_34>@M * 
                   (HP_35(next_25_34,x#))&true]

EXPECTING
 inferred hprel: [(HP_2(y,x@NI))
                   --> y::node<val_25_33,next_25_34>@M * 
                   (HP_35(next_25_34,x#))&true]
infer [HP_1,HP_2,HP_8,H1] 
HP_8(next_25_827,x) * y::node<val_25_826,next_25_827> * 
//x'::node<val_24_819,next_24_820>
* HP_1(next_24_820,y)
&x=x' & y=y' 
& x'!=null 
//& !(v_bool_21_795') & x'!=null & !(v_bool_21_795') 
& n1_34'=val_24_819 & n2_35'=val_25_826 & val_24_819=n2_35'+n1_34' 
& next_24_820=v_node_27_791' & 
next_25_827=v_node_27_790'
 |-  H1(v_node_27_791',v_node_27_790').

print residue.

/*

===============================================================
# zip-bug5a.slk: FIXED

GOT
 inferred hprel: [(HP_8(v_node_27_790',x@NI)) * (HP_1(v_node_27_791',y@NI))&
                   true --> (H1(v_node_27_791',v_node_27_790')) * (HP_37(x))&
                   true]

Why do we instantiate HP_37(x)? We should not instantiate
for parameters that has been marked as x@NI.
We can instantiate for FIELDS an for parameters that are not marked
as @NI

===============================================================
# zip-bug5b.slk: FIXED

infer [HP_1,HP_2,HP_8,H1,G1] 
y::node<val_25_826,next_25_827> * 
G1(next_24_820,next_25_827,next_24_820) * 
x::node<val_24_819,next_24_820>@M
&x!=null 
//& !(v_bool_21_795') & x!=null & !(v_bool_21_795') 
//& val_24_819=val_25_826+val_24_819 & next_24_820=next_24_820 & next_25_827=next_25_827 
& res=x
 |-  G1(x,y,res). 

print residue.

====

GOT
 inferred hprel: [y::node<val_25_826,next_25_827>@M * 
                   x::node<val_24_819,next_24_820>@M&res=x --> G1(x,y,res)&
                   true]

Why isn't G1(next_24_820,next_25_827,next_24_820) 
picked up?

EXPECTING :

 inferred hprel: [y::node<val_25_826,next_25_827>@M * 
                   x::node<val_24_819,next_24_820>@M
                   * G1(next_24_820,next_25_827,next_24_820) 
                   &res=x --> G1(x,y,res)&
                   true]
===============================================================
# conseq1.slk: FIXED (the example, not code)

//(3)
infer [H1,H2] //FIXED: add H2 as selected hp
x::node<_,n1> * y::node<_,n2> * H2(n1,_) |-  H1(x,y). 
print residue.
/*
WRONG : missing H2(n1,_)

 <1>H2(n1,Anon_18)&true&{FLOW,(19,20)=__norm}[]
 inferred hprel: [x::node<Anon_16,n1>@M * y::node<Anon_17,n2>@M&
                   true --> H1(x,y)&true]
*/

//(4)
infer [H1,H2,H3] FIXED
x::node<_,n1> * y::node<_,n2> * H2(n1,_) * H3(_,n2) |-  H1(x,y). 
print residue.
/*
WRONG : missing H2(n1,_)*H3(_,n2)

 <1>H2(n1,Anon_18)&true&{FLOW,(19,20)=__norm}[]
 inferred hprel: [x::node<Anon_16,n1>@M * y::node<Anon_17,n2>@M&
                   true --> H1(x,y)&true]
*/
===============================================================
# pre-2.slk

!!! >>>>>> generalize_one_cs_hp: <<<<<<
ERROR: at _0:0_0:0 
Message: sau.get_hpdef_name
 Fatal error: exception Failure("sau.get_hpdef_name")

relAssume P
  P(x#I) --> x::node<q>*P2(q#?).

relAssume P2
  P2(x)  --> P(x).

shape_infer[P,P2][].

/*

WRONG:
[ P(x_28) ::= x_28::node<q_21>@M * (P(q_21)) * (P(q_23)) * q_21::node<q_23>@M&true,
 P2(x_29) ::= x_29::node<q>@M * (P2(q))&true]

STEPS
=====
first confirm P:
  P(x) <--> x::node<q>*P2(q).
  P2(x)  --> P(x).
         --> x::node<q>*P2(q).
confirm P2
  P2(x)  <--> x::node<q>*P2(q).


Confirm P2
  P2(x)  --> P(x)
         <--> P(x)
  P(x) --> x::node<q>*P2(q).
       --> x::node<q>*P(q).
Confirm P
  P(x) <--> x::node<q>*P(q).

===============================================================
# pre-2a.slk


===============================================================
# id.ss: FIXED

cell id (cell x)
 infer [P,G]  requires P(x)  ensures  G(x,res);
//requires true  ensures  x=res;
{
  return x;
}

/*

A predicate is non-dangling if it is being used
for a pre-pred definition.
I suppose dangling classification may have to be
done after base-case splitting.


[ P(x)&res=x --> G(x,res)&true]

====

[ P(x) ::= emp& XPURE(P(x)),
 G(x_773,res_774) ::= emp&res_774=x_773 &  XPURE(P(x_773))]

====

Sufficient to use:

  P(x) --> emp
  res=x --> G(x,res)

====>
  P(x)     <--> true
  G(x,res) <--> res=x

*/

===============================================================
# zip-bug5c.slk   OK now

infer [HP_1,HP_2]
HP_1(next_24_820,y) * HP_2(y,x) * 
x::node<val_24_819,next_24_820>@M & x!=null 
 |-  y::node<_,next_25_782'>@L. 
print residue.

/*

GOT
 inferred hprel: [HP_2(y,x@NI)&true --> y::node<Anon_30,next_25_31>@M * 
                   (HP_32(next_25_31,x@NI))&true]

Could we remove a spurious "("...")", for 
(HP_32(next_25_31,x@NI))?

Could we have an option for enabling/disabling the printing of 
options; such as @NI, @M, [Orig]. For now, the default is
to --en-print-ann; but we can use --dis-print-ann to have those
removed; so that it will be easier to cut out sleek proofs.



===============================================================
# zip1.slk: FIXED

shape_infer[H1,HP_2,HP_1,HP_8][G1].

/*

[ HP_8(next_25_827,x_77) ::= emp& XPURE(HP_8(next_25_827,x_77)),
 HP_1(next_24_75,y_76) ::= emp& XPURE(HP_1(next_24_75,y_76)),
 H1(x_176,y_177) ::= emp&x_176=null,
 HP_2(y_178,x_179) ::= y_178::node<val_25_826,next_25_827>@M& XPURE(HP_8(next_25_827,x_179)),
 G1(x_180,y_181,res_183) ::= 
 emp&x_180=null
 or y_181::node<val_25_826,next_25_827>@M * x_180::node<val_24_819,nn>@M * 
    (G1(nn,next_25_827,nn))&true
 ]

WHY do we use XPURE(..) when I have specified all the predicates as non-dangling??

*/
===============================================================
# zip1.slk  DONE

GOT
====

[ H1(x_243,y_244) ::= 
 H1(next_24_110,next_25_108) * y_244::node<val_25_107,next_25_108>@M * 
 x_243::node<val_24_109,next_24_110>@M&true
 or HP_64(y_244)&x_243=null
 ,
 HL(y_247) ::= HP_64(y_247)&true,
 G1(x_248,y_249,res_250) ::= HP_251(x_248,y_249,res_250)&res_250=x_248,
 HP_251(x_248,y_249,res_250) ::= 
 HP_64(y_249)&x_248=null & res_250=null
 or y_249::node<val_25_826,next_25_827>@M * x_248::node<val_24_819,nn>@M * 
    HP_251(nn,next_25_827,nn)&true
 ,
 HP_64(y) ::=NONE]



[ HP_2(y_176,x_177) ::= y_176::node<val_25_826,next_25_827>@M * (HP_8(next_25_827,x_177))&true,

 HP_1(next_24_820,y) ::= (H1(x,y)) * (HP_2(y,x))&true,
 HP_8(next_25_827,x) ::= HP_2(y,x)&true,

 H1(x_178,y_179) ::= 
 emp&x_178=null
 or (H1(next_24_103,next_25_101)) * y_179::node<val_25_100,next_25_101>@M * 
    x_178::node<val_24_102,next_24_103>@M&true
 ,

 G1(x_180,y_181,res_183) ::= 
 emp&x_180=null
 or y_181::node<val_25_826,next_25_827>@M * x_180::node<val_24_819,nn>@M * 
    (G1(nn,next_25_827,nn))&true
 ]

PROBLEMS
========
Why did we get:
 HP_1(next_24_820,y) ::= (H1(x,y)) * (HP_2(y,x))&true,
 HP_8(next_25_827,x) ::= HP_2(y,x)&true,

EXPECTING: (tupled definition for two pre-pred)
 (HP_1(next_24_820,y@NI)) * (HP_8(next_25_827,x@NI))&
  true <--> H1(next_24_820,next_25_827)&true,

======================================================

# zip.ss: DONE

Wrong answer:
============
[ H(x_934,y_935) ::= emp&x_934=null,
 G1(x_941,y_939,res_940) ::= 
 emp&res_940=null
 or y_939::node<val_35_810,next_35_811>@M * 
    (G1(next_34_804,next_35_811,v_node_37_842)) * 
    res_940::node<v_int_36_826,v_node_37_842>@M&true
 ]

Relational assumption OK (except for G1) see zip1.slk
=========================================
[ H(x,y)&x!=null --> x::node<val_34_803,next_34_804>@M * 
  (HP_805(next_34_804,y@NI)) * (HP_806(y,x@NI))&true,
 HP_806(y,x@NI)&true --> y::node<val_35_810,next_35_811>@M * 
  (HP_812(next_35_811,x@NI))&true,
 (HP_805(next_34_804,y@NI)) * (HP_812(next_35_811,x@NI))&
  true --> H(next_34_804,next_35_811)&true,
 H(x,y)&x=null --> emp&true,
 emp&x=null & res=null --> G1(x,y,res)&true,
 y::node<val_35_810,next_35_811>@M * 
  (G1(next_34_804,next_35_811,v_node_37_842)) * 
  x::node<v_int_36_826,v_node_37_842>@M&res=x --> G1(x,y,res)&true]

[ H(x,y)&x!=null --> x::node<val_34_803,next_34_804>@M * 
  (HP_805(next_34_804,y@NI)) * (HP_806(y,x@NI))&true,
 HP_806(y,x@NI)&true --> y::node<val_35_810,next_35_811>@M * 
  (HP_812(next_35_811,x@NI))&true,
 (HP_805(next_34_804,y@NI)) * (HP_812(next_35_811,x@NI))&
  true --> H(next_34_804,next_35_811)&true,
 H(x,y)&x=null --> emp&true,
 emp&x=null & res=null --> G1(x,y,res)&true,
 y::node<val_35_810,next_35_811>@M * 
  (G1(next_34_804,next_35_811,v_node_37_842)) * 
  x::node<v_int_36_826,v_node_37_842>@M&res=x --> G1(x,y,res)&true]
*

=============================================================
# zip1b.slk  DONE

When HL is non-dangling:
It introduced HL(Y) :: emp. 
Can we avoid this, as it has nullified uninterpreted predicates.


[ HP_2(y_242,x_243) ::= y_242::node<val_25_826,next_25_827>@M * (HP_8(next_25_827,x_243))&true,
 H1(x_244,y_245) ::= 
 emp&x_244=null
 or (H1(next_24_109,next_25_107)) * y_245::node<val_25_106,next_25_107>@M * 
    x_244::node<val_24_108,next_24_109>@M&true
 ,
 HL(y_246) ::= emp&true,
 HP_1(next_24_820,y) ::= (H1(x,y)) * (HP_2(y,x))&true,
 HP_8(next_25_827,x) ::= HP_2(y,x)&true,
 G1(x_247,y_248,res_250) ::= 
 emp&x_247=null
 or y_248::node<val_25_826,next_25_827>@M * x_247::node<val_24_819,nn>@M * 
    (G1(nn,next_25_827,nn))&true
 ]

=============================================================
# zip1c.slk: DONE with --sa-s-split


[ HP_2(y_175,x_176) ::= y_175::node<val_25_826,next_25_827>@M * (HP_8(next_25_827,x_176))&true,
 H1(x_177,y_178) ::= 
 emp&x_177=null
 or (H1(next_24_102,next_25_100)) * y_178::node<val_25_99,next_25_100>@M * 
    x_177::node<val_24_101,next_24_102>@M&true
 ,

Problem below:
=============
 HP_1(next_24_820,y) ::= (H1(x,y)) * (HP_2(y,x))&true,
 HP_8(next_25_827,x) ::= HP_2(y,x)&true,

 G1(x_179,y_180,res_181) ::= HP_182(x_179,y_180,res_181)&res_181=x_179,
 HP_182(x_179,y_180,res_183) ::= 
 emp&x_179=null
 or y_180::node<val_25_826,next_25_827>@M * x_179::node<val_24_819,nn>@M * 
    (HP_182(nn,next_25_827,nn))&true
 ]

--sa-s-split

PROBLEM : Base case for H1 disappeared..

 HP_2(y_176,x_177) ::= y_176::node<val_25_826,next_25_827>@M * (HP_8(next_25_827,x_177))&true,

 H1(x_178,y_179) ::= (H1(next_24_103,next_25_101)) * y_179::node<val_25_100,next_25_101>@M * 
x_178::node<val_24_102,next_24_103>@M&x_178!=null,

 HP_1(next_24_820,y) ::= (H1(x,y)) * (HP_2(y,x))&true,
 HP_8(next_25_827,x) ::= HP_2(y,x)&true,

 G1(x_180,y_181,res_182) ::= HP_183(x_180,y_181,res_182)&res_182=x_180,
 HP_183(x_180,y_181,res_182) ::= 
 HP_60(y_181)&x_180=null & res_182=null
 or y_181::node<val_25_826,next_25_827>@M * x_180::node<val_24_819,nn>@M * 
    (H



=============================================================
# zip1d.slk: FIXED (test zip.ss: check inferred rel_assumption of base cases)

(2) Also, for G, we seem to lose the relation x=r. Why is it missing??
 EXPECTING:
 G1(x_180,y_181,res_183) ::= 
 emp&x_180=null  //& x=r
 or y_181::node<val_25_826,next_25_827>@M * x_180::node<val_24_819,nn>@M * 
    (G1(nn,next_25_827,nn))  //& x=r


==========================================================
# zip1c1.slk DONE

relAssume G1
H1(x,y) & x=null & res=null --> G1(x,y,res).
 
shape_infer[H1][G1].

GOT
====

[ H1(x_35,y_36) ::= HP_29(x_35)&x_35=null,
 G1(x_37,y_38,res_39) ::= HP_29(x_37)&x_37=null & res_39=null,
 HP_29(x) ::= H1(x,y)&x=null]

EXPECTING without a defn for HP_29 (maybe NONE for body)
===========

  H1(x_35,y) ::= HP_29(y)&x_35=null,
  G1(x_37,y,res_39) ::= HP_29(y)&x_37=null & res_39=null,


I guess this should be done during split-base itself. Instead
of:

 HP_29(x)&res=null & x=null --> G1(x,y,res)&true,
 H1(x,y)&x=null --> HP_29(x)&true

SHOULD BE:
==========
 HP_29(y)&res=null & x=null --> G1(x,y,res)&true,
 H1(x,y)&x=null --> HP_29(y)&true


This is if y is instantiating. If not, do just the
usual split.

==========================================================
# zip1c2.slk DONE

HeapPred H1(node a, node@NI b).
HeapPred G1(node a, node b, node c).

relAssume G1
H1(x,y) & x=null & res=null --> G1(x,y,res).
 
shape_infer[H1][G1].


GOT
====

[ G1(x_22,y_23,res_24) ::= H1(x_22,y_23)&x_22=null & res_24=null & res_24=x_22]

WHY is it NOT splitting?
EXPECTING
=========

H1(x,y) & x=null & res=null --> emp.
emp & x=null & res=null --> G1(x,y,res).

*/

=================================================================
# zip1b1.slk  DONE

PROBLEMS
 (i) where is base case for H1
(ii) Instead of:
   HP_1(next_24_820,y) ::= (H1(x,y)) * (HP_2(y,x))&true,
   HP_8(next_25_827,x) ::= HP_2(y,x)&true,
Can we just have:
  HP_8(next_25_827,x) * HP_1(next_24_820,y)  
     <--> H1(next_24_820,next_25_827).

[ HP_2(y_177,x_178) ::= y_177::node<val_25_826,next_25_827>@M * (HP_8(next_25_827,x_178))&true,
 H1(x_179,y_180) ::= 
 emp&x_179=null
 or (H1(next_24_104,next_25_102)) * y_180::node<val_25_101,next_25_102>@M * 
    x_179::node<val_24_103,next_24_104>@M&true
 ,
 HP_1(next_24_820,y) ::= (H1(x,y)) * (HP_2(y,x))&true,
 HP_8(next_25_827,x) ::= HP_2(y,x)&true,
 G1(x_181,y_182,res_184) ::= 
 emp&x_181=null
 or y_182::node<val_25_826,next_25_827>@M * x_181::node<val_24_819,nn>@M * 
    (G1(nn,next_25_827,nn))&true
 ]

 HL(y_184)&x_183=null & res_185=null
 or y_184::node<val_25_826,next_25_827>@M * x_183::node<val_24_819,nn>@M * 
    (HP_186(nn,next_25_827,nn))&true
 ]

============

[ HP_2(y_242,x_243) ::= y_242::node<val_25_826,next_25_827>@M * (HP_8(next_25_827,x_243))&true,
 H1(x_244,y_245) ::= 
 emp&x_244=null
 or (H1(next_24_109,next_25_107)) * y_245::node<val_25_106,next_25_107>@M * 
    x_244::node<val_24_108,next_24_109>@M&true
 ,
 HL(y_246) ::= emp&true,
 HP_1(next_24_820,y) ::= (H1(x,y)) * (HP_2(y,x))&true,
 HP_8(next_25_827,x) ::= HP_2(y,x)&true,
 G1(x_247,y_248,res_250) ::= 
 emp&x_247=null
 or y_248::node<val_25_826,next_25_827>@M * x_247::node<val_24_819,nn>@M * 

*/

============================================================
# zip1b1.slk: FIXED

Previously, you managed to eliminate:

 HP_2(y_181,x_182) ::= y_181::node<val_25_826,next_25_827>@M * (HP_8(next_25_827,x_182))&true,
 (HP_8(next_25_827,x)) * 
  (HP_1(next_24_820,y)) ::= H1(next_24_820,next_25_827)&true,

The --sa-dis-eup is on by default. However, the above
useless predicates are still been eliminated.

Can I have an option sa-dis-eup that would allow the above
to be kept, rather than eliminated? This woul permit me to
see what were the full set of predicates that were constructed,
including those that may have been redundant subsequently.

Could we implement --sa-en-eup and --sa-dis-eup properly

have an option --sa-dis-elim-unused-pred 
to keep the unused pred so that we know they are transformed
correctly. That is the elim of unused pred is dis-enabled
when the above option is turned on.


GREAT!

TWO small PROBLEMS
(i)  x=res  not captured for G1.by adding res=x in the assumption
(ii) We can figure some predicates are redundant, namely: (DONE)



Also, for zip1b2.slk,zip1b.slk DONE

=====

[ HP_2(y_177,x_178) ::= y_177::node<val_25_826,next_25_827>@M * (HP_8(next_25_827,x_178))&true,
 H1(x_179,y_180) ::= 
 emp&x_179=null
 or (H1(next_24_104,next_25_102)) * y_180::node<val_25_101,next_25_102>@M * 
    x_179::node<val_24_103,next_24_104>@M&true
 ,
 G1(x_181,y_182,res_184) ::= 
 emp&x_181=null
 or y_182::node<val_25_826,next_25_827>@M * x_181::node<val_24_819,nn>@M * 
    (G1(nn,next_25_827,nn))&true
 ,
 (HP_8(next_25_827,x)) * 
  (HP_1(next_24_820,y)) ::= H1(next_24_820,next_25_827)&true]

======

PROBLEMS DONE
 (i) where is base case for H1?
 H1(x_181,y_182) ::= (H1(next_24_106,next_25_104)) * y_182::node<val_25_103,next_25_104>@M * 
x_181::node<val_24_105,next_24_106>@M&x_181!=null,

(ii) Instead of:
   HP_1(next_24_820,y) ::= (H1(x,y)) * (HP_2(y,x))&true,
   HP_8(next_25_827,x) ::= HP_2(y,x)&true,
Can we just have:
  HP_8(next_25_827,x) * HP_1(next_24_820,y)  
     <--> H1(next_24_820,next_25_827).

[ HP_2(y_179,x_180) ::= y_179::node<val_25_826,next_25_827>@M * (HP_8(next_25_827,x_180))&true,

 H1(x_181,y_182) ::= (H1(next_24_106,next_25_104)) * y_182::node<val_25_103,next_25_104>@M * 
x_181::node<val_24_105,next_24_106>@M&x_181!=null,

 HP_1(next_24_820,y) ::= (H1(x,y)) * (HP_2(y,x))&true,
 HP_8(next_25_827,x) ::= HP_2(y,x)&true,
 HL(y) ::= H1(x,y)&true,
 G1(x_183,y_184,res_185) ::= HP_186(x_183,y_184,res_185)&res_185=x_183,
 HP_186(x_183,y_184,res_185) ::= 
 HL(y_184)&x_183=null & res_185=null
 or y_184::node<val_25_826,next_25_827>@M * x_183::node<val_24_819,nn>@M * 
    (HP_186(nn,next_25_827,nn))&true
 ]

===============================================================
# zip.ss: FIXED

How come below, when its relational assumption
in zip1f.slk gives correct answer?

[ H(x_945,y_946) ::= emp&x_945=null,
 G1(x_949,y_950,res_951) ::= HP_952(x_949,y_950,res_951)&res_951=x_949,
 HP_952(x_953,y_950,res_951) ::= 
 emp&res_951=null
 or y_950::node<val_32_821,next_32_822>@M * 
    (HP_952(next_31_815,next_32_822,v_node_34_853))&true
 ]

===============================================================
# dll-app3a1.slk: FIXED

infer [HP_9,HP_0,HP_1] 
HP_9(next_16_7,l2) * HP_0(prev_16_8,l2) * HP_1(l2,l1) * 
l1::node<l2,prev_16_8> 
//& l1=l1' & l2=l2' 
& next_16_7=null & 
//!(v_bool_16_768') & next_16_7=null & !(v_bool_16_768') & 
next_16_7=next_20_807
 |-  l2::node<next_21_766',prev_21_767'>.

print residue.

/*

GOT
===
 inferred hprel: [HP_1(l2',l1'@NI)&
                   true --> l2'::node<next_21_41,prev_21_42>@M * 
                   (HP_43(next_21_41,l1'@NI)) * (HP_44(prev_21_42,l1'@NI))&
                   true; 
                  HP_9(next_16_7,l2'@NI)&next_16_7=null --> emp&true]
PROBLEM
=======
Base-case equation for HP_9 (below) is not needed!
Why was it generated?
    HP_9(next_16_7,l2'@NI)&next_16_7=null --> emp&true]


===============================================================

# zip1b3.slk: DONE

relAssume G1
 //res=x & 
 x=null & res=null --> G1(x,y,res).

[ G1(x_36,y_37,res_38) ::= HP_39(x_36,y_37,res_38)&res_38=x_36,
 HP_39(x_36,y_37,res_38) ::= 
 emp&x_36=null & res_38=null
 or y_37::node<val_25_826,next_25_827>@M * x_36::node<val_24_819,nnn>@M * 
    HP_39(nnn,next_25_827,nnn)&true
 ]

=================================================================
# zip1b4.slk: FIXED

relAssume G1
 y::node<val_25_826,next_25_827> * x::node<val_24_819,rr>
  * G1(nn,next_25_827,rr) 
  & nn=rr
  & res=x --> G1(x,y,res).

===>
relAssume G1
 y::node<val_25_826,next_25_827> * x::node<val_24_819,rr>
  * G1(rr,next_25_827,rr) 
      ^^^^
  & nn=rr
  & res=x --> G1(x,y,res).

=================================================================
# zip1b5.slk: DONE

relAssume G1
 //res=x & 
 x=null & res=null --> G1(x,y,res).

relAssume G1
 y::node<val_25_826,next_25_827> * x::node<val_24_819,rr>
  * G1(nn,next_25_827,rr) 
 // & nn=rr
  & res=x --> G1(x,y,res).

===>
relAssume G1
 y::node<val_25_826,next_25_827> * x::node<val_24_819,rr>
  * G1(rr,next_25_827,rr) 
  & nn=rr
   ^^^^^^^
  & res=x --> G1(x,y,res).

====================================================================
# id.ss: FIXED

GOT:
[ P(x)&res=x --> G(x,res)&true]

WHY are both treated as UNKNOWN!

[ P(a) ::=NONE,
 G(a,r) ::=NONE]

P/Q should be normal pre/post; and have
defns:

  P(a) ::= emp.
 G(a,r) ::= a=res

====================================================================
# id.slk: fIXED

HeapPred P(cell a).
HeapPred G(cell a, cell r).

Declare_Dangling [].
Declare_Unknown [].

relAssume G
P(a) & a=res --> G(a,res).

shape_infer [P][G].

/*
[ G(a_18,res_19) ::= P(a_18)&a_18=res_19]

WHY is it not splitting?

*/
================================================
# zip1.slk: FIXED

Why an intermediate HP_64?

[ H1(x_243,y_244) ::= 
 H1(next_24_110,next_25_108) * y_244::node<val_25_107,next_25_108>@M * 
 x_243::node<val_24_109,next_24_110>@M&true
 or HP_64(y_244)&x_243=null
 ,
 HL(y_247) ::= HP_64(y_247)&true,
 G1(x_248,y_249,res_250) ::= HP_251(x_248,y_249,res_250)&res_250=x_248,
 HP_251(x_248,y_249,res_250) ::= 
 HP_64(y_249)&x_248=null & res_250=null
 or y_249::node<val_25_826,next_25_827>@M * x_248::node<val_24_819,nn>@M * 
    HP_251(nn,next_25_827,nn)&true
 ,
 HP_64(y) ::=NONE]

================================================
# zip1z.slk: FIXED (example is wrong. should use G1 as post-pred instead of G)

relAssume G1
// x=null & res=null --> G1(x,y,res).
// HL(x) & x=null & res=null --> G1(x,y,res).
 H1(x,res) & x=null & res=null --> G1(x,y,res).

shape_infer [H1][G].

/*
Why isn't splitting invoked?

[ H1(x_30,res_31) ::= G1(x_30,y,res_31)&res_31=null & x_30=null]


*/

================================================
# sll-bug-1.slk

infer [H1,H2] x::node<_,q>*H2(q,r) |- H1(q,x).
print residue.

/*

GOT:
 <1>emp&true&{FLOW,(19,20)=__norm}[]
 inferred hprel: [x::node<Anon_11,q>@M * H2(q,r)&true --> H1(q,x)&true]

EXPECT:
 <1>emp&true&{FLOW,(19,20)=__norm}[]
 inferred hprel: [H2(q,r)&true --> H1(q,x)&true]

ALGORITM
========

   q match with H2(q,r) 
   x match with x::node<_,q>*H2(q,r) 

Since they overlap, we pick only q; and drop x matching.

Another ALGO:
   q match with H2(q,r) --> {q}{r}  // q is captured, r is continuation
   x match with x::node<_,q> --> {x}{q} // x is captured, q is continuation

Since q already captured, we drop x from consideration. 

================================================
# heap-bug-2.slk (URGENT): FIXED

infer [H,G,HP_0,HP_1] 
 HP_0(left_24_838) * HP_1(right_24_839) * 
 x::node<key_24_837,left_24_838,right_24_839> &x=x' & 
 left_24_838!=null 
 & right_24_839=null 
 & left_24_838=s_31' & s_31'!=null 
 |-  s_31'::node<key_35_795',left_35_796',right_35_797'>.

print residue.
/*

yields
======
 inferred hprel: [HP_0(s_31')&
                   s_31'!=null --> s_31'::node<key_35_34,left_35_35,right_35_36>@M * 
                   HP_37(left_35_35) * HP_38(right_35_36)&true; 
                  HP_1(right_24_839)&right_24_839=null --> emp&true]

WHY a spurious
                  HP_1(right_24_839)&right_24_839=null --> emp&true]

==================================================================
# heap-bug-3b.slk

infer [H,G,HP_4,HP_5] 
HP_4(left_39_832) * HP_5(right_39_833) * 
x::node<key_39_831,left_39_832,right_39_833>@M
& left_39_832=null & v_bool_39_812' 
 |-  G(x). 
print residue.

infer [H,G,HP_4,HP_5] 
HP_4(left_39_832) * HP_5(right_39_833) * 
x::node<key_39_831,null,right_39_833>@M
& left_39_832=null & v_bool_39_812' 
 |-  G(x). 
print residue.

/*

Can the first entailment produce the same outcome
as 2nd entailment.

============================================================
# heap-bug-3a.slk

relAssume G
HP_4(left_39_832) * HP_5(right_39_833) * 
x::node<key_39_831,left_39_832,right_39_833>@M
& left_39_832=null & v_bool_39_812' 
 -->  G(x). 

shape_infer [HP_4,HP_5][G].


/*

There seems a base-case split here which may
not be needed. The reason is that LHS
pre-pred is not in a base-case scenario.

[ HP_4(left_39_27) ::= emp&left_39_27=null,
 HP_5(right_39_28) ::= emp&true,
 G(x_29) ::= x_29::node<key_39_831,left_39_832,right_39_833>@M&left_39_832=null]

I suggest that we do not trigger a base-case split here.
But U am not sure on what basis to not trigger it. Maybe
for base case split, we do need some base-case condition for
G(x), such as x=null which does not seem to be present in
this case.

============================================================
# two-bug-1.slk :FIXED

infer [HP_5,HP_6]
 //HP_5(next_24_784,y) * 
 HP_6(y,x) * x::node<val_24_783,next_24_784> 
 & next_24_784!=null 
 // &x=x' & y=y' 
 //& !(v_bool_24_764') & next_24_784!=null & !(v_bool_24_764')
 |-  y::node<val_27_762',next_27_763'>@L.

print residue.



/*

WHY next_24_784!=null when not related to y,x.

 inferred hprel: [HP_6(y,x@NI)&
                   next_24_784!=null --> y::node<val_27_31,next_27_32>@M * 
                   HP_33(next_27_32,x@NI)&true]

================================================================
# tree-1-bug-1.slk: FIXED (use --sa-dangling for dangling)

Declare_Unknown [HP_2].

relAssume H
 H(x)&true --> x::node<key_25_788,left_25_789,right_25_790>@M * 
  HP_1(left_25_789) * HP_2(right_25_790).

relAssume H
 HP_1(left_25_789)&left_25_789!=null --> H(left_25_789).

relAssume H
 HP_1(left_25_789)&left_25_789=null --> emp.

relAssume H
 HP_2(right_25_790) * x::node<key_25_788,left_25_789,right_25_790> &
  left_25_789=null --> G(x)&true.

relAssume H
 HP_2(right_25_790) * x::node<key_25_788,left_25_789,right_25_790>@M * 
  G(left_25_789)&left_25_789!=null --> G(x).

shape_infer [H,HP_1,HP_2][G].

/* 

This outcome seems wrong.

[ HP_1(left_25_69) ::= emp&left_25_69=null,
 HP_2(right_25_70) ::= emp&true,
 H(x_71) ::= x_71::node<key_25_788,left_25_789,right_25_790>@M&left_25_789=null,
 G(x_72) ::= x_72::node<key_25_788,left_25_789,right_25_790>@M * 
HP_73(left_25_789,right_25_790)&true,
 HP_73(left_25_789,right_25_790) ::= 
 emp&left_25_789=null
 or left_25_789::node<key_25_788,left_25_74,right_25_75>@M * 
    HP_73(left_25_74,right_25_75)&true
 ]

Declaring HP_2 as Unknown seem to produce a more 
correct result:
 
[ HP_1(left_25_69) ::= 
   emp&left_25_69=null
   or left_25_69::node<key_25_788,left_25_789,right_25_790>@M * 
    HP_1(left_25_789) * HP_2(right_25_790)&true
 ,
 H(x_70) ::= 
  x_70::node<key_25_788,left_25_789,right_25_790>@M * HP_1(left_25_789) * 
   HP_2(right_25_790)&true,

 G(x_71) ::= x_71::node<key_25_788,left_25_789,right_25_790>@M * 
  HP_72(left_25_789,right_25_790) * HP_2(right_25_790)&true,

 HP_72(left_25_789,right_25_790) ::= 
 emp&left_25_789=null
 or left_25_789::node<key_25_788,left_25_73,right_25_74>@M * 
    HP_72(left_25_73,right_25_74) * HP_2(right_25_74)&true

 HP_2(a) ::=NONE]

==============================================================
# tail-bug-1.slk

Declare_Unknown [HP_9].
//Declare_Dangling [HP_9].

relAssume H
 H1(c)&true --> c::node<val_14_777,next_14_778> * HP_9(next_14_778).

relAssume H
 HP_9(next_14_778) * c::node<val_14_777,next_14_778> &
  next_14_778=res --> G1(res,c).

shape_infer [H1,HP_9][G1].

/* 

Yields
======
[ H1(c_38) ::= c_38::node<val_14_777,next_14_778>@M * HP_9(next_14_778)&true,
 G1(res_39,c_40) ::= HP_9(res_39) * c_40::node<val_14_777,res_39>@M&true,
 HP_9(a) ::=NONE]


QUESTION : When would dangling be better than UNKNOWN?

*/

=====================================================================
# tree-3.ss: FIXED

EXPECTED:
  H(x)&true <--> x::node<_,left,right>@M * 
    HP_1(left) * HP_2(right)&true,
 HP_2(x) <--> x=null
   or x::node<_,left,right>@M * 
      HP_1(left) * HP_2(right)&true,
 G(x) <--> HP_1(left) * x::node<_,left,right>@M * G1(right)  
 G1(right) <-->
      right=null or  HP_1(l) * right::node<_,l,r>@M * G1(r)
 HP_1(a) <--> NONE

=====================================================================
# tree-2-bug-1.slk: FIXED

relAssume H
 H(x)&true --> x::node<key_25_797,left_25_798,right_25_799>@M * 
  HP_0(left_25_798) * HP_1(right_25_799).

relAssume H
 HP_0(left_25_798)&left_25_798!=null --> H(left_25_798).

relAssume H
 HP_1(right_25_799)&right_25_799!=null --> H(right_25_799).

relAssume HP_1
 HP_1(right_25_799)&right_25_799=null --> emp.

relAssume HP_0
 HP_0(left_25_798)&left_25_798=null --> emp.


shape_infer [H,HP_0,HP_1][].

/* 


WRONG!
======

[ HP_0(left_25_64) ::= emp&left_25_64=null,
 HP_1(right_25_65) ::= emp&right_25_65=null,
 H(x_66) ::= x_66::node<key_25_797,left_25_798,right_25_799>@M
   &left_25_798=null & right_25_799=null]

EXPECT
======
 H(x)&true <--> x::node<key_25_797,left_25_798,right_25_799>@M * 
  HP_0(left_25_798) * HP_1(right_25_799).

 HP_1(right_25_799)&right_25_799=null --> emp.
 HP_1(right)&right!=null --> 
   right::node<key_25_797,left_25_798,right_25_799>@M * 
  HP_0(left_25_798) * HP_1(right_25_799)

 HP_0(left_25_798)&left_25_798=null --> emp.
 HP_0(left)&left!=null --> 
   left::node<key_25_797,left_25_798,right_25_799>@M * 
  HP_0(left_25_798) * HP_1(right_25_799)


THUS:
=====

 H(x)&true <--> x::node<key_25_797,left_25_798,right_25_799>@M * 
  HP_0(left_25_798) * HP_1(right_25_799).
 HP_1(right) = right=null
   or    right::node<key_25_797,left_25_798,right_25_799>@M * 
         HP_0(left_25_798) * HP_1(right_25_799)
 HP_0(left) = left=null
   or    left::node<key_25_797,left_25_798,right_25_799>@M * 
         HP_0(left_25_798) * HP_1(right_25_799)

*/

==========================================================================
# tree-4.slk: 

TODO: implement --sa-unify: intra-defs: between branches
this example is not correct
=====================================================================
# tree-2-bug-1.slk: DONE

TODO: implement --sa-unify: inter-defs

relAssume H
 H(x)&true --> x::node<key_25_797,left_25_798,right_25_799>@M * 
  HP_0(left_25_798) * HP_1(right_25_799).

relAssume H
 HP_0(left_25_798)&left_25_798!=null --> H(left_25_798).

relAssume H
 HP_1(right_25_799)&right_25_799!=null --> H(right_25_799).

relAssume HP_1
 HP_1(right_25_799)&right_25_799=null --> emp.

relAssume HP_0
 HP_0(left_25_798)&left_25_798=null --> emp.


shape_infer [H,HP_0,HP_1][].

/* 

EXPECT
======
H(x)&true <--> x::node<key_25_797,left_25_798,right_25_799>@M * 
  HP_0(left_25_798) * HP_1(right_25_799).
 HP_1(right) = right=null
   or    right::node<key_25_797,left_25_798,right_25_799>@M * 
         HP_0(left_25_798) * HP_1(right_25_799)
 HP_0(left) = left=null
   or    left::node<key_25_797,left_25_798,right_25_799>@M * 
         HP_0(left_25_798) * HP_1(right_25_799)

=====>

HP_0 <---> HP_1

 H(x)&true <--> x::node<key_25_797,left_25_798,right_25_799>@M * 
  HP_0(left_25_798) * HP_0(right_25_799).
 HP_1(right) = right=null
   or    right::node<key_25_797,left_25_798,right_25_799>@M * 
         HP_1(left_25_798) * HP_1(right_25_799)
 HP_0(left) = left=null
   or    left::node<key_25_797,left_25_798,right_25_799>@M * 
         HP_0(left_25_798) * HP_0(right_25_799)

*/

==========================================================================

# two-2.slk

relAssume HP_6
  HP_6(y,x) --> y::node<val_27_794,next_27_795>@M * HP_9(next_27_795,x)&true.

relAssume G2
  HP_5(n,y) * HP_6(y,x) * 
  x::node<_,n>@M&n=null --> G2(x,y).

Declare_Unknown [ HP_5, HP_9].
shape_infer [HP_5,HP_6,HP_9][G2].

/*


GOT
===
[ HP_6(y_44,x_45) ::= y_44::node<val_27_794,next_27_795>@M * HP_9(next_27_795,x_45)&true,
 G2(x_46,y_47) ::= HP_5(n,y_47) * x_46::node<Anon_11,n>@M&n=null,
 HP_5(a,b) ::=NONE,
 HP_9(a,b) ::=NONE]

Was it to to a bad base-case split?

EXPECT
======
  HP_6(y,x) <--> y::node<val_27_794,next_27_795>@M * HP_9(next_27_795,x)&true.

  HP_5(n,y) * y::node<val_27_794,next_27_795>@M * HP_9(next_27_795,x) * 
  x::node<_,n>@M&n=null --> G2(x,y).

  G2(x,y) <->
     y::node<val_27_794,next_27_795>@M * HP_9(next_27_795,x) * 
     x::node<_,n>@M&n=null --> G2(x,y).

*/
=================================================
# id.ss  FIXED

cell id (cell x)
 infer [P,G]  requires P(x)  ensures  G(x,res);
//requires emp  ensures  emp & x=res;
{
  return x;
}

/*

We obtained:

[ P(x)&res=x --> G(x,res)&true]

We should not do base-case split here.

First, we consider pre-pred. There
is only P but no definition. Hence,
P is unknown. Thus, we have

 P(x) ::= NONE

Next, we consider the post-pred G.
There is only one assumption:
   P(x) & res=x --> G(x,res)

We derive:
   G(x,res) ::= P(x) & res=x

Thus:
   P(x) ::= NONE
   G(x,res) ::= P(x) & res=x

===========================================================
# cll-1b.slk: FIXED

Declare_Unknown [HP_7].

relAssume H //(1)
 H(rest,h)&h!=rest --> rest::node<val_36_824,next_36_825> * 
  HP_6(next_36_825,h) * HP_7(h,rest).

relAssume H //(2)
 HP_6(next_36_825,h) * HP_7(h,rest)&h!=rest 
   --> H(next_36_825,h).

relAssume H //(3)
 H(rest,h)&h=rest --> emp.

shape_infer [H,HP_6,HP_7][].
/*

WRONG
=====
[ H(rest_45,h_46) ::=  emp&h_46=rest_45,
 HP_6(next_36_825,h) ::=  H(next_36_825,h)&h!=rest,
 HP_7(a,b) ::= NONE]

EXPECT
======

Make Equal (2)
 HP_6(next_36_825,h) * HP_7(h,rest)&h!=rest 
   <--> H(next_36_825,h). //(2a)

Use (2a) to strengthen (1)
 H(rest,h)&h!=rest --> rest::node<val_36_824,nn> * 
  H(nn,h). //(1a)

Combine (1a) & (3)
 H(rest,h) --> 
  rest::node<val_36_824,nn> * H(nn,h) & h!=null
  or h=res

Make Equal
 H(rest,h) <--> 
  rest::node<val_36_824,nn> * H(nn,h) & h!=null
  or h=res

*/

//shape_infer [H,HP_6,HP_7][].
shape_strengthen_conseq [H,HP_6,HP_7][].
/*
========================================================
# cll-1c.slk

GOT
===
 H(rest,h)&h!=rest --> rest::node<val_36_824,next_36_825>@M * 
  HP_6(next_36_825,h) * HP_7(h,rest)&true,
 H(next_36_37,h_38)&h_38!=rest_36 --> H(rest_36,h_38)&h_38!=rest_36,
 H(rest,h)&h=rest --> emp&true]
*
EXPECT
======
 H(rest,h)&h!=rest --> rest::node<val_36_824,next_36_825> * 
  H(next_36_825,rest).
 H(next_36_825,h) --> HP_6(next_36_825,h) * HP_7(h,rest)&h!=rest.
 H(rest,h)&h=rest --> emp.

========================================================
# cll-1b.slk:

GOT
===
[ H(rest_43,h_44) ::=  
 emp&h_44=rest_43
 or H(next_36_40,h_44) * rest_43::node<val_36_39,next_36_40>@M&h_44!=rest_43
 ,
 HP_6(next_36_825,h) ::=  H(next_36_825,h)&h!=rest,
 HP_7(a,b) ::= NONE]
*

2nd equation is wrong. 

EXPECT
======
 HP_6(next_36_825,h) * HP_7(h,rest)&h!=rest 
                                    ^^^^^^^
   <--> H(next_36_825,h).

===============================
# two-1a.slk

Basically from two-2.slk + two-1.slk. GOT

[ H2(x_137,y_138) ::=  y_138::node<val_27_794,next_27_795>@M * HP_9(next_27_795,x_137) * 
x_137::node<val_24_67,next_24_68>@M * HP_5(next_24_68,y_138)&true,
 HP_6(y_139,x_140) ::=  y_139::node<val_27_794,next_27_795>@M * HP_9(next_27_795,x_140)&true,
 G2(x_142,y_143) ::=  x_142::node<Anon_11,n>@M * y_143::node<val_27_794,next_27_141>@M * 
HP_144(n,y_143) * HP_5(n,y_143) * HP_9(next_27_141,x_142)&true,
 HP_144(n,y_143) ::=  emp&n=null,
 HP_5(a,b) ::= NONE,
 HP_9(a,b) ::= NONE]

CORRECT except for: 
===================

 G2(x_151,y_152) ::=  x_151::node<Anon_12,n>@M * y_152::node<Anon_11,nn>@M * HP_153(n,y_152) * 
HP_9(nn,x_151)&true,
 HP_153(n,y_152) ::=  
 emp&n=null
 or HP_5(n,y_152)&n!=null

==========================================================
# tree-5.slk: FIXED

EXPECT:
======
  G1 (x) <--> G2 (x)

  G2(x) <--> x=null
     or x::node<_,left,right> * G2(left) * G2(right)

==========================================================
# tree-5a.slk: FIXED

EXPECT:
======
 G2=G1

 G(x) <-->   x::node<k,l,r> * G1(l) * G1(r)

 G1(left) <--->
  left=null
  or left::node<k,l,r> * G1(l) * G1(r)
==========================================================
# tree.ss: FIXED

GOT BELOW which is WRONG
========================
[ H(x_971) ::=  x_971::node<key_31_797,left_31_798,right_31_799>@M * HP_801(right_31_799)&
left_31_798=null,
 G(x_973) ::=  x_973::node<key_31_797,left_31_798,right_31_799>@M * 
HP_974(left_31_798,right_31_799)&true,
 HP_801(right_31_870) ::=  
 right_31_870::node<key_31_797,left_31_798,right_31_799>@M * 
 HP_800(left_31_798) * HP_801(right_31_799)&true
 or emp&right_31_870=null
 ,
 HP_974(left_31_798,right_31_799) ::=  
 emp&left_31_798=null
 or emp&right_31_799=null & left_31_798!=null
 or left_31_798::node<key_31_797,left_31_975,right_31_976>@M * 
    HP_974(left_31_975,right_31_976) * 
    right_31_799::node<key_31_797,left_31_975,right_31_976>@M * 
    HP_974(left_31_975,right_31_976)&true
 ,
 HP_800(left_31_972) ::=  emp&left_31_972=null]

POSSIBLE ALGO
=============
in tree.ss comment.


=============================================================
# tree-4.slk: FIXED

GOT
===
[ HP_0(x_35) ::=  
 emp&x_35=null
 or x_35::node<key_25_797,left_25_798,right_25_799>@M * HP_0(left_25_798) * 
    HP_1(right_25_799)&true
 ,
 HP_1(x_36) ::=  
 emp&x_36=null
 or x_36::node<key_25_797,left_25_798,right_25_799>@M * HP_1(left_25_798) * 
    HP_0(right_25_799)&true
 ]

WITH --sa-unify
===============
[ HP_0(x_35) ::=  
 emp&x_36=null
 or x_36::node<key_25_797,left_25_798,right_25_799>@M * HP_0(left_25_798) * 
    HP_0(right_25_799)&true
 ]

MISSING
=======
 HP_1(x) ::= HP_0(x)

/* 

=============================================================
# tree-4a.slk: FIXED


Added an equation:
==================
relAssume HP_1
 HP_1(x)&x!=null --> x::node<key_25_797,left_25_798,right_25_799>@M * 
  HP_1(left_25_798) * HP_1(right_25_799).

SEEMS BRITTLE (wrong HP_1 defn)
===============================

[ HP_0(x_41) ::=  
 emp&x_41=null
 or x_41::node<key_25_797,left_25_798,right_25_799>@M * HP_0(left_25_798)&
    right_25_799=null
 ,
 HP_1(right_25_42) ::=  emp&right_25_42=null]
*************************************

=============================================================
# tree-4a.slk: FIXED

We now GOT (which is very nice):

 HP_1(x_42) ::=  
 emp&x_42=null
 or x_42::node<key_25_797,left_25_798,right_25_799>@M 
     * HP_1(left_25_798) * HP_0(right_25_799)&true
 or x_42::node<key_25_797,left_25_798,right_25_799>@M 
     * HP_1(left_25_798) * (HP_1(right_25_799)/&\HP_0(right_25_799))&true
 ]

Two problems:
 (i) the 2nd disjunct should have disappeared after we
     do conj-unify; that is:

       LHS --> A
       LHS --> B
      ==============
       LHS --> A/\B
      where the two relAssume in premise is being REPLACED
      by the new relAssume in consequent.

 (ii) for the 3rd equation, it may be better to introduce
      or x_42::node<key_25_797,left_25_798,right_25_799>@M 
          * HP_1(left_25_798) * HP_1(right_25_799)
      HP_0(x) <--> HP_1(x)
      but I also note that --sa-unify will trigger that
      scenario.

=============================================================
# tree-4b.slk : DONE --pred-unify

GOT with --sa-unify
===
[ HP_0(x_33) ::=  
 emp&x_33=null
 or x_33::node<key_25_797,left_25_798,right_25_799>@M * HP_0(left_25_798) * 
    HP_0(right_25_799)&true
 ,
 HP_1(x_34) ::=  
 emp&x_34=null
 or x_34::node<key_25_797,left_25_798,right_25_799>@M * HP_1(left_25_798) * 
    HP_1(right_25_799)&true
 
I wondered why we did not get the same answer as tree-4.slk
which obtained a mutual-recursive HP_0,HP_1 which
was then unified. For tree-4b.slk, we have two indenpendent
recursion which are similar; and may be subject to unification; 
let us say pred-unify, as opposed to conj-unify or disj-unify?

[ HP_0(x_35) ::=  HP_1(x_35)&true,
 HP_1(x_36) ::=  
 emp&x_36=null
 or x_36::node<key_25_797,left_25_798,right_25_799>@M * HP_1(left_25_798) * 
    HP_1(right_25_799)&true
 ]

===================================================================
# single-bug-1.slk

infer [G] x::node<val_29_788,next_29_789> * G(y_31',t_32')
 &x=x' & next_29_789=y_31' & y_31'!=null & !(v_bool_30_769') 
 & y_31'!=null &  !(v_bool_30_769') & next_29_789=y_31' 
 & v_null_34_766'=null
 |-  t_32'::node<val_34_767',next_34_768'>. 
print residue.

# conflicts with --en-sleek-logging-txt from single.ss

GOT
===
 <1>EXISTS(t_32': x::node<val_29_788,next_29_789>@M[Orig] * HP_33(next_34_32,y_31') * HP_34(y_31',t_32')&x=x' & next_29_789=y_31' & y_31'!=null & !(v_bool_30_769') & y_31'!=null & !(v_bool_30_769') & next_29_789=y_31' & v_null_34_766'=null & val_34_31=val_34_767' & next_34_32=next_34_768'&{FLOW,(19,20)=__norm})[]
 inferred hprel: [G(y_31',t_32')&
                   y_31'!=null --> t_32'::node<val_34_31,next_34_32>@M * 
                   HP_33(next_34_32,y_31'@NI) * HP_34(y_31',t_32'@NI)&true]

but this seem different from below with residue G(..): WHY?
======================================================

 id: 11; caller: []; line: 34; classic: false; kind: BIND; hec_num: 5; evars: []; infer_vars: [H,G,HP_0]; c_heap: emp
 checkentail x::node<val_29_788,next_29_789>@M[Orig] * G(y_31',t_32')&x=x' & 
next_29_789=y_31' & y_31'!=null & !(v_bool_30_769') & y_31'!=null & 
!(v_bool_30_769') & next_29_789=y_31' & v_null_34_766'=null&
{FLOW,(22,23)=__norm}[]
 |-  t_32'::node<val_34_767',next_34_768'>@M[Orig]&true&{FLOW,(1,25)=__flow}[]. 
hprel_ass: [ G(next_29_789,t_32')&
  next_29_789!=null --> t_32'::node<val_34_802,next_34_803>@M * 
  HP_804(next_34_803,next_29_789) * HP_805(next_29_789,t_32')&true]
res:  [
  x::node<val_29_788,next_29_789>@M[Orig] * G(y_31',t_32') * HP_804(next_34_803,next_29_789) * HP_805(next_29_789,t_32')&x=x' & next_29_789=y_31' & y_31'!=null & !(v_bool_30_769') & y_31'!=null & !(v_bool_30_769') & next_29_789=y_31' & v_null_34_766'=null & val_34_767'=val_34_802 & next_34_768'=next_34_803&{FLOW,(22,23)=__norm}[]
  ]
*/


