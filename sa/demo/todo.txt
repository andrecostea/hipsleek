# dll-append3.ss

fails during assumption collection, does not infer l2::node ....
!!! >>>>>> mismatch ptr is not found (or inst) in the lhs <<<<<<
( [(,1 ); (,1 )]) :dll-append3.ss:22: 3: bind: node  l2'::node<next_22_776',prev_22_777'>@M[Orig] cannot be derived from context
 

# dll-app-bug3.ss  (WN : FIXED, I think)

  should not allow me to prove false, seems like a substitution problem


# dll-app-bug2.slk

relAssume G3
 l1::node<l2,p> * HP_844(n3,l1) * HP_845(p,l1) * l2::node<n3,l1> --> G3(l1,l2).
 
shape_infer [HP_844,HP_845][G3].

/*
# dll-app-bug2.slk

The input is circular but
WHY is there an exception??

ERROR: at _0:0_0:0 
Message: sau.find_root_x: dont have a root. what next?
 Fatal error: exception Failure("sau.find_root_x: dont have a root. what next?")
*/

# app.ss: FIXED

Problem with hip invoking shape_infer...

[ H1(c,y)&true --> c::node<val_16_787,next_16_788>@M * 
  (HP_789(next_16_788,y))&true,
 HP_789(next_16_788,y)&next_16_788!=null --> H1(next_16_788,y)&true,
 c::node<val_16_787,next_16_788>@M * (G1(next_16_788,y))&
  next_16_788!=null --> G1(c,y)&true,
 (HP_789(next_16_788,y)) * c::node<val_16_787,y>@M&
  next_16_788=null --> G1(c,y)&true]

Dangling predicate derived is wrong...

[ H1(c_836,y_837) ::= c_836::node<val_16_787,next_16_788>@M
    & XPURE(HP_789(next_16_788,y_837)),
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 G1(c_838,y_839) ::= c_838::node<val_16_787,y_840>@M * (HP_841(y_840,y_839))&true,
 HP_841(y_840,y_839) ::= 
 emp& XPURE(HP_789(next_16_788,y_839)) & y_839=y_840 & next_16_788=null
 or y_840::node<val_16_787,y_842>@M * (HP_841(y_842,y_839))&true
 ]

However, app.slk is OK it produced the correct result.
How come hip did not invoke shape_infer correctly?


[ H1(c_87,y_88) ::= c_87::node<val_16_751',next_16_752'>@M * (HP_4(next_16_752',y_88))&true,
 HP_4(next_16_89,y_90) ::= 
 emp&next_16_89=null
 or next_16_89::node<val_16_751',next_16_752'>@M * (HP_4(next_16_752',y_90))&
    true
 ,
 G1(c_91,y_92) ::= c_91::node<Anon_11,t>@M * (HP_93(t,y_92))&true,
 HP_93(t,y_92) ::= 
 emp&t=y_92
 or t::node<Anon_11,t_94>@M * (HP_93(t_94,y_92))&true
 ]

===================================================================
# sll-dll-bug2.slk: FIXED

infer [H1,HP_2,HP_3,G1]
 HP_2(pp,p) * HP_3(nn,p) * c::node<_,p,nn>@M 
  |-  H1(nn,c).

print residue.
/*
GOT:
====
 <1>emp&true&{FLOW,(19,20)=__norm}[]
 inferred hprel: [(HP_2(pp,p)) * (HP_3(nn,p)) * c::node<Anon_11,p,nn>@M&
                   true --> H1(nn,c)&true]
Expecting:
==========
   HP_3(nn,p) --> H1(nn,c)
   residue: HP_2(pp,p) * c::node<_,p,nn>@M


=====================================================================
# tree.slk

(H is both pre and post: not supported yet)
/* 

Why got two definitions for H?
Got: 
[ H(x) ::= x::node<l,r>@M& XPURE(HP_2(r)) &  XPURE(HP_1(l)),
 H(l_48) ::= l_48::node<l,r>@M * (H(l)) * (H(r))&true]


Expecting: [ H(x_119) ::= 
 emp&x_119=null
 or (H(r_63)) * (H(l_62)) * x_119::node<l_62,r_63>@M&true ]

*/


=====================================================================
# dll-append2.slk


 /* error during shape inference
 
 !!! >>>>>> pre-predicates: step pre-6: combine<<<<<<Fatal error: exception Failure("tl")

*/

similarly obtained for dll-append and dll_append2 and simpl-tree-trav




=====================================================================
# tll.ss

Why got two definitions for G?

got: 
[ H(x_980,r_981) ::= x_980::node<l,r,n>@M * HP_849(r,r_981)


 G(r,rr,l_47') ::=  H(l,l_47') & r!=null
 or HP_849(r,l_47') & r!=null
 
 G(x_984,r_985,res_986) ::= x_984::node<l,r,r_987> * HP_988(l,r,r_987,r_985,res_986)


 HP_849(r2,r_983) ::=  emp&r2=null
 or r2::node<l,r,n>@M * HP_849(r,r_983) & r!=null



 HP_988(l,r,r_987,r_995,res_986) ::= emp & r=null
 or l::node<l1,r2,r_991>@M * HP_988(l1,r2,r_991,l_879,res_986) & r!=null ]

=========================================================================
# sll-dll.ss FIXED (test with hip/ll-append10.ss)

GOT
===
[ H1(c,p)&c!=null --> c::node<val_20_807,prev_20_808,next_20_809>@M * 
  (HP_810(prev_20_808,p)) * (HP_811(next_20_809,p))&true,

 HP_811(next_20_809,p)&true --> H1(next_20_809,c')&true,

 (HP_810(prev_20_808,p)) * c::node<val_20_807,p,next_20_809>@M * 
  (G1(next_20_809,c))&true --> G1(c,p)&true,

 H1(c,p)& XPURE(H1(c,p)) & c=null --> G1(c,p)&true]
         ^^^^^^^^^^^^^^^
EXPECT:
=======
 H1(c,p)&c!=null --> c::node<val_21_809,prev_21_810,next_21_811>@M * 
  HP_2(prev_21_810,p) * HP_3(next_21_811,p)&true.
relAssume H1
 HP_3(next_20_809,p)&true --> H1(next_20_809,c')&true.
relAssume G1
 HP_2(prev_20_808,p) * c::node<val_20_807,p,next_20_809>@M * 
  G1(next_20_809,c)&true --> G1(c,p).
relAssume G1
 H1(c,p) & c=null --> G1(c,p).

--en-sleek-logging-txt

 checkentail H1(c,p)&c=null & !(v_bool_18_784') & c=null & !(v_bool_18_784')&
{FLOW,(22,23)=__norm}[]
 |-  G1(c,p)&true&{FLOW,(22,23)=__norm}[]. 
hprel_ass: [ H1(c,p)& XPURE(H1(c,p)) & c=null --> G1(c,p)&true]
                      ^^^^^^^^^^^^^^
res:  [
  emp&c=null & !(v_bool_18_784') & c=null & !(v_bool_18_784')&{FLOW,(22,23)=__norm}[]
  ]

This problem seems to be caused in "hip" as I was not
able to reproduce the same bug in sll-dll-bug3.slk.

FINAL expected:
===============
 HP_3(next_20_93,p_94) ::= H1(next_20_93,c')&true,
 H1(c_95,p_97) ::= 
 emp&c_95=null
 or (H1(next_21_54,c')) * c_95::node<val_21_52,prev_21_53,next_21_54>@M&
     XPURE(HP_2(prev_21_53,p_96))
 ,
 G1(c_98,p_99) ::= 
 emp&c_98=null
 or c_98::node<val_20_807,p_99,next_20_809>@M * (G1(next_20_809,c_98))&
     XPURE(HP_2(prev_20_808,p_99))
 ]

--sa-inlining

[ HP_3(next_20_93,p_94) ::= H1(next_20_93,c')&true,
 H1(c_95,p_97) ::= 
 (H1(next_21_54,c')) * c_95::node<val_21_52,UU_HP_2_UU,next_21_54>@M&true
 or emp&c_95=null
 ,
 G1(c_98,p_99) ::= 
 c_98::node<val_20_807,p_99,next_20_809>@M * (G1(next_20_809,c_98))&true
 or emp&c_98=null
 ]


=========================================================================
# tree.ss FIXED (test with hip/ll-append10.ss)

infer [H,G] requires H(x) ensures G(x);

PROBLEM with spurious XPURE
---------------------------
[ H(x)&x!=null --> x::node<left_24_795,right_24_796>@M * 
  (HP_797(left_24_795)) * (HP_798(right_24_796))&true,
 HP_797(left_24_795)&true --> H(left_24_795)&true,
 HP_798(right_24_796)&true --> H(right_24_796)&true,
 H(x)& XPURE(H(x)) & x=null --> G(x)&true,
       ^^^^^^^^^^^
 x::node<left_24_795,right_24_796>@M * (G(left_24_795)) * (G(right_24_796))&
  true --> G(x)&true]

=========================================================================
# pair-bug2.slk: FIXED

HeapPred G1(cell a, cell b).

infer [G1] x::cell<a> * y::cell<b> |-  G1(x,y). 
print residue.
/*
<1>y::cell<b>@M[Orig]&true&{FLOW,(19,20)=__norm}[]
 inferred hprel: [x::cell<a>@M&true --> G1(x,y)&true]

which seems to have lost y::cell<a>. I suppose, we may need to
try capture both sets of links from x,y for folding; so that we
will have:

 x::cell<a>@M * y::cell<b> --> G1(x,y)&true]

We probably can try to traverse separately, each parameter
that can be instantiated. Thus, for post-pred, we also determine
the parameters that can be instantiated to pick set of heap state
from that parameter.

For non-instantiation annotation, I suggest:

 HeapPred G1(cell@NI a, cell b).
 HeapPred G1(cell a, cell@NI b).

============================================================
# zip-bug2.slk  FIXED


pred ltwo<p:node> == 
   p::node<_,null> & self = null  or 
   self::node<_, q> * p::node<_,r> * q::ltwo<r>.

/*
  why isn't p a materialized var?
  materialized vars: 
  addr vars: 
*/


checkentail 
 x::ltwo<y>
 & x=null 
 |-  y::ll<>.
print residue.

/*
 why did the above fail? why didn't
 we unfold x::ltwo<y>? when we detect some materialized var?
*/

============================================================
# zip.ss FIXED

weird bug here..

 id: 10; caller: []; line: 22; classic: false; kind: POST; hec_num: 4; evars: []; infer_vars: []; c_heap: y_820::ll@M[1][Orig]
 checkentail emp&x=null & y=y_820 & x=null & v_bool_24_800' & x=null & v_bool_24_800' & 
v_null_24_781'=null & res=v_null_24_781'&{FLOW,(22,23)=__norm}[]
 |-  emp&res=x&{FLOW,(22,23)=__norm}[]. 
res:  failctx
         fe_kind: MAY
         fe_name: logical bug
         fe_locs: {
                   fc_message: failed in entailing pure formula(s) in conseq
                   fc_current_lhs_flow: {FLOW,(22,23)=__norm}}

============================================================
# zip-bug1c.slk FIXED

checkentail  x=null & res=null
 |-  res=x. 

/*
 above currently fails due to our translation:
    x=null --> x<=0
 I guess the solution to this problem is to explicitly
 add x=res is to collect the set of vars {x,res} which are
 v=null and then to explicitly add their equality
 using x=res on the LHS.

 For example, if we have:
 x=null & res=null & y=null
 |-  x=y. 

 We should transform antecedent to:
 x=null & res=null & y=null & x=res & res=y
 and then prove:

 x=null & res=null & y=null & x=res & res=y
 |- x=y


*/

============================================================
# dll-app-bug1d.slk: FIXED

infer [HP_7] // (1)
HP_7(x,l2) & x!=null |-  x::node<_,_>@M.
print residue.
// should fail
/*
GOT:
 <1>(HP_28(Anon_26,l2)) * (HP_29(Anon_27,l2))&x!=null & Anon_11=Anon_26 & Anon_1
2=Anon_27&{FLOW,(19,20)=__norm}[]
 inferred hprel: [HP_7(x,l2)&x!=null --> x::node<Anon_26,Anon_27>@M * 
                   (HP_28(Anon_26,l2)) * (HP_29(Anon_27,l2))&true]

but should FAIL since x is @NI (non-instantiating)
*/

infer [HP_7] //(2)
HP_7(x,l2) & x!=null |-  l2::node<_,_>@M.
print residue.
// should succeed
// HP_7(x,l2) --> l2::node<p,q>*HP_10(p,x#)*HP_11(q,x#)
/*
GOT:
====
 <1>(HP_39(Anon_37,x)) * (HP_40(Anon_38,x))&x!=null & Anon_13=Anon_37 & Anon_14=Anon_38&{FLOW,(19,20)=__norm}[]
 inferred hprel: [HP_7(x,l2)&x!=null --> (HP_39(Anon_37,x)) * 
                   (HP_40(Anon_38,x))&true]
BUI instantiation is WRONG. Should have been:
 HP_7(x,l2) & x!=null --> l2::node<p,q>*HP_10(p,x#)*HP_11(q,x#)

*/

============================================================
# dll-app-bug1d1.slk: FIXED

HeapPred HP_9(node a,node b).

infer [HP_9] //(3)
HP_9(x,l2) & x!=null |-  l2::node<_,_>@M.
print residue.
// should succeed
/*
GOT:
 inferred hprel: [HP_9(x,l2)&x!=null --> l2::node<Anon_24,Anon_25>@M * 
                   (HP_26(Anon_24,x)) * (HP_27(Anon_25,x))&true]

EXPECTING:

 HP_9(x,l2)  & x!=null
  --> l2::node<p,q>*HP_10(p,x@NI)*HP_11(q,x@NI)*HP_12(x,l2@NI)

Please use the above instead of:
 HP_9(x,l2)  & x!=null
  --> l2::node<p,q>*HP_10(p,x)*HP_11(q,x)*HP_12(x,l2)

*/

============================================================
# dll-app-bug1d2.slk: FIXED
HeapPred HP_7(node@NI a,node b).

infer [HP_7] //(2)
HP_7(x,l2) & x!=null |-  l2::node<_,_>@M.
print residue.
// should succeed

/*

GOT:
====
 inferred hprel: [HP_7(x,l2)&x!=null --> l2::node<Anon_22,Anon_23>@M * 
                   (HP_24(Anon_22,x)) * (HP_25(Anon_23,x))&true]

Can you print it as:

 HP_7(x@NI,l2)&x!=null --> l2::node<Anon_22,Anon_23>@M * 
         HP_24(Anon_22,x@NI) * HP_25(Anon_23,x@NI)

*/
============================================================
# pair2-bug1.slk  FIXED

HeapPred H1(cell a, cell b).

infer [H1] H1(x,y) |- x::cell<a>.
print residue.

/*


GOT
===
 <1>emp&a=a_18&{FLOW,(19,20)=__norm}[]
 inferred hprel: [H1(x,y)&true --> x::cell<a_18>@M&true]

SHOULD BE
=========
 H1(x,y)&true --> x::cell<a_18>@M * HP_2(y,x@NI)

*/

============================================================
# pair2.ss FIXED


[ H1(x,y)&true --> x::cell<val_20_783>@M * (HP_784(y,x))&true,
 HP_784(y,x)&true --> y::cell<val_21_788>@M&true,
 x::cell<val_20_783>@M * y::cell<val_21_788>@M&true --> G1(x,y)&true]

GOT
 H1(x_828,y_829) ::= y_829::cell<val_21_788>@M&true,
 G1(x_832,y_833) ::= x_832::cell<val_20_783>@M * y_833::cell<val_21_788>@M&true]

EXPECTING:
 H1(x_828,y_829) ::= 
   x::cell<val_20_783>@M * y_829::cell<val_21_788>@M&true,
 G1(x_832,y_833) ::= x_832::cell<val_20_783>@M * y_833::cell<val_21_788>@M&t
*/


============================================================
# pair2-bug2.slk FIXED

relAssume H1
 H1(x,y) --> x::cell<val_20_783> * HP_4(y,x).
relAssume HP_4
 HP_4(y,x) --> y::cell<val_21_788> .
relAssume G1
 x::cell<val_20_783> * y::cell<val_21_788> --> G1(x,y).
shape_infer [H1,HP_4][G1].

GOT
===
[ H1(x_64,y_65) ::= y_65::cell<val_21_788>@M&true,
 HP_4(y_66,x_67) ::= y_66::cell<val_21_788>@M&true,
 G1(x_68,y_69) ::= x_68::cell<val_20_783>@M * y_69::cell<val_21_788>@M&true]

WRONG H1 defn:
===============
Missing:
 H1(x_64,y_65) ::= x::cell<val_20_783> * y_65::cell<val_21_788>@M&true,


Steps
=====
Confirm HP_4 as an equation:
 HP_4(y,x) --> y::cell<val_21_788> .
to:
 HP_4(y,x) <--> y::cell<val_21_788> .

Strengthen consequent of H1:
 H1(x,y) --> x::cell<val_20_783> * y::cell<val_21_788>

Confirm H1 as an equation:
 H1(x,y) <--> x::cell<val_20_783> * y::cell<val_21_788>

Confirm G1 as an equation:
 x::cell<val_20_783> * y::cell<val_21_788> <--> G1(x,y).


*/

infer [HP_7] //(2)
HP_7(x,l2) & x=null |-  x::node<_,_>@M.
print residue.
// should succeed

/*

============================================================
# dll-app-bug1d3.slk    FIXED (by Cristian)

GOT
==
 <1>(HP_24(Anon_22,l2)) * (HP_25(Anon_23,l2)) * (HP_26(l2,x))&x=null & Anon_11=Anon_22 & Anon_12=Anon_23&{FLOW,(19,20)=__norm}[]
 inferred hprel: [HP_7(x,l2)&x=null --> x::node<Anon_22,Anon_23>@M * 
                   (HP_24(Anon_22,l2@NI)) * (HP_25(Anon_23,l2@NI)) * 
                   (HP_26(l2,x@NI))&true]

Should have been a contradiction lemma of the form instead.
It was working before.

  HP_7(x,l) --> x!=null

============================================================
#foo.ss: FIXED

GOT:
  H(x)&true --> x::node<val_19_788,next_19_789>@M * (HP_790(next_19_789))&true,
 HP_790(next_19_789)&next_19_789!=null --> H(next_19_789)&true,
 x::node<val_19_788,v_node_20_807>@M&true --> G(x)&true,
 (HP_790(next_19_789)) * x::node<val_19_788,next_19_789>@M&
  next_19_789=null --> G(x)&true]

EXPECTED:

  H(x)&true --> x::node<val_19_788,next_19_789>@M * (HP_790(next_19_789))&true,
 HP_790(next_19_789)&next_19_789!=null --> H(next_19_789)&true,
 x::node<val_19_788,v_node_20_807>@M * G(v_node_20_807) &true --> G(x)&true,
                                       ^^^^^^^^^^^^^^^^
 (HP_790(next_19_789)) * x::node<val_19_788,next_19_789>@M&
  next_19_789=null --> G(x)&true]

When G has two parameters:
===========================
[ H(x)&true --> x::node<val_22_792,next_22_793>@M * (HP_794(next_22_793))&true,
 HP_794(next_22_793)&next_22_793!=null --> H(next_22_793)&true,
 (G(next_22_793,r_812)) * x::node<val_22_792,next_22_793>@M&
  next_22_793!=null --> G(x,r_814)&true,
 (HP_794(next_22_793)) * x::node<val_22_792,next_22_793>@M&
  next_22_793=null --> G(x,r_815)&true]

============================================================
#zip-bug4.slk


============================================================
# zip-1.ss

going into a LOOP!

!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!! >>>>>> step 3a: simplification <<<<<<
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!! >>>>>> step 3a: simplification <<<<<<
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!! >>>>>> step 3a: simplification <<<<<<
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!! >>>>>> step 3a: simplification <<<<<<
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<^C
l

============================================================
# foo.slk: FIXED

  Need to include res=x below!
*/

infer [G] G(next_22_793,r_812) * x::node<val_22_792,next_22_793>&
next_22_793!=null 
//& v_bool_22_771' & next_22_793!=null & v_bool_22_771' 
//& next_22_793=next_22_793 
& res=x
 |-  G(x,r). 
print residue.
/*
 <1>emp&next_22_793!=null & res=x & r=r_24&{FLOW,(19,20)=__norm}[]
 inferred hprel: [(G(next_22_793,r_812)) * x::node<val_22_792,next_22_793>@M&
                   next_22_793!=null --> G(x,r_24)&true]
*/



infer [G,H4] H4(next_22_793) * x::node<val_22_792,next_22_793> &
next_22_793=null 
//& !(v_bool_22_771') & next_22_793=null & !(v_bool_22_771') 
& res=x
 |-  G(x,r). 

print residue.
/*
 <1>emp&next_22_793=null & res=x & r=r_34&{FLOW,(19,20)=__norm}[]
 inferred hprel: [(H4(next_22_793)) * x::node<val_22_792,next_22_793>@M&
                   next_22_793=null --> G(x,r_34)&true]
*/

===============================================================
# zip.ss

Problems, 
 (i) why ins't @NI printing?
 (ii) Why did we have:
            H1(x,y) x=null?


[ H1(x,y)&x!=null --> x::node<val_24_819,next_24_820>@M * 
  (HP_821(next_24_820,y)) * (HP_822(y,x))&true,
 (HP_821(next_24_820,y)) * (HP_822(y,x))&
  true --> y::node<val_25_826,next_25_827>@M * (HP_828(next_25_827,x))&true,
 HP_828(next_25_827,x)&true --> H1(next_24_820,next_25_827)&true,
 H1(x,y)&x=null & res=null --> G1(x,y,res)&true,
 y::node<val_25_826,next_25_827>@M * x::node<val_24_819,next_24_820>@M&
  res=x --> G1(x,y,res)&true]

======>

[ H1(x_1059,y_1060) ::= emp&x_1059=null,
 G1(x_1061,y_1062,res_1063) ::= 
 emp&res_1063=null & x_1061=null
 or y_1062::node<val_25_826,next_25_827>@M * 
    x_1061::node<val_24_819,next_24_820>@M&res_1063=x_1061
 ]


*/

===============================================================
# zip-bug5.slk: FIXED

infer [HP_1,HP_2] HP_1(next_24_820,y) * HP_2(y,x) * 
x::node<val_24_819,next_24_820> 
& x!=null 
 |-  y::node<val_25_781',next_25_782'>@L. 
print residue.

/*

GOT below but HP_1(..) not needed: We need to traverse from
y but we should not pick from HP_1 since it has y@NI

 inferred hprel: [(HP_1(next_24_820,y@NI)) * (HP_2(y,x@NI))&
                   true --> y::node<val_25_33,next_25_34>@M * 
                   (HP_35(next_25_34,x#))&true]

EXPECTING
 inferred hprel: [(HP_2(y,x@NI))
                   --> y::node<val_25_33,next_25_34>@M * 
                   (HP_35(next_25_34,x#))&true]
infer [HP_1,HP_2,HP_8,H1] 
HP_8(next_25_827,x) * y::node<val_25_826,next_25_827> * 
//x'::node<val_24_819,next_24_820>
* HP_1(next_24_820,y)
&x=x' & y=y' 
& x'!=null 
//& !(v_bool_21_795') & x'!=null & !(v_bool_21_795') 
& n1_34'=val_24_819 & n2_35'=val_25_826 & val_24_819=n2_35'+n1_34' 
& next_24_820=v_node_27_791' & 
next_25_827=v_node_27_790'
 |-  H1(v_node_27_791',v_node_27_790').

print residue.

/*

===============================================================
# zip-bug5a.slk: FIXED

GOT
 inferred hprel: [(HP_8(v_node_27_790',x@NI)) * (HP_1(v_node_27_791',y@NI))&
                   true --> (H1(v_node_27_791',v_node_27_790')) * (HP_37(x))&
                   true]

Why do we instantiate HP_37(x)? We should not instantiate
for parameters that has been marked as x@NI.
We can instantiate for FIELDS an for parameters that are not marked
as @NI

===============================================================
# zip-bug5b.slk: FIXED

infer [HP_1,HP_2,HP_8,H1,G1] 
y::node<val_25_826,next_25_827> * 
G1(next_24_820,next_25_827,next_24_820) * 
x::node<val_24_819,next_24_820>@M
&x!=null 
//& !(v_bool_21_795') & x!=null & !(v_bool_21_795') 
//& val_24_819=val_25_826+val_24_819 & next_24_820=next_24_820 & next_25_827=next_25_827 
& res=x
 |-  G1(x,y,res). 

print residue.

====

GOT
 inferred hprel: [y::node<val_25_826,next_25_827>@M * 
                   x::node<val_24_819,next_24_820>@M&res=x --> G1(x,y,res)&
                   true]

Why isn't G1(next_24_820,next_25_827,next_24_820) 
picked up?

EXPECTING :

 inferred hprel: [y::node<val_25_826,next_25_827>@M * 
                   x::node<val_24_819,next_24_820>@M
                   * G1(next_24_820,next_25_827,next_24_820) 
                   &res=x --> G1(x,y,res)&
                   true]
===============================================================
# conseq1.slk: FIXED (the example, not code)

//(3)
infer [H1,H2] //FIXED: add H2 as selected hp
x::node<_,n1> * y::node<_,n2> * H2(n1,_) |-  H1(x,y). 
print residue.
/*
WRONG : missing H2(n1,_)

 <1>H2(n1,Anon_18)&true&{FLOW,(19,20)=__norm}[]
 inferred hprel: [x::node<Anon_16,n1>@M * y::node<Anon_17,n2>@M&
                   true --> H1(x,y)&true]
*/

//(4)
infer [H1,H2,H3] FIXED
x::node<_,n1> * y::node<_,n2> * H2(n1,_) * H3(_,n2) |-  H1(x,y). 
print residue.
/*
WRONG : missing H2(n1,_)*H3(_,n2)

 <1>H2(n1,Anon_18)&true&{FLOW,(19,20)=__norm}[]
 inferred hprel: [x::node<Anon_16,n1>@M * y::node<Anon_17,n2>@M&
                   true --> H1(x,y)&true]
*/
===============================================================
# pre-2.slk

relAssume P
  P(x#I) --> x::node<q>*P2(q#?).

relAssume P2
  P2(x)  --> P(x).

shape_infer[P,P2][].

/*

WRONG:
[ P(x_28) ::= x_28::node<q_21>@M * (P(q_21)) * (P(q_23)) * q_21::node<q_23>@M&true,
 P2(x_29) ::= x_29::node<q>@M * (P2(q))&true]

STEPS
=====
first confirm P:
  P(x) <--> x::node<q>*P2(q).
  P2(x)  --> P(x).
         --> x::node<q>*P2(q).
confirm P2
  P2(x)  <--> x::node<q>*P2(q).


Confirm P2
  P2(x)  --> P(x)
         <--> P(x)
  P(x) --> x::node<q>*P2(q).
       --> x::node<q>*P(q).
Confirm P
  P(x) <--> x::node<q>*P(q).

===============================================================
# pre-2a.slk


===============================================================
# id.ss:

cell id (cell x)
 infer [P,G]  requires P(x)  ensures  G(x,res);
//requires true  ensures  x=res;
{
  return x;
}

/*

A predicate is non-dangling if it is being used
for a pre-pred definition.
I suppose dangling classification may have to be
done after base-case splitting.


[ P(x)&res=x --> G(x,res)&true]

====

[ P(x) ::= emp& XPURE(P(x)),
 G(x_773,res_774) ::= emp&res_774=x_773 &  XPURE(P(x_773))]

====

Sufficient to use:

  P(x) --> emp
  res=x --> G(x,res)

====>
  P(x)     <--> true
  G(x,res) <--> res=x

*/

===============================================================
# zip-bug5c.slk   OK now

infer [HP_1,HP_2]
HP_1(next_24_820,y) * HP_2(y,x) * 
x::node<val_24_819,next_24_820>@M & x!=null 
 |-  y::node<_,next_25_782'>@L. 
print residue.

/*

GOT
 inferred hprel: [(HP_1(next_24_820,y@NI)) * (HP_2(y,x@NI))&
                   true --> y::node<Anon_30,next_25_31>@M * 
                   (HP_32(next_25_31,x@NI))&true]

Why did you pick HP_1(..,y@NI)?

EXPECT
======
 inferred hprel: [HP_2(y,x@NI) &
                   true --> y::node<Anon_30,next_25_31>@M * 
                   (HP_32(next_25_31,x@NI))&true]

===============================================================
# zip1.slk: FIXED

shape_infer[H1,HP_2,HP_1,HP_8][G1].

/*

[ HP_8(next_25_827,x_77) ::= emp& XPURE(HP_8(next_25_827,x_77)),
 HP_1(next_24_75,y_76) ::= emp& XPURE(HP_1(next_24_75,y_76)),
 H1(x_176,y_177) ::= emp&x_176=null,
 HP_2(y_178,x_179) ::= y_178::node<val_25_826,next_25_827>@M& XPURE(HP_8(next_25_827,x_179)),
 G1(x_180,y_181,res_183) ::= 
 emp&x_180=null
 or y_181::node<val_25_826,next_25_827>@M * x_180::node<val_24_819,nn>@M * 
    (G1(nn,next_25_827,nn))&true
 ]

WHY do we use XPURE(..) when I have specified all the predicates as non-dangling??

*/
===============================================================
# zip1.slk 

GOT
====

[ HP_2(y_176,x_177) ::= y_176::node<val_25_826,next_25_827>@M * (HP_8(next_25_827,x_177))&true,

 HP_1(next_24_820,y) ::= (H1(x,y)) * (HP_2(y,x))&true,
 HP_8(next_25_827,x) ::= HP_2(y,x)&true,

 H1(x_178,y_179) ::= 
 emp&x_178=null
 or (H1(next_24_103,next_25_101)) * y_179::node<val_25_100,next_25_101>@M * 
    x_178::node<val_24_102,next_24_103>@M&true
 ,

 G1(x_180,y_181,res_183) ::= 
 emp&x_180=null
 or y_181::node<val_25_826,next_25_827>@M * x_180::node<val_24_819,nn>@M * 
    (G1(nn,next_25_827,nn))&true
 ]

PROBLEMS
========
Why did we get:
 HP_1(next_24_820,y) ::= (H1(x,y)) * (HP_2(y,x))&true,
 HP_8(next_25_827,x) ::= HP_2(y,x)&true,

EXPECTING: (tupled definition for two pre-pred)
 (HP_1(next_24_820,y@NI)) * (HP_8(next_25_827,x@NI))&
  true <--> H1(next_24_820,next_25_827)&true,

======================================================

# zip.ss

Wrong answer:
============
[ H(x_934,y_935) ::= emp&x_934=null,
 G1(x_941,y_939,res_940) ::= 
 emp&res_940=null
 or y_939::node<val_35_810,next_35_811>@M * 
    (G1(next_34_804,next_35_811,v_node_37_842)) * 
    res_940::node<v_int_36_826,v_node_37_842>@M&true
 ]

Relational assumption OK (except for G1) see zip1.slk
=========================================
[ H(x,y)&x!=null --> x::node<val_34_803,next_34_804>@M * 
  (HP_805(next_34_804,y@NI)) * (HP_806(y,x@NI))&true,
 HP_806(y,x@NI)&true --> y::node<val_35_810,next_35_811>@M * 
  (HP_812(next_35_811,x@NI))&true,
 (HP_805(next_34_804,y@NI)) * (HP_812(next_35_811,x@NI))&
  true --> H(next_34_804,next_35_811)&true,
 H(x,y)&x=null --> emp&true,
 emp&x=null & res=null --> G1(x,y,res)&true,
 y::node<val_35_810,next_35_811>@M * 
  (G1(next_34_804,next_35_811,v_node_37_842)) * 
  x::node<v_int_36_826,v_node_37_842>@M&res=x --> G1(x,y,res)&true]

[ H(x,y)&x!=null --> x::node<val_34_803,next_34_804>@M * 
  (HP_805(next_34_804,y@NI)) * (HP_806(y,x@NI))&true,
 HP_806(y,x@NI)&true --> y::node<val_35_810,next_35_811>@M * 
  (HP_812(next_35_811,x@NI))&true,
 (HP_805(next_34_804,y@NI)) * (HP_812(next_35_811,x@NI))&
  true --> H(next_34_804,next_35_811)&true,
 H(x,y)&x=null --> emp&true,
 emp&x=null & res=null --> G1(x,y,res)&true,
 y::node<val_35_810,next_35_811>@M * 
  (G1(next_34_804,next_35_811,v_node_37_842)) * 
  x::node<v_int_36_826,v_node_37_842>@M&res=x --> G1(x,y,res)&true]
*

=============================================================
# zip1b.slk

When HL is non-dangling:
It introduced HL(Y) :: emp. 
Can we avoid this, as it has nullified uninterpreted predicates.


[ HP_2(y_242,x_243) ::= y_242::node<val_25_826,next_25_827>@M * (HP_8(next_25_827,x_243))&true,
 H1(x_244,y_245) ::= 
 emp&x_244=null
 or (H1(next_24_109,next_25_107)) * y_245::node<val_25_106,next_25_107>@M * 
    x_244::node<val_24_108,next_24_109>@M&true
 ,
 HL(y_246) ::= emp&true,
 HP_1(next_24_820,y) ::= (H1(x,y)) * (HP_2(y,x))&true,
 HP_8(next_25_827,x) ::= HP_2(y,x)&true,
 G1(x_247,y_248,res_250) ::= 
 emp&x_247=null
 or y_248::node<val_25_826,next_25_827>@M * x_247::node<val_24_819,nn>@M * 
    (G1(nn,next_25_827,nn))&true
 ]

=============================================================
# zip1c.slk: DONE with --sa-s-split

3) We had a split:
relAssume G1
 H1(x,y) & x=null & res=null --> G1(x,y,res).

Since y is instantiating. Perhaps, we should have a special SPLIT
that preserves its data using a special predicate HL(y).
 H1(x,y)&x=null  --> HL(y)
 HL(y) & x=null & res=null --> G1(x,y,res)

=============================================================
# zip1d.slk: FIXED (test zip.ss: check inferred rel_assumption of base cases)

(2) Also, for G, we seem to lose the relation x=r. Why is it missing??
 EXPECTING:
 G1(x_180,y_181,res_183) ::= 
 emp&x_180=null  //& x=r
 or y_181::node<val_25_826,next_25_827>@M * x_180::node<val_24_819,nn>@M * 
    (G1(nn,next_25_827,nn))  //& x=r


