# app.ss: FIXED

Problem with hip invoking shape_infer...

[ H1(c,y)&true --> c::node<val_16_787,next_16_788>@M * 
  (HP_789(next_16_788,y))&true,
 HP_789(next_16_788,y)&next_16_788!=null --> H1(next_16_788,y)&true,
 c::node<val_16_787,next_16_788>@M * (G1(next_16_788,y))&
  next_16_788!=null --> G1(c,y)&true,
 (HP_789(next_16_788,y)) * c::node<val_16_787,y>@M&
  next_16_788=null --> G1(c,y)&true]

Dangling predicate derived is wrong...

[ H1(c_836,y_837) ::= c_836::node<val_16_787,next_16_788>@M
    & XPURE(HP_789(next_16_788,y_837)),
      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 G1(c_838,y_839) ::= c_838::node<val_16_787,y_840>@M * (HP_841(y_840,y_839))&true,
 HP_841(y_840,y_839) ::= 
 emp& XPURE(HP_789(next_16_788,y_839)) & y_839=y_840 & next_16_788=null
 or y_840::node<val_16_787,y_842>@M * (HP_841(y_842,y_839))&true
 ]

However, app.slk is OK it produced the correct result.
How come hip did not invoke shape_infer correctly?


[ H1(c_87,y_88) ::= c_87::node<val_16_751',next_16_752'>@M * (HP_4(next_16_752',y_88))&true,
 HP_4(next_16_89,y_90) ::= 
 emp&next_16_89=null
 or next_16_89::node<val_16_751',next_16_752'>@M * (HP_4(next_16_752',y_90))&
    true
 ,
 G1(c_91,y_92) ::= c_91::node<Anon_11,t>@M * (HP_93(t,y_92))&true,
 HP_93(t,y_92) ::= 
 emp&t=y_92
 or t::node<Anon_11,t_94>@M * (HP_93(t_94,y_92))&true
 ]

===================================================================
# sll-dll-bug2.slk: FIXED

infer [H1,HP_2,HP_3,G1]
 HP_2(pp,p) * HP_3(nn,p) * c::node<_,p,nn>@M 
  |-  H1(nn,c).

print residue.
/*
GOT:
====
 <1>emp&true&{FLOW,(19,20)=__norm}[]
 inferred hprel: [(HP_2(pp,p)) * (HP_3(nn,p)) * c::node<Anon_11,p,nn>@M&
                   true --> H1(nn,c)&true]
Expecting:
==========
   HP_3(nn,p) --> H1(nn,c)
   residue: HP_2(pp,p) * c::node<_,p,nn>@M


=====================================================================
# tree.slk

/* 

Why got two definitions for H?
Got: 
[ H(x) ::= x::node<l,r>@M& XPURE(HP_2(r)) &  XPURE(HP_1(l)),
 H(l_48) ::= l_48::node<l,r>@M * (H(l)) * (H(r))&true]


Expecting: [ H(x_119) ::= 
 emp&x_119=null
 or (H(r_63)) * (H(l_62)) * x_119::node<l_62,r_63>@M&true ]

*/


=====================================================================
# dll-append2.slk


 /* error during shape inference
 
 !!! >>>>>> pre-predicates: step pre-6: combine<<<<<<Fatal error: exception Failure("tl")

*/

similarly obtained for dll-append and dll_append2 and simpl-tree-trav




=====================================================================
# tll.ss

Why got two definitions for G?

got: 
[ H(x_980,r_981) ::= x_980::node<l,r,n>@M * HP_849(r,r_981)


 G(r,rr,l_47') ::=  H(l,l_47') & r!=null
 or HP_849(r,l_47') & r!=null
 
 G(x_984,r_985,res_986) ::= x_984::node<l,r,r_987> * HP_988(l,r,r_987,r_985,res_986)


 HP_849(r2,r_983) ::=  emp&r2=null
 or r2::node<l,r,n>@M * HP_849(r,r_983) & r!=null



 HP_988(l,r,r_987,r_995,res_986) ::= emp & r=null
 or l::node<l1,r2,r_991>@M * HP_988(l1,r2,r_991,l_879,res_986) & r!=null ]

=========================================================================
# sll-dll.ss FIXED (test with hip/ll-append10.ss)

GOT
===
[ H1(c,p)&c!=null --> c::node<val_20_807,prev_20_808,next_20_809>@M * 
  (HP_810(prev_20_808,p)) * (HP_811(next_20_809,p))&true,

 HP_811(next_20_809,p)&true --> H1(next_20_809,c')&true,

 (HP_810(prev_20_808,p)) * c::node<val_20_807,p,next_20_809>@M * 
  (G1(next_20_809,c))&true --> G1(c,p)&true,

 H1(c,p)& XPURE(H1(c,p)) & c=null --> G1(c,p)&true]
         ^^^^^^^^^^^^^^^
EXPECT:
=======
 H1(c,p)&c!=null --> c::node<val_21_809,prev_21_810,next_21_811>@M * 
  HP_2(prev_21_810,p) * HP_3(next_21_811,p)&true.
relAssume H1
 HP_3(next_20_809,p)&true --> H1(next_20_809,c')&true.
relAssume G1
 HP_2(prev_20_808,p) * c::node<val_20_807,p,next_20_809>@M * 
  G1(next_20_809,c)&true --> G1(c,p).
relAssume G1
 H1(c,p) & c=null --> G1(c,p).

--en-sleek-logging-txt

 checkentail H1(c,p)&c=null & !(v_bool_18_784') & c=null & !(v_bool_18_784')&
{FLOW,(22,23)=__norm}[]
 |-  G1(c,p)&true&{FLOW,(22,23)=__norm}[]. 
hprel_ass: [ H1(c,p)& XPURE(H1(c,p)) & c=null --> G1(c,p)&true]
                      ^^^^^^^^^^^^^^
res:  [
  emp&c=null & !(v_bool_18_784') & c=null & !(v_bool_18_784')&{FLOW,(22,23)=__norm}[]
  ]

This problem seems to be caused in "hip" as I was not
able to reproduce the same bug in sll-dll-bug3.slk.

FINAL expected:
===============
 HP_3(next_20_93,p_94) ::= H1(next_20_93,c')&true,
 H1(c_95,p_97) ::= 
 emp&c_95=null
 or (H1(next_21_54,c')) * c_95::node<val_21_52,prev_21_53,next_21_54>@M&
     XPURE(HP_2(prev_21_53,p_96))
 ,
 G1(c_98,p_99) ::= 
 emp&c_98=null
 or c_98::node<val_20_807,p_99,next_20_809>@M * (G1(next_20_809,c_98))&
     XPURE(HP_2(prev_20_808,p_99))
 ]

--sa-inlining

[ HP_3(next_20_93,p_94) ::= H1(next_20_93,c')&true,
 H1(c_95,p_97) ::= 
 (H1(next_21_54,c')) * c_95::node<val_21_52,UU_HP_2_UU,next_21_54>@M&true
 or emp&c_95=null
 ,
 G1(c_98,p_99) ::= 
 c_98::node<val_20_807,p_99,next_20_809>@M * (G1(next_20_809,c_98))&true
 or emp&c_98=null
 ]


=========================================================================
# tree.ss FIXED (test with hip/ll-append10.ss)

infer [H,G] requires H(x) ensures G(x);

PROBLEM with spurious XPURE
---------------------------
[ H(x)&x!=null --> x::node<left_24_795,right_24_796>@M * 
  (HP_797(left_24_795)) * (HP_798(right_24_796))&true,
 HP_797(left_24_795)&true --> H(left_24_795)&true,
 HP_798(right_24_796)&true --> H(right_24_796)&true,
 H(x)& XPURE(H(x)) & x=null --> G(x)&true,
       ^^^^^^^^^^^
 x::node<left_24_795,right_24_796>@M * (G(left_24_795)) * (G(right_24_796))&
  true --> G(x)&true]

=========================================================================
# pair-bug2.slk: FIXED

HeapPred G1(cell a, cell b).

infer [G1] x::cell<a> * y::cell<b> |-  G1(x,y). 
print residue.
/*
<1>y::cell<b>@M[Orig]&true&{FLOW,(19,20)=__norm}[]
 inferred hprel: [x::cell<a>@M&true --> G1(x,y)&true]

which seems to have lost y::cell<a>. I suppose, we may need to
try capture both sets of links from x,y for folding; so that we
will have:

 x::cell<a>@M * y::cell<b> --> G1(x,y)&true]

We probably can try to traverse separately, each parameter
that can be instantiated. Thus, for post-pred, we also determine
the parameters that can be instantiated to pick set of heap state
from that parameter.

For non-instantiation annotation, I suggest:

 HeapPred G1(cell@NI a, cell b).
 HeapPred G1(cell a, cell@NI b).

============================================================
# zip-bug2.slk  FIXED


pred ltwo<p:node> == 
   p::node<_,null> & self = null  or 
   self::node<_, q> * p::node<_,r> * q::ltwo<r>.

/*
  why isn't p a materialized var?
  materialized vars: 
  addr vars: 
*/


checkentail 
 x::ltwo<y>
 & x=null 
 |-  y::ll<>.
print residue.

/*
 why did the above fail? why didn't
 we unfold x::ltwo<y>? when we detect some materialized var?
*/

============================================================
# zip.ss FIXED

weird bug here..

 id: 10; caller: []; line: 22; classic: false; kind: POST; hec_num: 4; evars: []; infer_vars: []; c_heap: y_820::ll@M[1][Orig]
 checkentail emp&x=null & y=y_820 & x=null & v_bool_24_800' & x=null & v_bool_24_800' & 
v_null_24_781'=null & res=v_null_24_781'&{FLOW,(22,23)=__norm}[]
 |-  emp&res=x&{FLOW,(22,23)=__norm}[]. 
res:  failctx
         fe_kind: MAY
         fe_name: logical bug
         fe_locs: {
                   fc_message: failed in entailing pure formula(s) in conseq
                   fc_current_lhs_flow: {FLOW,(22,23)=__norm}}

============================================================
# zip-bug1c.slk FIXED

checkentail  x=null & res=null
 |-  res=x. 

/*
 above currently fails due to our translation:
    x=null --> x<=0
 I guess the solution to this problem is to explicitly
 add x=res is to collect the set of vars {x,res} which are
 v=null and then to explicitly add their equality
 using x=res on the LHS.

 For example, if we have:
 x=null & res=null & y=null
 |-  x=y. 

 We should transform antecedent to:
 x=null & res=null & y=null & x=res & res=y
 and then prove:

 x=null & res=null & y=null & x=res & res=y
 |- x=y


*/

============================================================
# dll-app-bug1d.slk: FIXED

infer [HP_7] // (1)
HP_7(x,l2) & x!=null |-  x::node<_,_>@M.
print residue.
// should fail
/*
GOT:
 <1>(HP_28(Anon_26,l2)) * (HP_29(Anon_27,l2))&x!=null & Anon_11=Anon_26 & Anon_1
2=Anon_27&{FLOW,(19,20)=__norm}[]
 inferred hprel: [HP_7(x,l2)&x!=null --> x::node<Anon_26,Anon_27>@M * 
                   (HP_28(Anon_26,l2)) * (HP_29(Anon_27,l2))&true]

but should FAIL since x is @NI (non-instantiating)
*/

infer [HP_7] //(2)
HP_7(x,l2) & x!=null |-  l2::node<_,_>@M.
print residue.
// should succeed
// HP_7(x,l2) --> l2::node<p,q>*HP_10(p,x#)*HP_11(q,x#)
/*
GOT:
====
 <1>(HP_39(Anon_37,x)) * (HP_40(Anon_38,x))&x!=null & Anon_13=Anon_37 & Anon_14=Anon_38&{FLOW,(19,20)=__norm}[]
 inferred hprel: [HP_7(x,l2)&x!=null --> (HP_39(Anon_37,x)) * 
                   (HP_40(Anon_38,x))&true]
BUI instantiation is WRONG. Should have been:
 HP_7(x,l2) & x!=null --> l2::node<p,q>*HP_10(p,x#)*HP_11(q,x#)

*/
