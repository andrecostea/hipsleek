data node { int val ; node next }.

HeapPred H(node a).
HeapPred H1(node a).
HeapPred G(node a, node b).
 //1. for x.next
 infer [H] H(x) |- x::node<a,b>@L.
// infer [H] H(x) |- x::node<a,b>.
print residue.

//1a infer [H] H(x)* x::node<a,b>  |- x::node<a,b>@L.

//1b.
 //infer [H] H(x) & x'=x  |- x'::node<a,b>@L.
//print residue.


//infer [] x::node<u,v>  |- x::node<a,b>@L.
//print residue.
/*
infer [] x::node<u,v>  |- x::node<a,b>.
print residue.
*/
/*
  --> [H,G,H1] x::node<a,b>*H1(x,b)
   with H(x) -> x::node<a,b>*H1(b,x)
*/

/*
//function call on x!=null
 [H,G,H1] x::node<a,q>*H1(x,q) |- true --* b & q!=null \/ !(b) & x=null
  -->  x::node<a,x'>*H1(x,x') &  b & q!=null
       or x::node<a,x'>*H1(x,x') &  !b & q!=null
*/

/*
//state after then branch
 [H,G,H1] x::node<a,x'>*H1(x,x') &  b & x'!=null
*/

/*
//recursive function call
 [H,G,H1] x::node<a,x'>*H1(x,x') &  b & x'!=null
    |- H(x') --* G(x',x")
  --> [H,G,H1] x::node<a,x0> * G(x0,x') & x0!=null
   with x0!=null & H1(x0) -> H(x0)
*/
//2.
//infer [H,H1] x::node<a,x0>*H1(x0) &  b & x0!=null  |- H(x0).

/*
 //Postcondition for then branch
  [H,G,H1] x::node<a,x0> * G(x0,x') & b & x0!=null

     |- G(x,x')
  with x::node<a,x0> * G(x0,x') & x0!=null -> G(x,x')
*/
//3.
//infer [G] x::node<a,x0> * G(x0,x1) & b & x0!=null  |- G(x,x1).

/*
 state after else branch
 [H,G,H1] x::node<a,x'>*H1(x,x') &  !b & x'=null
*/

/*
 //Postcondition for else branch
  [H,G,H1] x::node<a,x'> * H1(x,x') & b & x'=null
     |- G(x,x')
  with x::node<a,x'> * H1(x,x') & x'=null -> G(x,x')
*/
//4.
//infer [G,H1] x::node<a,x0> * H1(x0) & b & x0=null  |- G(x,x0).
