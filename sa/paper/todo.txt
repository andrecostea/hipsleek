==================================================================
# tll-guard.slk: FIXED
  (from tll.ss)

infer [H,G,H_4,H_5,H_6]
 H_4(left_1,t) * H_6(next_3,t) *  x::node<left_1,right_2,next_3>@M * 
 G(right_2,l_47',t')&x=x' & t=t' 
  & right_2!=null & !(v_bool_2') 
  //& right_2!=null & !(v_bool_2') & right_2=right_2 
  & t=t' & left_1=v_node_0'
  |-  H(v_node_0',l_47').

print residue.

 inferred hprel: [
  H_4(v_node_0',t'@NI) |#| x::node<v_node_0',right_2,next_3>@M 
    --> H(v_node_0',l_47'@NI)]

PROBLEM
=======
Heap guard here is useless, as it does not serve
to instantiate l_47'. We should drop such useless
heap guards.

ALGO
====
Given U1(vs) |#| G --> U2(ws)

A guard is selected if:
  vars(G) /\ vs != []

A guard is useful if
  vars(G) /\ (ws-vs) != []
==================================================================
# check-mcf-4.ss: FIXED

We have:
 H1(t) --> t::tree<children_42_1079>@M * HP_1080(children_42_1079),
 HP_1080(children_42_1079)&
  children_42_1079!=null |#| t::tree<children_42_1079>@M --> H2(children_42_1079,n_37'@NI,t@NI)

It seems that H1 is processed before HP_1080:

!!!  synthesize: [HP_1009,H1]
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!! >>>>>> step 3a: simplification <<<<<<
!!!  synthesize: [HP_1007]
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!! >>>>>> step 3a: simplification <<<<<<
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!!  synthesize: [H2,HP_1008,HP_1080]

PROBLEM
=======
HP_1080 cannot be unfolded since H1 was confirmed earlier.
Can you change the order so that guarded assumptions
are processed before those like H1.
That means the following priorities:

   1. H(..) --> H2(..)
   2. H(..) | G --> H2(..)
   3. H(..) * D --> H2(..)
   4. H(..)  --> D*H2(..)

==================================================================
# last-obl3.slk:

infer [G_1]
  next_3::node<val_20_59,next_20_60>@M *
  G_1(next_62,next_20_60)&next_0=next_62 & next_62=null & 
         next_0=null  |- G_1(next_0,next_3).
print residue.

infer [G_1]
  next_3::node<val_20_59,next_20_60>@M *
  G_1(null,next_20_60)&next_0=null & 
         next_0=null  |- G_1(next_0,next_3).
print residue.

ISSUE
=====
The first example gave a longer answer because we were traversing
NULL ptr. Can we avoid traversing null when we perform folding
against unknowns? This may cause some base-case split to be automatically
done, but --classic will pick them up.

Entail (1) : Valid. 

 <1>next_3::node<val_20_59,next_20_60>@M[Orig]&next_0=next_62 & next_62=null & next_0=null&{FLOW,(19,20)=__norm}[]
 inferred hprel: [G_1(next_62,next_20_60@NI)&next_0=next_62 & next_62=null & 
                   next_0=null |#| next_3::node<val_20_59,next_20_60>@M --> G_1(next_0,next_3@NI)]


Entail (2) : Valid. 

 <1>EXISTS(flted_20_38: next_3::node<val_20_59,next_20_60>@M[Orig] * G_1(flted_20_38,next_20_60)&flted_20_38=null & next_0=null & next_0=null&{FLOW,(19,20)=__norm})[]
 inferred hprel: [emp&next_0=null --> G_1(next_0,next_3@NI)]
==================================================================
# check-dll.ss: FIXED

We generated:
[ H1(l,prv@NI)&l!=null --> l::node<prev_19_892,next_19_893>@M * 
  HP_894(prev_19_892,prv@NI) * HP_895(next_19_893,prv@NI),
 HP_895(next_19_893,prv@NI) |#| l::node<prev_19_892,next_19_893>@M --> H1(next_19_893,l@NI),
 H1(l,prv@NI)&l=null --> G1(l,prv@NI),
 HP_894(prev_19_892,prv@NI) * l::node<prev_19_892,next_19_893>@M * 
  G1(next_19_893,l@NI)&prev_19_892=prv --> G1(l,prv@NI),
 HP_894(prev_19_892,prv@NI) --> emp&prev_19_892=prv]

where:
 HP_894(prev_19_892,prv@NI) --> emp&prev_19_892=prv]

Currently, it is marked as NONE, as shown below:

[ H1(l_930,prv_931) ::= 
 H1(next_19_926,l_930) * l_930::node<prev_19_927,next_19_926>@M&
 prev_19_927=prv_931
 or emp&l_930=null
 ,
 G1(l_934,prv_935) ::= 
 HP_894(prev_19_892,prv_935) * l_934::node<prev_19_892,next_19_893>@M * 
 G1(next_19_893,l_934)&prev_19_892=prv_935
 or emp&l_934=null
 ,
 HP_894(prev_19_892,prv) ::= NONE]

Though this may be a dangling predicate, it did provide
a equality relation that we may want to use. Perhaps, we can
have an option to utilize this information; so that we
can have a simpler outcome, namely:

 G1(l_934,prv_935) ::= 
 l_934::node<prev_19_892,next_19_893>@M * 
 G1(next_19_893,l_934)&prev_19_892=prv_935 & prev_19_892=prv_935
 or emp&l_934=null,

I guess this is useful for conciseness, and to support
code reuse later.
==================================================================
#  check-cdll.ss
 - wrong apply transitive for H1: FIXED
 - pre-oblg: exception
 - post-oblg: TYPE ERROR 1 : Found node but expecting NUM:
  omega simplification


==================================================================
# paper/check-sorted.ss --sa-en-pure-field

Why isn't HP_885 unfolded?

[ H(x_911,v_912) ::= 
 x_911::node<val_21_907,next_21_908>@M * HP_885(next_21_908,v_912)&
 v_912<=val_21_907
 or emp&x_911=null
 ,
 G(x_917,v_918) ::= 
 emp&x_917=null
 or x_917::node<val_21_882,next_21_883>@M * G(next_21_883,val_21_882)&
    v_918<=val_21_882
 ,
 HP_885(next_21_913,v_914) |#| x::node<val_21_882,next_21_913>@M ::= H(next_21_913,val_21_882)&v_914<=val_21_882]

You were processing it in the right order though,
so the problem is with unfolding guarded defn.

!!! >>>>>> step 3a: simplification <<<<<<
!!!  synthesize: [HP_885,HP_884]
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!! >>>>>> step 3a: simplification <<<<<<
!!! >>>>>> step 3b: do apply_transitive_imp <<<<<<
!!!  synthesize: [H]
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================

