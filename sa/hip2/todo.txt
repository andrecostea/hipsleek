# cll-imm.slk   DONE (fixed by Andreea)

  false when @L is used

infer [] x::node<_,_> |-  x::node<a,b>@L. 
print residue.

/*
Why is there a false on conseq?

INPUT: 
 ### ante =  x::node<Anon_11,Anon_12>@M[Orig]&true&{FLOW,(19,20)=__norm}[]
 ### conseq =  EBase exists (Expl)(Impl)[a; b](ex)x::node<a,b>@L[Orig]&false&
       {FLOW,(19,20)=__norm}[]

*/
(**************************************)

# cll-d1.slk: FIXED

infer [HP_6,x] HP_6(n) & n=v & v!=null & x!=n
    |-  v::node<_,_> .
print residue.

/*
This currently generates:
 <1>HP_28(Anon_27)&n=v & v!=null & n!=x & Anon_11=Anon_26 & Anon_12=Anon_27&{FLOW,(19,20)=__norm}[]
 inferred hprel: [HP_6(v)&v!=null --> v::node<Anon_26,Anon_27>@M * 
                   (HP_28(Anon_27))&true]

I wonder if we can add a constraint v!=x and generate instead:

 inferred hprel: [HP_6(v)&v!=null & v!=x --> v::node<Anon_26,Anon_27>@M * 
                   (HP_28(Anon_27))&true]

This is to allow parameter expansion, later to:

 HP_6(v) --> HP_6e(v,n)
 inferred hprel: [HP_6(v,n)&v!=null & v!=x --> v::node<Anon_26,Anon_27>@M * 
                   (HP_28(Anon_27))&true]


*/
***************************************************
# cll-d2a.slk: FIXED

infer [HP_6,x]
HP_6(v) * xp::node<val_35_804,v> & n!=x & n=v & x=xp
 |-  v::node<_,_> .
print residue.

/*
Why isn't x!=v captured here? just because of an extra x=xp?

 inferred hprel: [HP_6(v)&true --> v::node<Anon_47,Anon_48>@M * 
                   (HP_49(Anon_48))&true]
*/

***************************************************

# cll-d2a.slk: : FIXED

Why did the 2nd version below dropped HP_6 pred on
the LHS?

 <1>(HP_6(n)) * xp::node<val_35_804,n>@M[Orig] * (HP_51(Anon_50))&x=xp & n!=x & n=v & Anon_13=Anon_49 & Anon_14=Anon_50&{FLOW,(19,20)=__norm}[]
 inferred hprel: [emp&v!=x --> v::node<Anon_49,Anon_50>@M * (HP_51(Anon_50))&
                   true]

infer [HP_6,x]
HP_6(v) * xp::node<val_35_804,n> & x=xp & n!=x & n=v 
 |-  v::node<_,_> .
print residue.

infer [HP_6,x]
HP_6(n) * xp::node<val_35_804,n> & x=xp & n!=x & n=v 
 |-  v::node<_,_> .
print residue.

***************************************************
# cll-d3a.slk: DONE (--sa-split-base)

infer [HP_6] HP_6(n) * x_814::node<_,n> & x=x_814 & n=x_814 & xp=null
 |-  G(x,xp). 
print residue.
/*
 Should we first obtain:
   HP_6(n) * x::node<_,n> & x=n & xp=null --> G(x,xp)

 After that, we can split to:
   HP_6(n) & x=n --> emp
   x::node<_,n> & x=n & xp=null --> G(x,xp)

 This split should be organized as a procedure that is
 invoked as --en-split-base ==> --sa-split-base

 Why is x_814::node<..> duplicated in your split-base operation?

 <1>HP_6(n)&x=x_814 & n=x_814 & xp=null&{FLOW,(19,20)=__norm}[]
 inferred hprel: [x_814::node<Anon_11,x_814>@M&xp=null --> G_28(x_814,xp)&
                   true; 
                  (HP_6(x_814)) * x_814::node<Anon_11,x_814>@M&true --> emp&
                   true]
*/

infer [HP_6,x,G] HP_6(n) * x_814::node<_,n> & x=x_814 & n=x_814 & xp=null
 |-  G(x,xp). 
print residue.

/*
  Obtained:

 <1>HP_6(n)&x=x_814 & n=x_814 & xp=null&{FLOW,(19,20)=__norm}[]
 inferred hprel: [x::node<Anon_12,x>@M&xp=null --> G_39(x,xp)&true; 
                  (HP_6(x_814)) * x_814::node<Anon_12,x_814>@M&true --> emp&
                   true]

  Why did we not capture  x!=x_814 below?
  Remember that this is always for pre-pred implication.

  HP_6(x_814) & x=x_814 --> emp
  x::node<_,n> & n=x & xp=null -> G(x,xp).

*/

***************************************************
# cll-d3b.slk: FIXED

some scenarios for inferences

//sol: check infer_vars_hp in rhs only
infer [HP_6] HP_6(x) * x::node<_,x> & xp=null
 |-  G(x,xp).
print residue.
// expecting a failure since G(..) is not to be inferred

infer [G] HP_6(x) * x::node<_,x> & xp=null
 |-  G(x,xp). 
print residue.
/*
 expecting
   x::node<_,x> & xp=null --> G(x,xp)
  since HP_6 is not to be inferred
*/

infer [G,HP_6] HP_6(x) * x::node<_,x> & xp=null
 |-  G(x,xp). 
print residue.
/*
 expecting
   HP_6(x) & x::node<_,x> & xp=null --> G(x,xp)
 which is later base-splitted into:
   HP_6(x) --> emp
   x::node<_,x> & xp=null --> G(x,xp)
*/

infer [G,HP_6,x] HP_6(x) * x::node<_,x> & xp=null
 |-  G(x,xp). 
print residue.
/*
 expecting
   HP_6(x) & x::node<_,x> & xp=null --> G(x,xp)
 which is later base-splitted into:
   HP_6(v) & v=x --> emp
   x::node<_,x> & xp=null --> G(x,xp)
*/
***********************************************
# bug-imm.ss (TODO Andreea to fix)

/* function to delete the node after the head in a circular list */
void delete(ref node x)

	requires x::ll<> & x!=null
	ensures x'::ll<> & x::node<_,null>;

/*

Post-cond has a "conjunction" but this result in
wrong message below:

Exception Failure("The postcondition cannot contain @L heap predicates/data nodes/field annotations\n") Occurred!
(Program not linked with -g, cannot print stack backtrace)


*/
***********************************************
# ll-d1.slk: FIXED


relAssume  H
 H(x) --> x::node<_,nn> .
relAssume  G
 x::node<_,null> &  x'=null  --> G(x,x').
relAssume  G
 x::node<_,null> &  x'=nn --> G(x,x').

This bug occurs before merging with default too.

/*
!! >>>>>> step 1: find dangling ptrs that link pre and post-preds<<<<<<
ERROR: at _0:0_0:0 
Message: SAU.drop_get_hrel: not handle yet
 Fatal error: exception Failure("SAU.drop_get_hrel: not handle yet")

*/

*****************************************************
# cll-d3a.slk (without --sa-split-base)  OK

infer [HP_6,G] HP_6(n) * x_814::node<_,n> & x=x_814 & n=x_814 & xp=null
 |-  G(x,xp). 
print residue.
/*
Got:
 <1>emp&x=x_814 & n=x_814 & xp=null & x=x_814&{FLOW,(19,20)=__norm}[]
 inferred hprel: [(HP_6(n)) * x_814::node<Anon_11,n>@M&n=x_814 & 
                   xp=null --> G(x_814,xp)&true]
Expecting:
  (HP_6(n)) * x_814::node<Anon_11,n>@M&n=x_814 & 
                   xp=null & x=x_814 --> G(x_814,xp)&true]

Look at RHS G(x_814,xp). Extract connected heap predicate for x_815
and all pure predicates linked from there and x_418,xp.

*/

infer [HP_6,G,x] HP_6(n) * x_814::node<_,n> & x=x_814 & n=x_814 & xp=null
 |-  G(x,xp). 
print residue.
/*

Got:
<1>HP_6(n)&x=x_814 & n=x_814 & xp=null&{FLOW,(19,20)=__norm}[]
 inferred hprel: [(HP_6(x)) * x::node<Anon_12,x>@M&xp=null --> G(x,xp)&true]

Expecting:
<1> emp &x=x_814 & n=x_814 & xp=null&{FLOW,(19,20)=__norm}[]
  (HP_6(n)) * x_814::node<Anon_11,n>@M&n=x_814 & 
                   xp=null & x=x_814 --> G(x_814,xp)&true]

Look at RHS G(x_814,xp). Extract connected heap predicate for x_815
and all pure predicates linked from there and x_418,xp.

*/
***********************************************************************
# cll-d3a.slk --sa-split-base  OK

infer [HP_6,G] HP_6(n) * x_814::node<_,n> & x=x_814 & n=x_814 & xp=null
 |-  G(x,xp).
print residue.
/*
Got:
 <1>HP_6(n)&x=x_814 & n=x_814 & xp=null & x=x_814&{FLOW,(19,20)=__norm}[]
 inferred hprel: [x_814::node<Anon_11,n>@M&n=x_814 & xp=null --> G(x_814,xp)&
                   true;
                  HP_6(n)&n=x_814 --> emp&true]
Problems :
  (i) why is HP_6(n) present in the residue?
       <1>HP_6(n)&x=x_814 & n=x_814 & xp=null & x=x_814&{FLOW,(19,20)=__norm}[]

 (ii) For pre-predicate on the LHS, we should just have:
                  HP_6(n) --> emp

Solution:
=========
Assuming:
  (HP_6(n)) * x_814::node<Anon_11,n>@M&n=x_814 &
                   xp=null & x=x_814 --> G(x_814,xp)&true]
Split:
  (HP_6(n)) & n=x_814 & x=x_814 --> emp
  x_814::node<Anon_11,n>@M& n=x_814 & 
                   xp=null & x=x_814 --> G(x_814,xp)&true]

Simplify :
  HP_6(n)  --> emp  (using exists x_814,x)
  x_814::node<Anon_11,n>@M& n=x_814 & 
                   xp=null --> G(x_814,xp)&true (using exists x)

*/

infer [HP_6,G,x] HP_6(n) * x_814::node<_,n> & x=x_814 & n=x_814 & xp=null
 |-  G(x,xp). 
print residue.
/*
Got:
 <1>HP_6(n)&x=x_814 & n=x_814 & xp=null&{FLOW,(19,20)=__norm}[]
 inferred hprel: [x::node<Anon_12,x>@M&xp=null --> G(x,xp)&true; 
                  HP_6(x)&true --> emp

  (i) why is HP_6(n) present in the residue?
       <1>HP_6(n)&x=x_814 & n=x_814 & xp=null & x=x_814&{FLOW,(19,20)=__norm}[]

 (ii) For pre-pred on the LHS, we should keep var x and n
      separately, and generate instead:
                  HP_6(n) & n=x --> emp

*/
Solution:
=========
Assuming:
  (HP_6(n)) * x_814::node<Anon_11,n>@M&n=x_814 & 
                   xp=null & x=x_814 --> G(x_814,xp)&true]
Split:
  (HP_6(n)) & n=x_814 & x=x_814 --> emp
  x_814::node<Anon_11,n>@M& n=x_814 & 
                   xp=null & x=x_814 --> G(x_814,xp)&true]

Simplify :
  HP_6(n) & n=x  --> emp  (using exists x_814)
  x_814::node<Anon_11,n>@M& n=x_814 & 
                   xp=null --> G(x_814,xp)&true (using exists x)
**********************************************************
# TODO post-condition extraction of pre-pred for hip

Towards the end of proving, we will need to extract
pre-pred from the residue hip state during post-condition
proving; if pre-pred  are being inferred.
**********************************************************

# ll-d2.slk  DONE

relAssume  G
 x::node<_,null> &  xp=null  --> G(x,xp).
relAssume  G
 x::node<_,null> &  xp!=null --> G(x,xp).

shape_infer [][G].

/*
Got:
 G(x_37,xp_38) ::= x_37::node<Anon_11,flted_10_16>@M * (HP_39(flted_10_16,xp_38))&true,
 HP_39(flted_10_16,xp_38) ::= emp&flted_10_16=null & xp_38=null]

However, expecting:
 G(x_37,xp_38) ::= 
     x_37::node<Anon_11,null>@M *& xp_38=null
  or x_37::node<Anon_12,null>@M *& xp_38!=null

*/
**********************************************************
# cll-d3a2.slk :

Given :

relAssume G
   HP_6(n) * x_814::node<_,n>@M & n=x_814 & xp=null & x=x_814 --> G(x_814,xp) &true.
shape_split_base [H,x][G].

Got:

 RELASS [G] unknown svl: ;  unknown hps: ;  predefined: ; x_814::node<Anon_11,n>@M&
  n=x_814 & xp=null & x=x_814 --> G(x_814,xp)&true,

 RELASS [HP_6] unknown svl: ;  unknown hps: ;  predefined: ; HP_6(x_814)&
  true --> emp&true]

Shouldn't HP_6 be since x was specified in [H,x]:

   HP_6(x_814)& x=x_816 --> emp&true]



/*
 <1>emp&xp=null&{FLOW,(19,20)=__norm}[]
 inferred hprel: [(H(n)) * x::node<Anon_11,n>@M&xp=null --> G(x,xp)&true]

At the sleek level, we do not know if H is a pre-pred or a post-pred.
Hence, it is not useful to invoke --sa-split-base

This must instead be done by shape_infer; after redundant pred has
been identified and removed. For relAssume with both pre/post pred,
we attempt to do a base-case split.

To test it, we could support the following in sleek:
DONE
relAssume 
   (H(n)) * x::node<Anon_11,n>@M&xp=null --> G(x,xp)&true.
shape_split_base [H][G].

TODO:
Alternatively, we could use:
 infer [H@pre,G@post] H(n) * x::node<_,n>  & xp=null
   |-  G(x,xp). 
 print residue.
and then use the pre/post annotation to support
base-case-split

*/
===========================================
# ll-del-1.slk vs.: FIXED
the first example of cll-d3b.slk

Why is the following basic thing failing?

infer [H] H(x) |-  x::node<_,_>. OK
print residue.


# cll-d3a2.slk 

infer [H,G] HP_6(n) * x_814::node<Anon_11,n> & n=x_814 & 
                   xp=null & x=x_814 
 |-  G(x_814,xp). 
print residue.

/*
We obtained:
<1>HP_6(n)&n=x_814 & xp=null & x=x_814&{FLOW,(19,20)=__norm}[]
 inferred hprel: [x_814::node<Anon_11,n>@M&n=x_814 & xp=null --> G(x_814,xp)&
                   true]

How come we did not include HP_6(n)? I think at the very
least, we should try to include XPURE(HP_6(n)):

<1>HP_6(n)&n=x_814 & xp=null & x=x_814&{FLOW,(19,20)=__norm}[]
 inferred hprel: 
   x_814::node<Anon_11,n>@M&n=x_814 & xp=null & XPURE(HP_6(n)) 
     --> G(x_814,xp)& true]

*/


===========================================

relAssume G
   HP_6(n) * x_814::node<_,n>@M & n=x_814 & xp=null & x=x_814 --> G(x_814,xp) &true.

shape_split_base [H,x][G].
/*

 Shouldn't splitted HP_6 be:
   HP_6(x_814)& x=x_816 --> emp&true]
======================================
# ll-getnext.slk: FIXED

infer [HP_6,x,G] 
 HP_6(next_23_782) * x::node<val_23_781,next_23_782>@M & next_23_782=res
 |-  G(x,res). 

/*
SOLN:
 - when compute residue after constraints generated, should consider closure of aliasing.
 since constraints are in normal form,
       but residue is not. and we want to drop exact matching of args
 - test bugs/bug-app1b.slk together
----------
 <1>HP_6(next_23_782)&next_23_782=res&{FLOW,(19,20)=__norm}[]
 inferred hprel: [(HP_6(res)) * x::node<val_23_781,res>@M&true --> G(x,res)&
                   true]

 Problem: spurious residue:
   Why is HP_6 not consumed?

*/
===============================================
# ll-getnext.ss: DONE

Why disjunct in post-pred?

 H(x_799) ::= x_799::node<val_42_781,next_42_782>@M& XPURE(HP_786(next_42_782)),
 G(x_800,res_801) ::= 
 emp& XPURE(HP_786(res_801))
 or x_800::node<val_42_781,res_801>@M& XPURE(HP_786(res_801))

Please see ll-getnext-a.slk


Why is there a spurious XPure(..) generated by hip that is
not present in sleek command?

 id: 6; caller: []; line: 20; classic: false; kind: POST; hec_num: 5; evars: []; c_heap: emp
 checkentail (HP_783(next_23_782)) * x::node<val_23_781,next_23_782>@M[Orig]&
next_23_782=res&{FLOW,(22,23)=__norm}[]
 |-  G(x,res)&true&{FLOW,(22,23)=__norm}[]. 
hprel_ass: [ (HP_783(res)) * x::node<val_23_781,res>@M&
   XPURE(HP_786(next_23_782)) --> G(x,res)&true]
   ^^^^^^^^^^^^^^^^^^^^^^^^^^
res:  [
  HP_783(next_23_782)&next_23_782=res&{FLOW,(22,23)=__norm}[]
  es_infer_vars/rel: [x]
  ]
===============================================
# ll-getnext2.ss -dd

es_history is redundant and also duplicated es_heap,
as trace below show.

 es_heap: x::node<Anon_11,v_null_25_806>@M[Orig]
 es_history: [x::node<Anon_11,q>@M[Orig]]

=============================================
# ll-getnext2a.ss: 

You have now generated:

[ H(x_809) ::= x_809::node<val_26_784,next_26_785>@M& XPURE(HP_786(next_26_785)),
 G(x,res) ::= x::node<val_26_784,v_null_27_793>@M&v_null_27_793=null & 
 XPURE(HP_786(res)) &  XPURE(HP_786(res))]

This is good. Not sure why XPURE(HP_786(res)) 
was duplicated though. We can try to remove such
a redundant step later.

=============================================
# ll-getnext2.slk: use --sa-inlining DONE

WE got:

H(x_42) ::= x_42::node<val_26_784,next_26_785>@M& XPURE(HP_27(next_26_785)),
 G(x,res) ::= x::node<val_26_784,v_null_27_793>@M&v_null_27_793=null &  XPURE(HP_27(res))]

and then generated below via --sa-inling:

 H(x_42) ::= x_42::node<val_26_784,UU_next_26_43>@M&true,
 G(x,res) ::= x::node<val_26_784,v_null_27_793>@M&v_null_27_793=null & UU_next_26_43=res]

To avoid problem with naming, I suggest using instead the name
of the predicates. That is:

  UU_HP_27_UU: DONE

rather than:

  UU_next_26_4

The above is more stable and not affected by variable renaming.

 Why dangling introduction for shape_infer not working?

relAssume H
  H(x)&true --> x::node<val_26_784,next_26_785>@M * HP_6(next_26_785).
 
relAssume G
  HP_6(res) * x::node<val_26_784,v_null_27_793> 
   & v_null_27_793=null --> G(x,res).

shape_infer [H][G].

/*

H(x_42) ::= x_42::node<val_26_784,next_26_785>@M& XPURE(HP_27(next_26_785)),
 G(x,res) ::= x::node<val_26_784,v_null_27_793>@M&v_null_27_793=null &  XPURE(HP_27(res))]

Tried --sa-dangling, --sa-refine-dang, --sa-unify-dangling
What are these different options anyway?

How come we did not get:

 H(x_42) ::= x_42::node<val_26_784,next_26_785>@M& 
     UU_HP_27_UU=next_26_785),
 G(x,res) ::= x::node<val_26_784,v_null_27_793>@M&v_null_27_793=null 
     &  UU_HP_27_UU=res

Solution: This could be done by replacing

   XPure(P(v)) ==> UU_P_UU=v


*/
=================================================
# ll-getnext-a.slk: FIXED

Problem with post-derivation:

relAssume H
  H(x)&true --> x::node<_,next_26_785>@M * HP_6(next_26_785).
relAssume G
  HP_6(res) * x::node<_,res>  --> G(x,res).

shape_infer [H][G].

/*
Output:

[ H(x_40) ::= x_40::node<Anon_11,next_26_785>@M& XPURE(HP_27(next_26_785)),
 G(x_41,res_42) ::= 
 emp& XPURE(HP_27(res_42))
 or x_41::node<Anon_12,res_42>@M& XPURE(HP_27(res_42))
 ]

However, defn of G should have been:

  G(x,res) ::= x::node<_,res> & XPURE( HP_6(res)).

Why did we have a disjunction?

*/
=================================================
# ll-append9-10.ss: wo. --sa-split-base: OK

=================================================
# ll-del1a.slk

 Why was XPURE(HP_6(..)) dropped?

relAssume  G
 x::node<_,nn> * HP_6(nn) & nn=null & x'=null  --> G(x,x').
relAssume  G
 x::node<_,null> * HP_6(nn) & nn!=null & x'=nn --> G(x,x').

shape_infer [][G].

/*
 Obtained:

[ G(x_44,x_45) ::= 
 x_44::node<Anon_11,nn>@M&nn=null & x_45=null
 or EXISTS(flted_14_25: x_44::node<Anon_11,flted_14_25>@M&flted_14_25=null & 
    x_45!=null&[]
 ]

*/
=================================================
# ll-del.slk

relAssume  H
 H(x) --> x::node<_,nn> * HP_6(nn) .
relAssume  G
 x::node<_,nn> * HP_6(nn) & nn=null & x'=null  --> G(x,x').
relAssume  G
 x::node<_,null> * HP_6(nn) & nn!=null & x'=nn --> G(x,x').

shape_infer [H,x][G].

/*

 H(x_65) ::= x_65::node<Anon_11,nn>@M&nn=null,
 G(x_66,x_67) ::= 
 x_66::node<Anon_12,nn>@M&nn=null & x_67=null
 or EXISTS(flted_17_32: x_66::node<Anon_12,flted_17_32>@M&flted_17_32=null & 
    x_67!=null&[]
 ]

How come HP_6 has been dropped?
Why do we have nn=null in H(..) pred?

Should it not have been:

 H(x_65) ::= x_65::node<Anon_11,nn>@M& XPure(HP_6(nn))
 G(x,x') ::= x::node<_,nn> * GH(nn,x') & HP_6(nn)
 GH(nn,x') ::=  nn=null & x'=null or nn!=null & x'=nn

=================================================
# ll-del1b.slk

HeapPred HP_6(node a).
HeapPred G(node a, node a).

relAssume  G
 x::node<_,nn> * HP_6(nn) & nn=null & x'=null  --> G(x,x').

shape_infer [][G].

/*
 Obtained:

  G(x_23,x_24) ::= x_23::node<Anon_11,nn>@M&nn=null & x_24=null]

 Why was XPURE(HP_6(..)) dropped?

*/
=================================================
# ll-del1c.slk

relAssume  G
 x::node<_,null> * HP_6(nn) & nn!=null & x'=nn --> G(x,x').

shape_infer [][G].

/*
 Obtained:

[ G(x_28,x_29) ::= EXISTS(flted_11_16: x_28::node<Anon_11,flted_11_16>@M&flted_11_16=null & 
nn=x_29 &  XPURE(HP_26(nn)) &  XPURE(G_27(x_29)) & nn!=null&[]]
*
 but where did HP_26 and G_27 came from?
 and what happen to HP_6.

*/
=================================================
# ll-del1b1.slk vs ll-del1b.slk

ll-del1b1.slk Seems OK below:

!!! >>>>>> step 6: generalization <<<<<<
!!! before remove redundant:[]
!!! after remove redundant:[]

!!! before remove redundant:[[(G,[x,x'], x::node<Anon_11,nn>@M&x'=null &  XPURE(HP_21(nn)),[nn])]]
!!! after remove redundant:[HP_RELDEFN G:  G(x_22,x_23) ::=  x_22::node<Anon_11,nn>@M&x_23=null &  XPURE(HP_21(nn))]
*************************************
*******relational definition ********
*************************************
[ G(x_22,x_23) ::= x_22::node<Anon_11,nn>@M&x_23=null &  XPURE(HP_21(nn))]

However, for  ll-del1b.slk, we obtained instead below where there is
an extra generalization step which removed HP_6!
Why is there such an extra generalization step?

!!! >>>>>> step 6: generalization <<<<<<
!!! before remove redundant:[[(HP_6,[nn], emp&nn=null,[])]]
!!! after remove redundant:[HP_RELDEFN HP_6:  HP_6(nn_22) ::=  emp&nn_22=null

*************************************
*******relational definition ********
*************************************
[ G(x_23,x_24) ::= x_23::node<Anon_11,nn>@M&nn=null & x_24=null]
*************************************

*/
=================================================
# ll-del1b2.slk 

relAssume  G
 x::node<_,nn> * HP_6(nn) & x'=null & nn=null  --> G(x,x').

shape_split_base [][G].

GOT:

 RELASS [G] unknown svl: ;  unknown hps: ;  predefined: ; x::node<Anon_11,nn>@M&
  nn=null & x'=null --> G(x,x')&true,
 RELASS [HP_6] unknown svl: ;  unknown hps: ;  predefined: ; HP_6(nn)&
  nn=null --> emp&true]

But we should not split-base on HP_6 which is a
redundant predicate that will be used as a dangling reference

=================================================
# ll-getnext2a.slk  FIXED

relAssume  H
 H(x)  --> x::node<_,nn>@M * HP_6(nn).

relAssume  H
 HP_6(res) * x::node<_,vv> & vv=null --> G(x,res).

shape_infer [H][G].

/*
I obtained below. But why did we rename HP_6 to HP_29.
I think we should never rename heap predicate. Can
you check which part of renaming does that; as it breaks
our inference to rename heap predicate.

[ H(x_44) ::= x_44::node<Anon_11,nn>@M& XPURE(HP_29(nn)),
 G(x,res) ::= x::node<Anon_12,vv>@M&vv=null &  XPURE(HP_29(res))]

The renaming of HP_6--> HP_29 seems to occur early in
SA2.split_constr. Please investigate.

split_constr@2@1
split_constr inp1 :[ RELASS [H] unknown svl: ;  unknown hps: ;  predefined: ; H(x)&
  true --> x::node<Anon_11,nn>@M * (HP_6(nn))&true,
 RELASS [H] unknown svl: ;  unknown hps: ;  predefined: ; (HP_6(res)) * 
  x::node<Anon_12,vv>@M&vv=null --> G(x,res)&true]
split_constr inp2 :[]
split_constr@2 EXIT out :([ RELASS [H] unknown svl: ;  unknown hps: ;  predefined: ; H(x)&
  true --> x::node<Anon_11,nn>@M * (HP_6(nn))&true,
 RELASS [H] unknown svl: [res];  unknown hps: ;  predefined: ; (HP_6(res)) * 
  x::node<Anon_12,vv>@M&vv=null &  XPURE(HP_29(res)) --> G(x,res)&true],[([(HP_6,0),(G,1)],XPURE(HP_29(res)))])

*/

=================================================
# ll-getnext2a1.slk

relAssume  H
 H(vv) * x::node<_,vv> * HP_6(vv) --> G(x,res).

shape_split_base [H][G].

/*

OBTAINED:
[ RELASS [H] unknown svl: ;  unknown hps: ;  predefined: ; (H(vv)) * 
  x::node<Anon_11,vv>@M * (HP_6(vv))&true --> G(x,res)&true]

But we should strictly enforce a split. I am expecting:

 x::node<_,vv> & XPURE(HP_6(vv)) --> G(x,res).
 H(vv) & XPURE(HP_6(vv)) --> G(x,res).

SOLUTION:
  (i) first identify HP_6 as a redundant predicate
      and convert it to XPURE(..) so that it can be freely
      duplicated:
    Thus, convert:
      H(vv) * x::node<_,vv> * HP_6(vv) --> G(x,res).
    into:
      H(vv) * x::node<_,vv> & XPURE(HP_6(vv)) --> G(x,res).
  (ii) traverse post-pred x::node<_,vv> & XPURE(HP_6(vv)) but
       take care not to include pre-pred H(..).
  (iii) traverse for pre-pred H(vv) & XPURE(HP_6(vv)) but
       take care not to include any post-pred G(..).

*/
=================================================
# loc-1.slk

HeapPred H(node a,node b).
HeapPred HP_1(node a,node b).
HeapPred HP_2(node a,node b).
HeapPred G(node a, node a).

relAssume  H // (1)
 H(x,y) --> x::node<_,prev, next> * HP_1(prev, y) * HP_2(next,y).

relAssume  HP_2 // (2)
  HP_2(next,y) & next!=null 
   --> next::node<_,prev, nn> * HP_1(prev, y) * HP_2(nn,y).

relAssume  HP_2 // (3)
  HP_2(next,y) & next=null --> emp.

relAssume  G // (3)
  next=null --> G(next,y).

shape_infer [H,HP_2][G].

/*

OBTAINED:

[ H(x_62,y_63) ::= x_62::node<Anon_11,prev,next>@M * (HP_2(next,y_63))& XPURE(H(y_63)) & 
 XPURE(HP_1(prev)),

 # why is there a XPURE(H(y_63))? 

 HP_2(next_64,y_65) ::= HP_66(next_64,y_65)& XPURE(H(y_65)),

 # why is there a XPURE(H(y_65))? 

 G(next_67,y_68) ::= emp&next_67=null &  XPURE(G(y_68)),

 # why is there a XPURE(G(y_68))? 

 HP_66(next_64,y_65) ::= 
 emp&next_64=null
 or next_64::node<Anon_12,prev,nn>@M * (HP_66(nn,y_65))& XPURE(HP_1(prev))
 ]


*/
=================================================
# loc-1.slk -dd

The -dd tracing for shape_infer is almost absent at the moment.
This makes it difficult to trace the detailed steps of shape analysis.
I think we need to add print out on meaningful steps taken
using:

  Debug.dinfo_pprint "..." pos
  Debug.dinfo_hprint "..." pos

!!!:0: 0: >>>>>> step 1: find dangling ptrs that link pre and post-preds<<<<<<

   ##### Found HP_1,.. dangling ptrs

!!!:0: 0: >>>>>> step 2: apply transitive implication<<<<<<

  ##### Given:
          HP_2(next,y) & next!=null --> H(next,y)
  ##### Unfold H(..) to derive:
          HP_2(next,y) & next!=null 
          --> next::node<_,prev, nn> * HP_1(prev, y) * HP_2(nn,y).

!!!:0: 0: >>>>>> step 1a: simplification <<<<<<
!!!:0: 0: >>>>>> step 1b: do apply_transitive_imp <<<<<<

   #### how is this different from Step 2?

!!!:0: 0: IMP #1
!!!:0: 0: imply_timeout: ante:  true
!!!:0: 0: imply_timeout: conseq:  next_49=null &  XPURE(H(y_52))
!!!:0: 0: ante 1: : true
!!!:0: 0: ante 3: : true
!!!:0: 0: ante 4: : true
!!!:0: 0: res: :false
!!!:0: 0: >>>>>> pre-predicates<<<<<<
!!!:0: 0: res: :false
!!!:0: 0: >>>>>> pre-predicates<<<<<<
!!!:0: 0: >>>>>> step 3: remove unused predicates<<<<<<
!!!:0: 0: pre-preds: [HP_1] are removed

 ##### After removing HP_1, derived:
    H(x,y) --> x::node<_,prev, next> * HP_2(next,y) & XPURE(HP_1(prev, y)).
    HP_2(next,y) & next!=null 
          --> next::node<_,prev, nn> * HP_2(nn,y) & XPURE(HP_1(prev, y)) .

!!!:0: 0: >>>>>> pre-predicates: step 4: group & simpl impl<<<<<<
!!!:0: 0: >>>>>> pre-predicates: step 5: combine<<<<<<
!!!:0: 0: SAT #2
!!!:0: 0:  next!=null &  XPURE(HP_1(prev)) &  XPURE(H(y)) & next=null &  XPURE(H(y))
!!!:0: 0: SAT #3
!!!:0: 0:  next=null &  XPURE(H(y)) & next!=null &  XPURE(HP_1(prev)) &  XPURE(H(y))
!!!:0: 0: >>>>>> pre-predicates: step 6: remove redundant x!=null<<<<<<
!!!:0: 0: >>>>>> pre-predicates: step 7: strengthen<<<<<<
!!!:0: 0: >>>>>> step 6: generalization <<<<<<

# ll-del1b.slk

relAssume  G
 x::node<_,nn> * HP_6(nn) & nn=null & x'=null  --> G(x,x').
shape_infer [][G].

For shape_infer, any heap predicate not declared
as pre or post will automatically be classified as dangling.

Thus, for this example, once we have identified HP_6 to be dangling,
we will immediately convert from:
 x::node<_,nn> * HP_6(nn) & nn=null & x'=null  --> G(x,x').
to:
 x::node<_,nn> & nn=null & x'=null & XPURE(HP_6(nn))  --> G(x,x').

The presence of HP_6 would allow us to link with the dangling
reference (named as UU_HP_6_UU) in pre-condition; despite
any substitution that may occur; such as:

 x::node<_,null> & x'=null & XPURE(HP_6(null))  --> G(x,x').

This would not cause a problem, as we can use --sa-inlining
to obtain below:

 x::node<_,null> & x'=null & UU_HP_6_UU=null  --> G(x,x').

where UU_HP_6_UU would have been a logical variable from pre-condition.


