# cll-imm.slk   DONE (fixed by Andreea)

  false when @L is used

infer [] x::node<_,_> |-  x::node<a,b>@L. 
print residue.

/*
Why is there a false on conseq?

INPUT: 
 ### ante =  x::node<Anon_11,Anon_12>@M[Orig]&true&{FLOW,(19,20)=__norm}[]
 ### conseq =  EBase exists (Expl)(Impl)[a; b](ex)x::node<a,b>@L[Orig]&false&
       {FLOW,(19,20)=__norm}[]

*/
(**************************************)

# cll-d1.slk: FIXED

infer [HP_6,x] HP_6(n) & n=v & v!=null & x!=n
    |-  v::node<_,_> .
print residue.

/*
This currently generates:
 <1>HP_28(Anon_27)&n=v & v!=null & n!=x & Anon_11=Anon_26 & Anon_12=Anon_27&{FLOW,(19,20)=__norm}[]
 inferred hprel: [HP_6(v)&v!=null --> v::node<Anon_26,Anon_27>@M * 
                   (HP_28(Anon_27))&true]

I wonder if we can add a constraint v!=x and generate instead:

 inferred hprel: [HP_6(v)&v!=null & v!=x --> v::node<Anon_26,Anon_27>@M * 
                   (HP_28(Anon_27))&true]

This is to allow parameter expansion, later to:

 HP_6(v) --> HP_6e(v,n)
 inferred hprel: [HP_6(v,n)&v!=null & v!=x --> v::node<Anon_26,Anon_27>@M * 
                   (HP_28(Anon_27))&true]


*/

# cll-d2a.slk

infer [HP_6,x]
HP_6(v) * xp::node<val_35_804,v> & n!=x & n=v & x=xp
 |-  v::node<_,_> .
print residue.

/*
Why isn't x!=v captured here? just because of an extra x=xp?

 inferred hprel: [HP_6(v)&true --> v::node<Anon_47,Anon_48>@M * 
                   (HP_49(Anon_48))&true]
*/
