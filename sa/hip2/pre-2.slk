data node{
 int val;
 node next;
}.


HeapPred H(node a).
HeapPred HP_2(node a).

relAssume  H // (1)
 H(x) & x=null --> emp.
relAssume  HP // (2)
 H(x) --> x::node<_,next> * HP_2(next) .

shape_infer [H][].

/*

GOT:
[ H(x) ::= x::node<Anon_11,next>@M& XPURE(HP_2(next))
        or emp&x=null
 ]

EXPECTING:
[ H(x) ::= x::node<Anon_11,next>@M& XPURE(HP_2(next))
]


 H(x) --> x=null -> emp
 H(x) --> true -> x::node<_,next> & XPURE(HP_2(next))
---------------------------------------------------------
 H(x) --> false & not(true) -> emp
   /\ true & x!=null -> x::node<_,next> & XPURE(HP_2(next))
   /\ true & x=null -> x::node<_,next> & XPURE(HP_2(next)) &  x=null
---------------------------------------------------------
 H(x) --> false \/ x::node<..> \/ false
      --> x::node<_,next> & XPURE(HP_2(next))


 B --> A1 -> C1
 B --> A2 -> C2
------------------
 B --> A1->C1 /\ A2-> C2
------------------
 B --> A1 & not(C2) -> C1 
    /\ A2 & not(A1) -> C2
    /\ A1 & A2 -> C1 /\ C2
------------------
 B -->  C1 & A1 & not(C2)
    \/  C2 & A2 & not(A1)
   \/  C1 /\ C2 & A1 & A2
*/