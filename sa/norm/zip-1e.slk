data node{
     int val;
     node next;
}.

pred zipNM<y,n,m> ==
  self=null & y=null & n=0 & m=0
or self::node<_,p>*y::node<_,q>*p::zipNM<q, n1,m1> & n=n1+1 & m=m1+1.

pred zipN<n> ==
  self=null & n=0 
 or self::node<_,p>*p::zipN<n1> & n=n1+1 
 inv n>=0.

HeapPred P1(node a, int b).
HeapPred P2(node a, int b).
relation P3(int a, int b).

pred zip<> ==
  self=null  
 or self::node<_,p>*p::zip<>  
 inv true.

//lemma_safe self::zipNM<y,m,n> -> self::zipN<n> * y::zipM<m>.

//lemma_safe "both" self::zipNM<y> & n=m <-> self::zipN<n> * y::zipN<m> .

//lemma_test "one" self::zipNM<y>  <- self::zipN<n> * y::zipN<m> & n=m .


lemma_infer [P1,P2,P3] "one2" self::zipNM<y,m,n> -> P1(self,n) * P2(y,m).


print residue.
