/*
id: 9 src:2; caller: []; line: 27; classic: false; kind: UNKNOWN; hec_num: 1; evars: []; infer_vars: []; c_heap: emp
*/

data node{
	int val;
	node next;
}.

pred ll<n> == self = null & n=0  or self::node<_, q> * q::ll<n-1>
inv n>=0.

  relation P(int a, int b).
  relation Q(int a, int b, int c).

infer [P] x::ll<n>@L * y::ll<m>@L&P(m,n)
   & x=null & y!=null
   //& y=y' & x=x' 
   //& x'=null & v_bool_22_910' 
   //& x'=null & v_bool_22_910' & y'!=null 
   //& !(v_bool_24_894') 
   //& y'!=null & !(v_bool_24_894')
 |-  false.
print residue.

infer [P] 
   P(m,n)
   & x=null & y!=null
   & (x=null & n=0 | x!=null & n>0)
   & (y=null & m=0 | y!=null & m>0)
 |-  false.
print residue.


infer [m,n] 
   x=0 & y!=0
   & (x=0 & n=0 | x!=0 & n>0)
   & (y=0 & m=0 | y!=0 & m>0)
 |-  false.
/*
Below is incorrect. We are selectively inferring m,n.
However, x & y are also present!

 <1>hfalse&false&{FLOW,(21,22)=__norm}[]
 inferred pure: [((x=0 & n=0) | (x!=0 & 1<=n)); ((y=0 & m=0) | (y!=0 & 
                 1<=m))]

*/
print residue.