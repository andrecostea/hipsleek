# sll-2.slk: reset the set of inferred ass for each sleek proving: DONE


Why 2nd sleek command did not infer. I suppose we need to treat
each sleek command afresh? That is reset the earlier inferred result.
 
Entail (1) : Valid. 

 <1>EXISTS(Anon_13,Anon_12: (HP_25(Anon_12,p)) * (HP_26(Anon_13,p))&true&{FLOW,(19,20)=__norm})[]
 inferred hprel: [H1(c,p)&true --> c::node<Anon_11,Anon_12,Anon_13>@M * 
                   (HP_25(Anon_12,p)) * (HP_26(Anon_13,p))&true]

Entail (2) : Valid. 

 <1>EXISTS(Anon_16,Anon_15: (HP_25(Anon_15,p)) * (HP_26(Anon_16,p))&true&{FLOW,(19,20)=__norm})[]
===========================================================
# sll-3.slk


infer [H1] H1(c,p) |- c::node<_@A,x1@M,x2@M>.
print residue.

/*

Isn't x1,x2 instantiated? We should not use EXISTS wrapper.


 <1>EXISTS(x2,x1,Anon_14: c::node<Anon_14@M,x1@A,x2@A>@M[Orig] * (HP_37(x1,p)) * (HP_38(x2,p))&true&{FLOW,(19,20)=__norm})[]
 inferred hprel: [H1(c,p)&true --> c::node<Anon_14,x1,x2>@M * 
                   (HP_37(x1,p)) * (HP_38(x2,p))&true]

*/

===========================================================
# sll-dll2.ss

Error during shape inference ..

************************************
*******relational assumption ********
*************************************
[ H1(c,p)&c!=null --> c::node<Anon_11',pp',nn'>@M * (HP_771(pp',p)) * 
  (HP_772(nn',p))&true,
 (HP_772(nn',p)) * c'::node<Anon_11',p,nn'>@M&true --> H1(nn',c')&true,
 (HP_771(pp_773,p)) * (G1(nn_784,c)) * c::node<Anon_783,p,nn_784>@M&
  true --> G1(c,p)&true,
 H1(c,p)&c=null --> G1(c,p)&true]
*************************************

Procedure paper_fix$node~node FAIL-2

Exception Invalid_argument("List.combine") Occurred!
(Program not linked with -g, cannot print stack backtrace)


# dll-3b.slk

/*

Below seems wrong still...

[ H1(c_51,p_53) ::= 
 (H1(next_19,c')) * c_51::node<Anon_11,prev_19_766',next_19>@M&true
 or c_51::node<Anon_11,prev_19_766',next_19>@M * 
    (HP_796(prev_19_766',p_52)) * (H1(next_19,c'))&true
 or emp&c_51=null
 ,
 G1(c_54,p_55) ::= emp&c_54=null,
 HP_796(prev_19_46,p) ::= (H1(c_44,p)) * (H1(next_19,c')) * (HP_796(prev_19_46,p))&true]


*************************************

Why did we not get below:

 H1(c,p) ::= 
   c::node<_,prev_19_766',next_19>@M * (H1(next_19,p))&c!=null
   or c=null & emp

 G1(c,p) := c=null
      or c::node<_,p,next_19_767'> * G1(next_19_806,c)

Note that 2nd paramter of of H1 is useless.

This came from :


Pre
---
 H1(c,p) ::= 
   c::node<_,prev_19_766',next_19_767'>@M * (HP_797(next_19_767',p))&c!=null
   or c=null --> emp
 HP_797(n,p) & true --> H1(n,c')&true.

Post
----
 G1(c,p) := c=null
      or c::node<_,p,next_19_767'> * G1(next_19_806,c)

which should further simplify to:

# dll-4a.ss

relAssume H1
 H1(c)&c!=null --> c::node<_,prev_19_765',next_19_766'>@M * 
  HP_795(prev_19_765') * HP_796(next_19_766')&true.
relAssume H1
 HP_796(n)&true --> H1(n)&true.
relAssume H1
 H1(c)&c=null --> emp&true.

Why did we go into a loop?


# dll-4b.ss

relAssume G1
 c::node<_,p,n>@M * G1(n,c)&true 
  --> G1(c,p)&true.
relAssume G1
 emp&c=null --> G1(c,p)&true.

Why did we have the following base case only?


[ G1(c_23,p_24) ::= emp&c_23=null]

# bug-app1.slk

pred ln<> ==
    self::node<_,q> & q=null
  or self::node<_,q> * q::ln<> & q!=null
 inv self!=null.

infer [H2] H2(x) |- x=null.
print residue.
/*
Entail (1) : Fail.


Last Proving Location: 1 File "bug-app1.slk",Line:10,Col:5
*/

infer [H2] H2(r)   |- r::ln<>.
print residue.
/*
RROR: at _0:0_0:0 
Message: infer.find_undefined_selective_pointers
 caught
(Program not linked with -g, cannot print stack backtrace)

Entailment Failure (2) Failure("infer.find_undefined_selective_pointers")
*/
