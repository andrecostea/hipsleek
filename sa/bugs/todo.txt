# sll-2.slk: reset the set of inferred ass for each sleek proving: DONE


Why 2nd sleek command did not infer. I suppose we need to treat
each sleek command afresh? That is reset the earlier inferred result.
 
Entail (1) : Valid. 

 <1>EXISTS(Anon_13,Anon_12: (HP_25(Anon_12,p)) * (HP_26(Anon_13,p))&true&{FLOW,(19,20)=__norm})[]
 inferred hprel: [H1(c,p)&true --> c::node<Anon_11,Anon_12,Anon_13>@M * 
                   (HP_25(Anon_12,p)) * (HP_26(Anon_13,p))&true]

Entail (2) : Valid. 

 <1>EXISTS(Anon_16,Anon_15: (HP_25(Anon_15,p)) * (HP_26(Anon_16,p))&true&{FLOW,(19,20)=__norm})[]
===========================================================
# sll-3.slk


infer [H1] H1(c,p) |- c::node<_@A,x1@M,x2@M>.
print residue.

/*

Isn't x1,x2 instantiated? We should not use EXISTS wrapper.


 <1>EXISTS(x2,x1,Anon_14: c::node<Anon_14@M,x1@A,x2@A>@M[Orig] * (HP_37(x1,p)) * (HP_38(x2,p))&true&{FLOW,(19,20)=__norm})[]
 inferred hprel: [H1(c,p)&true --> c::node<Anon_14,x1,x2>@M * 
                   (HP_37(x1,p)) * (HP_38(x2,p))&true]

*/

===========================================================
# sll-dll2.ss

Error during shape inference ..

************************************
*******relational assumption ********
*************************************
[ H1(c,p)&c!=null --> c::node<Anon_11',pp',nn'>@M * (HP_771(pp',p)) * 
  (HP_772(nn',p))&true,
 (HP_772(nn',p)) * c'::node<Anon_11',p,nn'>@M&true --> H1(nn',c')&true,
 (HP_771(pp_773,p)) * (G1(nn_784,c)) * c::node<Anon_783,p,nn_784>@M&
  true --> G1(c,p)&true,
 H1(c,p)&c=null --> G1(c,p)&true]
*************************************

Procedure paper_fix$node~node FAIL-2

Exception Invalid_argument("List.combine") Occurred!
(Program not linked with -g, cannot print stack backtrace)


# dll-3b.slk

Got below which seems wrong..

H1(c_51,p_52) ::= c_51::node<Anon_11,prev_19_766',next_19>@M * 
      HP_53(prev_19_766',next_19,p_52))&true,
G1(c_59,p_60) ::= c_59::node<Anon_11,prev_19_766',next_19>@M * 
      HP_53(prev_19_766',next_19,p_60))&c_59=null,
HP_53(prev_19_766',next_19,p_58) ::= 
      next_19::node<Anon_11,prev_19_54,next_55>@M * 
       (HP_53(prev_19_54,next_55,c'))&true]

Why did we not get below:

Pre
---
 H1(c,p) ::= 
   c::node<_,prev_19_766',next_19_767'>@M * (HP_797(next_19_767',p))&c!=null
   or c=null --> emp
 HP_797(n,p) & true --> H1(n,c')&true.

Post
----
 G1(c,p) := c=null
      or c::node<_,p,next_19_767'> * G1(next_19_806,c)

which should further simplify to:

 H1(c,p) ::= 
   c::node<_,prev_19_766',next_19>@M * (H1(next_19,p))&c!=null
   or c=null --> emp
 G1(c,p) := c=null
      or c::node<_,p,next_19_767'> * G1(next_19_806,c)

Note that 2nd paramter of p is useless.
