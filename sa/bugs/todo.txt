# sll-2.slk: reset the set of inferred ass for each sleek proving: DONE


Why 2nd sleek command did not infer. I suppose we need to treat
each sleek command afresh? That is reset the earlier inferred result.
 
Entail (1) : Valid. 

 <1>EXISTS(Anon_13,Anon_12: (HP_25(Anon_12,p)) * (HP_26(Anon_13,p))&true&{FLOW,(19,20)=__norm})[]
 inferred hprel: [H1(c,p)&true --> c::node<Anon_11,Anon_12,Anon_13>@M * 
                   (HP_25(Anon_12,p)) * (HP_26(Anon_13,p))&true]

Entail (2) : Valid. 

 <1>EXISTS(Anon_16,Anon_15: (HP_25(Anon_15,p)) * (HP_26(Anon_16,p))&true&{FLOW,(19,20)=__norm})[]
===========================================================
# sll-3.slk


infer [H1] H1(c,p) |- c::node<_@A,x1@M,x2@M>.
print residue.

/*

Isn't x1,x2 instantiated? We should not use EXISTS wrapper.


 <1>EXISTS(x2,x1,Anon_14: c::node<Anon_14@M,x1@A,x2@A>@M[Orig] * (HP_37(x1,p)) * (HP_38(x2,p))&true&{FLOW,(19,20)=__norm})[]
 inferred hprel: [H1(c,p)&true --> c::node<Anon_14,x1,x2>@M * 
                   (HP_37(x1,p)) * (HP_38(x2,p))&true]

*/

===========================================================
# sll-dll2.ss

Error during shape inference ..

************************************
*******relational assumption ********
*************************************
[ H1(c,p)&c!=null --> c::node<Anon_11',pp',nn'>@M * (HP_771(pp',p)) * 
  (HP_772(nn',p))&true,
 (HP_772(nn',p)) * c'::node<Anon_11',p,nn'>@M&true --> H1(nn',c')&true,
 (HP_771(pp_773,p)) * (G1(nn_784,c)) * c::node<Anon_783,p,nn_784>@M&
  true --> G1(c,p)&true,
 H1(c,p)&c=null --> G1(c,p)&true]
*************************************

Procedure paper_fix$node~node FAIL-2

Exception Invalid_argument("List.combine") Occurred!
(Program not linked with -g, cannot print stack backtrace)


# dll-3b.slk

/*

Below seems wrong still...

[ H1(c_51,p_53) ::= 
 (H1(next_19,c')) * c_51::node<Anon_11,prev_19_766',next_19>@M&true
 or c_51::node<Anon_11,prev_19_766',next_19>@M * 
    (HP_796(prev_19_766',p_52)) * (H1(next_19,c'))&true
 or emp&c_51=null
 ,
 G1(c_54,p_55) ::= emp&c_54=null,
 HP_796(prev_19_46,p) ::= (H1(c_44,p)) * (H1(next_19,c')) * (HP_796(prev_19_46,p))&true]


*************************************

Why did we not get below:

 H1(c,p) ::= 
   c::node<_,prev_19_766',next_19>@M * (H1(next_19,p))&c!=null
   or c=null & emp

 G1(c,p) := c=null
      or c::node<_,p,next_19_767'> * G1(next_19_806,c)

Note that 2nd paramter of of H1 is useless.

This came from :


Pre
---
 H1(c,p) ::= 
   c::node<_,prev_19_766',next_19_767'>@M * (HP_797(next_19_767',p))&c!=null
   or c=null --> emp
 HP_797(n,p) & true --> H1(n,c')&true.

Post
----
 G1(c,p) := c=null
      or c::node<_,p,next_19_767'> * G1(next_19_806,c)

which should further simplify to:

# dll-4a.ss

relAssume H1
 H1(c)&c!=null --> c::node<_,prev_19_765',next_19_766'>@M * 
  HP_795(prev_19_765') * HP_796(next_19_766')&true.
relAssume H1
 HP_796(n)&true --> H1(n)&true.
relAssume H1
 H1(c)&c=null --> emp&true.

Why did we go into a loop?

*************************************

# dll-4b.ss

relAssume G1
 c::node<_,p,n>@M * G1(n,c)&true 
  --> G1(c,p)&true.
relAssume G1
 emp&c=null --> G1(c,p)&true.

Why did we have the following base case only?


[ G1(c_23,p_24) ::= emp&c_23=null]
*************************************
# bug-app1.slk

pred ln<> ==
    self::node<_,q> & q=null
  or self::node<_,q> * q::ln<> & q!=null
 inv self!=null.

infer [H2] H2(x) |- x=null.
print residue.
/*
Entail (1) : Fail.


Last Proving Location: 1 File "bug-app1.slk",Line:10,Col:5
*/

infer [H2] H2(r)   |- r::ln<>.
print residue.
/*
RROR: at _0:0_0:0 
Message: infer.find_undefined_selective_pointers
 caught
(Program not linked with -g, cannot print stack backtrace)

Entailment Failure (2) Failure("infer.find_undefined_selective_pointers")
*/
************************************************
# bugs-app2.slk: DONE

HeapPred H2(node a).

infer [H2] H2(x) & n>0 |- x=null & n>=0.
print residue.

Below needs to be have a relational assumption added.

!!! >>>>>> infer_pure_m <<<<<<
!!! Adding heap assumption?
!!! unk_heaps:[ H2(x)]
!!! lhs_xpure: 0<n
!!! rhs_xpure: x=null & 0<=n
Entail (1) : Fail.
*******************************************************
# bug-app1.slk: DONE

Expecting relational assumption : H(r) --> r::lseg<q> * q::ln<>

@5! Loc : add heap assumption H(..) -> p(..).. 
@5! ========================================== 
@5! n_unmatched: r::lseg<q>@M[0][Orig][LHSCase]
@5! lfb: H2(r)&true&{FLOW,(19,20)=__norm}[]
@5! rfb: r::lseg<q>@M[0][Orig][LHSCase] * q::ln@M[0][Orig][LHSCase]&true&
{FLOW,(19,20)=__norm}[]
*******************************************************
# bug-app3.slk

# bug-app1b.slk

infer [H2] H2(r)*H2(q)   |- r::lseg<null>*q::ln<>.
print residue.

/*

 es_trace:  COND ==>  InferHeap ==> 
 es_infer_vars_hp_rel: [H2; HP_42]
 es_infer_hp_rel: [(H2(r)) * (H2(q))&
                    true --> r::lseg<flted_20_41>@M[LHSCase] * 
                    (HP_42(flted_20_41))&true]
 es_unsat_flag: false
!!! n_lhs: q::ln@M[0][Orig][LHSCase]
!!! n_lhs: q::ln@M[0][Orig][LHSCase]
Entail (1) : Fail.

*/

# ltail.ss --field-ann

Checking procedure foo$node... 
!!! Andreea : we need to normalise struc_vheap
!!! ==========================================
!!! struc_vheap: EBase c'::node<val_11_764'@A,prev_11_765'@A,next_11_766'@L>@L[Orig]&true&
       {FLOW,(1,25)=__flow}[]

# i-app.ss

Problems:
 (i) Need to get rid of redundant prev fields..
 (ii) Why is there an extra predicate 
       HP_797(?)

[ H1(c,y)&true --> c::node<val_17_753',prev_17_754',next_17_755'>@M * 
  (HP_778(prev_17_754',y)) * (HP_779(next_17_755',y))&true,
 (HP_778(prev_17_790,y)) * (HP_779(t_32',y))&t_32'!=null 
    --> (H1(t_32',y)) * (HP_797(prev_17_790))&true,
                         ^^^^^^^^^^^^^^^^^^^
 c::node<val_17_789,prev_17_790,t_802>@M * (HP_797(prev_17_790)) *
                                           ^^^^^^^^^^^^^^^^^^^^^ 
  (G1(t_802,y))&t_802!=null --> G1(c,y)&true,
 (HP_778(prev_17_786,y)) * (HP_779(next_22_800,y)) * 
  c::node<val_17_785,prev_17_786,y>@M&next_22_800=null --> G1(c,y)&true]

data node{
	int val;
	node prev;
	node next;
}

ll<> == self = null  or self::node<_, _ , q> * q::ll<>;

HeapPred H1(node a, node b).
HeapPred G1(node a, node b).

void foo (node c, node y)
  infer [H1,G1]
  requires H1(c,y)
  ensures  G1(c,y);
{
   node t = c.next;
   if (t!=null) {
      foo(t,y);
   }
   else {
      c.next=y;
   }
}
