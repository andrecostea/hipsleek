# sll-2.slk: reset the set of inferred ass for each sleek proving: DONE


Why 2nd sleek command did not infer. I suppose we need to treat
each sleek command afresh? That is reset the earlier inferred result.
 
Entail (1) : Valid. 

 <1>EXISTS(Anon_13,Anon_12: (HP_25(Anon_12,p)) * (HP_26(Anon_13,p))&true&{FLOW,(19,20)=__norm})[]
 inferred hprel: [H1(c,p)&true --> c::node<Anon_11,Anon_12,Anon_13>@M * 
                   (HP_25(Anon_12,p)) * (HP_26(Anon_13,p))&true]

Entail (2) : Valid. 

 <1>EXISTS(Anon_16,Anon_15: (HP_25(Anon_15,p)) * (HP_26(Anon_16,p))&true&{FLOW,(19,20)=__norm})[]
===========================================================
# sll-3.slk  FIXED


infer [H1] H1(c,p) |- c::node<_@A,x1@M,x2@M>.
print residue.

/*

Isn't x1,x2 instantiated? We should not use EXISTS wrapper.


 <1>EXISTS(x2,x1,Anon_14: c::node<Anon_14@M,x1@A,x2@A>@M[Orig] * (HP_37(x1,p)) * (HP_38(x2,p))&true&{FLOW,(19,20)=__norm})[]
 inferred hprel: [H1(c,p)&true --> c::node<Anon_14,x1,x2>@M * 
                   (HP_37(x1,p)) * (HP_38(x2,p))&true]

*/

===========================================================
# sll-dll2.ss

Error during shape inference ..

************************************
*******relational assumption ********
*************************************
[ H1(c,p)&c!=null --> c::node<Anon_11',pp',nn'>@M * (HP_771(pp',p)) * 
  (HP_772(nn',p))&true,
 (HP_772(nn',p)) * c'::node<Anon_11',p,nn'>@M&true --> H1(nn',c')&true,
 (HP_771(pp_773,p)) * (G1(nn_784,c)) * c::node<Anon_783,p,nn_784>@M&
  true --> G1(c,p)&true,
 H1(c,p)&c=null --> G1(c,p)&true]
*************************************


I think bind node c'::node<Anon_11',p,nn'>@M should not have been added
into hp_rel_ass!!

 id: 7; caller: []; line: 23; classic: false; kind: PRE-2; hec_num: 5; evars: []; c_heap: emp
 checkentail (HP_784(pp_786,p)) * (HP_785(nn',p))&c=c' & p=p' & c'!=null & 
v_bool_18_760' & c'!=null & v_bool_18_760' & p'=pp'&{FLOW,(22,23)=__norm}[]
 |-  H1(nn',c')&true&{FLOW,(22,23)=__norm}[]. 
hprel_ass: [ (HP_785(nn',p)) * c'::node<Anon_11',p,nn'>@M&true --> H1(nn',c')&true]
res:  [
  HP_784(pp_786,p)&c=c' & p=p' & c'!=null & v_bool_18_760' & c'!=null & v_bool_18_760' & p'=pp'&{FLOW,(22,23)=__norm}[]
  ]

checkentail HP_784(pp_786,p) * HP_785(nn',p) &c=c' & p=p' & c'!=null & 
v_bool_18_760' & c'!=null & v_bool_18_760' & p'=pp'
 |-  H1(nn',c') . 

*************************************
# dll-3b.slk: DONE
TODO:  enhance --sa-useless to elim unused parameters in H1

/*

[ H1(c_44,p_46) ::= 
 emp&c_44=null
 or (H1(next_19,c')) * c_44::node<Anon_40,prev_19_41,next_19>@M&true
 ,
 G1(c_47,p_48) ::= 
 emp&c_47=null
 or (G1(next_19,c_47)) * c_47::node<Anon_12,p_48,next_19>@M&true
 ]

with --sa-useless

 [ H1(c_44) ::= 
 emp&c_44=null
 or (H1(next_19)) * c_44::node<Anon_40,prev_19_41,next_19>@M&true
 ,
 G1(c_46,p_47) ::= 
 emp&c_46=null
 or (G1(next_19,c_46)) * c_46::node<Anon_12,p_47,next_19>@M&true
 ]

I think we should have instead: DONE
  H1(c,p) ::= H1x(c)
  H1x(c_44) ::= 
      emp&c_44=null
      or (H1x(next_19)) * c_44::node<Anon_40,prev_19_41,next_19>@M&true


Note that 2nd paramter of of H1 is useless.

This came from :


Pre
---
 H1(c,p) ::= 
   c::node<_,prev_19_766',next_19_767'>@M * (HP_797(next_19_767',p))&c!=null
   or c=null --> emp
 HP_797(n,p) & true --> H1(n,c')&true.

Post
----
 G1(c,p) := c=null
      or c::node<_,p,next_19_767'> * G1(next_19_806,c)

which should further simplify to:
*************************************
# dll-4a.slk: FIXED

relAssume H1
 H1(c)&c!=null --> c::node<_,prev_19_765',next_19_766'>@M * 
  HP_795(prev_19_765') * HP_796(next_19_766')&true.
relAssume H1
 HP_796(n)&true --> H1(n)&true.
relAssume H1
 H1(c)&c=null --> emp&true.

Why did we go into a loop?

*************************************

# dll-4b.ss: FIXED

relAssume G1
 c::node<_,p,n>@M * G1(n,c)&true 
  --> G1(c,p)&true.
relAssume G1
 emp&c=null --> G1(c,p)&true.

Why did we have the following base case only?


[ G1(c_23,p_24) ::= emp&c_23=null]
*************************************
# bug-app1.slk: FIXED

pred ln<> ==
    self::node<_,q> & q=null
  or self::node<_,q> * q::ln<> & q!=null
 inv self!=null.

infer [H2] H2(x) |- x=null.
print residue.
/*
Entail (1) : Fail.


Last Proving Location: 1 File "bug-app1.slk",Line:10,Col:5
*/

infer [H2] H2(r)   |- r::ln<>.
print residue.
/*
RROR: at _0:0_0:0 
Message: infer.find_undefined_selective_pointers
 caught
(Program not linked with -g, cannot print stack backtrace)

Entailment Failure (2) Failure("infer.find_undefined_selective_pointers")
*/
************************************************
# bugs-app2.slk: DONE

HeapPred H2(node a).

infer [H2] H2(x) & n>0 |- x=null & n>=0.
print residue.

Below needs to be have a relational assumption added.

!!! >>>>>> infer_pure_m <<<<<<
!!! Adding heap assumption?
!!! unk_heaps:[ H2(x)]
!!! lhs_xpure: 0<n
!!! rhs_xpure: x=null & 0<=n
Entail (1) : Fail.
*******************************************************
# bug-app1.slk: DONE

Expecting relational assumption : H(r) --> r::lseg<q> * q::ln<>

@5! Loc : add heap assumption H(..) -> p(..).. 
@5! ========================================== 
@5! n_unmatched: r::lseg<q>@M[0][Orig][LHSCase]
@5! lfb: H2(r)&true&{FLOW,(19,20)=__norm}[]
@5! rfb: r::lseg<q>@M[0][Orig][LHSCase] * q::ln@M[0][Orig][LHSCase]&true&
{FLOW,(19,20)=__norm}[]
*******************************************************
# bug-app3.slk:

loss: flted_13_30 = null

inferred hprel: [H2(r)&true --> r::lseg<flted_13_30>@M[LHSCase] * 
                   (HP_31(flted_13_30))&true]

*******************************************************
# bug-app1b.slk

infer [H2] H2(r)*H2(q)   |- r::lseg<null>*q::ln<>.
print residue.

/*

 es_trace:  COND ==>  InferHeap ==> 
 es_infer_vars_hp_rel: [H2; HP_42]
 es_infer_hp_rel: [(H2(r)) * (H2(q))&
                    true --> r::lseg<flted_20_41>@M[LHSCase] * 
                    (HP_42(flted_20_41))&true]
 es_unsat_flag: false
!!! n_lhs: q::ln@M[0][Orig][LHSCase]
!!! n_lhs: q::ln@M[0][Orig][LHSCase]
Entail (1) : Fail.

*/
=================================*===============
# ltail.ss --field-ann DONE (by Andreea)

Checking procedure foo$node... 
!!! Andreea : we need to normalise struc_vheap
!!! ==========================================
!!! struc_vheap: EBase c'::node<val_11_764'@A,prev_11_765'@A,next_11_766'@L>@L[Orig]&true&
       {FLOW,(1,25)=__flow}[]
=================================*===============
# ll-size4: H(x) & x=null --> H1(x)&true. DONE

break into two constraints

=================================*===============
# i-app.ss: 

Problems:
 (i) Need to get rid of redundant prev fields..
 (ii) Why is there an extra predicate 
       HP_797(?)

Latest result is below, but there is a complex
RHS    --> H1(t_32',y)) * HP_810(prev_17_803).

[ H1(c,y)&true --> c::node<val_17_766',prev_17_767',next_17_768'>@M * 
  HP_791(prev_17_767',y) * HP_792(next_17_768',y)&true,

 HP_791(prev_17_803,y) * HP_792(t_32',y) &t_32'!=null 
   --> H1(t_32',y)) * HP_810(prev_17_803) ,

 c::node<val_17_802,prev_17_803,t_815>@M * HP_810(prev_17_803) * 
  (G1(t_815,y))&t_815!=null --> G1(c,y)&true,

 HP_792(next_22_813,y)&next_22_813=null --> emp&true,

 (HP_791(prev_17_799,y)) * c::node<val_17_798,prev_17_799,y>@M&
  true --> G1(c,y)&true]
*

[ H1(c,y)&true --> c::node<val_17_753',prev_17_754',next_17_755'>@M * 
  (HP_778(prev_17_754',y)) * (HP_779(next_17_755',y))&true,
 (HP_778(prev_17_790,y)) * (HP_779(t_32',y))&t_32'!=null 
    --> (H1(t_32',y)) * (HP_797(prev_17_790))&true,
                         ^^^^^^^^^^^^^^^^^^^
 c::node<val_17_789,prev_17_790,t_802>@M * (HP_797(prev_17_790)) *
                                           ^^^^^^^^^^^^^^^^^^^^^ 
  (G1(t_802,y))&t_802!=null --> G1(c,y)&true,
 (HP_778(prev_17_786,y)) * (HP_779(next_22_800,y)) * 
  c::node<val_17_785,prev_17_786,y>@M&next_22_800=null --> G1(c,y)&true]

data node{
	int val;
	node prev;
	node next;
}

ll<> == self = null  or self::node<_, _ , q> * q::ll<>;

HeapPred H1(node a, node b).
HeapPred G1(node a, node b).

void foo (node c, node y)
  infer [H1,G1]
  requires H1(c,y)
  ensures  G1(c,y);
{
   node t = c.next;
   if (t!=null) {
      foo(t,y);
   }
   else {
      c.next=y;
   }
}
=================================*===============
# dll-4a1.slk: FIXED

why did we get emp?

/*
*************************************
*******relational definition ********
*************************************
[ H1(c_35) ::= emp&c_35=null,
 G1(c_36,p_37) ::= emp&c_36=null]
************************
*/
=================================*===============
# bug-t3.slk (to be fixed in ann-1 branch)

@v annotation problematic
=================================*===============
# bind2.ss (to fix at default branch)

ERROR : why did bind not temporarily remove a node?
It seems we still use @L annotation on node & field regardless..

@2! vheap: c'::node<Anon_12'@L,nn'@L>@L[Orig]&true&{FLOW,(1,25)=__flow}[]
@2! vheap 2: c'::node<Anon_12'@L,nn'@L>@L[Orig]&true&{FLOW,(1,25)=__flow}[]


[
 Label: 
 State:c::node<Anon_11,p>@M[Orig]&c=c' & Anon_11=Anon_12' & nn'=p&{FLOW,(22,23)=__norm}[]
       es_var_measures: MayLoop
       es_trace: empty

 ]
=================================*===============
# i-app3.slk : DONE

(i)  bug with useless elim below. # DONE
(ii) can we add sa-useless as a SLEEK command
    that can transform predicates?

[ G1(c_25,y_26) ::= c_25::node<Anon_11,p,t>@M * (HP_27(p,t,y_26))&true,
 HP_27(p,t,y_26) ::= 
 emp&t=y_26
 or t::node<Anon_11,p_28,t_29>@M * (HP_27(p_28,t_29,y_26))&true
 ]

--sa-useless

BUG with useless elim. 
should be HP_27(t_20,y_26)

[ G1(c_25,y_26) ::= c_25::node<Anon_11,p,t>@M * (HP_27(y_26,y_26))&true,
 HP_27(t,y_26) ::= 
 emp&t=y_26
 or t::node<Anon_11,p_28,t_29>@M * (HP_27(y_26,y_26))&true
                                         ^^^^^ t_29
 ]
=================================*===============
# use3.slk

type inference problem. (see use1.slk)

ERROR: at use3.slk_9:16_9:22 
Message: couldn't infer type for p in ; (p Unknown); (pp node); (qq node); (pp_15 node); (y node); (self node); (Anon_12 int); (tt node); (TVar__18 node); (y_16 node); (TVar__26 node); (TVar__27 node)

 Fatal error: exception Failure("couldn't infer type for p in ; (p Unknown); (pp node); (qq node); (pp_15 node); (y node); (self node); (Anon_12 int); (tt node); (TVar__18 node); (y_16 node); (TVar__26 node); (TVar__27 node)
")
=================================*===============
# use1.slk; use2.slk: 

Instead of:
 self::G2(y) = ...

Should you not have generated another intermediate
predicate to capture the eliminated paras.

 self::G2(p,y) = self::G2x(y)
 self::G2x(y)  = ....

=================================*===============
# i-app3a.slk : DONE

/*

Problem : Post-predicate HP_3 is redundant and could be eliminated
see steps-i-app3a.txt

*************************************
*******relational definition ********
*************************************
[ G1(c_31,y_32) ::= c_31::node<Anon_11,p,t>@M * (HP_33(p,t,y_32)) * (HP_3(p,y_32))&true,
 HP_33(p,t,y_32) ::= 
 emp&t=y_32
 or t::node<Anon_11,p_34,t_35>@M * (HP_33(p_34,t_35,y_32)) * 
    (HP_3(p_34,y_32))&true
 ]
*************************************

*/

# sll-dll3.ss  DONE

Above generates:

 H1(c)&c!=null --> c::node<val_20_777',prev_20_778',next_20_779'>@M * 
  (HP_808(prev_20_778')) * (HP_809(next_20_779'))&true,
 HP_809(next_20_818)&true --> H1(next_20_818)&true,
 H1(c)&c=null --> emp&true,
 c::node<val_20_817,p,next_20_818>@M * (G1(next_20_818,c))&true --> G1(c,p)&
  true,
 emp&c=null --> G1(c,p)&true]

BUT goes into a loop afterwards during predicate synthesis?

This is in contrast to shape infer
done by sll-dll3.slk which terminates.

# i-app-r.slk  DONE

 Result below has spuriuous HP_P predicate.

[ H1(c_53,y_54) ::= c_53::node<val_17_766',prev_17_767',next_17_768'>@M * 
(HP_p(prev_17_767',y_54))&next_17_768'=null,
 HP_2(n_55,y_56) ::= emp&n_55=null,
 G1(c_57,y_58) ::= c_57::node<Anon_11,p,t>@M * (HP_59(p,t,y_58)) * (HP_p(p,y_58))&true,
 HP_p(prev_17_767',y) ::= 
 (HP_2(t_31',y)) * (HP_p(prev_17_767',y)) * (HP_2(next_17_768',y))&true
 or (H1(c,y)) * (HP_2(next_17_768',y))&true
 ,
 HP_59(p,t,y_58) ::= 
 emp&t=y_58
 or t::node<Anon_11,p_60,t_61>@M * (HP_59(p_60,t_61,y_58)) * 
    (HP_p(p_60,y_58))&true
 ]

However, when I split pre-pred and post-pred into two files
   i-app-r1.slk for post-pred
   i-app-r2.slk for pre-pred

I got a much better result with redundant HP_p predicate
eliminated.

[ G1(c_36,y_37) ::= c_36::node<Anon_11,p,t>@M * (HP_38(p,t,y_37))&true,
 HP_38(p,t,y_37) ::= 
 emp&t=y_37
 or t::node<Anon_11,p_39,t_40>@M * (HP_38(p_39,t_40,y_37))&true
 ]

[ H1(c_37,y_38) ::= c_37::node<val_17_766',prev_17_767',next_17_768'>@M * 
                     (HP_2(next_17_768',y_38))&true,
 HP_2(n_39,y_40) ::= 
 emp&n_39=null
 or n_39::node<val_17_766',prev_17_767',next_17_768'>@M * 
    (HP_2(next_17_768',y_40))&true
 ]

# i-app.ss

This generated below. The 2nd relational assumption seems wrong.

[ H1(c,y)&true --> c::node<val_17_766',prev_17_767',next_17_768'>@M * 
     (HP_791(prev_17_767',y)) * (HP_792(next_17_768',y))&true,

 (HP_791(prev_17_803,y)) * (HP_792(t_32',y))&t_32'!=null 
      --> (H1(t_32',y)) * (HP_810(prev_17_803))&true,

 c::node<val_17_802,prev_17_803,t_815>@M * (HP_810(prev_17_803)) * 
  (G1(t_815,y))&t_815!=null --> G1(c,y)&true,

 HP_792(next_22_813,y)&next_22_813=null --> emp&true,

 (HP_791(prev_17_799,y)) * c::node<val_17_798,prev_17_799,y>@M&
  true --> G1(c,y)&true]

# i-app-w.slk
  
infer [H1] HP_p(prev_17_803,y) * HP_2(t_32',y) * 
c'::node<val_17_802,prev_17_803,t_32'> &c=c' & y=y' & t_32'!=null & 
v_bool_18_772' & t_32'!=null & v_bool_18_772'
 |-  H1(t_32',y'). 
print residue.

/*

Why did we generate HP_34 below?

 <1>c'::node<val_17_802,prev_17_803,t_32'>@M[Orig] * (HP_34(prev_17_803))&c=c' & y=y' & t_32'!=null & v_bool_18_772' & t_32'!=null & v_bool_18_772'&{FLOW,(19,20)=__norm}[]
 inferred hprel: [(HP_p(prev_17_803,y')) * (HP_2(t_32',y'))&
                   t_32'!=null --> (H1(t_32',y')) * (HP_34(prev_17_803))&true]

Solution
========

    H(x) |- x::node<...>
 =================================
 H(x,p) --> x::node<.,q>* Hg<q,p>


     H(x,p)   |- x::lseg<q>
 ==================================
   H(x,p) --> x::lseg<q>*Hg<q,p>

Given:
  x::lseg<q>
We have:
  x is root parameter
  q is continuation parameter
For HeapPred
 (i) by default, first parameter is the root
 (ii) unless named as "self"


*/

We have:

infer [H1] 
HP_p(prev_17_803,y) * HP_2(t_32',y) * 
c'::node<val_17_802,prev_17_803,t_32'> &c=c' & y=y' & t_32'!=null & 
v_bool_18_772' & t_32'!=null & v_bool_18_772'
 |-  H1(t_32',y'). 

Our goal is to match the RHS. There is already a very natural
match HP_2(t_32',y) on the LHS together with the constraints
t_32'!=null & y=y'; which would allow us to build:

   HP_2(t_32',y) & t_32'!=null & y=y' -->  H1(t_32',y'). 

Leaving a residue of:

HP_p(prev_17_803,y) * c'::node<val_17_802,prev_17_803,t_32'> &
  c=c' & y=y' & t_32'!=null & 
  v_bool_18_772' & t_32'!=null & v_bool_18_772'

Why do we wish to instantiate prev_17_803 which has already
been instantiated before using HP_p(prev_17_803,y). Instantiating
of nodes and their fields occur in rules of the form:
      H(x,..) |- x::node<...>

Are there are places where you need to instantiate new predicates?
Could you give examples, so that we can be careful where they are 
generated. 

The inferred rule below is not good:
 inferred hprel: [(HP_p(prev_17_803,y')) * (HP_2(t_32',y'))&
                   t_32'!=null --> (H1(t_32',y')) * (HP_34(prev_17_803))&true]
as it has both complex LHS and complex RHS.


# sll-dll2.ss

On sleek logging of sll-dll2.ss, we got:

 checkentail (HP_784(pp_786,p)) * (HP_785(nn',p))&c=c' & p=p' & c'!=null & 
v_bool_18_760' & c'!=null & v_bool_18_760' & p'=pp'&{FLOW,(22,23)=__norm}[]
 |-  H1(nn',c')&true&{FLOW,(22,23)=__norm}[]. 
hprel_ass: [ (HP_785(nn',p)) * c'::node<Anon_11',p,nn'>@M&true --> H1(nn',c')&true]
res:  [
  HP_784(pp_786,p)&c=c' & p=p' & c'!=null & v_bool_18_760' & c'!=null & v_bool_18_760' & p'=pp'&{FLOW,(22,23)=__norm}[]
  ]

However, when I test on sleek sll-dll2-i.slk, it seems to have behaved
properly. Why?

infer [H1,HP_4,HP_5] HP_4(pp_786,p) * HP_5(nn',p) & c=c' & p=p' & c'!=null & 
v_bool_18_760' & c'!=null & v_bool_18_760' & p'=pp'
 |-  H1(nn',c') . 
print residue.

/*
We derived:

<1>HP_4(pp_786,p)&c=c' & p=p' & c'!=null & v_bool_18_760' & c'!=null & v_bool_18_760' & p'=pp'&{FLOW,(19,20)=__norm}[]
 inferred hprel: [HP_5(nn',pp')&c'!=null --> H1(nn',c')&true]

# sll-dll2b.slk

Given:
relAssume G1
 c::node<Anon_796,p,nn_797> * G1(nn_797,c) --> G1(c,p).
relAssume G1
 emp&c=null --> G1(c,p) .
shape_infer [][G1].//[pre_hps][post_hps]

Why did we synthesize an empty predicate?

 G1(c_27,p_28) ::= emp&c_27=null]

Did you revert to old code??????

