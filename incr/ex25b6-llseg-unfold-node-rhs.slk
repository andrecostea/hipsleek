data node {
  int val;
  node next;
}.

pred ll<> == self=null
 or self::node<_,q>*q::ll<> .

HeapPred U1(node x).
HeapPred R1(node x).
HeapPred U2(node x,int v).


infer [U2,@classic,@pure_field] x::node<_,null>  |- U1(x).
//infer [U2,@classic,@pure_field] x::ll<>  |- U1(x).
//infer [U2,@classic,@pure_field] x::ll<>*y::node<1,_>  |- U1(x) * y::ll<>.
//infer [U2,@classic,@pure_field] U1(x) |- x::ll<> .
print residue.
expect Valid.


/*
# ex25b6.slk 

infer [U2,@classic,@pure_field] x::node<_,null>  |- U1(x).

# schedule a infer_fold??

Entail (1) : Fail.(may) cause:UnionR[**solver.ml#11576:,Cannot infer: infer_collect_hp_rel 3a]

Residue:

 MaybeErr Context: 
    fe_kind: MAY
    fe_name: separation entailment
    fe_locs: {
        fc_message: BaseCaseFold on Unknown Pred (not on inferred list)
        fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
      }
    [[ SEARCH ==>  BaseCaseFold]]
   FAIL_UNION 
    fe_kind: MAY
    fe_name: separation entailment
    fe_locs: {
        fc_message: infer_heap_node
        fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
      }
    [[ SEARCH ==>  InferHeap]]
   
--------------------------------------------
infer [U2,@classic,@pure_field] x::ll<>*y::node<1,_>  |- U1(x) * y::ll<>.

spatial_ctx_extract@2@1
spatial_ctx_extract inp1 :h_formula: x::ll<>@M * y::node<flted_14_29,Anon_13>@M
spatial_ctx_extract inp2 :imm:@M
spatial_ctx_extract inp3 :aset:[x]
spatial_ctx_extract inp4 :rhs_node: U1(x)
spatial_ctx_extract@2 EXIT:list of match_res:
[ Type: Root
 LHS: x::ll<>@M
 RHS: U1(x)
 lhs_rest: y::node<flted_14_29,Anon_13>@M
 rhs_rest: y::ll<>@M]
-----------------------------------------

infer [U2,@classic,@pure_field] U1(x) |- x::ll<> .

!!! **context.ml#2491:process_matches (steps) :
 ### LHS : U1(x)
 ### RHS : x::ll<>@M
 ### matches :
[ Type: Root
 LHS: U1(x)
 RHS: x::ll<>@M
 lhs_rest: emp
 rhs_rest: emp]

infer [U2,@classic,@pure_field] U2(x,v)  |- v!=0 .

 MaybeErr Context: 
   fe_kind: MAY
   fe_name: logical bug
   fe_locs: {
     fc_message:  true |-  v=0. LOCS:[0;14] (may-bug)
     fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
   }
 [[empty]]
 CEX:false
Validate 1: Expecting(3)Valid BUT got : Fail_May

============================

infer [U2,@classic,@pure_field] U2(x,v) |- x!=null .
print residue.

infer [U2,@classic,@pure_field] U2(x,v) |- x=null .
print residue.

# why is v@NI?
 inferred hprel: [U2(x,v@NI)&true |#|3  --> emp&x=null]


infer [U2,@classic,@pure_field] U2(x,v) |- v!=0 .

Entail (1) : Fail.(may) cause: true |-  v!=0. LOCS:[0;14] (may-bug)

Residue:

 MaybeErr Context: 
   fe_kind: MAY
   fe_name: logical bug
   fe_locs: {
     fc_message:  true |-  v!=0. LOCS:[0;14] (may-bug)
     fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
   }
 [[empty]]
 CEX:false
Validate 1: Expecting(3)Valid BUT got : Fail_May

(==solver.ml#8294==)
infer_collect_hp_rel_empty_rhs#1@1
infer_collect_hp_rel_empty_rhs#1 inp1 : es_formula: 
 U2(x,v)&{FLOW,(20,21)=__norm#E}[]
 es_infer_vars_hp_rel: [U2]
infer_collect_hp_rel_empty_rhs#1 inp2 : v!=0
infer_collect_hp_rel_empty_rhs#1@1 EXIT:(Res:true,Sel HP:
 es_formula: 
 emp&{FLOW,(20,21)=__norm#E}[]
 es_infer_vars_hp_rel: [U2],Inferred Relations:[ U2(x,v) |#|  --> emp])


*/
