/* singly linked lists */

/* representation of a node */
data node {
	int val;
	node next;
}.

HeapPred H(node a).

//(1)
//infer_exact [H] H(p) & p=null |- emp.
//print residue.
//expect_infer Valid R{emp}.
// <1>emp&p=null&{FLOW,(20,21)=__norm#E}[]
// inferred hprel: [H(p)&p=null --> emp&true]


//infer_exact [H] H(p) * H(q) & p=null |- emp.
// infer_classic, then infer_empty

//infer_exact [H] H(p) * H(q) & p=null |- true.
// infer_empty

//infer_exact [H] H(p) & p=null |- emp.
// infer_empty

//infer_exact [H] H(p) & p=null |- true.
// infer_empty

//infer_exact [H] H(p) |- emp.
// infer_empty

//infer_exact [H] H(p) |- true.
// infer_empty

//infer_exact [H] H(p) * x::node<_,p> |- true.
// <1>x::node<Anon_12,p>@M&{FLOW,(20,21)=__norm#E}[]
// inferred hprel: [H(p)&true --> emp&true]

//infer_exact [H] H(p) * x::node<_,p> & p=null |- true.
// BUG:
//<1>x::node<Anon_12,p>@M&p=null&{FLOW,(20,21)=__norm#E}[]
// inferred hprel: [H(p)&p=null --> emp&true]
// <1>x::node<Anon_12,p>@M&{FLOW,(20,21)=__norm#E}[]

//infer_exact [H] H(p) * x::node<_,p> |- emp.
//Entail (1) : Fail.(must) cause: x::node<Anon_12,p>@M&{FLOW,(20,21)=__norm#E}[]:memory leak failure : residue is forbidden.


//infer_exact [H] H(p) * x::node<_,p> & p=null |- emp.
//Entail (1) : Fail.(must) cause: x::node<Anon_12,p>@M&{FLOW,(20,21)=__norm#E}[]:memory leak failure : residue is forbidden.
print residue.



/*
# ex10b8.slk -dre "generate_co\|extract_hre\|simplify_lhs_rhs" 

infer_exact [H] H(p) * H(q) & p=null & n=5 |- emp.
print residue.

# How come a diff way to infer_collect_hp_rel_classsic ??
  Can merge with infer_collect_hp_rel_empty_rhs ?

Residue:
 <1>emp&n=5 & p=null&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [H(p)&p=null --> emp&true; H(q)&true --> emp&true]


# WHY infer_collect not invoked at all

# Why did we not infer:
    H(p) & p=null -> emp
    H(q) -> emp

Need to make below much more general to return
a list of hprel & its residue.

Implemeted as:

(* (==infer.ml#3554==) *)
(* extract_hrel_head_list@9@6 *)
(* extract_hrel_head_list inp1 : H(p)&p=null&{FLOW,(20,21)=__norm#E}[] *)
(* extract_hrel_head_list@9 EXIT:Some(([(H,[ p])], emp&p=null&{FLOW,(20,21)=__norm#E}[])) *)
let extract_hrel_head_list (f0:formula) =
  let rec helper f =
    match f with
*/
