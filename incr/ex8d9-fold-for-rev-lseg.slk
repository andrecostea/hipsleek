/* Build a list of the form 1->...->1->0 */

data node {
 int h;
 node next;
}.

pred rev_lseg<p> == self=p or self::rev_lseg<t>*t::node<_,p>.

checkentail tt::node<1,p>@M * ppp::rev_lseg<tt>@M
 |-  ppp::rev_lseg<p>
.
//print residue.


/*
# ex8d9.slk

checkentail tt::node<1,p>@M * ppp::rev_lseg<tt>@M
 |-  ppp::rev_lseg<p>
.

# Can we make it work by scheduling a "fold" operation?
  for such rev-lseg specification?

  self preds: [rev_lseg]

# Can we also include a fold at priority 2?

compute_actions@1 EXIT: COND =>[
  Prio:1
  Match =>
    LHS: ppp::rev_lseg<tt>@M
    RHS: ppp::rev_lseg<p_42>@M;
  Prio:3
  BaseCaseUnfold =>
    LHS: ppp::rev_lseg<tt>@M
    RHS: ppp::rev_lseg<p_42>@M
  ]

*/

