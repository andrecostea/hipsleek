data node {
	int val; 
	node next;	
}.


/* view for a singly linked list */

pred ll<> == self = null
	or self::node<_, q> * q::ll<> 
  inv true.

pred lseg<p> == self = p
	or self::node<_, q> * q::lseg<p> 
  inv true.

pred PP<y> == self::node<_,null>
	or self::node<_, q> * q::PP<y> & q!=null 
inv true.

pred PP0<> == self::node<_,null>
	or self::node<_, q> * q::PP0<> & q!=null 
inv true.


HeapPred P(node x, node y).
HeapPred U(node x, node y).

lemma_test "L6" self::PP0<> <- self::ll<> & self!=null.
// can we unfold again if there is a false?

/*
Entailing lemma lem_16: Fail. Details below:
	 "==>" implication: : Valid.
	 "<==" implication: : Fail. (cex)(may) cause: UnionR[ (q_149!=null | q_149=null) |-  q_149=null. LOCS:[1;0;17] (may-bug),base case unfold failed]
*/

//lemma_test self::PP<y> <-> self::ll<> & self!=null.

//lemma_test self::PP<y> -> self::lseg<y> & self!=null.

//lemma_test self::PP<y> <-> self::node<_,q>*q::lseg<y>.


/*
# ex21a2.ss

lemma_test "L6" self::PP0<> <- self::ll<> & self!=null.

# extra unfolds needed when false detected on branches..

Entailing lemma lem_16: Fail. Details below:
	 "==>" implication: : Valid.
	 "<==" implication: : Fail. (cex)(may) cause: UnionR[ (q_149!=null | q_149=null) |-  q_149=null. LOCS:[1;0;17] (may-bug),base case unfold failed]

(==solver.ml#14401==)
apply_right_coercion@1
apply_right_coercion inp1 :  q_134::ll<>@M&
self_L6!=null & Anon_137=Anon_133 & q_138=q_134 & Anon_137=Anon_133 & 
q_138=q_134&{FLOW,(20,21)=__norm#E}[]
 es_gen_impl_vars(E): []
 es_heap: self_L6::node<Anon_133,q_134>@M
 es_ante_evars: [Anon_133; q_134]
 es_trace:  Fold ==>  Match(self_L6,self_L6) ==>  SEARCH ==>  (Lemma <== L6(q_134,q_138))
 es_proof_traces: 
   [self_L6::node<Anon_133,q_134>@M * q_134::ll<>@M&
    self_L6!=null:self_L6::PP0<>@M&{FLOW,(20,21)=__norm#E}[]]
apply_right_coercion inp2 : q_138::PP0<>@M
apply_right_coercion inp3 : emp
apply_right_coercion inp4 :Lemma "L6":  self::PP0<>@M&{FLOW,(20,21)=__norm#E}[]<== self::ll<>@M&self!=null&{FLOW,(20,21)=__norm#E}[]
 head match:PP0
 body view:ll
 body pred_list:[ll]
 coercion_univ_vars: []
 materialized vars:  [(self,full,[ll])]
 coercion_case: Simple
 head:  self::PP0<>@M&{FLOW,(20,21)=__norm#E}[]
 body:  self::ll<>@M&self!=null&{FLOW,(20,21)=__norm#E}[]
 head_norm:  self::PP0<>@M&{FLOW,(20,21)=__norm#E}[]
 body_norm:  EBase 
   self::ll<>@M&self!=null&{FLOW,(20,21)=__norm#E}[]
 coercion_univ_vars: []
 coercion_case: Simple
 coercion_origin: user-given
 coercion_infer_vars: []
 coercion_infer_obj: []
 coercion_kind: LEM_TEST
 coercion_fold: None

apply_right_coercion inp5 : q_138::PP0<>@M&q_138!=null&{FLOW,(1,26)=__flow#E}[]
apply_right_coercion@1 EXIT: MaybeErr Context: 
   fe_kind: MAY
   fe_name: separation entailment
   fe_locs: {
     fc_message: base_case_unfold failed
     fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}


*/
