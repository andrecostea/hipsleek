/* singly linked lists */

/* representation of a node */
data node {
	int val;
	node next;
}.

HeapPred H(node a).

//(1)
//infer_exact [H] H(p) & p=null |- emp.
//print residue.
//expect_infer Valid R{emp}.
// <1>emp&p=null&{FLOW,(20,21)=__norm#E}[]
// inferred hprel: [H(p)&p=null --> emp&true]

infer_exact [H] H(p) & p=null |- emp.
print residue.

/*
infer_exact [H] H(p) & p=null & n=5 |- emp.
print residue.

infer_exact [H] H(p) * H(q) & p=null & n=5 |- emp.
print residue.
*/

/*
# ex10b7.slk -dre "generate_co\|extract_hre\|simplify_lhs_rhs" 

 infer_exact [H] H(p) |- emp.

# GOT below. Why did we not infer H(p) --> emp

Need to make below much more general to return
a list of hprel & its residue.

Implemeted as:

(* (==infer.ml#3554==) *)
(* extract_hrel_head_list@9@6 *)
(* extract_hrel_head_list inp1 : H(p)&p=null&{FLOW,(20,21)=__norm#E}[] *)
(* extract_hrel_head_list@9 EXIT:Some(([(H,[ p])], emp&p=null&{FLOW,(20,21)=__norm#E}[])) *)
let extract_hrel_head_list (f0:formula) =
  let rec helper f =
    match f with

*/
