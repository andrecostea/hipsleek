# ex12c.slk

lemma_safe "V22" self::lseg<a, r> * r::lseg<b, p> 
   -> self::lseg<n, p> & n = a + b & a,b >=0.

lemma_safe "V21" self::lseg<n, p> & n = a + b & a,b >=0 <- self::lseg<a, r> * r::lseg<b, p>.

# V21 is mirror of V22
  Why only V22 fails by itself?

Entailing lemma V22: Fail. (cex)(may) cause: AndR[ (flted_13_451+1)!=0 & exists(n_456:n_456!=0 & flted_13_451+1=n_456) & 
 (((1<=flted_13_451 & r_453!=null) | (r_454=r_453 & flted_13_451=0))) & 
 (((1<=b & r_454!=null) | (p=r_454 & b=0))) & exists(p_455:r_454=p_455) |-  r_454=p. LOCS:[13;1;0;33];  exists(p_455:r_454=p_455) & 
 (((1<=flted_13_451 & r_453!=null) | (r_454=r_453 & flted_13_451=0))) & 
 (((1<=b & r_454!=null) | (p=r_454 & b=0))) & a!=0 & flted_13_451+1=a & 
 exists(n_456:n_456!=0 & flted_13_451+1=n_456) |-  1+flted_13_451=a+b. LOCS:[1;0;13;33] (may-bug).]
=========================================================================
# ex12d.slk --assert-no-glob-vars

lemma_safe "V22" self::lseg<a, r> * r::lseg<b, p> 
   -> self::lseg<n, p> & n = a + b & a,b >=0.

!!! WARNING logtime exception:0.000242error at: 
SLEEK FAILURE (END)

# can we print more better messages ..

!!! **solver.ml#9571:impl_vars:[]
!!! **solver.ml#9572:glob_vs:[b_113,p_114]
!!! **solver.ml#9573:evars:[]
!!! **solver.ml#9574:ivars:[]
!!! WARNING logtime exception:0.000268
Exception processed: Failure("non-empty global vars to_conseq(glob):[(b_113,b_87),(p_114,p_88)]")
error at: 
SLEEK FAILURE (END)
=========================================================================
# ex21b1a.slk

infer [U,@classic] self::node<_,null> |- self::node<_,q>*U(q,y).
print residue.

# can we use a diff message than UnmatchedRHSData?

Residue:
 <1>emp&Anon_17=Anon_16 & q=null&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [emp&q=null --> U(q,y)&true]
[[ Match(self,self) ==>  COND ==>  UnmatchedRHSData]]
=========================================================================
# ex21b3c.slk --old-search-action

compute_actions@1 EXIT: SEARCH =>[
  Prio:1
  (Lemma ==> lem_16) =>
    LHS: self::app2<y>@M
    RHS: U1(self);
  Prio:2
  InferFold =>
    LHS: self::app2<y>@M
    RHS: U1(self)
  ]

# How come no searching? There is but seems Only one answer

 <1>emp&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [self::app2<y>@M&true --> U1(self)&true]
[[ SEARCH ==>  InferFold  ==>  COND ==>  Match(self,self)]]
=========================================================================
# ex21d4.slk

# should print without --old-pred-synthesis

Residue:

 <1>emp&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U3(self_lem_19,q_156)&
                   true |#| q_156::node<Anon_157,flted_32_155>@M&
                   flted_32_155=null --> emp&self_lem_19=q_156]
[[ SEARCH ==>  BaseCaseUnfold ==>  Match(q_156,self_lem_19)]]

<2>emp&{FLOW,(20,21)=__norm#E}[]
inferred hprel: [HP_181(q_148,q_171@NI,self_lem_19@NI)&true --> emp& q_148!=null; 
                 HP_181(q_148,q_171@NI,self_lem_19@NI)& true --> U3(q_148,q_171)&true; 
                 U3(self_lem_19,q_171)&
                  true |#| q_171::node<Anon_172,flted_32_170>@M&
                  flted_32_170=null --> self_lem_19::node<Anon_179,q_180>@M * 
                                        HP_181(q_180,q_171@NI,self_lem_19@NI)&
                  true]
[[ SEARCH ==>  InferUnfold  ==>  COND ==>  (Lemma <== lem_19(q_180,q_148)) ==>  InferUnfold  ==>  Match(q_171,q_187)]]
==========================================

  HP_181(q_148,q_171@NI,self_lem_19@NI)&true --> emp& q_148!=null; 
  HP_181(q_148,q_171@NI,self_lem_19@NI)& true --> U3(q_148,q_171)&true; 

  HP_181(q_148,q_171@NI,self_lem_19@NI) --> U3(q_148,q_171)&true &q_148!=null

  HP_181(q_148,q_171@NI,self_lem_19@NI) == U3(q_148,q_171)&true &q_148!=null

========================

 U3(self_lem_19,q_156)& true |#| q_156::node<Anon_157,flted_32_155>@M& flted_32_155=null 
          --> emp&self_lem_19=q_156]
 // drop guard
 U3(self_lem_19,q_156) --> emp&self_lem_19=q_156]

 U3(self_lem_19,q_171)& true |#| q_171::node<Anon_172,flted_32_170>@M& flted_32_170=null 
     --> self_lem_19::node<Anon_179,q_180>@M *  HP_181(q_180,q_171@NI,self_lem_19@NI)&
 // unfold HP
 U3(self_lem_19,q_171)& true |#| q_171::node<Anon_172,flted_32_170>@M& flted_32_170=null 
     --> self_lem_19::node<Anon_179,q_180>@M *  U3(q_148,q_171)&true &q_148!=null
 // drop guard
 U3(self_lem_19,q_171)& true 
     --> self_lem_19::node<Anon_179,q_180>@M *  U3(q_148,q_171)&true &q_148!=null

 Combine
 =======
 U3(self_lem_19,q_156) --> emp&self_lem_19=q_156]
 \/  U3(self_lem_19,q_171)& true 
     --> self_lem_19::node<Anon_179,q_180>@M *  U3(q_148,q_171)&true &q_148!=null
 // combine
 U3(self_lem_19,q_156) --> emp&self_lem_19=q_156]
   or self_lem_19::node<Anon_179,q_180>@M *  U3(q_148,q_171)&true &q_148!=null
 // form defn
 U3(self_lem_19,q_156) == emp&self_lem_19=q_156]
   or self_lem_19::node<Anon_179,q_180>@M *  U3(q_148,q_171)&true &q_148!=null

=========================================================================
# ex21d1a.slk (Loc to fix)

lemma_unsafe
  self::app3<> -> self::node<_,q>*U(q).

infer [U1,classic]
  self::app3<> & q2!=null 
   |- U1(self).

# infer_fold 1
# lemma ==>

Need to schedule this inside:
     process_one_match_mater_unk_w_view [] right_preds vl_name h_name m_res ms alternative
     (* TODO : if data_node for view, schedule Seq_action [infer_fold 1; lemma] *)

--=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
