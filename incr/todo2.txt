# ex12c.slk

lemma_safe "V22" self::lseg<a, r> * r::lseg<b, p> 
   -> self::lseg<n, p> & n = a + b & a,b >=0.

lemma_safe "V21" self::lseg<n, p> & n = a + b & a,b >=0 <- self::lseg<a, r> * r::lseg<b, p>.

# V21 is mirror of V22
  Why only V22 fails by itself?

Entailing lemma V22: Fail. (cex)(may) cause: AndR[ (flted_13_451+1)!=0 & exists(n_456:n_456!=0 & flted_13_451+1=n_456) & 
 (((1<=flted_13_451 & r_453!=null) | (r_454=r_453 & flted_13_451=0))) & 
 (((1<=b & r_454!=null) | (p=r_454 & b=0))) & exists(p_455:r_454=p_455) |-  r_454=p. LOCS:[13;1;0;33];  exists(p_455:r_454=p_455) & 
 (((1<=flted_13_451 & r_453!=null) | (r_454=r_453 & flted_13_451=0))) & 
 (((1<=b & r_454!=null) | (p=r_454 & b=0))) & a!=0 & flted_13_451+1=a & 
 exists(n_456:n_456!=0 & flted_13_451+1=n_456) |-  1+flted_13_451=a+b. LOCS:[1;0;13;33] (may-bug).]
=========================================================================
# ex12d.slk --assert-no-glob-vars

lemma_safe "V22" self::lseg<a, r> * r::lseg<b, p> 
   -> self::lseg<n, p> & n = a + b & a,b >=0.

!!! WARNING logtime exception:0.000242error at: 
SLEEK FAILURE (END)

# can we print more better messages ..

!!! **solver.ml#9571:impl_vars:[]
!!! **solver.ml#9572:glob_vs:[b_113,p_114]
!!! **solver.ml#9573:evars:[]
!!! **solver.ml#9574:ivars:[]
!!! WARNING logtime exception:0.000268
Exception processed: Failure("non-empty global vars to_conseq(glob):[(b_113,b_87),(p_114,p_88)]")
error at: 
SLEEK FAILURE (END)
=========================================================================
# ex21b1a.slk

infer [U,@classic] self::node<_,null> |- self::node<_,q>*U(q,y).
print residue.

# can we use a diff message than UnmatchedRHSData?

Residue:
 <1>emp&Anon_17=Anon_16 & q=null&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [emp&q=null --> U(q,y)&true]
[[ Match(self,self) ==>  COND ==>  UnmatchedRHSData]]
=========================================================================
# ex21b3c.slk --old-search-action

compute_actions@1 EXIT: SEARCH =>[
  Prio:1
  (Lemma ==> lem_16) =>
    LHS: self::app2<y>@M
    RHS: U1(self);
  Prio:2
  InferFold =>
    LHS: self::app2<y>@M
    RHS: U1(self)
  ]

# How come no searching? There is but seems Only one answer

 <1>emp&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [self::app2<y>@M&true --> U1(self)&true]
[[ SEARCH ==>  InferFold  ==>  COND ==>  Match(self,self)]]
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
=========================================================================
