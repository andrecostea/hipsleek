=====================================================================
# ex3b.ss

# Can we derive more reusable shape specification,
  namely the 1st spec below.

  ll<> == self=null or self::node<_,q>*q::ll<>;
  lseg<p> == self=p or self::node<_,q>*q::lseg<p>;
  gg<p> == self=null or self=p or self::node<_,q>*q::gg<p>;

  requires x::ll<>
  ensures x::ll<> or x::lseg<p>*p::ll<>;

Above verifies!

  requires x::ll<>
  ensures x::gg<p>*p::ll<>;

Above verifies!

The former is better since it supports better re-use of
specification and predicates.

=====================================================================
# ex3c.ss

  infer [R1,R2]
  requires x::ll<>
  ensures x::ll<> & R1(res) or x::lseg<p>*p::ll<> & R2(res);

# pure bi-abduction is not working here. is it due
  to mutual recursion?

# see ex3d.ss as our target spec ..
  requires x::ll<>
  ensures x::ll<> & res or x::lseg<p>*p::ll<> & !res;

We need to investigate. Is it due to fixcalc 
or some other problems..

*************************************
******pure relation assumption 1 *******
*************************************
[RELDEFN R1: ( 1<=res) -->  R1(res),
RELDEFN R2: ( 1<=res) -->  R2(res),
RELDEFN R1: ( R1(res)) -->  R1(res),
RELDEFN R2: ( R1(res)) -->  R2(res),
RELDEFN R2: ( R2(res)) -->  R2(res),
RELDEFN R1: ( not(res)) -->  R1(res),
RELDEFN R2: ( not(res)) -->  R2(res)]
*************************************

!!! PROBLEM with fix-point calculation
ExceptionFailure("split_quantifiers: invalid argument (formula_or)")Occurred!

=====================================================================
# ex3f1.ss

  requires x::ll<>
  ensures x::llR<R1> & res or x::lsegR<R1,p>*p::ll<> & !res;

# not sure why fail. need to check if pred built correctly.

Context of Verification Failure: ex3f1-verify-content-check-all-ones-ll-lseg.ss_28:10_28:26

Last Proving Location: ex3f1-verify-content-check-all-ones-ll-lseg.ss_36:14_36:19

ERROR: at ex3f1-verify-content-check-all-ones-ll-lseg.ss_28:10_28:26
Message: Post condition cannot be derived.

Procedure check_ones$node FAIL.(2)


Exception Failure("Post condition cannot be derived.") Occurred!
==========================
# ex3f1.ss --pcp

# Not enough type info for relation..

 view lsegR{}[]<R:RelT([]),p:node>= 
  view_domains: 
   view lsegR<R:RelT([]),p:node>= 
    EList
      :EBase 
         (* lbl: *){222}->emp&self=p&{FLOW,(1,28)=__flow#E}[]
      || :EBase 
            exists (Expl)[](Impl)[v; 
            q](ex)[](* lbl: *){223}->(exists p_24: (* lbl: *){223}->self::node<v,q>@M * 
                                                                    q::lsegR<R,p_24>@M&
            R(v) & p_24=p&{FLOW,(1,28)=__flow#E}[]

# Did R1 capture r=1? Can print?

 relation R1(int r).

# what are these warnings for?

WARNING: _0:0_0:0:Z3 error message: (error "line 3427 column 29: unknown function/constant R1_1553")

# maybe we can try with simpler examples involving
  2nd-order verification..
=====================================================================
# ex3b2.ss

  infer [R]
  requires x::ll<>
  ensures x::lseg<p>*p::ll<> & R(res,p);

GOT
===
!!! **pi.ml#775:>>>>>>>>>>> (bef postprocess): <<<<<<<<<
!!! **pi.ml#776:>>REL POST:  R(res,p)
!!! **pi.ml#777:>>POST:  (not(res) | (p=null & res))
!!! **pi.ml#778:>>REL PRE :  true
!!! **pi.ml#779:>>PRE :  true

Can we get a stronger:
    !!! **pi.ml#777:>>POST:  (not(res) & p!=null | (p=null & res))
=====================================================================
# ex3b1.ss

  requires x::ll<>
  ensures x::lseg<p>*p::ll<> & (res & p=null | !res & p!=null);

Above verifies!

Above seems a more concise spec to aim for ..
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
=====================================================================
