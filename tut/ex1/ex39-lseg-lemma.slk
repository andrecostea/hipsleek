data node {
  int val;
  node next;
}.

/*
pred lseg<n,p> == emp & self=p & n=0
  or self::node<_,q>*q::lseg<n-1,p>
  inv n>=0.
*/

pred lseg<n, p> ==
 case {
  n=0 -> [] emp & self = p & n = 0;
  n!=0 -> [] self::node<_, q> * q::lseg<n - 1, p>;
 } inv n >= 0.

/*
pred ls_nt<n,p> == emp & self=p & n=0
  or self::node<_,q>*q::ls_nt<n-1,p> & self!=p
  inv n>=0.
*/

pred ls_nt<n, p> ==
 case {
  n=0 -> [] emp & self = p & n = 0;
  n!=0 -> [] self::node<_, q> * q::ls_nt<n - 1, p> & self!=p;
 } inv n >= 0.

lemma_safe "lseg-combine" self::lseg<n,p> <- 
         self::lseg<a,q>*q::lseg<b,p> & n=a+b.

lemma_safe "ls_nt_combine" self::ls_nt<n,p> <- 
         self::ls_nt<a,q>*q::ls_nt<b,p> * p::node<_,_>@L & n=a+b.

lemma_safe "lseg-split" self::lseg<n,p> & n=a+b & a,b>=0 -> 
         self::lseg<a,q>*q::lseg<b,p>.

lemma_safe "ls_nt-split" self::ls_nt<n,p> & n=a+b & a,b>=0 -> 
         self::ls_nt<a,q>*q::ls_nt<b,p>.
