
data node {
	int val@VAL; 
	node next@REC; 
}.

pred ll<> == self=null
  or self::node<_,p> * p::ll<>
inv true.

pred_extn size<R,n> ==
   n=0 // base case
   or R::size<R,m> & n=1+m // recursive case
   inv n>=0.

pred_extn head<V,n> ==
   n=V .

pred_extn sum<V,R,s> ==
   s=0 // base case
   or REC::sum<V,R,s2> & n=V+s2 .

pred_extn height<R,h> ==
   h=0 // base case
   or R::height<R,h2> & h=1+max(h2) .

pred_extn ordered<V,RR:relation(int,int)> ==
   R::ordered<V2,RR> & RR(V,V2) .

pred_extn set<V,R,S> ==
   S={}
   or R::set<V,R,S2> & S={V} union S2 .

pred_extn minValue<V,m> ==
   R::minValue<V,m2> & m=min(V,m2).

pred_extn maxValue<V,m> ==
   R::maxValue<V,m2> & m=max(V,m2).

pred llN<n> == extend ll<> with size<REC,n> .

pred llNSum<s,n> == extend llN<n> with sum<VAL,REC,s> .

pred llH<n> == extend ll<> with height<REC,n>.

pred llS<n> == extend ll<> with set<VAL,REC,S>.

pred llNS<n,S> == extend llN<n> with set<VAl,REC,S>.

pred llHead<n> == extend ll<> with head<VAL,n>.

pred llMin<m> == extend ll<> with minValue<VAL,m>.

pred llMax<m> == extend ll<> with maxValue<VAL,m>.

relation Inc(int a, Int b) == a<=b .

relation Dec(int a, Int b) == a>=b .

pred llOrdered<v,R> == extend llHead<h> with ordered<v,R> .

pred llSorted<v> == extend llHead<h> with ordered<v,Inc> .

pred llSorted<v> == llOrdered<v,Dec> .

pred llMinMax<mi,mx> == extend ll<> 
             with maxValue<VAL,mx>,minValue<VAL,mi>.

data node2 {
	int val@VAL; 
	node2 next@REC; 
	node2 next@REC; 
}.

pred tree<> == self=null
  or tree::node2<_,p,q> * p::tree<> * q::tree<>
inv true.

pred treeN<n> == extend tree<> with size<REC,n> .

pred treeNSum<n> == extend treeN<n> with sum<VAL,REC,n> .

pred treeH<n> == extend tree<> with height<REC,n>.

pred treeS<n> == extend tree<> with set<VAL,REC,S>.

pred treeNS<n,S> == extend treeN<n> with set<VAl,REC,S> .

pred treeHead<n> == extend tree<> with head<VAL,n> .











