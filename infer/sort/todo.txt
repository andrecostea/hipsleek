## n-ins-3a.ss

 infer [R]
 requires x::sortA<a> * y::node<v,null>
 ensures  res::sortA<b> & R(b,a,v);

  requires x::sortA<a> * y::node<v,null>
  ensures  res::sortA<b> & b=min(a,v) ;

 why does this example succeed individually
 but fails when put together? 
 esp when infernce is done before checking
 Is this due to us modifying the spec after inference?
 Maybe we need to re-think on this.


## n-sort-2f.ss

node sort(node x)
     infer [R0,R1]
     requires x::sortHO<a,R0>
     ensures  res::sortHO<b,R1> & b<=a;
     //b<=a ;

[RELASS [R0,R1]: ( R1(r_647,a_648)) -->  r_647<=a_648,
RELDEFN R1: ( r_677<=a_678) -->  R1(r_677,a_678)]
*************************************

!!! REL POST :  R1(r_677,a_678)
!!! POST:  r_677<=a_678
!!! REL PRE :  true
!!! PRE :  true

@@  R1 is not strictly a post. but it is a post-relation
    where ideally, we wish for the strongest? However, what if we
    had :  Pred(..R..) :- not(R(..))

## n-ins-3c.ss (simplifying RELDEFN)

@ NEED to do simplicafication of relational definition
  to avoid timeouts in larger examples.

RELDEFN R2: ( b<=v2_671) -->  R2(b,v2_671),
RELDEFN R2: ( R(r_744,a_745)) -->  R2(r_744,a_745),
RELDEFN R2: ( R(a,v2_619) & a=v2_709 & v2_619=v2_727) -->  R2(v2_709,v2_727),
   @can we substitute equality for existential variables on LHS 
    such as a=? and v2_619=? to obtain:
   R(v2_709,v2_727) -->  R2(v2_709,v2_727)
RELDEFN R2: ( v2_619=v2_727 & R2(v_617,v2_727) & R(a,v2_619) & v2_709=v_617 & a=v2_709 & 
b<=v2_709) -->  R2(b,v2_709),
  @elim exists = on LHS
  R2(v2_709,v2_727) & R(r_744,a_745) & R(v2_709,v2_727) &  b<=v2_709 
  -->  R2(b,v2_709)
  @filter irrelevant on LHS
  R2(v2_709,v2_727) & R(v2_709,v2_727) &  b<=v2_709 
  -->  R2(b,v2_709)
  @using R(..)->R2(..)
  R(v2_709,v2_727) &  b<=v2_709 
  -->  R2(b,v2_709)
RELDEFN R2: ( b<v2_758) -->  R2(b,v2_758),
RELDEFN R2: ( R(a,v2_619) & ((a=b & a<v2_798 & v2_798<=v2_619) | (a=b & v2_619=v2_798))) -->  R2(b,v2_798)]
*
   @do a deep split of disjunction on the LHS
    R(a,v2_619) & a=b & a<v2_798 & v2_798<=v2_619
    -->  R2(b,v2_798)]
    R(a,v2_619) & a=b & v2_619=v2_798 
    -->  R2(b,v2_798)]
   @eliminate existential = on LHS
    R(b,v2_619) & b<v2_798 & v2_798<=v2_619
    -->  R2(b,v2_798)]
    R(b,v2_798) 
    -->  R2(b,v2_798)]

 Summary:
   (b<=v2_671) -->  R2(b,v2_671),
   R(r_744,a_745) -->  R2(r_744,a_745)
   R(v2_709,v2_727) -->  R2(v2_709,v2_727)
   R(v2_709,v2_727) &  b<=v2_709 -->  R2(b,v2_709)
   b<v2_758) -->  R2(b,v2_758)
   R(b,v2_619) & b<v2_798 & v2_798<=v2_619 -->  R2(b,v2_798)]
   R(b,v2_798) -->  R2(b,v2_798)

 Remove duplicates:
   (b<=v2_671) -->  R2(b,v2_671),
   b<v2_758) -->  R2(b,v2_758)
   R(v2_709,v2_627) -->  R2(v2_709,v2_727)
   R(v2_709,v2_727) &  b<=v2_709 -->  R2(b,v2_709)
   R(b,v2_619) & b<v2_798 & v2_798<=v2_619 -->  R2(b,v2_798)]

 Combine constant on LHS and PairWiseCheck:
   b<=v2_671 -->  R2(b,v2_671),
   R(v2_709,v2_627) -->  R2(v2_709,v2_727)
   R(v2_709,v2_727) &  b<=v2_709 -->  R2(b,v2_709)
   R(b,v2_619) & b<v2_798 & v2_798<=v2_619 -->  R2(b,v2_798)]

##################################################

 At this point, we can do two things
  (i) keep relational constraints
  (ii) use strongest post; to find weakest pre

 Let us try (ii).
 We first determine the strongest post-relation, namely:
   b<=v2_671 -->  R2(b,v2_671),
 After that, we substitute in to determine pre of R(..)
   R(v2_709,v2_627) -->  v2_709<=v2_727)
   R(v2_709,v2_727) &  b<=v2_709 -->  b<=v2_709
   R(b,v2_619) & b<v2_798 & v2_798<=v2_619 -->  b<=v2_798
 This should then yield relational assumptions:
   R(v2_709,v2_627) -->  v2_709<=v2_727
   R(v2_709,v2_727) -->  v2_709<=v2_727

 With this, we can get:
  [a<=b -> R2(a,b); R(a,b) -> a<=b]
  [true -> R2(a,b); R(a,b) -> true]

We can add both versions to pre/post; as follows:

 node sort(node x)
  requires x::sortHO<a,R0> & R0(a,b)-->a<=b
  ensures  res::sortHO<b,R1> & b<=a & R2(a,b)-->a<=b;
  requires x::sortHO<a,R0> 
  ensures  res::sortHO<b,R1> & b<=a &
   b<=v2_671 -->  R2(b,v2_671),
   R(v2_709,v2_627) -->  R2(v2_709,v2_727)
   R(v2_709,v2_727) &  b<=v2_709 -->  R2(b,v2_709)
   R(b,v2_619) & b<v2_798 & v2_798<=v2_619 -->  R2(b,v2_798)]

## n-ins-4b3a.ss

PROBLEM : some time-outs and very large RELDEFN. 
 see a-ins-4b3a.ss.
 It is important to do the simplification mechanisms
 (see n-ins-2b.ss)

 for RELDEFN.

llMM<v,mi,mx> == self::node<v,null> & mi=v & mx=v 
  or self::node<v, p> * p::llMM<_,mi2,mx2> 
     & mi=min(v,mi2) & mx=max(v,mx2)
inv self!=null;


node insert(node x, node y)
     infer [P3,P4]
     requires x::llMM<v,mi,mx> * y::node<a,null> 
      //& R(a,mi,mx)
     ensures  res::llMM<v2,mi2,mx2> 
         & P3(mi,a,mi2) 
         & P4(mx,a,mx2);
Checking procedure insert$node~node... Timeout when checking #simplify  Restarting Omega after ... 166 invocations Stop Omega... 166 invocations Starting Omega...oc
Timeout when checking #simplify  Restarting Omega after ... 167 invocations Stop Omega... 167 invocations Starting Omega...oc

!!! REL POST :  P4(mx,a,mx2)
!!! POST:  (mx=mx2 & a<=mx) | (a=mx2 & mx<mx2)
!!! REL PRE :  true
!!! PRE :  true
!!! REL POST :  P3(mi,a,mi2)
!!! POST:  (a=mi2 & a<=mi) | (mi=mi2 & mi2<=a)
!!! REL PRE :  true
!!! PRE :  true
Total verification time: 15.200949 second(s)
	Time spent in main process: 6.4044 second(s)
	Time spent in child processes: 8.796549 second(s)


## n-sel-1.ss
Need to do sanity checks


## n-ins-3e.ss

node insert(node x, node y)
     infer [R,R2]
     requires x::sortHO<a,R> * y::node<v,null>
     ensures  res::sortHO<b,R2> 
        //&  b=min(a,v) 
        //& (v>a & b=a | (a>=b & b=v))
     ;

Without the post-relation b=min(a,v), how come
we are able to infer sortedness property below.
Have we checked the obligations?

How come we still can have strongest post for R2?
I suppose the last defn ( R(b,v2_615)) -->  R2(b,v2_794)
cannot be proven.

[RELDEFN R2: ( b<=v2_667) -->  R2(b,v2_667),
RELDEFN R2: ( R(r_740,a_741)) -->  R2(r_740,a_741),
RELDEFN R2: ( R(v2_705,v2_723)) -->  R2(v2_705,v2_723),
RELDEFN R2: ( R2(v2_705,v2_723) & R(v2_705,v2_723) & b<=v2_705) -->  R2(b,v2_705),
RELDEFN R2: ( b<v2_754) -->  R2(b,v2_754),
RELDEFN R2: ( R(b,v2_615)) -->  R2(b,v2_794)]

Below is the correct version.

RELDEFN R2: ( b<=v2_668) -->  R2(b,v2_668),
RELDEFN R2: ( R(r_741,a_742)) -->  R2(r_741,a_742),
RELDEFN R2: ( R(v2_706,v2_724)) -->  R2(v2_706,v2_724),
RELDEFN R2: ( R2(v2_706,v2_724) & R(v2_706,v2_724) & b<=v2_706) -->  R2(b,v2_706),
RELDEFN R2: ( b<v2_755) -->  R2(b,v2_755),
RELDEFN R2: ( R(b,v2_616) & b<v2_795 & v2_795<=v2_616) -->  R2(b,v2_795),
RELDEFN R2: ( R(b,v2_795)) -->  R2(b,v2_795)]

*************************************

*************************************
*******fixcalc of pure relation *******
*************************************
[( R2(b,v2_668), b<=v2_668, R(r_741,a_742), r_741<=a_742)]
*************************************

!!! REL POST :  R2(b,v2_668)
!!! POST:  b<=v2_668
!!! REL PRE :  R(r_741,a_742)
!!! PRE :  r_741<=a_742
Procedure insert$node~node SUCCESS
