# zip-n-2.ss #DONE

Please print the infer pre/post formed, e.g.
 infer [P,R]
 requires x::llN<a>*y::ll<b> & P(a,b)
 ensures res::ll<r> & R(r,a,b)

Also, why isn't a summary of pre/post
printed after fixcalc. Did it call fixcalc?

# n-z-1d-1.ss #DONE

Why do we infer P when it is not in the selected var list.

# n-z-1d.ss #DONE

!!! REL POST :  R(res,x,y)
!!! POST:  x>=0 & y>=x & res=x
!!! REL PRE :  P(x,y)
!!! PRE :  0<=x & x<=y

PROBLEM : can we gist x>=0 away
 from both pre/post

# zip-n.ss #DONE

For below:
 RELASS [P]: ( P(a,b)) -->  (b!=0 | 2>a) & (b!=0 | a!=1),
Why did we not derived below instead:
 RELASS [P]: ( P(a,b)) -->  (b!=0 | a<=0)

# zip-n-3.ss  #DONE

!!! REL PRE :  P(a,b)
!!! PRE :  (b<=(a-1) & b<=(0-1)) | a<=b
Can filter a disjunct to:
!!! PRE :  a<=b

# n-ins-3c.ss #DONE

!!! REL POST :  R2(b,v2_671)
!!! POST:  true
!!! REL PRE :  true
!!! PRE :  true

PROBLEM
=======

We need a stronger post-condition.

Algorithm
=========
(i) For each 
     X & Pre(..) --> Post(...)
    determine if X -> Post(..) reduces to true --> Post(...)
    and remove it if so, for pre-condition obligation later
(ii) Form a definition for Post(..) to compute least fix-point.
(iii) Extract pre from Post and form an assumption
          Pre(..) -> Y_i
(iv) For each obligation of form:
       X & Pre(..) --> ..
     determine relational assumptions of the form:
       Pre(..) --> Y_j
(v) Form an initial Precondition
      Pre(..) -> Y wher Y=Y1 & ... & Yn
   Check if current pre satisfies all the obligation
      ... & Pre(..) --> Pre(..)
(vi) If not, perform a top-down fix-point using 
      ... & Pre(..) --> Pre(..)
    to ensure it satisfies 
      Pre(..) --> Y
    for all recursive invocations.

# n-ins-3a.ss

 infer [R]
 requires x::sortA<a> * y::node<v,null>
 ensures  res::sortA<b> & R(b,a,v);

  requires x::sortA<a> * y::node<v,null>
  ensures  res::sortA<b> & b=min(a,v) ;

 why does this example succeed individually
 but fails when put together? 
 esp when infernce is done before checking
 Is this due to us modifying the spec after inference?
 Maybe we need to re-think on this.

# n-z-1d-2.ss

relation R(int a,int b,int c).
relation P(int a,int b).

int zip(int x, int y)
  infer [R]
  requires x>=0 & y>=0 & P(x,y)
  ensures  R(res,x,y);

Sound we have a WARNING that unknown P is not
in the inferred list?

# zip-i-2.ss; zip-i-def.ss

 WHY is printing below different with NEW SPECS

  infer [a,b,R]
  requires x::llN<a> * y::llN<b>
  ensures  res::llN<r> & R(a,b,r);


!!! REL POST :  R(a,b,r)
!!! POST:  a=r & 0<=r & r<=b
!!! REL PRE :  true
!!! PRE :  true
!!! NEW SPECS: ((None,[]),EBase exists (Expl)(Impl)[a; 
                  b](ex)x::llN<a>@M[0][Orig][LHSCase] * 
                  y::llN<b>@M[0][Orig][LHSCase]&true&{FLOW,(22,23)=__norm}[]
                    EBase emp&(1<=b | b<=(0-1) | a<=0) & MayLoop&
                          {FLOW,(1,25)=__flow}[]
                            EAssume 66::
                              EXISTS(r: res::llN<r>@M[0][Orig][LHSCase]&
                              a=r & 0<=r & r<=b&{FLOW,(22,23)=__norm})[])

# n-sort-2.ss
 
   WHY no error messages on missing R0; R1
   node sort(node x)
     infer [R0,R1]
     requires x::ls<a>
     ensures  res::sortA<b> & b<=a ;

# n-sort-2c.ss

Why false inferred?

*************************************
[RELASS [R0]: ( R0(r_643,a_644)) -->  r_643<=a_644,
RELDEFN R0: ( r_643<=a_644 & r_673<=a_674 & R0(r_643,a_644)) 
                -->  R0(r_673,a_674)]
*************************************

!!! REL POST :  R0(r_673,a_674)
!!! POST:  false
!!! REL PRE :  true
!!! PRE :  true
Procedure sort$node SUCCESS

# n-id.ss

node id(node x)
  infer [R1,R2]
  requires x::sortHO<a,R1>
  ensures  res::sortHO<a,R2> & res=x;

Checking procedure id$node... 
*************************************
*******pure relation assumption ******
*************************************
[RELDEFN R2: ( a=a_30 & v2_590=v2_622 & R1(a,v2_590)) -->  R2(a_30,v2_622)]
*************************************
fixcalc: Parse error on line 2 rest of line: ;

PROBLEM : should use 1=0 rather than false

/*
  # R1(a,b)-->R2(a,b)

  RELDEFN R2: ( a=a_30 & v2_590=v2_622 & R1(a,v2_590)) -->  R2(a_30,v2_622)]

*/
{

# err-9-m-app.ss

node append(node x, node y)
  infer [R1,P2]
  requires x::sortHO<a,R1,mi,mx> * y::node<b,null> &  P2(mx,b)
  ensures  res::sortHO<a,R2,mi2,mx2> & mi2=min(mi,b) & mx2=max(mx,b) & res=x;
/*

Need sanity checks on what is being inferred
so inconsistency are detected early.

In the above case it caused "simplify to have a problem".

Checking procedure append$node~node... Timeout when checking #simplify  Restarting Omega after ... 104 invocations Stop Omega... 104 invocations Starting Omega...oc

Solution 
  (i) fix Omega (done)
 (ii) provide sanity checks.

*/

# n-sort-2c.ss #DONE

  added filter_ante_wo_rel to avoid treating relation
  as variables

node sort(node x)
     infer [R0]
     requires x::ls<a>
     ensures  res::sortHO<b,R0> & b<=a ;
/*

We derived:

Checking procedure sort$node... 
*************************************
*******pure relation assumption ******
*************************************
[RELASS [R0]: ( R0(r_643,a_644)) -->  r_643<=a_644,
RELDEFN R0: ( r_643<=a_644 & r_673<=a_674 & R0(r_643,a_644)) 
                -->  R0(r_673,a_674)]
However  R0(r_643,a_644) is not really connected to
the output on RHS. Actually, we should have obtained
below instead if we only traverse the connected
formula on the LHS.

// --dis-pre-residue gives
*************************************
*******pure relation assumption ******
*************************************
[RELASS [R0]: ( R0(r_643,a_644)) -->  r_643<=a_644,
RELDEFN R0: ( r_673<=a_674) -->  R0(r_673,a_674)]
*************************************

# n-sort-2e.ss

node sort(node x)
     infer [R0,P]
     requires x::ls<a>
     ensures  res::sortHO<b,R0> & P(b,a);
     //b<=a ;
/*

WHY did we have superfluous vars r_674,a_675?
Weren't they quantified in the fixcalc input?
If so, they should NOT be present in the final answer.

!!! REL POST :  P(b,a)
!!! POST:  a=b | (b<a & r_674<=a_675)

P:={[a] -> [b] -> []: (b=a ||  (exists (a_631: (exists (b_642: (exists (a_645: (exists (r_644:((((b=a && (a<=b_642 && r_644<=a_645)) || (b_642=a && (a<b && r_644<=a_645))) && R0(r_644,a_645)) && P(b_642,a_631)))) )) )) )) )
};
R0:={[] -> [r_674,a_675] -> []: r_674<=a_675
};
bottomupgen([P,R0], [2,2], SimHeur);

Above is not mutually recursive. First R0 is non-recursive, so we
first determine that 
    R0(r,a) -> r<=a
Later, we inline R0(..) in the defintion of P(..). Actually,
we have already done the inlining with of --en-pre-residue.

With that, we perform a fix-point of just P(..)

# n-sort-2f.ss

node sort(node x)
     infer [R0,R1]
     requires x::sortHO<a,R0>
     ensures  res::sortHO<b,R1> & b<=a;
     //b<=a ;

[RELASS [R0,R1]: ( R1(r_647,a_648)) -->  r_647<=a_648,
RELDEFN R1: ( r_677<=a_678) -->  R1(r_677,a_678)]
*************************************

!!! REL POST :  R1(r_677,a_678)
!!! POST:  r_677<=a_678
!!! REL PRE :  true
!!! PRE :  true

@@  R1 is not strictly a post. but it is a post-relation
    where ideally, we wish for the strongest? However, what if we
    had :  Pred(..R..) :- not(R(..))

# n-ins-3c.ss (simplifying RELDEFN)

RELDEFN R2: ( b<=v2_671) -->  R2(b,v2_671),
RELDEFN R2: ( R(a,v2_619) & R(r_744,a_745)) -->  R2(r_744,a_745)
  @ why filter_ante_wo_rel did not remove R(a,v2_619)?
  R(r_744,a_745) -->  R2(r_744,a_745)
RELDEFN R2: 
   R(r_744,a_745) & R(a,v2_619) & a=v2_709 & v2_619=v2_727) 
         -->  R2(v2_709,v2_727)
   @can we substitute equality for existential variables on LHS 
    such as a=? and v2_619=? to obtain:
   R(r_744,a_745) & R(v2_709,v2_727) -->  R2(v2_709,v2_727)
   @this can be followed by filtet_ante_wo_rel
   R(v2_709,v2_727) -->  R2(v2_709,v2_727)
RELDEFN R2: 
  (v2_619=v2_727 & R2(v_617,v2_727) & R(r_744,a_745) & R(a,v2_619) & 
    v2_709=v_617 & a=v2_709 & b<=v2_709) -->  R2(b,v2_709)
  @elim exists = on LHS
  R2(v2_709,v2_727) & R(r_744,a_745) & R(v2_709,v2_727) &  b<=v2_709 
  -->  R2(b,v2_709)
  @filter irrelevant on LHS
  R2(v2_709,v2_727) & R(v2_709,v2_727) &  b<=v2_709 
  -->  R2(b,v2_709)
  @using R(..)->R2(..)
  R(v2_709,v2_727) &  b<=v2_709 
  -->  R2(b,v2_709)

RELDEFN R2: ( b<v2_758) -->  R2(b,v2_758),
RELDEFN R2: 
   ( R(a,v2_619) & 
     ((a=b & a<v2_798 & v2_798<=v2_619) | (a=b & v2_619=v2_798))) 
    -->  R2(b,v2_798)]
   @do a deep split of disjunction on the LHS
    R(a,v2_619) & a=b & a<v2_798 & v2_798<=v2_619
    -->  R2(b,v2_798)]
    R(a,v2_619) & a=b & v2_619=v2_798 
    -->  R2(b,v2_798)]
   @eliminate existential = on LHS
    R(b,v2_619) & b<v2_798 & v2_798<=v2_619
    -->  R2(b,v2_798)]
    R(b,v2_798) 
    -->  R2(b,v2_798)]

 Summary:
   (b<=v2_671) -->  R2(b,v2_671),
   R(r_744,a_745) -->  R2(r_744,a_745)
   R(v2_709,v2_727) -->  R2(v2_709,v2_727)
   R(v2_709,v2_727) &  b<=v2_709 -->  R2(b,v2_709)
   b<v2_758) -->  R2(b,v2_758)
   R(b,v2_619) & b<v2_798 & v2_798<=v2_619 -->  R2(b,v2_798)]
   R(b,v2_798) -->  R2(b,v2_798)

 Remove duplicates:
   (b<=v2_671) -->  R2(b,v2_671),
   b<v2_758) -->  R2(b,v2_758)
   R(v2_709,v2_627) -->  R2(v2_709,v2_727)
   R(v2_709,v2_727) &  b<=v2_709 -->  R2(b,v2_709)
   R(b,v2_619) & b<v2_798 & v2_798<=v2_619 -->  R2(b,v2_798)]

 Combine constant on LHS and PairWiseCheck:
   b<=v2_671 -->  R2(b,v2_671),
   R(v2_709,v2_627) -->  R2(v2_709,v2_727)
   R(v2_709,v2_727) &  b<=v2_709 -->  R2(b,v2_709)
   R(b,v2_619) & b<v2_798 & v2_798<=v2_619 -->  R2(b,v2_798)]

 At this point, we can do three things
  (i) keep relational constraints
  (ii) use weakest pre; to find strongest post
  (iii) use strongest post; to find weakest pre

 Let us try (ii).
 We first determine the weakest  R(..)
   R(a,b) --> true
 After that, we substitute in to determine strongest R1:
   b<=v2_671 -->  R2(b,v2_671),
   true -->  R2(v2_709,v2_727)
   b<=v2_709 -->  R2(b,v2_709)
   b<v2_798 & v2_798<=v2_619 -->  R2(b,v2_798)]
 After that, we substitute in to determine strongest R1:
   true --> R(v,b)

 Let us try (iii).
 We first determine the strongest post-relation, namely:
   b<=v2_671 -->  R2(b,v2_671),
 After that, we substitute in to determine pre of R(..)
   R(v2_709,v2_627) -->  v2_709<=v2_727)
   R(v2_709,v2_727) &  b<=v2_709 -->  b<=v2_709
   R(b,v2_619) & b<v2_798 & v2_798<=v2_619 -->  b<=v2_798
 This should then yield relational assumptions:
   R(v2_709,v2_627) -->  v2_709<=v2_727
   R(v2_709,v2_727) -->  v2_709<=v2_727

 With this, we can get:
  [a<=b -> R2(a,b); R(a,b) -> a<=b]
  [true -> R2(a,b); R(a,b) -> true]

node sort(node x)
  requires x::sortHO<a,R0> & R0(a,b)-->a<=b
  ensures  res::sortHO<b,R1> & b<=a & R2(a,b)-->a<=b;
  requires x::sortHO<a,R0> 
  ensures  res::sortHO<b,R1> & b<=a &
   b<=v2_671 -->  R2(b,v2_671),
   R(v2_709,v2_627) -->  R2(v2_709,v2_727)
   R(v2_709,v2_727) &  b<=v2_709 -->  R2(b,v2_709)
   R(b,v2_619) & b<v2_798 & v2_798<=v2_619 -->  R2(b,v2_798)]




