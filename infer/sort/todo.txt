# zip-n-2.ss #DONE

Please print the infer pre/post formed, e.g.
 infer [P,R]
 requires x::llN<a>*y::ll<b> & P(a,b)
 ensures res::ll<r> & R(r,a,b)

Also, why isn't a summary of pre/post
printed after fixcalc. Did it call fixcalc?

# n-z-1d-1.ss #DONE

Why do we infer P when it is not in the selected var list.

# n-z-1d.ss

!!! REL POST :  R(res,x,y)
!!! POST:  x>=0 & y>=x & res=x
!!! REL PRE :  P(x,y)
!!! PRE :  0<=x & x<=y

PROBLEM : can we gist x>=0 away
 from both pre/post

# zip-n.ss #DONE

For below:
 RELASS [P]: ( P(a,b)) -->  (b!=0 | 2>a) & (b!=0 | a!=1),
Why did we not derived below instead:
 RELASS [P]: ( P(a,b)) -->  (b!=0 | a<=0)

# zip-n-3.ss #DONE

!!! REL PRE :  P(a,b)
!!! PRE :  (b<=(a-1) & b<=(0-1)) | a<=b
Can filter a disjunct to:
!!! PRE :  a<=b

# n-ins-3c.ss

!!! REL POST :  R2(b,v2_671)
!!! POST:  true
!!! REL PRE :  true
!!! PRE :  true

PROBLEM
=======

We need a stronger post-condition.

Algorithm
=========
(i) For each 
     X & Pre(..) --> Post(...)
    determine if X -> Post(..) reduces to true --> Post(...)
    and remove it if so, for pre-condition obligation later
(ii) Form a definition for Post(..) to compute least fix-point.
(iii) Extract pre from Post and form an assumption
          Pre(..) -> Y_i
(iv) For each obligation of form:
       X & Pre(..) --> ..
     determine relational assumptions of the form:
       Pre(..) --> Y_j
(v) Form an initial Precondition
      Pre(..) -> Y wher Y=Y1 & ... & Yn
   Check if current pre satisfies all the obligation
      ... & Pre(..) --> Pre(..)
(vi) If not, perform a top-down fix-point using 
      ... & Pre(..) --> Pre(..)
    to ensure it satisfies 
      Pre(..) --> Y
    for all recursive invocations.

# n-ins-3a.ss

 infer [R]
 requires x::sortA<a> * y::node<v,null>
 ensures  res::sortA<b> & R(b,a,v);

  requires x::sortA<a> * y::node<v,null>
  ensures  res::sortA<b> & b=min(a,v) ;

 why does this example succeed individually
 but fails when put together? 
 esp when infernce is done before checking
 Is this due to us modifying the spec after inference?
 Maybe we need to re-think on this.

# n-z-1d-2.ss

relation R(int a,int b,int c).
relation P(int a,int b).

int zip(int x, int y)
  infer [R]
  requires x>=0 & y>=0 & P(x,y)
  ensures  R(res,x,y);

Sound we have a WARNING that unknown P is not
in the inferred list?

# zip-i-2.ss; zip-i-def.ss

 WHY is printing below different with NEW SPECS

  infer [a,b,R]
  requires x::llN<a> * y::llN<b>
  ensures  res::llN<r> & R(a,b,r);


!!! REL POST :  R(a,b,r)
!!! POST:  a=r & 0<=r & r<=b
!!! REL PRE :  true
!!! PRE :  true
!!! NEW SPECS: ((None,[]),EBase exists (Expl)(Impl)[a; 
                  b](ex)x::llN<a>@M[0][Orig][LHSCase] * 
                  y::llN<b>@M[0][Orig][LHSCase]&true&{FLOW,(22,23)=__norm}[]
                    EBase emp&(1<=b | b<=(0-1) | a<=0) & MayLoop&
                          {FLOW,(1,25)=__flow}[]
                            EAssume 66::
                              EXISTS(r: res::llN<r>@M[0][Orig][LHSCase]&
                              a=r & 0<=r & r<=b&{FLOW,(22,23)=__norm})[])

# n-sort-2.ss
 
   WHY no error messages on missing R0; R1
   node sort(node x)
     infer [R0,R1]
     requires x::ls<a>
     ensures  res::sortA<b> & b<=a ;

# n-sort-2b.ss (LOC to fix)

 WHY is R captured existentially? I thought this problem has been
 fixed before?

 |-  EXISTS(R_672,b_673: res::sortHO<b_673,R_672>@M[0][Orig][LHSCase]&true&
{FLOW,(22,23)=__norm})[]. 

 relation R(int r, int a) == r<=a .
 relation LT(int r, int a) == r>a .

 node insert(node x, node y)
  requires x::sortHO<a,R> * y::node<v,null>
  ensures  res::sortHO<b,R> & (v>a & b=a | (a>=b & b=v));

 node sort(node x)
     requires x::ls<a>
     ensures  res::sortHO<b,R> & b<=a ;

 id: 32; caller: []; line: 32; classic: false; kind: POST; hec_num: 5; evars: [R_672,b_673]; c_heap: emp
 checkentail v_node_39_568'::sortHO<b_670,R>@M[0][Orig][LHSCase]&a=v_616 & 
p_617=tmp_634 & tmp_634!=null & !(v_bool_35_569') & tmp_634!=null & 
!(v_bool_35_569') & next_37_567'=null & next_37_629=p_617 & a_630=v2_618 & 
p_617!=null & b_641<=a_630 & tmp_634!=null & a_635=b_641 & v=v_616 & 
x!=null & tmp_671!=null & (250::(a_635<v & a_635=b_670) | (b_670<=a_635 & 
b_670=v)) & tmp_671!=null & res=v_node_39_568'&{FLOW,(22,23)=__norm}[]
 |-  EXISTS(R_672,b_673: res::sortHO<b_673,R_672>@M[0][Orig][LHSCase]&true&
{FLOW,(22,23)=__norm})[]. 

--pcp why insert did not quantify R, but sort quantified R?

node insert$node~node(  node x,  node y)
static  ((None,[]),EBase exists (Expl)(Impl)[a; R; 
                  v](ex)EXISTS(flted_27_35: x::sortHO<a,R>@M[0][Orig][LHSCase] * 
                  y::node<v,flted_27_35>@M[Orig]&flted_27_35=null&
                  {FLOW,(22,23)=__norm})[]
                    EBase emp&MayLoop&{FLOW,(1,25)=__flow}[]
                            EAssume 66::
                              EXISTS(b: res::sortHO<b,R>@M[0][Orig][LHSCase]&
                              (a<v & a=b) | (b<=a & b=v)&
                              {FLOW,(22,23)=__norm})[])
dy
static  ((None,[]),EBase exists (Expl)(Impl)[a](ex)x::ls<a>@M[0][Orig][LHSCase]&
                  true&{FLOW,(22,23)=__norm}[]
                    EBase emp&MayLoop&{FLOW,(1,25)=__flow}[]
                            EAssume 67::
                              EXISTS(R,
                              b: res::sortHO<b,R>@M[0][Orig][LHSCase]&b<=a&
                              {FLOW,(22,23)=__norm})[])

# n-sort-2c.ss

--pcp

node sort$node(  node x) rec
static  ((None,[]),EBase exists (Expl)(Impl)[a](ex)x::ls<a>@M[0][Orig][LHSCase]&
                  true&{FLOW,(22,23)=__norm}[]
                    EBase emp&MayLoop&{FLOW,(1,25)=__flow}[]
                            EAssume 67::
                              EXISTS(LT,
                              b: res::sortHO<b,LT>@M[0][Orig][LHSCase]&b<=a&
                              {FLOW,(22,23)=__norm})[])
