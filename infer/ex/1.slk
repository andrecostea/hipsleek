data node {
	int val; 
	node next;	
}.

pred ll<n> == self = null & n = 0 
	or self::node<_, q> * q::ll<n-1> 
  inv n >= 0.

//checkentail true |- x::ll<n>.
//checkentail true |- x::node<v,q>.

infer[x] true |- x::ll<n>  .
/*
// WHY compute_action twice?
// should return VALID rather than MAY-ERR
compute_actions@1
compute_actions inp1 :EQ ptr:[]
compute_actions inp2 :LHS heap: true
compute_actions inp3 :RHS cand:[ x::ll<n>[Orig][LHSCase]]
compute_actions@1 EXIT out : =>COND:[Prio:2
                LHS: true
                RHS: x::ll<n>[Orig][LHSCase]=>BaseCaseFold;Prio:2UnmatchedRHSData:  x::ll<n>[Orig][LHSCase]]

PRECOND:  x::ll<n>[Orig][LHSCase] & true & {FLOW,(1,20)=__flow}

compute_actions@2
compute_actions inp1 :EQ ptr:[]
compute_actions inp2 :LHS heap: true
compute_actions inp3 :RHS cand:[ x::ll<n>[Orig][LHSCase]]
compute_actions@2 EXIT out : =>COND:[Prio:2
                LHS: true
                RHS: x::ll<n>[Orig][LHSCase]=>BaseCaseFold;Prio:2UnmatchedRHSData:  x::ll<n>[Orig][LHSCase]]
Infer  (1): Fail. (may) cause:(failure_code=15.3)  true |-  x!=null (may-bug)*/

infer [n] x=null & n=0 |- x::node<_,_>.
/*
// WHY compute_action twice?
// should return VALID rather than MUST-ERR
compute_actions@1
compute_actions inp1 :EQ ptr:[]
compute_actions inp2 :LHS heap: true
compute_actions inp3 :RHS cand:[ x::node<Anon_31,flted_15_32>[Orig]]
compute_actions@1 EXIT out : UnmatchedRHSData:  x::node<Anon_31,flted_15_32>[Orig]
PRECOND:  true & (1<=n | n<=(0 - 1)) & {FLOW,(1,20)=__flow}
compute_actions@2
compute_actions inp1 :EQ ptr:[]
compute_actions inp2 :LHS heap: true
compute_actions inp3 :RHS cand:[ x::node<Anon_33,flted_15_34>[Orig]]
compute_actions@2 EXIT out : UnmatchedRHSData:  x::node<Anon_33,flted_15_34>[Orig]
Infer  (1): Fail. (must) cause:15.1 x=null |-  x!=null (must-bug).
*/


//infer [n] x::ll<n> |- x::node<_,p> .
//infer [n] x::ll<n> |- x::node<_,null>.
//infer [p] x::node<1,p> |- x::ll<n> .

