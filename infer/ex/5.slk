data node {
	int val; 
	node next;	
}.

pred ll<na> == self = null & na = 0 
	or self::node<_, q> * q::ll<na-1> 
  inv na >= 0.

// TODO is it useful to infer n!=0 ?
//infer [n] n=0 |- y::ll<n>.
//print residue.
/*
Inferred Heap:[]
Inferred Pure:[ n!=0]
<1>false & false &
{FLOW,(17,18)=__norm}
*/


// (17) fail
// TODO : is the disj necessary?
//infer [y,n] y::ll<n> |- y::node<_,null>.
//print residue.
/*
Inferred Heap:[]
Inferred Pure:[ n=1, y!=null & 1<=n | n<=(0 - 1) & y!=null]
<1>EXISTS(q_56,flted_7_55: q_56::ll<flted_7_55>[Orig] & flted_7_55+1=n & 
n=1 &
*/


// (14)
// seems OK
//infer [n] y::ll<n> |- y::node<_,b>.
//print residue.
/*
Inferred Heap:[]
Inferred Pure:[ n!=0]
<1>EXISTS(flted_7_75: b::ll<flted_7_75>[Orig] & flted_7_75+1=n &
{FLOW,(17,18)=__norm})
*/

// (7) Valid & inferred n=0
//infer [n] y=null |- y::ll<n>.  
//print residue.
/*
Inferred Heap:[]
Inferred Pure:[ n=0]
<1>true & y=null & n=0 &
*/

// (9) Can improve inferred to n!=1 !!
//infer [n] n=1 & y=null |- y::ll<n>.
//print residue.
/*
Infer  (1): Valid.
Inferred Heap:[]
Inferred Pure:[ 2<=n | n<=0]
<1>false & false &
*/


//infer [n] n=1 & y=null |- n=0.
//print residue.
/*
Inferred Heap:[]
Inferred Pure:[ n!=1]
<1>false & false &
*/

// stronger RHS
infer [n] n>0 & n>m  |- n>3.
print residue.
/*
Inferred Heap:[]
Inferred Pure:[ m<n & 4<=n]
<1>true & 0<n & m<n & m<n & 4<=n &
{FLOW,(17,18)=__norm}


{
*/

// stronger RHS
infer [n] n>0 & n>m & m>4  |- n>8.
print residue.
/*
Infer  (2): Valid.
Inferred Heap:[]
Inferred Pure:[ 5<=m & m<n & 9<=n]
<1>true & 0<n & m<n & 4<m & 5<=m & m<n & 9<=n &
*/

// lhs & rhs -> false
infer [n] n>0 & n>m  |- false.
print residue.

// lhs & rhs -> false
infer [n,m] n>0 & n>m  |- false.
print residue.

// lhs & rhs -> false but no n
infer [n] true  |- n=1 & n=2.
print residue.

// lhs & rhs -> false
infer [n,m] n>0 & m=2  |- false.
print residue.
