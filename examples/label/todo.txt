# lab1.slk 

checkentail n>=0 & ["n":n>0; "s":n=0] |- (n>=-1) & ["n":n>=0].
print residue.

 Issues: 
 (i) why is CACHED called twice?
 (ii)  logging/caching of SAT seems at a higher level?
       Is splitting down for UNSAT? seems so.
 (iii)  IMPLY seems to use "" for ante always?

 id: 1; prover: MONA; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Sat:  (AndList ([],0<=n) & ([n],0<n) & ([s],n=0)) 
 res: SAT
 -------------------- 
 id: 2; prover : CACHED ; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Sat:  (AndList ([],0<=n) & ([n],0<n) & ([s],n=0)) 
 res: SAT
 -------------------- 
 id: 3; prover : CACHED ; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Sat:  (AndList ([],0<=n) & ([n],0<n) & ([s],n=0)) 
 res: SAT
 -------------------- 
 id: 4; prover: MONA; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Imply: ante: 0<=n
	     conseq:  (AndList ([],0<=(1+n))) 
 res: true
 -------------------- 
 id: 5; prover: MONA; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Imply: ante: 0<=n & 0<n
	     conseq:  (AndList ([n],0<=n)) 
 res: true
 --------------------
============================================================
# lab1.slk

checkentail n>=0 & ["n":n>0; "s":n=0] |- (n>=-1) & ["n":n>=0].
print residue.

Issues : 
 (1) why is there "true" on LHS?
 (2) it seems the first UNSAT is redundant
 (3) there are now 9 calls to UNSAT, we need to
     know why is_sat is called 3 times and
     hence tp_is_sat is called 9 times

 id: 1; prover: OMEGA CALCULATOR; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Sat:  true & 0<=n
 res: SAT
 -------------------- 
 id: 2; prover: OMEGA CALCULATOR; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Sat:  true & 0<=n & 0<n
 res: SAT
 -------------------- 
 id: 3; prover: OMEGA CALCULATOR; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Sat:  true & 0<=n & n=0
 res: SAT
 
============================================================
# lab2.slk -tp mona --en-proof-logging FIXED

checkentail n>=0 & n>0 |- (n>=-1) & n>=0.
print residue.

Why did it not call MONA?

I could not find any call to omega apart from the one in Mona.new_order_formula_x
It looks like there is a bug in the logging  and the maintainance of the Others.last_tp_used stack.

id: 1; prover: OMEGA CALCULATOR; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Sat:  0<=n & 0<n
 res: SAT
 -------------------- 
 id: 2; prover: OMEGA CALCULATOR; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Imply: ante: 0<=n & 0<n
	     conseq:  0<=(1+n)
 res: true
 -------------------- 
 id: 3; prover: OMEGA CALCULATOR; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Imply: ante: 0<=n & 0<n
	     conseq:  0<=n
 res: true
 --------------------

is_sat_sub_no #6@1
is_sat_sub_no #6 inp1 : (AndList ([],0<=n) & ([n],0<n) & ([s],n=0)) 
is_sat_sub_no #6 inp2 :1
is_sat_sub_no #6@1 EXIT out :true

is_sat_sub_no #6@5
is_sat_sub_no #6 inp1 : (AndList ([],0<=n) & ([n],0<n) & ([s],n=0)) 
is_sat_sub_no #6 inp2 :-8999
is_sat_sub_no #6@5 EXIT out :true

is_sat_sub_no #6@9
is_sat_sub_no #6 inp1 : (AndList ([],0<=n) & ([n],0<n) & ([s],n=0)) 
is_sat_sub_no #6 inp2 :-8998
is_sat_sub_no #6@9 EXIT out :true
============================================================
# lab1.slk

checkentail n>=0 & ["n":n>0; "s":n=0] |- (n>=-1) & ["n":n>=0].
print residue.

ISSUE :

The first unsat from "" label is redundant since
it was added to labels for "n","s" already.

 id: 1; prover: MONA; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Sat:  true & 0<=n
 res: SAT
 -------------------- 
 id: 2; prover: MONA; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Sat:  true & 0<=n & 0<n
 res: SAT
 -------------------- 
 id: 3; prover: MONA; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Sat:  true & 0<=n & n=0
 res: SAT
============================================================
# dll-app.ss  FIXED with wrap_no_filter

failed for --no-filter but succeed for --filter
============================================================
# swll-1.slk   FIXED (using UNSAT on disj ante)

1st version did not work; but 2nd did due to the absence of
UNSAT on the disj ante on "empty_RHS". Need to refine
wrap_no_filter to support more UNSATs.

checkentail x::ls<p,M> & ["n":x=p] |- true & ["s":M={}].

checkentail true & ["n":x=p; "s":M={}] 
    or x!=null & ["n":x=p & x!=p; "s":M!={}] |- true & ["s":M={}].

============================================================
# swll-1.ss   (does not work well esp for implication)

 UNSAT should not mix common "" with other labels
 to speed-up further

============================================================
# lab3.slk

checkentail n>=0 & ["n":n>0; "s":n=0] |- true & ["n":n>0; "s":n=1].
print residue.

Expecting 2 implications rather than 3. The last one below
redundant.

 id: 3; prover: OMEGA CALCULATOR; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Imply: ante: 0<=n & 0<n
	     conseq:  AndList[ ["n"]:0<n] 
 res: true
 -------------------- 
 id: 4; prover: OMEGA CALCULATOR; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Imply: ante: 0<=n & n=0
	     conseq:  AndList[ ["s"]:n=1] 
 res: false
 -------------------- 
 id: 5; prover: OMEGA CALCULATOR; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Imply: ante: true
	     conseq:  AndList[ ["n"]:0<n] 
 res: false

============================================================
# schorr-waite-list-lbl.ss -tp om --en-logging-txt

ISSUES
------
* Why disj conseq?
   conseq:  ((AndList[ ["s"]:MpX={}] ) | (AndList[ ["n"]:prev=sentinel_1000] ))
-> The disj is due to base case guard. It is checked during unfolding for base case.
in  do_base_case_unfold_only_x (solver.ml)               
	let (nctx,b) = sem_imply_add prog is_folding  fold_ctx bc1 !enable_syn_base_case in

* why no labels on LHS?
->  it was a problem with printing, i fixed it in tpdispatcher.ml 

 id: 242; prover: MONA; TIME: 5.032313; loc: schorr-waite-list-lbl_ss_43:2_43:26; kind: PRE_REC
 Imply: ante: ((cur=cur_1007 & prev=prev_1006 & sentinel=sentinel' & n_42'=nxt_997 & 
next_33_1005=nxt_997 & cur_1007=prev_1018 & cur_1017=n_42' & 
cur_1017!=sentinel' & !(v_bool_37_934') & cur_1017!=sentinel' & 
!(v_bool_37_934') & cur_1017=null & v_bool_38_935' & cur_1017=null & 
v_bool_38_935' & cur'=prev_1018 & prev'=null & cur_1007!=null & 
s_995=sentinel_999 & cur_1007!=sentinel_999 & cur!=null & 
sentinel=sentinel_999 & sentinel=sentinel_1000 & ((((s_995+1)<=nxt_997 & 
nxt_997=null) | (nxt_997=null & nxt_997<=(s_995-1)))) & prev=sentinel_1000 & 
Mc=union(Mnxt_998,{cur_1007}) & Mnxt_998={} & MpX={}) | (cur=cur_1007 & 
prev=prev_1006 & sentinel=sentinel' & n_42'=nxt_997 & next_33_1005=nxt_997 & 
cur_1007=prev_1018 & cur_1017=n_42' & cur_1017!=sentinel' & 
!(v_bool_37_934') & cur_1017!=sentinel' & !(v_bool_37_934') & 
cur_1017=null & v_bool_38_935' & cur_1017=null & v_bool_38_935' & 
cur'=prev_1018 & prev'=null & nxt_997!=null & prev!=null & cur_1007!=null & 
s_995=sentinel_999 & cur_1007!=sentinel_999 & cur!=null & 
sentinel=sentinel_999 & sentinel=sentinel_1000 & ((s_995<nxt_997 | 
nxt_997<s_995)) & ((sentinel_1000<prev | prev<sentinel_1000)) & 
Mc=union(Mnxt_998,{cur_1007}) & exists(Mnxt_1046:Mnxt_998=union(Mnxt_1046,
{nxt_997})) & exists(M1_1045:MpX=union({prev},M1_1045))) | (cur=cur_1007 & 
prev=prev_1006 & sentinel=sentinel' & n_42'=nxt_997 & next_33_1005=nxt_997 & 
cur_1007=prev_1018 & cur_1017=n_42' & cur_1017!=sentinel' & 
!(v_bool_37_934') & cur_1017!=sentinel' & !(v_bool_37_934') & 
cur_1017=null & v_bool_38_935' & cur_1017=null & v_bool_38_935' & 
cur'=prev_1018 & prev'=null & prev!=null & cur_1007!=null & 
s_995=sentinel_999 & cur_1007!=sentinel_999 & cur!=null & 
sentinel=sentinel_999 & sentinel=sentinel_1000 & ((((s_995+1)<=nxt_997 & 
nxt_997=null) | (nxt_997=null & nxt_997<=(s_995-1)))) & 
((sentinel_1000<prev | prev<sentinel_1000)) & Mc=union(Mnxt_998,
{cur_1007}) & Mnxt_998={} & exists(M1_1044:MpX=union({prev},M1_1044))) | 
(cur=cur_1007 & prev=prev_1006 & sentinel=sentinel' & n_42'=nxt_997 & 
next_33_1005=nxt_997 & cur_1007=prev_1018 & cur_1017=n_42' & 
cur_1017!=sentinel' & !(v_bool_37_934') & cur_1017!=sentinel' & 
!(v_bool_37_934') & cur_1017=null & v_bool_38_935' & cur_1017=null & 
v_bool_38_935' & cur'=prev_1018 & prev'=null & nxt_997!=null & 
cur_1007!=null & s_995=sentinel_999 & cur_1007!=sentinel_999 & cur!=null & 
sentinel=sentinel_999 & sentinel=sentinel_1000 & ((s_995<nxt_997 | 
nxt_997<s_995)) & prev=sentinel_1000 & Mc=union(Mnxt_998,{cur_1007}) & 
exists(Mnxt_1043:Mnxt_998=union(Mnxt_1043,{nxt_997})) & MpX={}))
	     conseq:  ((AndList[ ["s"]:MpX={}] ) | (AndList[ ["n"]:prev=sentinel_1000] ))
 res: false

============================================================
# lab5a.slk

checkentail  AndList("n":n>0; "s":n=0) |- 
  (AndList("n":n>0; "s":n=0) | AndList("": n<0; "n":n>=0; "s":n=1)).
print residue.

Currently, the disjunct on RHS is not split. If we detect conseq
is of form:

  AndList(...) | AndList(..) | ..

We should perform a labelling search on proving RHS, and terminate
with the first successful proof.

-------------------- 
 id: 3; prover: OMEGA CALCULATOR; loc: _0:0_0:0; kind: Sleek_Entail(1)
 Imply: ante: 0<n & n=0
	     conseq:  ((0<n & n=0) | (n<0 & 0<=n & n=1))
 res: true
============================================================
# swll-1.ss  FIXED due to hip calling wrong imply method

l-sw-1.slk was proof 252 extracted from 
   swll-1.ss --en-imp-top --en-logging-txt

When run as sleek, it will decompose ante (LHS) prior to
decomposing conseq.

However, in hip; it was decomposing conseq and then
dropping the labels from the LHS. Why is there such
inconsistency? 

to trace:
let imply_timeout (ante0 : CP.formula) (conseq0 : CP.formula) (imp_no : string) timeout process

============================================================
# swt-4f-set.ss (INFO)

multi pre/post is sufficient for swt algo

Procedure lscan$node~node~node SUCCESS
Stop Omega... 355 invocations 
6 false contexts at: ( (66,13)  (66,6)  (65,12)  (65,6)  (60,8)  (59,19) )

!!! time_log (small):(18.453534,1234)
!!! log (>.5s):(458.429221,[0.692192,0.69396,0.723799,0.715398,0.720225,0.716505,0.761808,0.769539,5.,4.404,5.,9.512595,9.524595,9.524595,2.829472,9.636603,23.069442,3.421265,6.532407,5.,4.948308,5.,4.964312,3.665216,4.999283,5.,10.172635,10.184636,10.184636,3.397345,10.296643,13.924869,3.382726,7.056441,5.,4.952308,5.,4.964311,0.674529,0.678187,0.712585,0.706763,0.720611,0.720981,0.76844,0.762388,3.20314,5.,5.,4.748295,22.201386,22.201386,22.325395,22.337396,3.119473,3.436215,3.656512,3.628227,3.615437,3.596224,5.,4.940309,5.,2.821175,5.,7.976498,7.988498,7.988498,4.188249,8.100505,13.032814,1.846151,6.264392,5.,4.920308,5.,4.980311,0.753405,2.910105,3.399065,0.583049,0.58025])
Total verification time: 153.689603 second(s)
	Time spent in main process: 3.248202 second(s)

============================================================
# swl-4-addr-lbl.ss --lbl-en-aggr -tp om

 E1=eq(S1) 
 E2=eq(S2) 
 E=E1&E2 
 W=fv(E)
 V1=fv(S1)
 V2=fv(S2)
 R1=ex(W-V1.E)
 R2=ex(W-V2.E)
 SAT(R1 & S1) | SAT(R2 & S2)
-----------------------------
 SAT(S1 & S2)
============================================================
# t-f.slk  -tp om --lbl-en-aggr-sat  FIXED

checkentail 
   prev::tx<b,sent_1313,M2>@M&
  AndList( 
  "":cur=cur' & prev=prev' & sent=sent' & a!=null & b=null & 
         cur!=sent & a=sent
 ; "n": a=cur' & sent_1312!=null 
//& ((a=null | a=sent_1312)) 
//&  sent=sent_1312 & sent=sent_1313
 ; "s":M1={}) 
 |-  cur'::node<mark_48_986',left_48_987',right_48_988'>@L.

Currently fails:
  Entail 1: Fail.

It should not have failed if equalities were properly propagated.

============================================================
# t-f-2a.slk -tp om --lbl-en-aggr-sat

PRIORITY
 
WHY is there a MONA limit reach for this simple example?
How many invocations to MONA did we have? Can we print
it just like omega

Starting Omega...oc
Mona is running ... restart (limit reached)

Entail 1: Fail.
Stop Omega... 50 invocations 
SAT Count   : 200

MONA seems to be restarted quite often.
One possibility is to restart mona only
and re-execute a proof only if
  (i) there were 100 previous working computation
 (ii) we have an unknown failure (e.g. time-out, exception etc)
If it fails again, we do not re-execute.
 
============================================================
# t-f-3.slk

PRIORITY

What is a 1b failure? Can we have a better error message?
Can such proof be split again?

Mona is running ... mona aborted execution
[mona] Warning: sat --> true(from mona failure 1b)

Entail 1: Fail.
============================================================
# swt-4g-set-lbl.ss -tp om --lbl-en-aggr --esl 

What is the cause of below? Is it Omega or MONA problem?

IMPLY : End_of_file when checking 
 Restarting Omega after ... 173 invocations Stop Omega... 173 invocations Starting Omega...oc
============================================================
# swt-4g-set-lbl.ss -tp om --lbl-en-aggr --esl 

PRIORITY

schor-waitte tree (g-version) now works with the aggressive
option but there are some timeouts below to investigate
for performance improvements:

!!! log (>.5s)():(213.773794,[10.,10.,10.,10.,10.,10.,10.,5.,10.,5.,10.,10.,10.,10.,10.,10.,10.,5.,10.,5.,10.,5.])

Procedure lscan$node~node~node SUCCESS
Stop Omega... 378 invocations 
!!! Logging logs/no_eps_proof_log_swt-4g-set-lbl_ss.txt

!!! Number of log entries 6627
!!! Logging logs/sleek_log_swt-4g-set-lbl_ss.txt

2 false contexts at: ( (57,8)  (56,19) )

!!! time_log (small):(133.909343,6785)
!!! log (>.5s)():(213.773794,[10.,10.,10.,10.,10.,10.,10.,5.,10.,5.,10.,10.,10.,10.,10.,10.,10.,5.,10.,5.,10.,5.])
Total verification time: 403.169194 second(s)
	Time spent in main process: 40.154508 second(s)
	Time spent in child processes: 363.014686 second(s)
	Time for logging: 25.453608 second(s)
============================================================
# swt-4g-set-lbl.ss -tp om --lbl-en-aggr --esl 

We need a more general time-out wrapper that can also
be applied to omega and sleek timeouts.

Mona is running ... Timeout when checking #2656!
============================================================
# t-to-432.slk -tp om --esl

timeout exception info not logged by add_proof_info
even though inside_timeout method was executed due
to a prior timer_start?
why? see current code below:
------
  method add_proof_info new_s no =
    print_endline "inside add_proof_info";
    match last_big with
      | None -> ()
      | Some(s,t) -> 
            begin
              print_endline "adding last_big";
              let to_flag = timer_timeout_flag in
              last_big<-None;
              let s2 = if to_flag then ":TIMEOUT:" else ":NO:" in
              let s2 = if last_timeout_flag then s2^":T2:" else s2 in
               hist_big # push(s^":"^no^s2^new_s,t)
            end
------

inside timer_start 0
inside timer_stop 0
inside timer_start 1
inside timer_stop 1
inside add_proof_info
inside timer_start 2
inside timer_stop 2
inside add_proof_info
inside timer_start 3
inside timer_timeout 3

[mona.ml]:Timeout exception

Mona is running ... Timeout when checking #3!
inside timer_start 3
inside timer_stop 3
inside add_proof_info
adding last_big
inside add_proof_info

Entail 1: Fail.


SAT Count   : 1
SAT % Hit   : 0.%
IMPLY Count : 2
IMPLY % Hit : 0.%
Time(cache overhead) : 0.004001 (seconds)

!!! log(small):(0.395107,3)
!!! log(bigger)(>4s)(1):(0.,[(imply:3:NO:MONA,5.)])
Total verification time: 8.696542 second(s)
	Time spent in main process: 0.080004 second(s)
	Time spent in child processes: 8.616538 second(s)

!!! src_files:[t-to-432.slk]
!!! Logging logs/no_eps_proof_log_t-to-432_slk.txt

!!! Number of log entries 3

===========================================================
# t-f-2.slk -tp om --esl

--dis-lbl

Stop Omega... 8 invocations 
SAT Count   : 21
SAT % Hit   : 52.38%
IMPLY Count : 14
IMPLY % Hit : 7.14%
Time(cache overhead) : 0.012001 (seconds)

!!! log(small):(0.231865,44)
Total verification time: 0.336019 second(s)
	Time spent in main process: 0.160009 second(s)
	Time spent in child processes: 0.17601 second(s)

!!! src_files:[t-f-2.slk]
!!! Logging logs/no_eps_proof_log_t-f-2_slk.txt

!!! Number of log entries 43

--------------------------------------------

!!! log(small):(1.009156,125)
!!! log(big)(>0.5s)(12):(9.756082,[(SAT,0.865794),(SAT,1.006212),(SAT,1.036937),(SAT,0.64791),(SAT,0.74909),(SAT,1.162425),(SAT,1.054024),(SAT,0.572506),(SAT,0.572178),(SAT,0.635461),(SAT,0.562629),(SAT,0.890916)])

!!! log(bigger)(>4s)(16):(9.756082,[(SAT:113:NO:MONA,5.),(SAT:114:NO:MONA,4.682976),(SAT:122:NO:MONA,4.745412),(SAT:123:NO:MONA,4.539973),(SAT:124:NO:MONA,4.912821),(SAT:125:NO:MONA,5.),(SAT:127:NO:MONA,5.),(SAT:128:NO:MONA,5.),(SAT:129:NO:MONA,4.899909),(SAT:130:NO:MONA,4.659544),(SAT:135:NO:MONA,4.804025),(SAT:136:NO:MONA,4.723027),(SAT:137:NO:MONA,4.89216),(SAT:138:NO:MONA,4.873554),(SAT:149:NO:MONA,4.960797),(SAT:150:NO:MONA,4.726344)])
Total verification time: 73.524594 second(s)
	Time spent in main process: 0.848052 second(s)
	Time spent in child processes: 72.676542 second(s)

PRIORITY
-----------------------

# t-f-2.slk --lbl-en-aggr-sat

better than non-aggressive but worst than t-f-2a.slk

Entail 1: Fail.

Stop Omega... 39 invocations 
SAT Count   : 168
SAT % Hit   : 31.54%
IMPLY Count : 16
IMPLY % Hit : 6.25%
Time(cache overhead) : 0.160007 (seconds)

!!! log(small):(2.36959,213)
!!! log(big)(>0.5s)(21):(29.271046,[(SAT,0.816119),(SAT,2.491544),(SAT,0.723605),(SAT,0.93768),(SAT,2.296391),(SAT,0.841883),(SAT,2.512535),(SAT,0.567169),(SAT,0.815026),(SAT,2.458119),(SAT,0.81167),(SAT,2.464257),(SAT,0.558812),(SAT,0.794554),(SAT,2.484909),(SAT,0.929318),(SAT,2.428048),(SAT,0.579604),(SAT,0.819784),(SAT,2.407985),(sleek-hec,0.532034)])
Total verification time: 28.005749 second(s)
	Time spent in main process: 1.092068 second(s)
	Time spent in child processes: 26.913681 second(s)


============================================================
# t-f-2.slk

Starting Omega...oc
[Warning] False ctx

Entail 1: Valid. 

Stop Omega... 40 invocations 
SAT Count   : 80
SAT % Hit   : 12.5%
IMPLY Count : 14
IMPLY % Hit : 7.14%
Time(cache overhead) : 0.084005 (seconds)

!!! log(small):(0.759882,143)
Total verification time: 1.384085 second(s)
	Time spent in main process: 0.684042 second(s)
	Time spent in child processes: 0.700043 second(s)

!!! src_files:[t-f-2a.slk]
!!! Logging logs/no_eps_proof_log_t-f-2a_slk.txt

!!! Number of log entries 142

--en-lbl-aggr

RROR: at t-f-2a.slk_7:30_7:88 
Message: view defn for tx does not entail supplied invariant

 Fatal error: exception Failure("view defn for tx does not entail supplied invariant
")

--dis-lbl

This option seems to work very well for this example!!

Entail 1: Valid. 

Stop Omega... 8 invocations 
SAT Count   : 21
SAT % Hit   : 52.38%
IMPLY Count : 14
IMPLY % Hit : 7.14%
Time(cache overhead) : 0.008002 (seconds)

!!! log(small):(0.190088,44)
Total verification time: 0.332019 second(s)
	Time spent in main process: 0.156009 second(s)
	Time spent in child processes: 0.17601 second(s)


============================================================


============================================================
============================================================
============================================================
============================================================
============================================================
============================================================
