

data cell{
  int val;
}
 
//view definitions

//cell_v<n> == self::cell<n>;
//endpoint_v<c, s, r> == self::endpoint<c,s,r>;


// message definitions

message packet <> == true  ;
message packet_one <cell x3> == x3::cell<_>  ;
message packet_two <cell x1,cell x2> == x1::cell<n1> * x2::cell<n2> & n=44  ;
message packet_test <> == true  ;
 
 


//message start [emp]
 
//contract definitions

contract C { 
  initial  state start { !packet_two -> middle;  
			 !packet_one -> end;
			  } 

  state middle {!packet_one -> next;}

  state next {!packet_one -> end; 
	      !packet -> middle;
	      !packet_two -> start;
	      !packet_test -> next;}
 
  final state end {}

}

 


void get(endpoint f) 
//  requires f::endpoint <C, 2, 1>
 // ensures f::endpoint <C, 3, 1>;
    requires f::endpoint <C, 2, 1>
  //  ensures f::endpoint <C, 2, 1>;
   ensures f::endpoint <C, st, 1> & (st = 2 |  st = 3 | st = 4 | st =1);
 {
  cell x, y;
  int n;

  receive(packet_one,f,x);
 // receive(packet_one,f,x);
  
  switch_receive {
    
    receive(packet_one,f, x) : {n = 1; }
    receive(packet, f): {n=3;}
    receive(packet_test, f): {n=4;}
    receive(packet_two,f, x, y) : {n = 2;}
  };
  dprint;
} 
 


 



