/*
 * LDK
 * Test to understand entailment and residue
 * VALID EXAMPLES without fractional permission
*/

data node { int val ; node next }.

pred ll<n> == self = null & n = 0
	or self::node<next = r> * r::ll<n - 1>
	inv n >= 0.


checkentail x::node<_, null> & m = 1 |- x::ll<m>.
print residue. // FOLD

checkentail x::node<_, null>         |- x::ll<m>.
print residue. // FOLD

checkentail x::node<_, null> & m = 1 |- m=1.
print residue. //EMP

checkentail x::node<_, r> * r::node<_, r2> * r2::ll<n> |- x::ll<n + 2>.
//FOLD, no residue

checkentail x::node<next = r1> * r1::node<next = aa> * y::node<> & b > 10 & aa=null |- x::ll<c>.
print residue. //FOLD

checkentail x::ll<n> & x!=null |- x::ll<m> & m>0.
print residue. //MATCH

checkentail x=null |- x::ll<0>.
print residue. //FOLD

checkentail x=null or x::node<_,q>*q::node<_,null> & q=null |- x::ll<d>.
print residue. //OR-L, valid because the 2nd disjunc of the antecedent is false

checkentail x=null or x::node<_,q>*q::node<_,null> |- x::ll<d>.
print residue. //OR-L, residue has a disjunction

checkentail x::ll<n> & x!=null |- x::ll<n> & n>0 or x::ll<0> .
print residue. //OR-R

checkentail x::node<_,q>*q::ll<n> & n>=0 |- x::ll<d>.
print residue. //FOLD

checkentail false |- x::ll<d>.
print residue. //False antecedent

checkentail x::ll<n> |- true.
print residue. //true consequent

checkentail x::ll<n> & n>1 |- x::node<_,q> * q::node<_,r>.
print residue. //UNFOLD

checkentail x::ll<n> & n<2 |- x=null or x::node<_,null>.
print residue. //OR-R

checkentail x::ll<n> & n<2 |- case { x=null -> [] x=null;
                                    x!=null ->  [] x::node<_,null>; }.
print residue. // CASE 

checkentail x::ll<n> & n > 0 |- x::ll<m>.
print residue. // FOLD

checkentail (exists n : x::ll<n> & n > 0) |- x!=null.
print residue. // EX-L

checkentail x=null       |- (exists n: x::ll<n> & n=0).
print residue. //EX-R, n is not in residue


checkentail x::node<_, r> & r=null        |-  x::ll<m>.
print residue. // FOLD, then MATCH

checkentail x::node<_, r> & r!=null       |-  x::ll<m> & m>0.
print residue. // FOLD ??? why fail

//if..., valid
checkentail x::node<_, r> * r::ll<n> & r!=null  |-  x::ll<m>.
print residue. // FOLD, then MATCH


checkentail x=null       |-  x::ll<n> & n=0.
print residue. //FOLD, valid
checkentail x!=null       |-  x::ll<m> & m>0.
print residue. // FOLD ???why fail
checkentail x!=null       |-  x::node<_, r> * r::ll<m>.
checkentail x!=null       |-  x::node<_, r>.
// ??? do not know which rule to apply???

//BUT, ... valid
checkentail x::node<_, r> |- x!=null .
print residue. //EMP, valid

//if ..., valid
checkentail x::ll<n> &  x!=null       |-  x::ll<m> & m>0.
print residue. // MATCHING

checkentail x::ll<n> |- x::ll<m>.
print residue. //MATCH
