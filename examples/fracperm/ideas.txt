I have three points to make.

First since permission are fraction, we probably need
redlog to handle its exact reasoning. Fortunately,
this prover is already supported by our system.

Second, for any given heap node:

     [p]x::node<_,null> 
  or [p]x::ll<n>

we expect the following invariant to hold:

  0<p<=1

Having such an permission invariant allows us 
to avoid the need to write logic related to 
permission which should hold by default.

Thirdly, one of the splitting rule needed for reasoning
can be written as follows:

 forall p1,p2:
  [p]x::p<..> & 0<p1,p2<1 & p=p1+p2
    <=> [p1]x::p<..> * [p2]x::p<..>

Here, the split provides  flexibility to p1,p2 through
the use of universal quantifier.  This is important
for unfold (lhs->rhs) reasoning, as follows:

 forall p1,p2:
  [p]x::p<..> & 0<p1,p2<1 & p=p1+p2
    => [p1]x::p<..> * [p2]x::p<..>

We cannot use the following which would be too weak:

  [p]x::p<..>
    => exists p1,p2. [p1]x::p<..> * [p2]x::p<..> 
         & 0<p1,p2<1 & p=p1+p2

This is because it gives some p1,p2 which may not have the conditions
we require.

In the reverse direction, we can use the folding mechanism
which would use the following instead:

  [p]x::p<..>
    <= exists p1,p2. [p1]x::p<..> * [p2]x::p<..> 
         & 0<p1,p2<1 & p=p1+p2

There is a similar lemma which we used for the lseg predicate.

 forall n1,n2:
  x::lseg<n,p> & n1,n2>=0 & n=n1+n2
    <==> x::lseg<n1,q> * q::lseg<n2,p>

You can play with it at examples/working/sleek/sleek{7,8}.slk
to see its versaility. In our implementation, we have to
handle universal lemma proving in a special way. The standard
mechanism works for only existential quantifier which is weak.

Lent Notation (This part is similar to @I immutable annotation)
=============

With permission accounting:

  requires [p]x::ll<n> & 0<p<=1
  ensures  [p]x::ll<n> & res=1

With Lent using @I immutability annotation, we can more concisely 
write it as:

  requires x::ll<n>@I
  ensures  res=1

In the case of fractional permission, we may use the
following instead:

  requires [p](H->x::ll<n>) & 0<p<=1
  ensures  [p] H & res=1

Here, H denotes the heap state that is matched against
x::ll<n>. This heap state is being preserved by the
immutable predicate, as it appears explicitly in H.

As a short-cut, we may use the following :

  requires [p@I]x::ll<n>
  ensures  res=1

We should investigate how immutable example can be handled
here in a concise and precise way.

=====================================

Bag of Addresses with Permissions
---------------------------------

Instead of {x,y}, we will add permission to each
distinct location, e.g: (p1,x),(p2,y)}

 Three rules, we may add are:


 {(p1,x),(p2,x)} & D       ==> {(p1+p2,x)} & D

 {(p1,x),(p2,y)} & p1+p2>1 |- x!=y

 {(p,x)} & p>1             |- false

=====================================

Related Work:

 Can we have counting and full fractional permissions?
