data node { int val ; node next }.

data cell { int val}.

pred cellp<v> == self::cell<v>
     inv true.

pred ll<n> == self = null & n = 0
     or self::node<next = r> * r::ll<n - 1>
     inv n>=0.

pred lseg<n, p> == self = p & n = 0
         or self::node<next = r> * r::lseg<n - 1, p>
         inv n >= 0.


lemma "split1" self::cellp(f)<v> & f=f1+f2 & f1>0.0 & f2>0.0  -> self::cellp(f1)<v> * self::cellp(f2)<v> & 0.0<f<=1.0.


lemma "L2R" self::lseg<n, p> & n = a + b & a,b >=0 -> self::lseg<a, r> * r::lseg<b, p> & n>=0 .


lemma "combine1" self::cellp(f)<v> & f=f1+f2 &f1>0.0 & f2>0.0 <- self::cellp(f1)<v> * self::cellp(f2)<v> &  0.0<f<=1.0.

lemma "R2L" self::lseg<n, p> & n = a + b & a,b >=0 <- self::lseg<a, r> * r::lseg<b, p> & n>=0.


checkentail x::lseg<n1, r1> * r1::lseg<n2, p> & n1 = 3 & n2 = 4 |- x::lseg<n, p> & n = 7.
print residue.// valid

checkentail x::cellp(0.4)<v1> * x::cellp(0.6)<v1>  |- x::cellp(1.0)<v2>.
print residue. //valid, COMBINE
