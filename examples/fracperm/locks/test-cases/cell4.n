Starting Reduce... 
Starting Omega...oc
Translating global variables to procedure parameters...
Eliminating variable aliasing...
Eliminating pointers...PASSED 

Checking procedure inc$lock~cell... 
dprint: cell4.ss:74: ctx:  List of Failesc Context: [FEC(0, 0, 1  )]

Successful States:
[
 Label: 
 State:l::LOCK(f)<x>@M[Orig][LHSCase]&Anon_full_perm=FLOAT 1. & ls'=ls & l'=l & x'=x & MayLoop&{FLOW,(20,21)=__norm}[]

 ]

procedure call:cell4.ss:75: 2: 
Verification Context:(Line:72,Col:13)
Proving precondition in method acquire$lock~cell for spec:
 EBase exists (Expl)(Impl)[f_676](ex)l'::LOCK(f_676)<x>@M[Derv]&
       l' <notin> ls'  & f_676>FLOAT 0. & f_676<=FLOAT 1.&
       {FLOW,(1,23)=__flow}[]
         EAssume 4::ref [ls]
           EXISTS(v_677: x'::cell()<l',v_677>@M[Orig] * 
           l'::LOCK(f_676)<x>@M[Derv]&0<=v_677 & ls'=union(ls,bag({l'}))&
           {FLOW,(20,21)=__norm})[] has failed 


dprint:cell4.ss:76 empty/false context
dprint:cell4.ss:80 empty/false context
procedure call:cell4.ss:81: 2: 
Verification Context:(Line:72,Col:13)
Proving precondition in method release$lock~cell for spec:
 EBase exists (Expl)(Impl)[f_692; v_693](ex)x'::cell()<l',v_693>@M[Orig] * 
       l'::LOCK(f_692)<x>@M[Derv]&0<=v_693 & l' <in> ls'  & f_692>FLOAT 0. & 
       f_692<=FLOAT 1.&{FLOW,(20,21)=__norm}[]
         EAssume 4::ref [ls]
           l'::LOCK(f_692)<x>@M[Derv]&ls'=ls-bag({l'})&
           {FLOW,(20,21)=__norm}[] has failed 


dprint:cell4.ss:82 empty/false context
Procedure inc$lock~cell result FAIL-1

Checking procedure main$... 
dprint: cell4.ss:47: ctx:  List of Failesc Context: [FEC(0, 0, 1  )]

Successful States:
[
 Label: 
 State:l_24'::LOCK(f_709)<x_25>@M[Derv]&Anon_full_perm=FLOAT 1. & v_int_40_698=0 & f_709=Anon_full_perm & v_710=v_int_40_698 & x_25'!=null & l_24'!=null & ls'=union(ls,bag({l_24'}))-bag({l_24'})&{FLOW,(20,21)=__norm}[]
       es_var_measures: MayLoop

 ]

dprint: cell4.ss:49: ctx:  List of Failesc Context: [FEC(0, 0, 1  ) FEC(0, 0, 1  )]

Successful States:
[
 Label: 
 State:true&x_25'=x_746 & l_24'=l_745 & Anon_full_perm=FLOAT 1. & v_int_40_698=0 & f_709=Anon_full_perm & v_710=v_int_40_698 & x_746!=null & l_745!=null & ls'=union(ls,bag({l_745}))-bag({l_745}) & x_746=x_25 & f=f_709 & id_26'=tid_723&{FLOW,(20,21)=__norm}
AND  <thread=tid_723>  <ref:> l_745::LOCK(f)<x_746>@M[Orig][LHSCase]&l_745!=null
       es_var_measures: MayLoop

 ],

Successful States:
[
 Label: 
 State:l_747::LOCK(f2_735)<x_25>@M[Derv]&x_25'=x_748 & l_24'=l_747 & FLOAT 0.<f_709 & f_709<=FLOAT 1. & Anon_full_perm=FLOAT 1. & v_int_40_698=0 & f_709=Anon_full_perm & v_710=v_int_40_698 & x_748!=null & l_747!=null & ls'=union(ls,bag({l_747}))-bag({l_747}) & x_748=x_25 & FLOAT 0.<f2_735 & FLOAT 0.<(f_709-f2_735) & f_709=f2_735+f & FLOAT 0.<f & FLOAT 0.<f2_735 & id_26'=tid_723&{FLOW,(20,21)=__norm}
AND  <thread=tid_723>  <ref:> l_747::LOCK(f)<x_748>@M[Orig][LHSCase]&l_747!=null
       es_var_measures: MayLoop

 ]

procedure call:cell4.ss:51: 2: 
Verification Context:(Line:37,Col:10)
Proving precondition in method acquire$lock~cell for spec:
 EBase exists (Expl)(Impl)[f_753](ex)l_24'::LOCK(f_753)<x_25>@M[Derv]&
       l_24' <notin> ls'  & f_753>FLOAT 0. & f_753<=FLOAT 1.&
       {FLOW,(1,23)=__flow}[]
         EAssume 1::ref [ls]
           EXISTS(v_754: x_25'::cell()<l_24',v_754>@M[Orig] * 
           l_24'::LOCK(f_753)<x_25>@M[Derv]&0<=v_754 & ls'=union(ls,
           bag({l_24'}))&{FLOW,(20,21)=__norm})[] has failed 


dprint:cell4.ss:54 empty/false context
procedure call:cell4.ss:55: 2: 
Verification Context:(Line:37,Col:10)
Proving precondition in method release$lock~cell for spec:
 EBase exists (Expl)(Impl)[f_763; 
       v_764](ex)x_25'::cell()<l_24',v_764>@M[Orig] * 
       l_24'::LOCK(f_763)<x_25>@M[Derv]&0<=v_764 & l_24' <in> ls'  & 
       f_763>FLOAT 0. & f_763<=FLOAT 1.&{FLOW,(20,21)=__norm}[]
         EAssume 1::ref [ls]
           l_24'::LOCK(f_763)<x_25>@M[Derv]&ls'=ls-bag({l_24'})&
           {FLOW,(20,21)=__norm}[] has failed 


procedure call:cell4.ss:63: 2: 
Verification Context:(Line:37,Col:10)
Proving precondition in method acquire$lock~cell for spec:
 EBase exists (Expl)(Impl)[f_767](ex)l_24'::LOCK(f_767)<x_25>@M[Derv]&
       l_24' <notin> ls'  & f_767>FLOAT 0. & f_767<=FLOAT 1.&
       {FLOW,(1,23)=__flow}[]
         EAssume 1::ref [ls]
           EXISTS(v_768: x_25'::cell()<l_24',v_768>@M[Orig] * 
           l_24'::LOCK(f_767)<x_25>@M[Derv]&0<=v_768 & ls'=union(ls,
           bag({l_24'}))&{FLOW,(20,21)=__norm})[] has failed 


procedure call:cell4.ss:65: 2: 
Verification Context:(Line:37,Col:10)
Proving precondition in method finalize$lock~cell for spec:
 EBase l_24'::LOCK()<x_25>@M[Derv]&l_24' <in> ls' &{FLOW,(20,21)=__norm}[]
         EAssume 1::ref [ls]
           l_24'::LOCK()<x_25>@M[Derv]&ls'=ls-bag({l_24'})&
           {FLOW,(20,21)=__norm}[] has failed 


Procedure main$ result FAIL-1
Halting Reduce... 
Stop Omega... 30 invocations 
0 false contexts at: ()

Total verification time: 0.39 second(s)
	Time spent in main process: 0.22 second(s)
	Time spent in child processes: 0.17 second(s)
