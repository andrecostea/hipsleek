/*
 * LDK
 * Examples with fractional permission over linked lists
 * Fractional permission is enclosed in []
*/

data node { int val ; node next }.

pred ll<n> == self = null & n = 0
	or self::node<next = r> * r::ll<n - 1>
	inv n >= 0.

//========== Fractional Permission using fractions
/*

Regaring permission, we classify into two:
1. Permission to access a heap part
2. Permission to access a variable (NOT CONSIDERED here)
(variables as resource, specify by Own(x))


Atomic heap formula ::= [perm]p::c<v*>
perm ::= [x/y]

Examples:

[1]x::node<..> or x::node<..> ::= full permission

[0]x::node<..> ::= no permission at all //??? under consideration
// node exists but cannot be accessed

[v]x::node<..> & 0<v<1 ::= strictly read-permission with no writing

[v]x::node<..> & 0<v<=1 ::= a read-permission with possible writing
// Is there a real difference to above?
// Guess both above are just read permission?

[v]x::node<..> & (v>1 or v<0) ::= false
// should we assume that any heap state
// [v]x::node<..> automatically has the invariant 0<v<=1


*/

forall p1,p2:
  [p]x::node<_,null> & 0<=p1,p2<=1 & p=p1+p2
    <=> [p1]x::node<_,null> * [p2]x::node<_,null

forall n1,n2:
 x::lseg<n,p> & n1,n2>=0 & n=n1+n2
    <==> x::lseg<n1,q> * q::lseg<n2,p>

//========== OBJECTS

//SPLIT
[p]x::node<_,null> 
 |- [p1]x::node<_,null> * [p2]x::node<_,null> & p=p1+p2.

//JOIN
[p1]x::node<_,null> * [p2]x::node<_,null> & p1+p2<=1 & p=p1+p2 
  |- [p]x::node<_,null>.

//JOIN
[p1]x::node<_,null> * [p2]x::node<_,null> 
  |- [p]x::node<_,null> & p=p1+p2.

/LOSE
[p]x::node<_,null> & p1<p 
  |- [p1]x::node<_,null>.

//NON-ALIAS
[p1]x::node<_,null> * [p2]y::node<_,null> & p1+p2>1 
  |- x!=y.

//CONTRADICT
[p1]x::node<_,null> * [p2]x::node<_,null> & p1+p2>1 
  |- false.

[p]x::node<_,null> & p1>p 
  |- [p1]x::node<_,null>.

// However, we can not say anything about x and y:

[p1]x::node<_,null> * [p2]y::node<_,null> & p1+p2<1 
  |- x=y.

[p1]x::node<_,null> * [p2]y::node<_,null> & p1+p2<1 
  |- x!=y.


//For examples:

//SPLIT
x::node<_,null> |- [1/2]x::node<_,null> * [1/2]x::node<_,null>.

//JOIN
[1/2]x::node<_,null> * [1/2]x::node<_,null> |- x::node<_,null>.

//LOSE
x::node<_,null> |- [1/2]x::node<_,null>.

//NON-ALIAS
[1/2]x::node<_,null> * [3/4]y::node<_,null> & p1+p2>1 |- x!=y.

//CONTRADICT
[1/2]x::node<_,null> * [3/4]x::node<_,null> |- false.

[1/2]x::node<_,null> |- [3/4]x::node<_,null>.

//========== PREDICATES

////rules for SPLIT, JOIN, LOSE, NON-ALIAS, CONTRADICT are similar to those of objects

//// component-wise rules

//MATCH
[p]x::ll<n> |- [p]x::ll<m> .
//residue := m=m


//MATCH
[p]x::ll<n> |- [p1]x::ll<m> .
//residue := [p2]x::ll<m> & m=n & p2=p-p1 & p2>=0

//UNFOLD
[p]x::ll<n> |- self = null & n = 0
	or [p]x::node<next = r> * [p]r::ll<n - 1>.

//FOLD
[p]x::node<_,null> |- [p]x::ll<n>
[p]x::node<_, r> * [p]r::ll<n> |- [p]x::ll<n + 1>.


For examples:

//MATCH
[1/2]x::ll<n> |- [1/2]x::ll<m> & n=m

//MATCH
[3/4]x::ll<n> |- [1/2]x::ll<m>
//residue := [1/4]x:ll<n> & n=m

//UNFOLD
[1/2]x::ll<n> & n>1 |- [1/2]x::node<_,q> * [1/2]q::node<_,r>.
print residue. //UNFOLD

//FOLD
[1/2]x::node<_,q> * [1/2]q::node<_,null> |- [1/2]x::ll<n> & n=2

//FOLD => MATCH x => FOLD => SPLIT q => MATCH q
[1/2]x::node<_,q> * q::node<_,null> |- [1/2]x::ll<n> * [1/2]q::node<_,null> & n=2

// UNFOLD ll => JOIN
[1/2]x::node<_,null> * [1/2]x::ll<n> & n=1 |- x::node<_,null>
[1/2]x::node<_,null> * [1/2]x::ll<n> |- x::ll<n> & n=1


//========== QUANTIFIED/EXISTENTIAL factional permission
Is is necessary to say that we know a heap part exits
but we do not have permission to read or write to it
(zero permission)

[0]x::node<..>

//========== HEURISTICS
x::node<_,null> |- [f]x::node<_,null> & 0<f<1
 <=> [w]x::node<_,null> |- [r]x::node<_,null>
     with w,r are reserved keywords. The system automatically infers the permission fraction

