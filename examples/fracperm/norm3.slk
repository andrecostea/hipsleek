/*
 * LDK
 * Explicit normalization with complex LHS
 *
*/

data node { int val ; node next }.

pred ls<n, p> == self = p & n = 0
         or self::node<next = r> * r::ls<n - 1, p> & self!=p
         inv n >= 0.


lemma "COMBls" self::ls<n1,p1> * p1::ls<n2,p2> * p2::node<a,b> -> self::ls<n1+n2,p2> * p2::node<a,b>.


checkentail x::ls<3,p1> * p2::ls<2,p> & p1=p2 |- x::ls<5,r>.
// fail

checkentail x::ls<3,p1> * p2::ls<2,p> * p::node<_,_> & p1=p2 |- x::ls<5,r>.
// valid with r=p
print residue.

checkentail x::ls<n1,p1> * p2::ls<n2,p> * p::node<_,_> & p1=p2 |- x::ls<n1+n2,r>.
// valid with r=p


checkentail x::ls<n1,p1> * p2::ls<n2,p> * p::node<_,_> & p1=p2 |- x::ls<n1+n2,r>.
// valid with r=p

checkentail x::ls<n1,p1> * p2::ls<n2,p> * p::node<_,_> & p1=p2 |- x::ls<n,r>.
// valid with 2 answers?
print residue.

checkentail x::ls<n1,p1> * p2::ls<n2,p> * p::node<_,_> & p1=p2 |- x::ls<n,p>.
// valid with only one answer?
print residue.

