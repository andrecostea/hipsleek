<html>
<head>	<link rel="stylesheet" type="text/css" href="hipsleek.css" />	<script type="text/javascript" src="hipsleek.js"></script></head>
<body>
<h1>./hip/array/arr_sparse.java</h1>
<ul class="TreeView" id="ProofTree"><li class="Collapsed progsource">Source<ul><table><tr id="L1" class="OddSourceLine"><td>1</td><td><pre>/** If the sparse array contains three elements x y z, at index</pre></td></tr>
<tr id="L2" class="EvenSourceLine"><td>2</td><td><pre> *  a b c respectively, then the three arrays look like this:</pre></td></tr>
<tr id="L3" class="OddSourceLine"><td>3</td><td><pre> *  </pre></td></tr>
<tr id="L4" class="EvenSourceLine"><td>4</td><td><pre> *               b     a      c</pre></td></tr>
<tr id="L5" class="OddSourceLine"><td>5</td><td><pre> * values +-----+-+---+-+----+-+----+</pre></td></tr>
<tr id="L6" class="EvenSourceLine"><td>6</td><td><pre> *        |     |y|   |x|    |z|    |</pre></td></tr>
<tr id="L7" class="OddSourceLine"><td>7</td><td><pre> *        +-----+-+---+-+----+-+----+</pre></td></tr>
<tr id="L8" class="EvenSourceLine"><td>8</td><td><pre> *</pre></td></tr>
<tr id="L9" class="OddSourceLine"><td>9</td><td><pre> * index  +-----+-+---+-+----+-+----+</pre></td></tr>
<tr id="L10" class="EvenSourceLine"><td>10</td><td><pre> *        |     |1|   |0|    |2|    |</pre></td></tr>
<tr id="L11" class="OddSourceLine"><td>11</td><td><pre> *        +-----+-+---+-+----+-+----+</pre></td></tr>
<tr id="L12" class="EvenSourceLine"><td>12</td><td><pre> *</pre></td></tr>
<tr id="L13" class="OddSourceLine"><td>13</td><td><pre> *         0 1 2  n=3</pre></td></tr>
<tr id="L14" class="EvenSourceLine"><td>14</td><td><pre> * back   +-+-+-+-------------------+</pre></td></tr>
<tr id="L15" class="OddSourceLine"><td>15</td><td><pre> *        |a|b|c|                   |</pre></td></tr>
<tr id="L16" class="EvenSourceLine"><td>16</td><td><pre> *        +-+-+-+-------------------+</pre></td></tr>
<tr id="L17" class="OddSourceLine"><td>17</td><td><pre> *        </pre></td></tr>
<tr id="L18" class="EvenSourceLine"><td>18</td><td><pre> * Reference:</pre></td></tr>
<tr id="L19" class="OddSourceLine"><td>19</td><td><pre> * Sparse Arrays in Why3</pre></td></tr>
<tr id="L20" class="EvenSourceLine"><td>20</td><td><pre> * http://proval.lri.fr/gallery/vacid_0_sparse_array.en.html</pre></td></tr>
<tr id="L21" class="OddSourceLine"><td>21</td><td><pre> * </pre></td></tr>
<tr id="L22" class="EvenSourceLine"><td>22</td><td><pre> * Remark: The original code has a macro MAXLEN for</pre></td></tr>
<tr id="L23" class="OddSourceLine"><td>23</td><td><pre> * the maximum size of the sparse array. In this implementation, </pre></td></tr>
<tr id="L24" class="EvenSourceLine"><td>24</td><td><pre> * we substitute that value by 1000.</pre></td></tr>
<tr id="L25" class="OddSourceLine"><td>25</td><td><pre> * </pre></td></tr>
<tr id="L26" class="EvenSourceLine"><td>26</td><td><pre> * Task 0 {50 pts} is handled.</pre></td></tr>
<tr id="L27" class="OddSourceLine"><td>27</td><td><pre> * Task 1 {30 pts} is in progress.</pre></td></tr>
<tr id="L28" class="EvenSourceLine"><td>28</td><td><pre> * </pre></td></tr>
<tr id="L29" class="OddSourceLine"><td>29</td><td><pre> * @author Vu An Hoa</pre></td></tr>
<tr id="L30" class="EvenSourceLine"><td>30</td><td><pre> */</pre></td></tr>
<tr id="L31" class="OddSourceLine"><td>31</td><td><pre></pre></td></tr>
<tr id="L32" class="EvenSourceLine"><td>32</td><td><pre></pre></td></tr>
<tr id="L33" class="OddSourceLine"><td>33</td><td><pre>data SparseArray {	</pre></td></tr>
<tr id="L34" class="EvenSourceLine"><td>34</td><td><pre>	int[] values;</pre></td></tr>
<tr id="L35" class="OddSourceLine"><td>35</td><td><pre>	int[] index;</pre></td></tr>
<tr id="L36" class="EvenSourceLine"><td>36</td><td><pre>	int[] back;</pre></td></tr>
<tr id="L37" class="OddSourceLine"><td>37</td><td><pre>	int n;</pre></td></tr>
<tr id="L38" class="EvenSourceLine"><td>38</td><td><pre>}</pre></td></tr>
<tr id="L39" class="OddSourceLine"><td>39</td><td><pre></pre></td></tr>
<tr id="L40" class="EvenSourceLine"><td>40</td><td><pre>//relation dom(int[] a, int i, int j) == true.</pre></td></tr>
<tr id="L41" class="OddSourceLine"><td>41</td><td><pre></pre></td></tr>
<tr id="L42" class="EvenSourceLine"><td>42</td><td><pre>relation bounded(int[] a, int i, int j, int low, int high) ==</pre></td></tr>
<tr id="L43" class="OddSourceLine"><td>43</td><td><pre>	forall(k : k < i | k > j | low <= a[k] <= high).</pre></td></tr>
<tr id="L44" class="EvenSourceLine"><td>44</td><td><pre></pre></td></tr>
<tr id="L45" class="OddSourceLine"><td>45</td><td><pre>relation different_pairwise(int[] a, int i, int j) ==</pre></td></tr>
<tr id="L46" class="EvenSourceLine"><td>46</td><td><pre>	forall(k, t : k < i | k > j | t < i | t > j | t = k | a[t] != a [k]).</pre></td></tr>
<tr id="L47" class="OddSourceLine"><td>47</td><td><pre>	</pre></td></tr>
<tr id="L48" class="EvenSourceLine"><td>48</td><td><pre>relation is_sparse_array(int[] val, int[] idx, int[] bk, int n) ==</pre></td></tr>
<tr id="L49" class="OddSourceLine"><td>49</td><td><pre>	forall(k, t : k < 0 | k >= n | t < 0 | t >= n | t = k | bk[t] != bk[k]) & </pre></td></tr>
<tr id="L50" class="EvenSourceLine"><td>50</td><td><pre>	forall(i : i < 0 | i >= n | 0 <= bk[i] < 1000 & idx[bk[i]] = i).</pre></td></tr>
<tr id="L51" class="OddSourceLine"><td>51</td><td><pre>	</pre></td></tr>
<tr id="L52" class="EvenSourceLine"><td>52</td><td><pre>relation is_modified(int[] val, int[] idx, int[] bk, int n, int i) ==</pre></td></tr>
<tr id="L53" class="OddSourceLine"><td>53</td><td><pre>	0 <= i < 1000 & 0 <= idx[i] < n & bk[idx[i]] = i.</pre></td></tr>
<tr id="L54" class="EvenSourceLine"><td>54</td><td><pre></pre></td></tr>
<tr id="L55" class="OddSourceLine"><td>55</td><td><pre>relation value_at(int[] val, int[] idx, int[] bk, int n, int i, int v) ==</pre></td></tr>
<tr id="L56" class="EvenSourceLine"><td>56</td><td><pre>	0 <= i <= 1000-1 & </pre></td></tr>
<tr id="L57" class="OddSourceLine"><td>57</td><td><pre>	(is_modified(val, idx, bk, n, i) & v = val[i] | </pre></td></tr>
<tr id="L58" class="EvenSourceLine"><td>58</td><td><pre>		!(is_modified(val, idx, bk, n, i)) & v = 0).</pre></td></tr>
<tr id="L59" class="OddSourceLine"><td>59</td><td><pre>	// the following property is provable in sleek:</pre></td></tr>
<tr id="L60" class="EvenSourceLine"><td>60</td><td><pre>	// forall(u : u = v | !(value_at(val,idx,bk,n,i,u))).</pre></td></tr>
<tr id="L61" class="OddSourceLine"><td>61</td><td><pre></pre></td></tr>
<tr id="L62" class="EvenSourceLine"><td>62</td><td><pre>axiom is_sparse_array(val, idx, bk, 1000) & 0 <= i < 1000 ==> is_modified(val, idx, bk, 1000, i).</pre></td></tr>
<tr id="L63" class="OddSourceLine"><td>63</td><td><pre>			</pre></td></tr>
<tr id="L64" class="EvenSourceLine"><td>64</td><td><pre>relation idexc(int[] val1, int[] idx1, int[] bk1, int n1, </pre></td></tr>
<tr id="L65" class="OddSourceLine"><td>65</td><td><pre>			int[] val2, int[] idx2, int[] bk2, int n2, int i) ==</pre></td></tr>
<tr id="L66" class="EvenSourceLine"><td>66</td><td><pre>	forall(k : k = i | </pre></td></tr>
<tr id="L67" class="OddSourceLine"><td>67</td><td><pre>		forall(h : !(value_at(val1,idx1,bk1,n1,k,h)) | value_at(val2,idx2,bk2,n2,k,h)) &</pre></td></tr>
<tr id="L68" class="EvenSourceLine"><td>68</td><td><pre>		forall(t : !(value_at(val2,idx2,bk2,n2,k,t)) | value_at(val1,idx1,bk1,n1,k,t))).</pre></td></tr>
<tr id="L69" class="OddSourceLine"><td>69</td><td><pre>	</pre></td></tr>
<tr id="L70" class="EvenSourceLine"><td>70</td><td><pre>void harness()</pre></td></tr>
<tr id="L71" class="OddSourceLine"><td>71</td><td><pre>	requires true ensures true;</pre></td></tr>
<tr id="L72" class="EvenSourceLine"><td>72</td><td><pre>{</pre></td></tr>
<tr id="L73" class="OddSourceLine"><td>73</td><td><pre>	SparseArray a = create(10);</pre></td></tr>
<tr id="L74" class="EvenSourceLine"><td>74</td><td><pre>	SparseArray b = create(20);</pre></td></tr>
<tr id="L75" class="OddSourceLine"><td>75</td><td><pre>	int a5 = get(a, 5);</pre></td></tr>
<tr id="L76" class="EvenSourceLine"><td>76</td><td><pre>	int b7 = get(b, 7);</pre></td></tr>
<tr id="L77" class="OddSourceLine"><td>77</td><td><pre>	assert a5' = 0 & b7' = 0;</pre></td></tr>
<tr id="L78" class="EvenSourceLine"><td>78</td><td><pre>	setsa(a, 5, 1);</pre></td></tr>
<tr id="L79" class="OddSourceLine"><td>79</td><td><pre>	setsa(b, 7, 2);</pre></td></tr>
<tr id="L80" class="EvenSourceLine"><td>80</td><td><pre>	a5 = get(a, 5);</pre></td></tr>
<tr id="L81" class="OddSourceLine"><td>81</td><td><pre>	b7 = get(b, 7);</pre></td></tr>
<tr id="L82" class="EvenSourceLine"><td>82</td><td><pre>	assert a5' = 1 & b7' = 2;</pre></td></tr>
<tr id="L83" class="OddSourceLine"><td>83</td><td><pre>	int a0 = get(a, 0);</pre></td></tr>
<tr id="L84" class="EvenSourceLine"><td>84</td><td><pre>	int b0 = get(b, 0);</pre></td></tr>
<tr id="L85" class="OddSourceLine"><td>85</td><td><pre>	assert a0' = 0 & b0' = 0;</pre></td></tr>
<tr id="L86" class="EvenSourceLine"><td>86</td><td><pre>}</pre></td></tr>
<tr id="L87" class="OddSourceLine"><td>87</td><td><pre></pre></td></tr>
<tr id="L88" class="EvenSourceLine"><td>88</td><td><pre></pre></td></tr>
<tr id="L89" class="OddSourceLine"><td>89</td><td><pre>SparseArray create(int sz)</pre></td></tr>
<tr id="L90" class="EvenSourceLine"><td>90</td><td><pre>	requires sz >= 0</pre></td></tr>
<tr id="L91" class="OddSourceLine"><td>91</td><td><pre>	ensures res::SparseArray<val,idx,bk,0> & dom(val,0,1000-1) </pre></td></tr>
<tr id="L92" class="EvenSourceLine"><td>92</td><td><pre>		& dom(idx,0,1000-1) & dom(bk,0,1000-1)</pre></td></tr>
<tr id="L93" class="OddSourceLine"><td>93</td><td><pre>		& is_sparse_array(val,idx,bk,0);</pre></td></tr>
<tr id="L94" class="EvenSourceLine"><td>94</td><td><pre>{</pre></td></tr>
<tr id="L95" class="OddSourceLine"><td>95</td><td><pre>	int[] values = new int[1000];</pre></td></tr>
<tr id="L96" class="EvenSourceLine"><td>96</td><td><pre>	int[] index = new int[1000];</pre></td></tr>
<tr id="L97" class="OddSourceLine"><td>97</td><td><pre>	int[] back = new int[1000];</pre></td></tr>
<tr id="L98" class="EvenSourceLine"><td>98</td><td><pre>	return new SparseArray(values, index, back, 0);</pre></td></tr>
<tr id="L99" class="OddSourceLine"><td>99</td><td><pre>}</pre></td></tr>
<tr id="L100" class="EvenSourceLine"><td>100</td><td><pre></pre></td></tr>
<tr id="L101" class="OddSourceLine"><td>101</td><td><pre></pre></td></tr>
<tr id="L102" class="EvenSourceLine"><td>102</td><td><pre>int get(SparseArray a, int i)</pre></td></tr>
<tr id="L103" class="OddSourceLine"><td>103</td><td><pre>	requires a::SparseArray<val,idx,bk,n>@I & dom(val,0,1000-1) </pre></td></tr>
<tr id="L104" class="EvenSourceLine"><td>104</td><td><pre>			& dom(idx,0,1000-1) & dom(bk,0,1000-1)</pre></td></tr>
<tr id="L105" class="OddSourceLine"><td>105</td><td><pre>			& 0 <= n <= 1000 & 0 <= i <= 1000-1</pre></td></tr>
<tr id="L106" class="EvenSourceLine"><td>106</td><td><pre>			& is_sparse_array(val,idx,bk,n)</pre></td></tr>
<tr id="L107" class="OddSourceLine"><td>107</td><td><pre>			& bounded(bk,0,n-1,0,1000-1)</pre></td></tr>
<tr id="L108" class="EvenSourceLine"><td>108</td><td><pre>	ensures value_at(val,idx,bk,n,i,res);</pre></td></tr>
<tr id="L109" class="OddSourceLine"><td>109</td><td><pre>{</pre></td></tr>
<tr id="L110" class="EvenSourceLine"><td>110</td><td><pre>	int[] idx = a.index;</pre></td></tr>
<tr id="L111" class="OddSourceLine"><td>111</td><td><pre>	int[] back = a.back;</pre></td></tr>
<tr id="L112" class="EvenSourceLine"><td>112</td><td><pre>	if (idx[i] >= 0 && idx[i] < a.n) {</pre></td></tr>
<tr id="L113" class="OddSourceLine"><td>113</td><td><pre>		if (back[idx[i]] == i) {</pre></td></tr>
<tr id="L114" class="EvenSourceLine"><td>114</td><td><pre>			int[] val = a.values;</pre></td></tr>
<tr id="L115" class="OddSourceLine"><td>115</td><td><pre>			return val[i];</pre></td></tr>
<tr id="L116" class="EvenSourceLine"><td>116</td><td><pre>		}</pre></td></tr>
<tr id="L117" class="OddSourceLine"><td>117</td><td><pre>	}</pre></td></tr>
<tr id="L118" class="EvenSourceLine"><td>118</td><td><pre>	return 0;</pre></td></tr>
<tr id="L119" class="OddSourceLine"><td>119</td><td><pre>}</pre></td></tr>
<tr id="L120" class="EvenSourceLine"><td>120</td><td><pre></pre></td></tr>
<tr id="L121" class="OddSourceLine"><td>121</td><td><pre></pre></td></tr>
<tr id="L122" class="EvenSourceLine"><td>122</td><td><pre>void setsa(SparseArray a, int i, int v)</pre></td></tr>
<tr id="L123" class="OddSourceLine"><td>123</td><td><pre>	requires a::SparseArray<val,idx,bk,n> & dom(val,0,1000-1) </pre></td></tr>
<tr id="L124" class="EvenSourceLine"><td>124</td><td><pre>				& dom(idx,0,1000-1) & dom(bk,0,1000-1)</pre></td></tr>
<tr id="L125" class="OddSourceLine"><td>125</td><td><pre>				& 0 <= n <= 1000 & bounded(bk,0,n-1,0,1000-1)</pre></td></tr>
<tr id="L126" class="EvenSourceLine"><td>126</td><td><pre>				& is_sparse_array(val,idx,bk,n)</pre></td></tr>
<tr id="L127" class="OddSourceLine"><td>127</td><td><pre>				& 0 <= i < 1000</pre></td></tr>
<tr id="L128" class="EvenSourceLine"><td>128</td><td><pre>	ensures a::SparseArray<valr,idxr,bkr,nr> & dom(valr,0,1000-1) </pre></td></tr>
<tr id="L129" class="OddSourceLine"><td>129</td><td><pre>				& dom(idxr,0,1000-1) & dom(bkr,0,1000-1)</pre></td></tr>
<tr id="L130" class="EvenSourceLine"><td>130</td><td><pre>				& 0 <= nr <= 1000</pre></td></tr>
<tr id="L131" class="OddSourceLine"><td>131</td><td><pre>				& (is_modified(val,idx,bk,n,i) & nr = n | </pre></td></tr>
<tr id="L132" class="EvenSourceLine"><td>132</td><td><pre>					!(is_modified(val,idx,bk,n,i)) & nr = n + 1)</pre></td></tr>
<tr id="L133" class="OddSourceLine"><td>133</td><td><pre>				& bounded(bkr,0,nr-1,0,1000-1)</pre></td></tr>
<tr id="L134" class="EvenSourceLine"><td>134</td><td><pre>				& value_at(valr,idxr,bkr,nr,i,v)</pre></td></tr>
<tr id="L135" class="OddSourceLine"><td>135</td><td><pre>				& is_sparse_array(valr,idxr,bkr,nr)</pre></td></tr>
<tr id="L136" class="EvenSourceLine"><td>136</td><td><pre>				& idexc(val,idx,bk,n,valr,idxr,bkr,nr,i);</pre></td></tr>
<tr id="L137" class="OddSourceLine"><td>137</td><td><pre>{</pre></td></tr>
<tr id="L138" class="EvenSourceLine"><td>138</td><td><pre>	int[] val = a.values;</pre></td></tr>
<tr id="L139" class="OddSourceLine"><td>139</td><td><pre>	int[] idx = a.index;</pre></td></tr>
<tr id="L140" class="EvenSourceLine"><td>140</td><td><pre>	int[] bk = a.back;</pre></td></tr>
<tr id="L141" class="OddSourceLine"><td>141</td><td><pre>	val[i] = v;</pre></td></tr>
<tr id="L142" class="EvenSourceLine"><td>142</td><td><pre>	if (idx[i] >= a.n || idx[i] < 0) {</pre></td></tr>
<tr id="L143" class="OddSourceLine"><td>143</td><td><pre>		assert (!(is_modified(val',idx',bk',n,i)));</pre></td></tr>
<tr id="L144" class="EvenSourceLine"><td>144</td><td><pre>		assume (!(is_modified(val',idx',bk',n,i)));</pre></td></tr>
<tr id="L145" class="OddSourceLine"><td>145</td><td><pre>		// if n = 1000 then both is_modified(val,idx,bk,n,i) and its negation holds.</pre></td></tr>
<tr id="L146" class="EvenSourceLine"><td>146</td><td><pre>		assert n < 1000;</pre></td></tr>
<tr id="L147" class="OddSourceLine"><td>147</td><td><pre>		assume n < 1000;</pre></td></tr>
<tr id="L148" class="EvenSourceLine"><td>148</td><td><pre>		idx[i] = a.n;</pre></td></tr>
<tr id="L149" class="OddSourceLine"><td>149</td><td><pre>		bk[a.n] = i;</pre></td></tr>
<tr id="L150" class="EvenSourceLine"><td>150</td><td><pre>		a.n = a.n + 1;</pre></td></tr>
<tr id="L151" class="OddSourceLine"><td>151</td><td><pre>	} else if (bk[idx[i]] != i) {</pre></td></tr>
<tr id="L152" class="EvenSourceLine"><td>152</td><td><pre>		assert (!(is_modified(val',idx',bk',n,i)));</pre></td></tr>
<tr id="L153" class="OddSourceLine"><td>153</td><td><pre>		assume (!(is_modified(val',idx',bk',n,i)));</pre></td></tr>
<tr id="L154" class="EvenSourceLine"><td>154</td><td><pre>		// if n = 1000 then both is_modified(val,idx,bk,n,i) and its negation holds.</pre></td></tr>
<tr id="L155" class="OddSourceLine"><td>155</td><td><pre>		assert n < 1000;</pre></td></tr>
<tr id="L156" class="EvenSourceLine"><td>156</td><td><pre>		assume n < 1000;</pre></td></tr>
<tr id="L157" class="OddSourceLine"><td>157</td><td><pre>		idx[i] = a.n;</pre></td></tr>
<tr id="L158" class="EvenSourceLine"><td>158</td><td><pre>		bk[a.n] = i;</pre></td></tr>
<tr id="L159" class="OddSourceLine"><td>159</td><td><pre>		a.n = a.n + 1;</pre></td></tr>
<tr id="L160" class="EvenSourceLine"><td>160</td><td><pre>	}</pre></td></tr>
<tr id="L161" class="OddSourceLine"><td>161</td><td><pre>	a.values = val;</pre></td></tr>
<tr id="L162" class="EvenSourceLine"><td>162</td><td><pre>	a.index = idx;</pre></td></tr>
<tr id="L163" class="OddSourceLine"><td>163</td><td><pre>	a.back = bk;</pre></td></tr>
<tr id="L164" class="EvenSourceLine"><td>164</td><td><pre>}</pre></td></tr>
</table></ul></li><li class="Collapsed proc">
Procedure setsa<ul><li class="Collapsed procdef">Internal representation
<ul>void setsa$SparseArray~int~int(  SparseArray a,  int i,  int v)<br/>
static  EBase exists (Expl)[](Impl)[val; idx; bk; <br/>
       n](ex)[]a::SparseArray&lt;val,idx,bk,n&gt;@M &amp; dom(val,0,1000 - 1) &amp; <br/>
       dom(idx,0,1000 - 1) &amp; dom(bk,0,1000 - 1) &amp; 0&lt;=n &amp; n&lt;=1000 &amp; <br/>
       bounded(bk,0,n - 1,0,1000 - 1) &amp; is_sparse_array(val,idx,bk,n) &amp; <br/>
       0&lt;=i &amp; i&lt;1000 &amp; {FLOW,(39,39)=__norm}<br/>
         EAssume 13::<br/>
           EXISTS(valr,idxr,bkr,nr: a::SparseArray&lt;valr,idxr,bkr,nr&gt;@M &amp;<br/>
           dom(valr,0,1000 - 1) &amp; dom(idxr,0,1000 - 1) &amp; dom(bkr,0,1000 -<br/>
           1) &amp; 0&lt;=nr &amp; nr&lt;=1000 &amp; (is_modified(val,idx,bk,n,i) &amp; nr=n | <br/>
           !(is_modified(val,idx,bk,n,i)) &amp; nr=1+n) &amp; bounded(bkr,0,nr -<br/>
           1,0,1000 - 1) &amp; value_at(valr,idxr,bkr,nr,i,v) &amp; <br/>
           is_sparse_array(valr,idxr,bkr,nr) &amp; <br/>
           idexc(val,idx,bk,n,valr,idxr,bkr,nr,i) &amp; {FLOW,(39,39)=__norm})<br/>
dynamic  []<br/>
int[] val_49;<br/>
val_49 = 100::bind a to (values_138_742,index_138_743,back_138_744,n_138_745) in <br/>
{values_138_742<br/>
};<br/>
int[] idx_50;<br/>
idx_50 = 101::bind a to (values_139_746,index_139_747,back_139_748,n_139_749) in <br/>
{index_139_747<br/>
};<br/>
int[] bk_51;<br/>
bk_51 = 102::bind a to (values_140_750,index_140_751,back_140_752,n_140_753) in <br/>
{back_140_752<br/>
};<br/>
val_49 = {<br/>
103::update___1d$int~int[]~int(v,val_49,i)<br/>
};<br/>
boolean v_bool_142_867;<br/>
v_bool_142_867 = {<br/>
boolean v_boolean_142_763;<br/>
v_boolean_142_763 = {<br/>
int v_int_142_759;<br/>
v_int_142_759 = {<br/>
array_get_elm_at___1d$int[]~int(idx_50,i)<br/>
};<br/>
int v_int_142_758;<br/>
v_int_142_758 = 134::bind a to (values_142_754,index_142_755,back_142_756,n_142_757) in <br/>
{n_142_757<br/>
};<br/>
133::gte___$int~int(v_int_142_759,v_int_142_758)<br/>
};<br/>
boolean v_boolean_142_762;<br/>
v_boolean_142_762 = {<br/>
int v_int_142_761;<br/>
v_int_142_761 = {<br/>
array_get_elm_at___1d$int[]~int(idx_50,i)<br/>
};<br/>
int v_int_142_760;<br/>
v_int_142_760 = 0;<br/>
132::lt___$int~int(v_int_142_761,v_int_142_760)<br/>
};<br/>
131::lor___$boolean~boolean(v_boolean_142_763,v_boolean_142_762)<br/>
};<br/>
104::if (v_bool_142_867) LABEL! 104,0: 119::assert 119::: EBase true &amp; !(is_modified(val_49&apos;,idx_50&apos;,bk_51&apos;,n,i)) &amp;<br/>
       {FLOW,(39,39)=__norm} ;<br/>
120:: assume  true &amp; !(is_modified(val_49&apos;,idx_50&apos;,bk_51&apos;,n,i)) &amp; {FLOW,(39,39)=__norm};<br/>
121::assert 121::: EBase true &amp; n&lt;1000 &amp; {FLOW,(39,39)=__norm} ;<br/>
122:: assume  true &amp; n&lt;1000 &amp; {FLOW,(39,39)=__norm};<br/>
idx_50 = {<br/>
int v_int_148_797;<br/>
v_int_148_797 = 124::bind a to (values_148_793,index_148_794,back_148_795,n_148_796) in <br/>
{n_148_796<br/>
};<br/>
123::update___1d$int~int[]~int(v_int_148_797,idx_50,i)<br/>
};<br/>
bk_51 = {<br/>
int v_int_149_802;<br/>
v_int_149_802 = 126::bind a to (values_149_798,index_149_799,back_149_800,n_149_801) in <br/>
{n_149_801<br/>
};<br/>
125::update___1d$int~int[]~int(i,bk_51,v_int_149_802)<br/>
};<br/>
{<br/>
int v_int_150_809;<br/>
v_int_150_809 = {<br/>
int v_int_150_808;<br/>
v_int_150_808 = 129::bind a to (values_150_803,index_150_804,back_150_805,n_150_806) in <br/>
{n_150_806<br/>
};<br/>
int v_int_150_807;<br/>
v_int_150_807 = 1;<br/>
128::add___$int~int(v_int_150_808,v_int_150_807)<br/>
};<br/>
130::bind a to (values_150_810,index_150_811,back_150_812,n_150_813) in <br/>
{n_150_813 = v_int_150_809<br/>
}<br/>
}<br/>
else LABEL! 104,1: boolean v_bool_151_866;<br/>
v_bool_151_866 = {<br/>
int v_int_151_815;<br/>
v_int_151_815 = {<br/>
int v_int_151_814;<br/>
v_int_151_814 = {<br/>
array_get_elm_at___1d$int[]~int(idx_50,i)<br/>
};<br/>
array_get_elm_at___1d$int[]~int(bk_51,v_int_151_814)<br/>
};<br/>
118::neq___$int~int(v_int_151_815,i)<br/>
};<br/>
105::if (v_bool_151_866) LABEL! 105,0: 106::assert 106::: EBase true &amp; !(is_modified(val_49&apos;,idx_50&apos;,bk_51&apos;,n,i)) &amp;<br/>
       {FLOW,(39,39)=__norm} ;<br/>
107:: assume  true &amp; !(is_modified(val_49&apos;,idx_50&apos;,bk_51&apos;,n,i)) &amp; {FLOW,(39,39)=__norm};<br/>
108::assert 108::: EBase true &amp; n&lt;1000 &amp; {FLOW,(39,39)=__norm} ;<br/>
109:: assume  true &amp; n&lt;1000 &amp; {FLOW,(39,39)=__norm};<br/>
idx_50 = {<br/>
int v_int_157_849;<br/>
v_int_157_849 = 111::bind a to (values_157_845,index_157_846,back_157_847,n_157_848) in <br/>
{n_157_848<br/>
};<br/>
110::update___1d$int~int[]~int(v_int_157_849,idx_50,i)<br/>
};<br/>
bk_51 = {<br/>
int v_int_158_854;<br/>
v_int_158_854 = 113::bind a to (values_158_850,index_158_851,back_158_852,n_158_853) in <br/>
{n_158_853<br/>
};<br/>
112::update___1d$int~int[]~int(i,bk_51,v_int_158_854)<br/>
};<br/>
{<br/>
int v_int_159_861;<br/>
v_int_159_861 = {<br/>
int v_int_159_860;<br/>
v_int_159_860 = 116::bind a to (values_159_855,index_159_856,back_159_857,n_159_858) in <br/>
{n_159_858<br/>
};<br/>
int v_int_159_859;<br/>
v_int_159_859 = 1;<br/>
115::add___$int~int(v_int_159_860,v_int_159_859)<br/>
};<br/>
117::bind a to (values_159_862,index_159_863,back_159_864,n_159_865) in <br/>
{n_159_865 = v_int_159_861<br/>
}<br/>
}<br/>
else LABEL! 105,1: <br/>
<br/>
;<br/>
136::bind a to (values_161_868,index_161_869,back_161_870,n_161_871) in <br/>
{values_161_868 = val_49<br/>
};<br/>
138::bind a to (values_162_872,index_162_873,back_162_874,n_162_875) in <br/>
{index_162_873 = idx_50<br/>
};<br/>
140::bind a to (values_163_876,index_163_877,back_163_878,n_163_879) in <br/>
{back_163_878 = bk_51<br/>
}<br/>
<br/>
{(122,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pre">
Memory safety of array update at line <a href="#L141">line 141</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; 0 &le; i &and; i &lt; 1000)  &#8866;   &exist; ahalb_1026  &exist; ahaub_1027 (dom(val,ahalb_1026,ahaub_1027) &and; ahalb_1026 &le; i &and; i &le; ahaub_1027)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt; i 1000))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1026 Int)) (exists ((ahaub_1027 Int)) (and (dom val ahalb_1026 ahaub_1027) (and (&lt;= ahalb_1026 i) (&lt;= i ahaub_1027)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Memory safety of array access at line <a href="#L142">line 142</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val_49',0,ahaub) &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; 0 &le; i &and; i &le; ahaub &and; update_array_1d(val,val_49',v,i))  &#8866;   &exist; ahalb_1035  &exist; ahaub_1036 (dom(idx,ahalb_1035,ahaub_1036) &and; ahalb_1035 &le; i &and; i &le; ahaub_1036)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1035 Int)) (exists ((ahaub_1036 Int)) (and (dom idx ahalb_1035 ahaub_1036) (and (&lt;= ahalb_1035 i) (&lt;= i ahaub_1036)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Memory safety of array access at line <a href="#L142">line 142</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1048 &and; dom(val_49',0,ahaub) &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; i &le; ahaub &and; update_array_1d(val,val_49',v,i) &and; dom(idx,0,ahaub_1048) &and; 0 &le; i &and; i &le; ahaub_1048 &and; n &le; idx[i])  &#8866;   &exist; ahalb_1053  &exist; ahaub_1054 (dom(idx,ahalb_1053,ahaub_1054) &and; ahalb_1053 &le; i &and; i &le; ahaub_1054)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1048 () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1048))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom idx 0 ahaub_1048))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1048))<br/>
(assert (&lt;= n (select idx i)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1053 Int)) (exists ((ahaub_1054 Int)) (and (dom idx ahalb_1053 ahaub_1054) (and (&lt;= ahalb_1053 i) (&lt;= i ahaub_1054)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1048 &and; dom(val_49',0,ahaub) &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; i &le; ahaub &and; update_array_1d(val,val_49',v,i) &and; dom(idx,0,ahaub_1048) &and; 0 &le; i &and; i &le; ahaub_1048 &and; idx[i] &lt; n)  &#8866;   &exist; ahalb_1055  &exist; ahaub_1056 (dom(idx,ahalb_1055,ahaub_1056) &and; ahalb_1055 &le; i &and; i &le; ahaub_1056)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1048 () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1048))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom idx 0 ahaub_1048))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1048))<br/>
(assert (&lt; (select idx i) n))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1055 Int)) (exists ((ahaub_1056 Int)) (and (dom idx ahalb_1055 ahaub_1056) (and (&lt;= ahalb_1055 i) (&lt;= i ahaub_1056)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed assert">
Assertion at <a href="#L143">line 143</a> holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1048 &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; i &le; ahaub &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and; n &le; idx[i] &and; dom(idx,0,ahaub_1048) &and; 0 &le; i &and; i &le; ahaub_1048 &and; 0 &le; idx[i])  &#8866;   &not; is_modified(val_49',idx,bk,n,i)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1048 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1048))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1048))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
;Negation of Consequence<br/>
(assert (not (not (is_modified val_49_primed idx bk n i))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1048 &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; i &le; ahaub &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; dom(idx,0,ahaub_1048) &and; 0 &le; i &and; i &le; ahaub_1048 &and; idx[i] &lt; 0)  &#8866;   &not; is_modified(val_49',idx,bk,n,i)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1048 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1048))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1048))<br/>
(assert (&lt; (select idx i) 0))<br/>
;Negation of Consequence<br/>
(assert (not (not (is_modified val_49_primed idx bk n i))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed assert">
Assertion at <a href="#L144">line 144</a> holds
<ul></ul></li>
<li class="Collapsed assert">
Assertion at <a href="#L146">line 146</a> holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1048 &and; 0 &le; idx[i] &and; i &le; ahaub_1048 &and; 0 &le; i &and; dom(idx,0,ahaub_1048) &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; n &le; idx[i] &and;  &not; is_modified(val_49',idx,bk,n,i))  &#8866;  n &lt; 1000
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1048 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1048))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= i ahaub_1048))<br/>
(assert (&lt;= 0 i))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
;Negation of Consequence<br/>
(assert (not (&lt; n 1000)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1048 &and; idx[i] &lt; 0 &and; i &le; ahaub_1048 &and; 0 &le; i &and; dom(idx,0,ahaub_1048) &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; idx[i] &lt; n &and;  &not; is_modified(val_49',idx,bk,n,i))  &#8866;  n &lt; 1000
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1048 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1048))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (&lt;= i ahaub_1048))<br/>
(assert (&lt;= 0 i))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
;Negation of Consequence<br/>
(assert (not (&lt; n 1000)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed assert">
Assertion at <a href="#L147">line 147</a> holds
<ul></ul></li>
<li class="Collapsed pre">
Memory safety of array update at line <a href="#L148">line 148</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1115 &and; n &lt; 1000 &and; dom(val_49',0,ahaub) &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; i &le; ahaub &and; update_array_1d(val,val_49',v,i) &and; n &le; idx[i] &and; dom(idx,0,ahaub_1115) &and; 0 &le; i &and; i &le; ahaub_1115 &and; 0 &le; idx[i] &and;  &not; is_modified(val_49',idx,bk,n,i))  &#8866;   &exist; ahalb_1122  &exist; ahaub_1123 (dom(idx,ahalb_1122,ahaub_1123) &and; ahalb_1122 &le; i &and; i &le; ahaub_1123)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (&lt; n 1000))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (dom idx 0 ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1122 Int)) (exists ((ahaub_1123 Int)) (and (dom idx ahalb_1122 ahaub_1123) (and (&lt;= ahalb_1122 i) (&lt;= i ahaub_1123)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1115 &and; n &lt; 1000 &and; dom(val_49',0,ahaub) &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; i &le; ahaub &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; dom(idx,0,ahaub_1115) &and; 0 &le; i &and; i &le; ahaub_1115 &and; idx[i] &lt; 0 &and;  &not; is_modified(val_49',idx,bk,n,i))  &#8866;   &exist; ahalb_1124  &exist; ahaub_1125 (dom(idx,ahalb_1124,ahaub_1125) &and; ahalb_1124 &le; i &and; i &le; ahaub_1125)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (&lt; n 1000))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (dom idx 0 ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1124 Int)) (exists ((ahaub_1125 Int)) (and (dom idx ahalb_1124 ahaub_1125) (and (&lt;= ahalb_1124 i) (&lt;= i ahaub_1125)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Memory safety of array update at line <a href="#L149">line 149</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1115 &and; dom(idx_50',0,ahaub_1115) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; 0 &le; idx[i] &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; n &le; idx[i] &and;  &not; is_modified(val_49',idx,bk,n,i) &and; n &lt; 1000 &and; update_array_1d(idx,idx_50',n,i))  &#8866;   &exist; ahalb_1141  &exist; ahaub_1142 (dom(bk,ahalb_1141,ahaub_1142) &and; ahalb_1141 &le; n &and; n &le; ahaub_1142)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (dom idx_50_primed 0 ahaub_1115))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1115))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; n 1000))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1141 Int)) (exists ((ahaub_1142 Int)) (and (dom bk ahalb_1141 ahaub_1142) (and (&lt;= ahalb_1141 n) (&lt;= n ahaub_1142)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1115 &and; dom(idx_50',0,ahaub_1115) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; idx[i] &lt; 0 &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; idx[i] &lt; n &and;  &not; is_modified(val_49',idx,bk,n,i) &and; n &lt; 1000 &and; update_array_1d(idx,idx_50',n,i))  &#8866;   &exist; ahalb_1143  &exist; ahaub_1144 (dom(bk,ahalb_1143,ahaub_1144) &and; ahalb_1143 &le; n &and; n &le; ahaub_1144)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (dom idx_50_primed 0 ahaub_1115))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1115))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; n 1000))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1143 Int)) (exists ((ahaub_1144 Int)) (and (dom bk ahalb_1143 ahaub_1144) (and (&lt;= ahalb_1143 n) (&lt;= n ahaub_1144)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Memory safety of array access at line <a href="#L151">line 151</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1164 &and; dom(val_49',0,ahaub) &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; i &le; ahaub &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; dom(idx,0,ahaub_1164) &and; 0 &le; i &and; i &le; ahaub_1164 &and; 0 &le; idx[i])  &#8866;   &exist; ahalb_1173  &exist; ahaub_1174 (dom(idx,ahalb_1173,ahaub_1174) &and; ahalb_1173 &le; i &and; i &le; ahaub_1174)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (dom idx 0 ahaub_1164))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1173 Int)) (exists ((ahaub_1174 Int)) (and (dom idx ahalb_1173 ahaub_1174) (and (&lt;= ahalb_1173 i) (&lt;= i ahaub_1174)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Memory safety of array access at line <a href="#L151">line 151</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1164 &and; i &le; ahaub_1164 &and; 0 &le; i &and; dom(idx,0,ahaub_1164) &and; 0 &le; idx[i] &and; idx[i] &lt; n &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; n &le; 1000 &and; 0 &le; n &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; v_int_151_814' = idx[i])  &#8866;   &exist; ahalb_1182  &exist; ahaub_1183 (dom(bk,ahalb_1182,ahaub_1183) &and; ahalb_1182 &le; v_int_151_814' &and; v_int_151_814' &le; ahaub_1183)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun v_int_151_814_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1164))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (= v_int_151_814_primed (select idx i)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1182 Int)) (exists ((ahaub_1183 Int)) (and (dom bk ahalb_1182 ahaub_1183) (and (&lt;= ahalb_1182 v_int_151_814_primed) (&lt;= v_int_151_814_primed ahaub_1183)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed assert">
Assertion at <a href="#L152">line 152</a> holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1177 &and; 1000 - 1 = ahaub_1164 &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; i &le; ahaub &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; dom(idx,0,ahaub_1164) &and; 0 &le; i &and; i &le; ahaub_1164 &and; dom(bk,0,ahaub_1177) &and; 0 &le; idx[i] &and; idx[i] &le; ahaub_1177 &and; bk[idx[i]] &ne; i)  &#8866;   &not; is_modified(val_49',idx,bk,n,i)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun ahaub_1177 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1177))<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (select idx i) ahaub_1177))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
;Negation of Consequence<br/>
(assert (not (not (is_modified val_49_primed idx bk n i))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed assert">
Assertion at <a href="#L153">line 153</a> holds
<ul></ul></li>
<li class="Collapsed assert">
Assertion at <a href="#L155">line 155</a> holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1164 &and; 1000 - 1 = ahaub_1177 &and; bk[idx[i]] &ne; i &and; idx[i] &le; ahaub_1177 &and; 0 &le; idx[i] &and; dom(bk,0,ahaub_1177) &and; i &le; ahaub_1164 &and; 0 &le; i &and; dom(idx,0,ahaub_1164) &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; idx[i] &lt; n &and;  &not; is_modified(val_49',idx,bk,n,i))  &#8866;  n &lt; 1000
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1177 () Int)<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (= (- 1000 1) ahaub_1177))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
(assert (&lt;= (select idx i) ahaub_1177))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 i))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
;Negation of Consequence<br/>
(assert (not (&lt; n 1000)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed assert">
Assertion at <a href="#L156">line 156</a> holds
<ul></ul></li>
<li class="Collapsed pre">
Memory safety of array update at line <a href="#L157">line 157</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1195 &and; n &lt; 1000 &and; dom(bk,0,ahaub_1177) &and; 1000 - 1 = ahaub_1177 &and; dom(val_49',0,ahaub) &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; i &le; ahaub &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; dom(idx,0,ahaub_1195) &and; 0 &le; i &and; i &le; ahaub_1195 &and; 0 &le; idx[i] &and; idx[i] &le; ahaub_1177 &and; bk[idx[i]] &ne; i &and;  &not; is_modified(val_49',idx,bk,n,i))  &#8866;   &exist; ahalb_1202  &exist; ahaub_1203 (dom(idx,ahalb_1202,ahaub_1203) &and; ahalb_1202 &le; i &and; i &le; ahaub_1203)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1195 () Int)<br/>
(declare-fun ahaub_1177 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1195))<br/>
(assert (&lt; n 1000))<br/>
(assert (dom bk 0 ahaub_1177))<br/>
(assert (= (- 1000 1) ahaub_1177))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (dom idx 0 ahaub_1195))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1195))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (select idx i) ahaub_1177))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1202 Int)) (exists ((ahaub_1203 Int)) (and (dom idx ahalb_1202 ahaub_1203) (and (&lt;= ahalb_1202 i) (&lt;= i ahaub_1203)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Memory safety of array update at line <a href="#L158">line 158</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1195 &and; 1000 - 1 = ahaub_1209 &and; dom(idx_50',0,ahaub_1195) &and; i &le; ahaub_1195 &and; 0 &le; i &and; dom(idx,0,ahaub_1195) &and; idx[i] &le; ahaub_1209 &and; 0 &le; idx[i] &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; idx[i] &lt; n &and; dom(bk,0,ahaub_1209) &and; bk[idx[i]] &ne; i &and;  &not; is_modified(val_49',idx,bk,n,i) &and; n &lt; 1000 &and; update_array_1d(idx,idx_50',n,i))  &#8866;   &exist; ahalb_1216  &exist; ahaub_1217 (dom(bk,ahalb_1216,ahaub_1217) &and; ahalb_1216 &le; n &and; n &le; ahaub_1217)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1195 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun ahaub_1209 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1195))<br/>
(assert (= (- 1000 1) ahaub_1209))<br/>
(assert (dom idx_50_primed 0 ahaub_1195))<br/>
(assert (&lt;= i ahaub_1195))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1195))<br/>
(assert (&lt;= (select idx i) ahaub_1209))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (dom bk 0 ahaub_1209))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; n 1000))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1216 Int)) (exists ((ahaub_1217 Int)) (and (dom bk ahalb_1216 ahaub_1217) (and (&lt;= ahalb_1216 n) (&lt;= n ahaub_1217)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1115 &and; 1000 - 1 = ahaub_1134 &and; v_int_150_1235 = 1 + n &and; update_array_1d(bk,bk_51',i,n) &and; dom(bk_51',0,ahaub_1134) &and; n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1115) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; n &lt; 1000 &and; 0 &le; idx[i] &and; n &le; idx[i] &and; i &le; ahaub &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and;  &not; is_modified(val_49',idx,bk,n,i))  &#8866;  dom(val_49',0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_150_1235 () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= v_int_150_1235 (+ 1 n)))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (dom bk_51_primed 0 ahaub_1134))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 ahaub_1134))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (dom idx_50_primed 0 ahaub_1115))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1115))<br/>
(assert (&lt; n 1000))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
;Negation of Consequence<br/>
(assert (not (dom val_49_primed 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1134 &and; v_int_150_1235 = 1 + n &and; update_array_1d(bk,bk_51',i,n) &and; dom(bk_51',0,ahaub_1134) &and; n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; 1000 - 1 = ahaub_1115 &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; 0 &le; idx[i] &and; n &le; idx[i] &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(idx,0,1000 - 1) &and; dom(idx_50',0,ahaub_1115) &and; update_array_1d(idx,idx_50',n,i))  &#8866;  dom(idx_50',0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_150_1235 () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= v_int_150_1235 (+ 1 n)))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (dom bk_51_primed 0 ahaub_1134))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 ahaub_1134))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1115))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom idx_50_primed 0 ahaub_1115))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
;Negation of Consequence<br/>
(assert (not (dom idx_50_primed 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1115 &and; v_int_150_1235 = 1 + n &and; n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; 1000 - 1 = ahaub_1134 &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1115) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; 0 &le; idx[i] &and; n &le; idx[i] &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(bk_51',0,ahaub_1134) &and; update_array_1d(bk,bk_51',i,n))  &#8866;  dom(bk_51',0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_150_1235 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (= v_int_150_1235 (+ 1 n)))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 ahaub_1134))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (dom idx_50_primed 0 ahaub_1115))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1115))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom bk_51_primed 0 ahaub_1134))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
;Negation of Consequence<br/>
(assert (not (dom bk_51_primed 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; i &lt; 1000 &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1115 &and; 1000 - 1 = ahaub_1134 &and; update_array_1d(bk,bk_51',i,n) &and; dom(bk_51',0,ahaub_1134) &and; n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1115) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; 0 &le; idx[i] &and; n &le; idx[i] &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; v_int_150_1235 = 1 + n)  &#8866;  0 &le; v_int_150_1235
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun v_int_150_1235 () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (&lt; i 1000))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (= v_int_150_1235 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= 0 v_int_150_1235)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; i &lt; 1000 &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1115 &and; 1000 - 1 = ahaub_1134 &and; update_array_1d(bk,bk_51',i,n) &and; dom(bk_51',0,ahaub_1134) &and; n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1115) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; 0 &le; idx[i] &and; n &le; idx[i] &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; v_int_150_1235 = 1 + n)  &#8866;  v_int_150_1235 &le; 1000
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun v_int_150_1235 () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (&lt; i 1000))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (= v_int_150_1235 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= v_int_150_1235 1000)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(bk_51',0,ahaub_1134) &and; 1000 - 1 = ahaub_1134 &and; dom(idx_50',0,ahaub_1115) &and; 1000 - 1 = ahaub_1115 &and; dom(val_49',0,ahaub) &and; 1000 - 1 = ahaub &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; dom(val,0,ahaub) &and; i &le; ahaub &and; update_array_1d(val,val_49',v,i) &and; n &le; idx[i] &and; 0 &le; idx[i] &and;  &not; is_modified(val_49',idx,bk,n,i) &and; n &lt; 1000 &and; dom(idx,0,ahaub_1115) &and; 0 &le; i &and; i &le; ahaub_1115 &and; update_array_1d(idx,idx_50',n,i) &and; dom(bk,0,ahaub_1134) &and; 0 &le; n &and; n &le; ahaub_1134 &and; update_array_1d(bk,bk_51',i,n) &and; v_int_150_1235 = 1 + n)  &#8866;  ((is_modified(val,idx,bk,n,i) &and; v_int_150_1235 = n) &or; ( &not; is_modified(val,idx,bk,n,i) &and; v_int_150_1235 = n + 1))
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun v_int_150_1235 () Int)<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; n 1000))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_150_1235 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (or (and (is_modified val idx bk n i) (= v_int_150_1235 n)) (and (not (is_modified val idx bk n i)) (= v_int_150_1235 (+ n 1))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1115 &and; n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; 1000 - 1 = ahaub_1134 &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1115) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; 0 &le; idx[i] &and; n &le; idx[i] &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(bk_51',0,ahaub_1134) &and; update_array_1d(bk,bk_51',i,n) &and; v_int_150_1235 = 1 + n)  &#8866;  bounded(bk_51',0,v_int_150_1235 - 1,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun v_int_150_1235 () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_150_1235 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (bounded bk_51_primed 0 (- v_int_150_1235 1) 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; 1000 - 1 = ahaub_1134 &and; dom(idx,0,ahaub_1115) &and; 1000 - 1 = ahaub_1115 &and; n &lt; 1000 &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; i &lt; 1000 &and; i &le; ahaub &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and; n &le; idx[i] &and; 0 &le; idx[i] &and;  &not; is_modified(val_49',idx,bk,n,i) &and; 0 &le; i &and; i &le; ahaub_1115 &and; dom(idx_50',0,ahaub_1115) &and; update_array_1d(idx,idx_50',n,i) &and; dom(bk_51',0,ahaub_1134) &and; update_array_1d(bk,bk_51',i,n) &and; v_int_150_1235 = 1 + n)  &#8866;  value_at(val_49',idx_50',bk_51',v_int_150_1235,i,v)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun v_int_150_1235 () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun v () Int)<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (&lt; n 1000))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_150_1235 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (value_at val_49_primed idx_50_primed bk_51_primed v_int_150_1235 i v)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; 1000 - 1 = ahaub_1134 &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; 1000 - 1 = ahaub_1115 &and; n &lt; 1000 &and; 0 &le; idx[i] &and; n &le; idx[i] &and; i &le; ahaub &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and;  &not; is_modified(val_49',idx,bk,n,i) &and; dom(idx_50',0,ahaub_1115) &and; update_array_1d(idx,idx_50',n,i) &and; dom(bk_51',0,ahaub_1134) &and; update_array_1d(bk,bk_51',i,n) &and; v_int_150_1235 = 1 + n)  &#8866;  is_sparse_array(val_49',idx_50',bk_51',v_int_150_1235)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun v_int_150_1235 () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (&lt; n 1000))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_150_1235 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (is_sparse_array val_49_primed idx_50_primed bk_51_primed v_int_150_1235)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1134 &and; 1000 - 1 = ahaub_1115 &and; 1000 - 1 = ahaub &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; dom(val,0,ahaub) &and; i &le; ahaub &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and; n &le; idx[i] &and; 0 &le; idx[i] &and;  &not; is_modified(val_49',idx,bk,n,i) &and; n &lt; 1000 &and; dom(idx,0,ahaub_1115) &and; 0 &le; i &and; i &le; ahaub_1115 &and; dom(idx_50',0,ahaub_1115) &and; update_array_1d(idx,idx_50',n,i) &and; dom(bk,0,ahaub_1134) &and; 0 &le; n &and; n &le; ahaub_1134 &and; dom(bk_51',0,ahaub_1134) &and; update_array_1d(bk,bk_51',i,n) &and; v_int_150_1235 = 1 + n)  &#8866;  idexc(val,idx,bk,n,val_49',idx_50',bk_51',v_int_150_1235,i)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun v_int_150_1235 () Int)<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun idexc ((Array Int Int) (Array Int Int) (Array Int Int) Int (Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((i Int) (val2 (Array Int Int)) (idx2 (Array Int Int)) (bk2 (Array Int Int)) (n2 Int) (val1 (Array Int Int)) (idx1 (Array Int Int)) (bk1 (Array Int Int)) (n1 Int)) (= (idexc val1 idx1 bk1 n1 val2 idx2 bk2 n2 i) (forall ((k Int)) (or (= k i) (and (forall ((h Int)) (or (not (value_at val1 idx1 bk1 n1 k h)) (value_at val2 idx2 bk2 n2 k h))) (forall ((t Int)) (or (not (value_at val2 idx2 bk2 n2 k t)) (value_at val1 idx1 bk1 n1 k t)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= n (select idx i)))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; n 1000))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_150_1235 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (idexc val idx bk n val_49_primed idx_50_primed bk_51_primed v_int_150_1235 i)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1115 &and; 1000 - 1 = ahaub_1134 &and; v_int_150_1237 = 1 + n &and; update_array_1d(bk,bk_51',i,n) &and; dom(bk_51',0,ahaub_1134) &and; n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1115) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; n &lt; 1000 &and; idx[i] &lt; 0 &and; idx[i] &lt; n &and; i &le; ahaub &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and;  &not; is_modified(val_49',idx,bk,n,i))  &#8866;  dom(val_49',0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_150_1237 () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= v_int_150_1237 (+ 1 n)))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (dom bk_51_primed 0 ahaub_1134))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 ahaub_1134))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (dom idx_50_primed 0 ahaub_1115))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1115))<br/>
(assert (&lt; n 1000))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
;Negation of Consequence<br/>
(assert (not (dom val_49_primed 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1134 &and; v_int_150_1237 = 1 + n &and; update_array_1d(bk,bk_51',i,n) &and; dom(bk_51',0,ahaub_1134) &and; n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; 1000 - 1 = ahaub_1115 &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; idx[i] &lt; 0 &and; idx[i] &lt; n &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(idx,0,1000 - 1) &and; dom(idx_50',0,ahaub_1115) &and; update_array_1d(idx,idx_50',n,i))  &#8866;  dom(idx_50',0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_150_1237 () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= v_int_150_1237 (+ 1 n)))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (dom bk_51_primed 0 ahaub_1134))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 ahaub_1134))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1115))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom idx_50_primed 0 ahaub_1115))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
;Negation of Consequence<br/>
(assert (not (dom idx_50_primed 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1115 &and; v_int_150_1237 = 1 + n &and; n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; 1000 - 1 = ahaub_1134 &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1115) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; idx[i] &lt; 0 &and; idx[i] &lt; n &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(bk_51',0,ahaub_1134) &and; update_array_1d(bk,bk_51',i,n))  &#8866;  dom(bk_51',0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_150_1237 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (= v_int_150_1237 (+ 1 n)))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 ahaub_1134))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (dom idx_50_primed 0 ahaub_1115))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1115))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom bk_51_primed 0 ahaub_1134))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
;Negation of Consequence<br/>
(assert (not (dom bk_51_primed 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; i &lt; 1000 &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1115 &and; 1000 - 1 = ahaub_1134 &and; update_array_1d(bk,bk_51',i,n) &and; dom(bk_51',0,ahaub_1134) &and; n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1115) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; idx[i] &lt; 0 &and; idx[i] &lt; n &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; v_int_150_1237 = 1 + n)  &#8866;  0 &le; v_int_150_1237
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun v_int_150_1237 () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (&lt; i 1000))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (= v_int_150_1237 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= 0 v_int_150_1237)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; i &lt; 1000 &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1115 &and; 1000 - 1 = ahaub_1134 &and; update_array_1d(bk,bk_51',i,n) &and; dom(bk_51',0,ahaub_1134) &and; n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1115) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; idx[i] &lt; 0 &and; idx[i] &lt; n &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; v_int_150_1237 = 1 + n)  &#8866;  v_int_150_1237 &le; 1000
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun v_int_150_1237 () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (&lt; i 1000))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (= v_int_150_1237 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= v_int_150_1237 1000)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(bk_51',0,ahaub_1134) &and; 1000 - 1 = ahaub_1134 &and; dom(idx_50',0,ahaub_1115) &and; 1000 - 1 = ahaub_1115 &and; dom(val_49',0,ahaub) &and; 1000 - 1 = ahaub &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; dom(val,0,ahaub) &and; i &le; ahaub &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; idx[i] &lt; 0 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; n &lt; 1000 &and; dom(idx,0,ahaub_1115) &and; 0 &le; i &and; i &le; ahaub_1115 &and; update_array_1d(idx,idx_50',n,i) &and; dom(bk,0,ahaub_1134) &and; 0 &le; n &and; n &le; ahaub_1134 &and; update_array_1d(bk,bk_51',i,n) &and; v_int_150_1237 = 1 + n)  &#8866;  ((is_modified(val,idx,bk,n,i) &and; v_int_150_1237 = n) &or; ( &not; is_modified(val,idx,bk,n,i) &and; v_int_150_1237 = n + 1))
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun v_int_150_1237 () Int)<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; n 1000))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_150_1237 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (or (and (is_modified val idx bk n i) (= v_int_150_1237 n)) (and (not (is_modified val idx bk n i)) (= v_int_150_1237 (+ n 1))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1115 &and; n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; 1000 - 1 = ahaub_1134 &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1115) &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; idx[i] &lt; 0 &and; idx[i] &lt; n &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(bk_51',0,ahaub_1134) &and; update_array_1d(bk,bk_51',i,n) &and; v_int_150_1237 = 1 + n)  &#8866;  bounded(bk_51',0,v_int_150_1237 - 1,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun v_int_150_1237 () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_150_1237 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (bounded bk_51_primed 0 (- v_int_150_1237 1) 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; 1000 - 1 = ahaub_1134 &and; dom(idx,0,ahaub_1115) &and; 1000 - 1 = ahaub_1115 &and; n &lt; 1000 &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; i &lt; 1000 &and; i &le; ahaub &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; idx[i] &lt; 0 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; 0 &le; i &and; i &le; ahaub_1115 &and; dom(idx_50',0,ahaub_1115) &and; update_array_1d(idx,idx_50',n,i) &and; dom(bk_51',0,ahaub_1134) &and; update_array_1d(bk,bk_51',i,n) &and; v_int_150_1237 = 1 + n)  &#8866;  value_at(val_49',idx_50',bk_51',v_int_150_1237,i,v)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun v_int_150_1237 () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun v () Int)<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (&lt; n 1000))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_150_1237 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (value_at val_49_primed idx_50_primed bk_51_primed v_int_150_1237 i v)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(n &le; ahaub_1134 &and; 0 &le; n &and; dom(bk,0,ahaub_1134) &and; 1000 - 1 = ahaub_1134 &and; i &le; ahaub_1115 &and; 0 &le; i &and; dom(idx,0,ahaub_1115) &and; 1000 - 1 = ahaub_1115 &and; n &lt; 1000 &and; idx[i] &lt; 0 &and; idx[i] &lt; n &and; i &le; ahaub &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and;  &not; is_modified(val_49',idx,bk,n,i) &and; dom(idx_50',0,ahaub_1115) &and; update_array_1d(idx,idx_50',n,i) &and; dom(bk_51',0,ahaub_1134) &and; update_array_1d(bk,bk_51',i,n) &and; v_int_150_1237 = 1 + n)  &#8866;  is_sparse_array(val_49',idx_50',bk_51',v_int_150_1237)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun v_int_150_1237 () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (&lt;= 0 i))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (&lt; n 1000))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_150_1237 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (is_sparse_array val_49_primed idx_50_primed bk_51_primed v_int_150_1237)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1134 &and; 1000 - 1 = ahaub_1115 &and; 1000 - 1 = ahaub &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; dom(val,0,ahaub) &and; i &le; ahaub &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; idx[i] &lt; 0 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; n &lt; 1000 &and; dom(idx,0,ahaub_1115) &and; 0 &le; i &and; i &le; ahaub_1115 &and; dom(idx_50',0,ahaub_1115) &and; update_array_1d(idx,idx_50',n,i) &and; dom(bk,0,ahaub_1134) &and; 0 &le; n &and; n &le; ahaub_1134 &and; dom(bk_51',0,ahaub_1134) &and; update_array_1d(bk,bk_51',i,n) &and; v_int_150_1237 = 1 + n)  &#8866;  idexc(val,idx,bk,n,val_49',idx_50',bk_51',v_int_150_1237,i)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1115 () Int)<br/>
(declare-fun ahaub_1134 () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun v_int_150_1237 () Int)<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun idexc ((Array Int Int) (Array Int Int) (Array Int Int) Int (Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((i Int) (val2 (Array Int Int)) (idx2 (Array Int Int)) (bk2 (Array Int Int)) (n2 Int) (val1 (Array Int Int)) (idx1 (Array Int Int)) (bk1 (Array Int Int)) (n1 Int)) (= (idexc val1 idx1 bk1 n1 val2 idx2 bk2 n2 i) (forall ((k Int)) (or (= k i) (and (forall ((h Int)) (or (not (value_at val1 idx1 bk1 n1 k h)) (value_at val2 idx2 bk2 n2 k h))) (forall ((t Int)) (or (not (value_at val2 idx2 bk2 n2 k t)) (value_at val1 idx1 bk1 n1 k t)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1134))<br/>
(assert (= (- 1000 1) ahaub_1115))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; n 1000))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1115))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n ahaub_1134))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_150_1237 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (idexc val idx bk n val_49_primed idx_50_primed bk_51_primed v_int_150_1237 i)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1195 &and; v_int_159_1239 = 1 + n &and; update_array_1d(bk,bk_51',i,n) &and; dom(bk_51',0,ahaub_1209) &and; n &le; ahaub_1209 &and; 0 &le; n &and; dom(bk,0,ahaub_1209) &and; 1000 - 1 = ahaub_1209 &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1195) &and; i &le; ahaub_1195 &and; 0 &le; i &and; dom(idx,0,ahaub_1195) &and; n &lt; 1000 &and; bk[idx[i]] &ne; i &and; idx[i] &le; ahaub_1209 &and; 0 &le; idx[i] &and; idx[i] &lt; n &and; i &le; ahaub &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and;  &not; is_modified(val_49',idx,bk,n,i))  &#8866;  dom(val_49',0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_159_1239 () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1195 () Int)<br/>
(declare-fun ahaub_1209 () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1195))<br/>
(assert (= v_int_159_1239 (+ 1 n)))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (dom bk_51_primed 0 ahaub_1209))<br/>
(assert (&lt;= n ahaub_1209))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 ahaub_1209))<br/>
(assert (= (- 1000 1) ahaub_1209))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (dom idx_50_primed 0 ahaub_1195))<br/>
(assert (&lt;= i ahaub_1195))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1195))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
(assert (&lt;= (select idx i) ahaub_1209))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
;Negation of Consequence<br/>
(assert (not (dom val_49_primed 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 1000 - 1 = ahaub &and; v_int_159_1239 = 1 + n &and; update_array_1d(bk,bk_51',i,n) &and; dom(bk_51',0,ahaub_1209) &and; n &le; ahaub_1209 &and; 0 &le; n &and; dom(bk,0,ahaub_1209) &and; 1000 - 1 = ahaub_1209 &and; i &le; ahaub_1195 &and; 0 &le; i &and; dom(idx,0,ahaub_1195) &and; 1000 - 1 = ahaub_1195 &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; bk[idx[i]] &ne; i &and; idx[i] &le; ahaub_1209 &and; 0 &le; idx[i] &and; idx[i] &lt; n &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(idx,0,1000 - 1) &and; dom(idx_50',0,ahaub_1195) &and; update_array_1d(idx,idx_50',n,i))  &#8866;  dom(idx_50',0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_159_1239 () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun ahaub_1209 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun ahaub_1195 () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= v_int_159_1239 (+ 1 n)))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (dom bk_51_primed 0 ahaub_1209))<br/>
(assert (&lt;= n ahaub_1209))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 ahaub_1209))<br/>
(assert (= (- 1000 1) ahaub_1209))<br/>
(assert (&lt;= i ahaub_1195))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1195))<br/>
(assert (= (- 1000 1) ahaub_1195))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
(assert (&lt;= (select idx i) ahaub_1209))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom idx_50_primed 0 ahaub_1195))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
;Negation of Consequence<br/>
(assert (not (dom idx_50_primed 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1195 &and; v_int_159_1239 = 1 + n &and; n &le; ahaub_1209 &and; 0 &le; n &and; dom(bk,0,ahaub_1209) &and; 1000 - 1 = ahaub_1209 &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1195) &and; i &le; ahaub_1195 &and; 0 &le; i &and; dom(idx,0,ahaub_1195) &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; bk[idx[i]] &ne; i &and; idx[i] &le; ahaub_1209 &and; 0 &le; idx[i] &and; idx[i] &lt; n &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(bk_51',0,ahaub_1209) &and; update_array_1d(bk,bk_51',i,n))  &#8866;  dom(bk_51',0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_159_1239 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1195 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun ahaub_1209 () Int)<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1195))<br/>
(assert (= v_int_159_1239 (+ 1 n)))<br/>
(assert (&lt;= n ahaub_1209))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 ahaub_1209))<br/>
(assert (= (- 1000 1) ahaub_1209))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (dom idx_50_primed 0 ahaub_1195))<br/>
(assert (&lt;= i ahaub_1195))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1195))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
(assert (&lt;= (select idx i) ahaub_1209))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom bk_51_primed 0 ahaub_1209))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
;Negation of Consequence<br/>
(assert (not (dom bk_51_primed 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; i &lt; 1000 &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1195 &and; update_array_1d(bk,bk_51',i,n) &and; dom(bk_51',0,ahaub_1209) &and; n &le; ahaub_1209 &and; 0 &le; n &and; dom(bk,0,ahaub_1209) &and; 1000 - 1 = ahaub_1209 &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1195) &and; i &le; ahaub_1195 &and; 0 &le; i &and; dom(idx,0,ahaub_1195) &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; bk[idx[i]] &ne; i &and; idx[i] &le; ahaub_1209 &and; 0 &le; idx[i] &and; idx[i] &lt; n &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; v_int_159_1239 = 1 + n)  &#8866;  0 &le; v_int_159_1239
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1195 () Int)<br/>
(declare-fun ahaub_1209 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun v_int_159_1239 () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (&lt; i 1000))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1195))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (&lt;= n ahaub_1209))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= (- 1000 1) ahaub_1209))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= i ahaub_1195))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
(assert (&lt;= (select idx i) ahaub_1209))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (= v_int_159_1239 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= 0 v_int_159_1239)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; i &lt; 1000 &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1195 &and; update_array_1d(bk,bk_51',i,n) &and; dom(bk_51',0,ahaub_1209) &and; n &le; ahaub_1209 &and; 0 &le; n &and; dom(bk,0,ahaub_1209) &and; 1000 - 1 = ahaub_1209 &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1195) &and; i &le; ahaub_1195 &and; 0 &le; i &and; dom(idx,0,ahaub_1195) &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; bk[idx[i]] &ne; i &and; idx[i] &le; ahaub_1209 &and; 0 &le; idx[i] &and; idx[i] &lt; n &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; v_int_159_1239 = 1 + n)  &#8866;  v_int_159_1239 &le; 1000
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1195 () Int)<br/>
(declare-fun ahaub_1209 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun v_int_159_1239 () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (&lt; i 1000))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1195))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (&lt;= n ahaub_1209))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= (- 1000 1) ahaub_1209))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= i ahaub_1195))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
(assert (&lt;= (select idx i) ahaub_1209))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (= v_int_159_1239 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= v_int_159_1239 1000)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(bk_51',0,ahaub_1209) &and; 1000 - 1 = ahaub_1209 &and; dom(idx_50',0,ahaub_1195) &and; 1000 - 1 = ahaub_1195 &and; dom(val_49',0,ahaub) &and; 1000 - 1 = ahaub &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; dom(val,0,ahaub) &and; i &le; ahaub &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; 0 &le; idx[i] &and; idx[i] &le; ahaub_1209 &and; bk[idx[i]] &ne; i &and;  &not; is_modified(val_49',idx,bk,n,i) &and; n &lt; 1000 &and; dom(idx,0,ahaub_1195) &and; 0 &le; i &and; i &le; ahaub_1195 &and; update_array_1d(idx,idx_50',n,i) &and; dom(bk,0,ahaub_1209) &and; 0 &le; n &and; n &le; ahaub_1209 &and; update_array_1d(bk,bk_51',i,n) &and; v_int_159_1239 = 1 + n)  &#8866;  ((is_modified(val,idx,bk,n,i) &and; v_int_159_1239 = n) &or; ( &not; is_modified(val,idx,bk,n,i) &and; v_int_159_1239 = n + 1))
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun ahaub_1195 () Int)<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1209 () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun v_int_159_1239 () Int)<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1209))<br/>
(assert (= (- 1000 1) ahaub_1195))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (select idx i) ahaub_1209))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; n 1000))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1195))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n ahaub_1209))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_159_1239 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (or (and (is_modified val idx bk n i) (= v_int_159_1239 n)) (and (not (is_modified val idx bk n i)) (= v_int_159_1239 (+ n 1))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; 1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1195 &and; n &le; ahaub_1209 &and; 0 &le; n &and; dom(bk,0,ahaub_1209) &and; 1000 - 1 = ahaub_1209 &and; update_array_1d(idx,idx_50',n,i) &and; dom(idx_50',0,ahaub_1195) &and; i &le; ahaub_1195 &and; 0 &le; i &and; dom(idx,0,ahaub_1195) &and; n &lt; 1000 &and;  &not; is_modified(val_49',idx,bk,n,i) &and; bk[idx[i]] &ne; i &and; idx[i] &le; ahaub_1209 &and; 0 &le; idx[i] &and; idx[i] &lt; n &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(bk_51',0,ahaub_1209) &and; update_array_1d(bk,bk_51',i,n) &and; v_int_159_1239 = 1 + n)  &#8866;  bounded(bk_51',0,v_int_159_1239 - 1,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun ahaub_1195 () Int)<br/>
(declare-fun ahaub_1209 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun v_int_159_1239 () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1195))<br/>
(assert (&lt;= n ahaub_1209))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= (- 1000 1) ahaub_1209))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= i ahaub_1195))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
(assert (&lt;= (select idx i) ahaub_1209))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_159_1239 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (bounded bk_51_primed 0 (- v_int_159_1239 1) 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(n &le; ahaub_1209 &and; 0 &le; n &and; dom(bk,0,ahaub_1209) &and; 1000 - 1 = ahaub_1209 &and; dom(idx,0,ahaub_1195) &and; 1000 - 1 = ahaub_1195 &and; n &lt; 1000 &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; i &lt; 1000 &and; i &le; ahaub &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; 0 &le; idx[i] &and; idx[i] &le; ahaub_1209 &and; bk[idx[i]] &ne; i &and;  &not; is_modified(val_49',idx,bk,n,i) &and; 0 &le; i &and; i &le; ahaub_1195 &and; dom(idx_50',0,ahaub_1195) &and; update_array_1d(idx,idx_50',n,i) &and; dom(bk_51',0,ahaub_1209) &and; update_array_1d(bk,bk_51',i,n) &and; v_int_159_1239 = 1 + n)  &#8866;  value_at(val_49',idx_50',bk_51',v_int_159_1239,i,v)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun ahaub_1209 () Int)<br/>
(declare-fun ahaub_1195 () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun v_int_159_1239 () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun v () Int)<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (&lt;= n ahaub_1209))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= (- 1000 1) ahaub_1209))<br/>
(assert (= (- 1000 1) ahaub_1195))<br/>
(assert (&lt; n 1000))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (select idx i) ahaub_1209))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1195))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_159_1239 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (value_at val_49_primed idx_50_primed bk_51_primed v_int_159_1239 i v)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(n &le; ahaub_1209 &and; 0 &le; n &and; dom(bk,0,ahaub_1209) &and; 1000 - 1 = ahaub_1209 &and; i &le; ahaub_1195 &and; 0 &le; i &and; dom(idx,0,ahaub_1195) &and; 1000 - 1 = ahaub_1195 &and; n &lt; 1000 &and; bk[idx[i]] &ne; i &and; idx[i] &le; ahaub_1209 &and; 0 &le; idx[i] &and; idx[i] &lt; n &and; i &le; ahaub &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and;  &not; is_modified(val_49',idx,bk,n,i) &and; dom(idx_50',0,ahaub_1195) &and; update_array_1d(idx,idx_50',n,i) &and; dom(bk_51',0,ahaub_1209) &and; update_array_1d(bk,bk_51',i,n) &and; v_int_159_1239 = 1 + n)  &#8866;  is_sparse_array(val_49',idx_50',bk_51',v_int_159_1239)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1195 () Int)<br/>
(declare-fun ahaub_1209 () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun v_int_159_1239 () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (&lt;= n ahaub_1209))<br/>
(assert (&lt;= 0 n))<br/>
(assert (= (- 1000 1) ahaub_1209))<br/>
(assert (&lt;= i ahaub_1195))<br/>
(assert (&lt;= 0 i))<br/>
(assert (= (- 1000 1) ahaub_1195))<br/>
(assert (&lt; n 1000))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
(assert (&lt;= (select idx i) ahaub_1209))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_159_1239 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (is_sparse_array val_49_primed idx_50_primed bk_51_primed v_int_159_1239)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1209 &and; 1000 - 1 = ahaub_1195 &and; 1000 - 1 = ahaub &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; dom(val,0,ahaub) &and; i &le; ahaub &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; 0 &le; idx[i] &and; idx[i] &le; ahaub_1209 &and; bk[idx[i]] &ne; i &and;  &not; is_modified(val_49',idx,bk,n,i) &and; n &lt; 1000 &and; dom(idx,0,ahaub_1195) &and; 0 &le; i &and; i &le; ahaub_1195 &and; dom(idx_50',0,ahaub_1195) &and; update_array_1d(idx,idx_50',n,i) &and; dom(bk,0,ahaub_1209) &and; 0 &le; n &and; n &le; ahaub_1209 &and; dom(bk_51',0,ahaub_1209) &and; update_array_1d(bk,bk_51',i,n) &and; v_int_159_1239 = 1 + n)  &#8866;  idexc(val,idx,bk,n,val_49',idx_50',bk_51',v_int_159_1239,i)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1195 () Int)<br/>
(declare-fun ahaub_1209 () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx_50_primed () (Array Int Int))<br/>
(declare-fun bk_51_primed () (Array Int Int))<br/>
(declare-fun v_int_159_1239 () Int)<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun idexc ((Array Int Int) (Array Int Int) (Array Int Int) Int (Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((i Int) (val2 (Array Int Int)) (idx2 (Array Int Int)) (bk2 (Array Int Int)) (n2 Int) (val1 (Array Int Int)) (idx1 (Array Int Int)) (bk1 (Array Int Int)) (n1 Int)) (= (idexc val1 idx1 bk1 n1 val2 idx2 bk2 n2 i) (forall ((k Int)) (or (= k i) (and (forall ((h Int)) (or (not (value_at val1 idx1 bk1 n1 k h)) (value_at val2 idx2 bk2 n2 k h))) (forall ((t Int)) (or (not (value_at val2 idx2 bk2 n2 k t)) (value_at val1 idx1 bk1 n1 k t)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1209))<br/>
(assert (= (- 1000 1) ahaub_1195))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (select idx i) ahaub_1209))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
(assert (not (is_modified val_49_primed idx bk n i)))<br/>
(assert (&lt; n 1000))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1195))<br/>
(assert (= idx_50_primed (store idx i n)))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n ahaub_1209))<br/>
(assert (= bk_51_primed (store bk n i)))<br/>
(assert (= v_int_159_1239 (+ 1 n)))<br/>
;Negation of Consequence<br/>
(assert (not (idexc val idx bk n val_49_primed idx_50_primed bk_51_primed v_int_159_1239 i)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; 1000 - 1 = ahaub_1164 &and; 1000 - 1 = ahaub_1177 &and; i = bk[idx[i]] &and; idx[i] &le; ahaub_1177 &and; 0 &le; idx[i] &and; dom(bk,0,ahaub_1177) &and; i &le; ahaub_1164 &and; 0 &le; i &and; dom(idx,0,ahaub_1164) &and; idx[i] &lt; n &and; i &le; ahaub &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; i &lt; 1000 &and; is_sparse_array(val,idx,bk,n) &and; dom(val,0,1000 - 1) &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i))  &#8866;  dom(val_49',0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1177 () Int)<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (= (- 1000 1) ahaub_1177))<br/>
(assert (= i (select bk (select idx i))))<br/>
(assert (&lt;= (select idx i) ahaub_1177))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (dom bk 0 ahaub_1177))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1164))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
;Negation of Consequence<br/>
(assert (not (dom val_49_primed 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub &and; dom(bk,0,ahaub_1177) &and; 1000 - 1 = ahaub_1177 &and; i &le; ahaub_1164 &and; 0 &le; i &and; 1000 - 1 = ahaub_1164 &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; idx[i] &lt; n &and; dom(idx,0,ahaub_1164) &and; 0 &le; idx[i] &and; idx[i] &le; ahaub_1177 &and; i = bk[idx[i]])  &#8866;  dom(idx,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun ahaub_1177 () Int)<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (dom bk 0 ahaub_1177))<br/>
(assert (= (- 1000 1) ahaub_1177))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 i))<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (dom idx 0 ahaub_1164))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (select idx i) ahaub_1177))<br/>
(assert (= i (select bk (select idx i))))<br/>
;Negation of Consequence<br/>
(assert (not (dom idx 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1164 &and; idx[i] &le; ahaub_1177 &and; 0 &le; idx[i] &and; 1000 - 1 = ahaub_1177 &and; i &le; ahaub_1164 &and; 0 &le; i &and; dom(idx,0,ahaub_1164) &and; idx[i] &lt; n &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; n &le; 1000 &and; 0 &le; n &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; dom(bk,0,ahaub_1177) &and; i = bk[idx[i]])  &#8866;  dom(bk,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun ahaub_1177 () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun bk () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (&lt;= (select idx i) ahaub_1177))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (= (- 1000 1) ahaub_1177))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1164))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (dom val_49_primed 0 ahaub))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (dom val 0 ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (dom bk 0 ahaub_1177))<br/>
(assert (= i (select bk (select idx i))))<br/>
;Negation of Consequence<br/>
(assert (not (dom bk 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1164 &and; 1000 - 1 = ahaub_1177 &and; i = bk[idx[i]] &and; idx[i] &le; ahaub_1177 &and; 0 &le; idx[i] &and; dom(bk,0,ahaub_1177) &and; i &le; ahaub_1164 &and; 0 &le; i &and; dom(idx,0,ahaub_1164) &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; idx[i] &lt; n)  &#8866;  0 &le; n
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1177 () Int)<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (= (- 1000 1) ahaub_1177))<br/>
(assert (= i (select bk (select idx i))))<br/>
(assert (&lt;= (select idx i) ahaub_1177))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 i))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; (select idx i) n))<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= 0 n)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1164 &and; 1000 - 1 = ahaub_1177 &and; i = bk[idx[i]] &and; idx[i] &le; ahaub_1177 &and; 0 &le; idx[i] &and; dom(bk,0,ahaub_1177) &and; i &le; ahaub_1164 &and; 0 &le; i &and; dom(idx,0,ahaub_1164) &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; idx[i] &lt; n)  &#8866;  n &le; 1000
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1177 () Int)<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (= (- 1000 1) ahaub_1177))<br/>
(assert (= i (select bk (select idx i))))<br/>
(assert (&lt;= (select idx i) ahaub_1177))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 i))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; (select idx i) n))<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= n 1000)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1177 &and; 1000 - 1 = ahaub_1164 &and; dom(val_49',0,ahaub) &and; 1000 - 1 = ahaub &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; dom(val,0,ahaub) &and; i &le; ahaub &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; dom(idx,0,ahaub_1164) &and; 0 &le; i &and; i &le; ahaub_1164 &and; dom(bk,0,ahaub_1177) &and; 0 &le; idx[i] &and; idx[i] &le; ahaub_1177 &and; i = bk[idx[i]])  &#8866;  ((is_modified(val,idx,bk,n,i) &and; n = n) &or; ( &not; is_modified(val,idx,bk,n,i) &and; n = n + 1))
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun ahaub_1177 () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1177))<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (select idx i) ahaub_1177))<br/>
(assert (= i (select bk (select idx i))))<br/>
;Negation of Consequence<br/>
(assert (not (or (and (is_modified val idx bk n i) (= n n)) (and (not (is_modified val idx bk n i)) (= n (+ n 1))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub &and; 1000 - 1 = ahaub_1164 &and; idx[i] &le; ahaub_1177 &and; 0 &le; idx[i] &and; 1000 - 1 = ahaub_1177 &and; i &le; ahaub_1164 &and; 0 &le; i &and; dom(idx,0,ahaub_1164) &and; update_array_1d(val,val_49',v,i) &and; dom(val_49',0,ahaub) &and; i &le; ahaub &and; dom(val,0,ahaub) &and; i &lt; 1000 &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; idx[i] &lt; n &and; dom(bk,0,ahaub_1177) &and; i = bk[idx[i]])  &#8866;  bounded(bk,0,n - 1,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1177 () Int)<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (&lt;= (select idx i) ahaub_1177))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (= (- 1000 1) ahaub_1177))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 i))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (= i (select bk (select idx i))))<br/>
;Negation of Consequence<br/>
(assert (not (bounded bk 0 (- n 1) 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1177 &and; 1000 - 1 = ahaub_1164 &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; i &le; ahaub &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; dom(idx,0,ahaub_1164) &and; 0 &le; i &and; i &le; ahaub_1164 &and; dom(bk,0,ahaub_1177) &and; 0 &le; idx[i] &and; idx[i] &le; ahaub_1177 &and; i = bk[idx[i]])  &#8866;  value_at(val_49',idx,bk,n,i,v)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun ahaub_1177 () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun v () Int)<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1177))<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (select idx i) ahaub_1177))<br/>
(assert (= i (select bk (select idx i))))<br/>
;Negation of Consequence<br/>
(assert (not (value_at val_49_primed idx bk n i v)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1177 &and; i &le; ahaub_1164 &and; 0 &le; i &and; 1000 - 1 = ahaub_1164 &and; i &le; ahaub &and; dom(val,0,ahaub) &and; 1000 - 1 = ahaub &and; i &lt; 1000 &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; dom(idx,0,ahaub_1164) &and; dom(bk,0,ahaub_1177) &and; 0 &le; idx[i] &and; idx[i] &le; ahaub_1177 &and; i = bk[idx[i]])  &#8866;  is_sparse_array(val_49',idx,bk,n)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1177 () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1177))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 i))<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (select idx i) ahaub_1177))<br/>
(assert (= i (select bk (select idx i))))<br/>
;Negation of Consequence<br/>
(assert (not (is_sparse_array val_49_primed idx bk n)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1177 &and; 1000 - 1 = ahaub_1164 &and; 1000 - 1 = ahaub &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; i &lt; 1000 &and; dom(val,0,ahaub) &and; i &le; ahaub &and; dom(val_49',0,ahaub) &and; update_array_1d(val,val_49',v,i) &and; idx[i] &lt; n &and; dom(idx,0,ahaub_1164) &and; 0 &le; i &and; i &le; ahaub_1164 &and; dom(bk,0,ahaub_1177) &and; 0 &le; idx[i] &and; idx[i] &le; ahaub_1177 &and; i = bk[idx[i]])  &#8866;  idexc(val,idx,bk,n,val_49',idx,bk,n,i)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun v () Int)<br/>
(declare-fun ahaub_1164 () Int)<br/>
(declare-fun ahaub_1177 () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun val_49_primed () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun idexc ((Array Int Int) (Array Int Int) (Array Int Int) Int (Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((i Int) (val2 (Array Int Int)) (idx2 (Array Int Int)) (bk2 (Array Int Int)) (n2 Int) (val1 (Array Int Int)) (idx1 (Array Int Int)) (bk1 (Array Int Int)) (n1 Int)) (= (idexc val1 idx1 bk1 n1 val2 idx2 bk2 n2 i) (forall ((k Int)) (or (= k i) (and (forall ((h Int)) (or (not (value_at val1 idx1 bk1 n1 k h)) (value_at val2 idx2 bk2 n2 k h))) (forall ((t Int)) (or (not (value_at val2 idx2 bk2 n2 k t)) (value_at val1 idx1 bk1 n1 k t)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1177))<br/>
(assert (= (- 1000 1) ahaub_1164))<br/>
(assert (= (- 1000 1) ahaub))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; i 1000))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (= val_49_primed (store val i v)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1164))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (select idx i) ahaub_1177))<br/>
(assert (= i (select bk (select idx i))))<br/>
;Negation of Consequence<br/>
(assert (not (idexc val idx bk n val_49_primed idx bk n i)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure get<ul><li class="Collapsed procdef">Internal representation
<ul>int get$SparseArray~int(  SparseArray a,  int i)<br/>
static  EBase exists (Expl)[](Impl)[val; idx; bk; <br/>
       n](ex)[]a::SparseArray&lt;val,idx,bk,n&gt;@I &amp; dom(val,0,1000 - 1) &amp; <br/>
       dom(idx,0,1000 - 1) &amp; dom(bk,0,1000 - 1) &amp; 0&lt;=n &amp; n&lt;=1000 &amp; 0&lt;=i &amp; (i+<br/>
       1)&lt;=1000 &amp; is_sparse_array(val,idx,bk,n) &amp; bounded(bk,0,n - 1,0,1000 -<br/>
       1) &amp; {FLOW,(39,39)=__norm}<br/>
         EAssume 8::<br/>
           true &amp; value_at(val,idx,bk,n,i,res) &amp; {FLOW,(39,39)=__norm}<br/>
dynamic  []<br/>
int[] idx_52;<br/>
idx_52 = 141::bind a to (values_110_907,index_110_908,back_110_909,n_110_910) in <br/>
{index_110_908<br/>
};<br/>
int[] back_53;<br/>
back_53 = 142::bind a to (values_111_911,index_111_912,back_111_913,n_111_914) in <br/>
{back_111_913<br/>
};<br/>
boolean v_bool_112_933;<br/>
v_bool_112_933 = {<br/>
boolean v_boolean_112_924;<br/>
v_boolean_112_924 = {<br/>
int v_int_112_916;<br/>
v_int_112_916 = {<br/>
array_get_elm_at___1d$int[]~int(idx_52,i)<br/>
};<br/>
int v_int_112_915;<br/>
v_int_112_915 = 0;<br/>
151::gte___$int~int(v_int_112_916,v_int_112_915)<br/>
};<br/>
boolean v_boolean_112_923;<br/>
v_boolean_112_923 = {<br/>
int v_int_112_922;<br/>
v_int_112_922 = {<br/>
array_get_elm_at___1d$int[]~int(idx_52,i)<br/>
};<br/>
int v_int_112_921;<br/>
v_int_112_921 = 150::bind a to (values_112_917,index_112_918,back_112_919,n_112_920) in <br/>
{n_112_920<br/>
};<br/>
149::lt___$int~int(v_int_112_922,v_int_112_921)<br/>
};<br/>
148::land___$boolean~boolean(v_boolean_112_924,v_boolean_112_923)<br/>
};<br/>
143::if (v_bool_112_933) LABEL! 143,0: boolean v_bool_113_932;<br/>
v_bool_113_932 = {<br/>
int v_int_113_926;<br/>
v_int_113_926 = {<br/>
int v_int_113_925;<br/>
v_int_113_925 = {<br/>
array_get_elm_at___1d$int[]~int(idx_52,i)<br/>
};<br/>
array_get_elm_at___1d$int[]~int(back_53,v_int_113_925)<br/>
};<br/>
147::eq___$int~int(v_int_113_926,i)<br/>
};<br/>
144::if (v_bool_113_932) LABEL! 144,0: int[] val_54;<br/>
val_54 = 145::bind a to (values_114_927,index_114_928,back_114_929,n_114_930) in <br/>
{values_114_927<br/>
};<br/>
int v_int_115_931;<br/>
v_int_115_931 = {<br/>
array_get_elm_at___1d$int[]~int(val_54,i)<br/>
};<br/>
146::return v_int_115_931<br/>
else LABEL! 144,1: <br/>
<br/>
else LABEL! 143,1: <br/>
;<br/>
int v_int_118_934;<br/>
v_int_118_934 = 0;<br/>
152::return v_int_118_934<br/>
<br/>
{(102,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pre">
Memory safety of array access at line <a href="#L112">line 112</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; 0 &le; i &and; i + 1 &le; 1000 &and; is_sparse_array(val,idx,bk,n))  &#8866;   &exist; ahalb_1328  &exist; ahaub_1329 (dom(idx,ahalb_1328,ahaub_1329) &and; ahalb_1328 &le; i &and; i &le; ahaub_1329)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= (+ i 1) 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1328 Int)) (exists ((ahaub_1329 Int)) (and (dom idx ahalb_1328 ahaub_1329) (and (&lt;= ahalb_1328 i) (&lt;= i ahaub_1329)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Memory safety of array access at line <a href="#L112">line 112</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1339 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; i + 1 &le; 1000 &and; is_sparse_array(val,idx,bk,n) &and; dom(idx,0,ahaub_1339) &and; 0 &le; i &and; i &le; ahaub_1339 &and; 0 &le; idx[i])  &#8866;   &exist; ahalb_1344  &exist; ahaub_1345 (dom(idx,ahalb_1344,ahaub_1345) &and; ahalb_1344 &le; i &and; i &le; ahaub_1345)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun ahaub_1339 () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1339))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (&lt;= (+ i 1) 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (dom idx 0 ahaub_1339))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1339))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1344 Int)) (exists ((ahaub_1345 Int)) (and (dom idx ahalb_1344 ahaub_1345) (and (&lt;= ahalb_1344 i) (&lt;= i ahaub_1345)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1339 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; i + 1 &le; 1000 &and; is_sparse_array(val,idx,bk,n) &and; dom(idx,0,ahaub_1339) &and; 0 &le; i &and; i &le; ahaub_1339 &and; idx[i] &lt; 0)  &#8866;   &exist; ahalb_1346  &exist; ahaub_1347 (dom(idx,ahalb_1346,ahaub_1347) &and; ahalb_1346 &le; i &and; i &le; ahaub_1347)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun ahaub_1339 () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1339))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (&lt;= (+ i 1) 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (dom idx 0 ahaub_1339))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1339))<br/>
(assert (&lt; (select idx i) 0))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1346 Int)) (exists ((ahaub_1347 Int)) (and (dom idx ahalb_1346 ahaub_1347) (and (&lt;= ahalb_1346 i) (&lt;= i ahaub_1347)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Memory safety of array access at line <a href="#L113">line 113</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1376 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; i + 1 &le; 1000 &and; is_sparse_array(val,idx,bk,n) &and; 0 &le; idx[i] &and; dom(idx,0,ahaub_1376) &and; 0 &le; i &and; i &le; ahaub_1376 &and; idx[i] &lt; n)  &#8866;   &exist; ahalb_1385  &exist; ahaub_1386 (dom(idx,ahalb_1385,ahaub_1386) &and; ahalb_1385 &le; i &and; i &le; ahaub_1386)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun ahaub_1376 () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1376))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (&lt;= (+ i 1) 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (dom idx 0 ahaub_1376))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1376))<br/>
(assert (&lt; (select idx i) n))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1385 Int)) (exists ((ahaub_1386 Int)) (and (dom idx ahalb_1385 ahaub_1386) (and (&lt;= ahalb_1385 i) (&lt;= i ahaub_1386)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Memory safety of array access at line <a href="#L113">line 113</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1376 &and; i &le; ahaub_1376 &and; 0 &le; i &and; dom(idx,0,ahaub_1376) &and; idx[i] &lt; n &and; 0 &le; idx[i] &and; i + 1 &le; 1000 &and; n &le; 1000 &and; 0 &le; n &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; v_int_113_925' = idx[i])  &#8866;   &exist; ahalb_1394  &exist; ahaub_1395 (dom(bk,ahalb_1394,ahaub_1395) &and; ahalb_1394 &le; v_int_113_925' &and; v_int_113_925' &le; ahaub_1395)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1376 () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun v_int_113_925_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1376))<br/>
(assert (&lt;= i ahaub_1376))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom idx 0 ahaub_1376))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (+ i 1) 1000))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (= v_int_113_925_primed (select idx i)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1394 Int)) (exists ((ahaub_1395 Int)) (and (dom bk ahalb_1394 ahaub_1395) (and (&lt;= ahalb_1394 v_int_113_925_primed) (&lt;= v_int_113_925_primed ahaub_1395)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Memory safety of array access at line <a href="#L115">line 115</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(bk,0,ahaub_1389) &and; 1000 - 1 = ahaub_1389 &and; dom(idx,0,ahaub_1376) &and; 1000 - 1 = ahaub_1376 &and; bounded(bk,0,n - 1,0,1000 - 1) &and; n &le; 1000 &and; 0 &le; n &and; dom(bk,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(val,0,1000 - 1) &and; i + 1 &le; 1000 &and; is_sparse_array(val,idx,bk,n) &and; idx[i] &lt; n &and; 0 &le; i &and; i &le; ahaub_1376 &and; 0 &le; idx[i] &and; idx[i] &le; ahaub_1389 &and; i = bk[idx[i]])  &#8866;   &exist; ahalb_1412  &exist; ahaub_1413 (dom(val,ahalb_1412,ahaub_1413) &and; ahalb_1412 &le; i &and; i &le; ahaub_1413)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun n () Int)<br/>
(declare-fun ahaub_1376 () Int)<br/>
(declare-fun ahaub_1389 () Int)<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom bk 0 ahaub_1389))<br/>
(assert (= (- 1000 1) ahaub_1389))<br/>
(assert (dom idx 0 ahaub_1376))<br/>
(assert (= (- 1000 1) ahaub_1376))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= 0 n))<br/>
(assert (dom bk 0 (- 1000 1)))<br/>
(assert (dom idx 0 (- 1000 1)))<br/>
(assert (dom val 0 (- 1000 1)))<br/>
(assert (&lt;= (+ i 1) 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1376))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (select idx i) ahaub_1389))<br/>
(assert (= i (select bk (select idx i))))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_1412 Int)) (exists ((ahaub_1413 Int)) (and (dom val ahalb_1412 ahaub_1413) (and (&lt;= ahalb_1412 i) (&lt;= i ahaub_1413)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1407 &and; 1000 - 1 = ahaub_1389 &and; 1000 - 1 = ahaub_1376 &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; i + 1 &le; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; idx[i] &lt; n &and; dom(idx,0,ahaub_1376) &and; i &le; ahaub_1376 &and; dom(bk,0,ahaub_1389) &and; 0 &le; idx[i] &and; idx[i] &le; ahaub_1389 &and; i = bk[idx[i]] &and; dom(val,0,ahaub_1407) &and; 0 &le; i &and; i &le; ahaub_1407 &and; v_int_115_931' = val[i])  &#8866;  value_at(val,idx,bk,n,i,v_int_115_931')
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1376 () Int)<br/>
(declare-fun ahaub_1389 () Int)<br/>
(declare-fun ahaub_1407 () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun v_int_115_931_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1407))<br/>
(assert (= (- 1000 1) ahaub_1389))<br/>
(assert (= (- 1000 1) ahaub_1376))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= (+ i 1) 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= i ahaub_1376))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (select idx i) ahaub_1389))<br/>
(assert (= i (select bk (select idx i))))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1407))<br/>
(assert (= v_int_115_931_primed (select val i)))<br/>
;Negation of Consequence<br/>
(assert (not (value_at val idx bk n i v_int_115_931_primed)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1389 &and; 1000 - 1 = ahaub_1376 &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; i + 1 &le; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; idx[i] &lt; n &and; dom(idx,0,ahaub_1376) &and; 0 &le; i &and; i &le; ahaub_1376 &and; dom(bk,0,ahaub_1389) &and; 0 &le; idx[i] &and; idx[i] &le; ahaub_1389 &and; bk[idx[i]] &ne; i)  &#8866;  value_at(val,idx,bk,n,i,0)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1376 () Int)<br/>
(declare-fun ahaub_1389 () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1389))<br/>
(assert (= (- 1000 1) ahaub_1376))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= (+ i 1) 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt; (select idx i) n))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1376))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= (select idx i) ahaub_1389))<br/>
(assert (not (= (select bk (select idx i)) i)))<br/>
;Negation of Consequence<br/>
(assert (not (value_at val idx bk n i 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1339 &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; i + 1 &le; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; 0 &le; idx[i] &and; dom(idx,0,ahaub_1339) &and; 0 &le; i &and; i &le; ahaub_1339 &and; n &le; idx[i])  &#8866;  value_at(val,idx,bk,n,i,0)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1339 () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1339))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= (+ i 1) 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt;= 0 (select idx i)))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1339))<br/>
(assert (&lt;= n (select idx i)))<br/>
;Negation of Consequence<br/>
(assert (not (value_at val idx bk n i 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1000 - 1 = ahaub_1339 &and; dom(val,0,1000 - 1) &and; dom(idx,0,1000 - 1) &and; dom(bk,0,1000 - 1) &and; 0 &le; n &and; n &le; 1000 &and; i + 1 &le; 1000 &and; is_sparse_array(val,idx,bk,n) &and; bounded(bk,0,n - 1,0,1000 - 1) &and; idx[i] &lt; 0 &and; dom(idx,0,ahaub_1339) &and; 0 &le; i &and; i &le; ahaub_1339 &and; idx[i] &lt; n)  &#8866;  value_at(val,idx,bk,n,i,0)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_1339 () Int)<br/>
(declare-fun val () (Array Int Int))<br/>
(declare-fun idx () (Array Int Int))<br/>
(declare-fun bk () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (= (- 1000 1) ahaub_1339))<br/>
(assert (&lt;= 0 n))<br/>
(assert (&lt;= n 1000))<br/>
(assert (&lt;= (+ i 1) 1000))<br/>
(assert (is_sparse_array val idx bk n))<br/>
(assert (bounded bk 0 (- n 1) 0 (- 1000 1)))<br/>
(assert (&lt; (select idx i) 0))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt;= i ahaub_1339))<br/>
(assert (&lt; (select idx i) n))<br/>
;Negation of Consequence<br/>
(assert (not (value_at val idx bk n i 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure create<ul><li class="Collapsed procdef">Internal representation
<ul>SparseArray create$int(  int sz)<br/>
static  EBase true &amp; 0&lt;=sz &amp; {FLOW,(39,39)=__norm}<br/>
         EAssume 7::<br/>
           EXISTS(flted_91_56,val,idx,<br/>
           bk: res::SparseArray&lt;val,idx,bk,flted_91_56&gt;@M &amp; flted_91_56=0 &amp; <br/>
           dom(val,0,1000 - 1) &amp; dom(idx,0,1000 - 1) &amp; dom(bk,0,1000 - 1) &amp; <br/>
           is_sparse_array(val,idx,bk,0) &amp; {FLOW,(39,39)=__norm})<br/>
dynamic  []<br/>
int[] values_57;<br/>
values_57 = {<br/>
int v_int_95_951;<br/>
v_int_95_951 = 1000;<br/>
aalloc___$int(v_int_95_951)<br/>
};<br/>
int[] index_58;<br/>
index_58 = {<br/>
int v_int_96_952;<br/>
v_int_96_952 = 1000;<br/>
aalloc___$int(v_int_96_952)<br/>
};<br/>
int[] back_59;<br/>
back_59 = {<br/>
int v_int_97_953;<br/>
v_int_97_953 = 1000;<br/>
aalloc___$int(v_int_97_953)<br/>
};<br/>
SparseArray v_SparseArray_98_955;<br/>
v_SparseArray_98_955 = {<br/>
int v_int_98_954;<br/>
v_int_98_954 = 0;<br/>
newSparseArray(values_57,index_58,back_59,v_int_98_954)<br/>
};<br/>
153::return v_SparseArray_98_955<br/>
<br/>
{(89,0),(0,-1)}<br/>
</ul></li><li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul><b>true</b>  &#8866;  0 = 0
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
;Relations declarations<br/>
;Axioms assertions<br/>
;Antecedent<br/>
(assert true)<br/>
;Negation of Consequence<br/>
(assert (not (= 0 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>dom(values_57',0,1000 - 1)  &#8866;  dom(values_57',0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun values_57_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom values_57_primed 0 (- 1000 1)))<br/>
;Negation of Consequence<br/>
(assert (not (dom values_57_primed 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>dom(index_58',0,1000 - 1)  &#8866;  dom(index_58',0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun index_58_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom index_58_primed 0 (- 1000 1)))<br/>
;Negation of Consequence<br/>
(assert (not (dom index_58_primed 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>dom(back_59',0,1000 - 1)  &#8866;  dom(back_59',0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun back_59_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom back_59_primed 0 (- 1000 1)))<br/>
;Negation of Consequence<br/>
(assert (not (dom back_59_primed 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(values_57',0,1000 - 1) &and; dom(index_58',0,1000 - 1) &and; dom(back_59',0,1000 - 1))  &#8866;  is_sparse_array(values_57',index_58',back_59',0)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun values_57_primed () (Array Int Int))<br/>
(declare-fun index_58_primed () (Array Int Int))<br/>
(declare-fun back_59_primed () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert true)<br/>
;Negation of Consequence<br/>
(assert (not (is_sparse_array values_57_primed index_58_primed back_59_primed 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure harness<ul><li class="Collapsed procdef">Internal representation
<ul>void harness$()<br/>
static  EBase true &amp; true &amp; {FLOW,(39,39)=__norm}<br/>
         EAssume 1::<br/>
           true &amp; true &amp; {FLOW,(39,39)=__norm}<br/>
dynamic  []<br/>
SparseArray a_60;<br/>
a_60 = {<br/>
int v_int_73_957;<br/>
v_int_73_957 = 10;<br/>
154::create$int(v_int_73_957)<br/>
};<br/>
SparseArray b_61;<br/>
b_61 = {<br/>
int v_int_74_958;<br/>
v_int_74_958 = 20;<br/>
155::create$int(v_int_74_958)<br/>
};<br/>
int a5_62;<br/>
a5_62 = {<br/>
int v_int_75_959;<br/>
v_int_75_959 = 5;<br/>
156::get$SparseArray~int(a_60,v_int_75_959)<br/>
};<br/>
int b7_63;<br/>
b7_63 = {<br/>
int v_int_76_960;<br/>
v_int_76_960 = 7;<br/>
157::get$SparseArray~int(b_61,v_int_76_960)<br/>
};<br/>
158::assert 158::: EBase true &amp; a5_62&apos;=0 &amp; b7_63&apos;=0 &amp; {FLOW,(39,39)=__norm} ;<br/>
{<br/>
int v_int_78_970;<br/>
v_int_78_970 = 5;<br/>
int v_int_78_969;<br/>
v_int_78_969 = 1;<br/>
159::setsa$SparseArray~int~int(a_60,v_int_78_970,v_int_78_969)<br/>
};<br/>
{<br/>
int v_int_79_972;<br/>
v_int_79_972 = 7;<br/>
int v_int_79_971;<br/>
v_int_79_971 = 2;<br/>
160::setsa$SparseArray~int~int(b_61,v_int_79_972,v_int_79_971)<br/>
};<br/>
a5_62 = {<br/>
int v_int_80_973;<br/>
v_int_80_973 = 5;<br/>
162::get$SparseArray~int(a_60,v_int_80_973)<br/>
};<br/>
b7_63 = {<br/>
int v_int_81_974;<br/>
v_int_81_974 = 7;<br/>
164::get$SparseArray~int(b_61,v_int_81_974)<br/>
};<br/>
165::assert 165::: EBase true &amp; a5_62&apos;=1 &amp; b7_63&apos;=2 &amp; {FLOW,(39,39)=__norm} ;<br/>
int a0_64;<br/>
a0_64 = {<br/>
int v_int_83_983;<br/>
v_int_83_983 = 0;<br/>
166::get$SparseArray~int(a_60,v_int_83_983)<br/>
};<br/>
int b0_65;<br/>
b0_65 = {<br/>
int v_int_84_984;<br/>
v_int_84_984 = 0;<br/>
167::get$SparseArray~int(b_61,v_int_84_984)<br/>
};<br/>
168::assert 168::: EBase true &amp; a0_64&apos;=0 &amp; b0_65&apos;=0 &amp; {FLOW,(39,39)=__norm} <br/>
<br/>
{(70,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pre">
Precondition of procedure call 154::create$int(v_int_73_957) at <a href="#L73">line 73</a> holds<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul><b>true</b>  &#8866;  0 &le; 10
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
;Relations declarations<br/>
;Axioms assertions<br/>
;Antecedent<br/>
(assert true)<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= 0 10)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Precondition of procedure call 155::create$int(v_int_74_958) at <a href="#L74">line 74</a> holds<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul><b>true</b>  &#8866;  0 &le; 20
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
;Relations declarations<br/>
;Axioms assertions<br/>
;Antecedent<br/>
(assert true)<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= 0 20)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Precondition of procedure call 156::get$SparseArray~int(a_60,v_int_75_959) at <a href="#L75">line 75</a> holds<ul></ul></li>
<li class="Collapsed pre">
Precondition of procedure call 157::get$SparseArray~int(b_61,v_int_76_960) at <a href="#L76">line 76</a> holds<ul></ul></li>
<li class="Collapsed assert">
Assertion at <a href="#L77">line 77</a> holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(is_sparse_array(val_1488,idx_1487,bk_1486,0) &and; dom(bk_1486,0,1000 - 1) &and; dom(idx_1487,0,1000 - 1) &and; dom(val_1488,0,1000 - 1) &and; value_at(val_1488,idx_1487,bk_1486,0,5,a5_62'))  &#8866;  a5_62' = 0
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun val_1488 () (Array Int Int))<br/>
(declare-fun idx_1487 () (Array Int Int))<br/>
(declare-fun bk_1486 () (Array Int Int))<br/>
(declare-fun a5_62_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (is_sparse_array val_1488 idx_1487 bk_1486 0))<br/>
(assert (value_at val_1488 idx_1487 bk_1486 0 5 a5_62_primed))<br/>
;Negation of Consequence<br/>
(assert (not (= a5_62_primed 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(is_sparse_array(val_1514,idx_1513,bk_1512,0) &and; dom(bk_1512,0,1000 - 1) &and; dom(idx_1513,0,1000 - 1) &and; dom(val_1514,0,1000 - 1) &and; value_at(val_1514,idx_1513,bk_1512,0,7,b7_63'))  &#8866;  b7_63' = 0
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun val_1514 () (Array Int Int))<br/>
(declare-fun idx_1513 () (Array Int Int))<br/>
(declare-fun bk_1512 () (Array Int Int))<br/>
(declare-fun b7_63_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (is_sparse_array val_1514 idx_1513 bk_1512 0))<br/>
(assert (value_at val_1514 idx_1513 bk_1512 0 7 b7_63_primed))<br/>
;Negation of Consequence<br/>
(assert (not (= b7_63_primed 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Precondition of procedure call 159::setsa$SparseArray~int~int(a_60,v_int_78_970,v_int_78_969) at <a href="#L78">line 78</a> holds<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(bk_1486,0,1000 - 1) &and; dom(idx_1487,0,1000 - 1) &and; dom(val_1488,0,1000 - 1) &and; is_sparse_array(val_1488,idx_1487,bk_1486,0) &and; value_at(val_1488,idx_1487,bk_1486,0,5,a5_62'))  &#8866;  dom(val_1488,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun idx_1487 () (Array Int Int))<br/>
(declare-fun bk_1486 () (Array Int Int))<br/>
(declare-fun a5_62_primed () Int)<br/>
(declare-fun val_1488 () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom bk_1486 0 (- 1000 1)))<br/>
(assert (dom idx_1487 0 (- 1000 1)))<br/>
(assert (dom val_1488 0 (- 1000 1)))<br/>
(assert (is_sparse_array val_1488 idx_1487 bk_1486 0))<br/>
(assert (value_at val_1488 idx_1487 bk_1486 0 5 a5_62_primed))<br/>
;Negation of Consequence<br/>
(assert (not (dom val_1488 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(bk_1486,0,1000 - 1) &and; dom(val_1488,0,1000 - 1) &and; dom(idx_1487,0,1000 - 1) &and; is_sparse_array(val_1488,idx_1487,bk_1486,0) &and; value_at(val_1488,idx_1487,bk_1486,0,5,a5_62'))  &#8866;  dom(idx_1487,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun val_1488 () (Array Int Int))<br/>
(declare-fun bk_1486 () (Array Int Int))<br/>
(declare-fun a5_62_primed () Int)<br/>
(declare-fun idx_1487 () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom bk_1486 0 (- 1000 1)))<br/>
(assert (dom val_1488 0 (- 1000 1)))<br/>
(assert (dom idx_1487 0 (- 1000 1)))<br/>
(assert (is_sparse_array val_1488 idx_1487 bk_1486 0))<br/>
(assert (value_at val_1488 idx_1487 bk_1486 0 5 a5_62_primed))<br/>
;Negation of Consequence<br/>
(assert (not (dom idx_1487 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(idx_1487,0,1000 - 1) &and; dom(val_1488,0,1000 - 1) &and; dom(bk_1486,0,1000 - 1) &and; is_sparse_array(val_1488,idx_1487,bk_1486,0) &and; value_at(val_1488,idx_1487,bk_1486,0,5,a5_62'))  &#8866;  dom(bk_1486,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun val_1488 () (Array Int Int))<br/>
(declare-fun idx_1487 () (Array Int Int))<br/>
(declare-fun a5_62_primed () Int)<br/>
(declare-fun bk_1486 () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom idx_1487 0 (- 1000 1)))<br/>
(assert (dom val_1488 0 (- 1000 1)))<br/>
(assert (dom bk_1486 0 (- 1000 1)))<br/>
(assert (is_sparse_array val_1488 idx_1487 bk_1486 0))<br/>
(assert (value_at val_1488 idx_1487 bk_1486 0 5 a5_62_primed))<br/>
;Negation of Consequence<br/>
(assert (not (dom bk_1486 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul><b>true</b>  &#8866;  0 &le; 0
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
;Relations declarations<br/>
;Axioms assertions<br/>
;Antecedent<br/>
(assert true)<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= 0 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul><b>true</b>  &#8866;  0 &le; 1000
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
;Relations declarations<br/>
;Axioms assertions<br/>
;Antecedent<br/>
(assert true)<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= 0 1000)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(idx_1487,0,1000 - 1) &and; dom(val_1488,0,1000 - 1) &and; dom(bk_1486,0,1000 - 1) &and; is_sparse_array(val_1488,idx_1487,bk_1486,0) &and; value_at(val_1488,idx_1487,bk_1486,0,5,a5_62'))  &#8866;  bounded(bk_1486,0,0 - 1,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun val_1488 () (Array Int Int))<br/>
(declare-fun idx_1487 () (Array Int Int))<br/>
(declare-fun a5_62_primed () Int)<br/>
(declare-fun bk_1486 () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (is_sparse_array val_1488 idx_1487 bk_1486 0))<br/>
(assert (value_at val_1488 idx_1487 bk_1486 0 5 a5_62_primed))<br/>
;Negation of Consequence<br/>
(assert (not (bounded bk_1486 0 (- 0 1) 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val_1488,0,1000 - 1) &and; dom(idx_1487,0,1000 - 1) &and; dom(bk_1486,0,1000 - 1) &and; is_sparse_array(val_1488,idx_1487,bk_1486,0) &and; value_at(val_1488,idx_1487,bk_1486,0,5,a5_62'))  &#8866;  is_sparse_array(val_1488,idx_1487,bk_1486,0)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun a5_62_primed () Int)<br/>
(declare-fun val_1488 () (Array Int Int))<br/>
(declare-fun idx_1487 () (Array Int Int))<br/>
(declare-fun bk_1486 () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (is_sparse_array val_1488 idx_1487 bk_1486 0))<br/>
(assert (value_at val_1488 idx_1487 bk_1486 0 5 a5_62_primed))<br/>
;Negation of Consequence<br/>
(assert (not (is_sparse_array val_1488 idx_1487 bk_1486 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul><b>true</b>  &#8866;  0 &le; 5
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
;Relations declarations<br/>
;Axioms assertions<br/>
;Antecedent<br/>
(assert true)<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= 0 5)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul><b>true</b>  &#8866;  5 &lt; 1000
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
;Relations declarations<br/>
;Axioms assertions<br/>
;Antecedent<br/>
(assert true)<br/>
;Negation of Consequence<br/>
(assert (not (&lt; 5 1000)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Precondition of procedure call 160::setsa$SparseArray~int~int(b_61,v_int_79_972,v_int_79_971) at <a href="#L79">line 79</a> holds<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(bk_1512,0,1000 - 1) &and; dom(idx_1513,0,1000 - 1) &and; dom(val_1514,0,1000 - 1) &and; is_sparse_array(val_1514,idx_1513,bk_1512,0) &and; value_at(val_1514,idx_1513,bk_1512,0,7,b7_63'))  &#8866;  dom(val_1514,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun idx_1513 () (Array Int Int))<br/>
(declare-fun bk_1512 () (Array Int Int))<br/>
(declare-fun b7_63_primed () Int)<br/>
(declare-fun val_1514 () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom bk_1512 0 (- 1000 1)))<br/>
(assert (dom idx_1513 0 (- 1000 1)))<br/>
(assert (dom val_1514 0 (- 1000 1)))<br/>
(assert (is_sparse_array val_1514 idx_1513 bk_1512 0))<br/>
(assert (value_at val_1514 idx_1513 bk_1512 0 7 b7_63_primed))<br/>
;Negation of Consequence<br/>
(assert (not (dom val_1514 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(bk_1512,0,1000 - 1) &and; dom(val_1514,0,1000 - 1) &and; dom(idx_1513,0,1000 - 1) &and; is_sparse_array(val_1514,idx_1513,bk_1512,0) &and; value_at(val_1514,idx_1513,bk_1512,0,7,b7_63'))  &#8866;  dom(idx_1513,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun val_1514 () (Array Int Int))<br/>
(declare-fun bk_1512 () (Array Int Int))<br/>
(declare-fun b7_63_primed () Int)<br/>
(declare-fun idx_1513 () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom bk_1512 0 (- 1000 1)))<br/>
(assert (dom val_1514 0 (- 1000 1)))<br/>
(assert (dom idx_1513 0 (- 1000 1)))<br/>
(assert (is_sparse_array val_1514 idx_1513 bk_1512 0))<br/>
(assert (value_at val_1514 idx_1513 bk_1512 0 7 b7_63_primed))<br/>
;Negation of Consequence<br/>
(assert (not (dom idx_1513 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(idx_1513,0,1000 - 1) &and; dom(val_1514,0,1000 - 1) &and; dom(bk_1512,0,1000 - 1) &and; is_sparse_array(val_1514,idx_1513,bk_1512,0) &and; value_at(val_1514,idx_1513,bk_1512,0,7,b7_63'))  &#8866;  dom(bk_1512,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun val_1514 () (Array Int Int))<br/>
(declare-fun idx_1513 () (Array Int Int))<br/>
(declare-fun b7_63_primed () Int)<br/>
(declare-fun bk_1512 () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom idx_1513 0 (- 1000 1)))<br/>
(assert (dom val_1514 0 (- 1000 1)))<br/>
(assert (dom bk_1512 0 (- 1000 1)))<br/>
(assert (is_sparse_array val_1514 idx_1513 bk_1512 0))<br/>
(assert (value_at val_1514 idx_1513 bk_1512 0 7 b7_63_primed))<br/>
;Negation of Consequence<br/>
(assert (not (dom bk_1512 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(idx_1513,0,1000 - 1) &and; dom(val_1514,0,1000 - 1) &and; dom(bk_1512,0,1000 - 1) &and; is_sparse_array(val_1514,idx_1513,bk_1512,0) &and; value_at(val_1514,idx_1513,bk_1512,0,7,b7_63'))  &#8866;  bounded(bk_1512,0,0 - 1,0,1000 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun val_1514 () (Array Int Int))<br/>
(declare-fun idx_1513 () (Array Int Int))<br/>
(declare-fun b7_63_primed () Int)<br/>
(declare-fun bk_1512 () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (is_sparse_array val_1514 idx_1513 bk_1512 0))<br/>
(assert (value_at val_1514 idx_1513 bk_1512 0 7 b7_63_primed))<br/>
;Negation of Consequence<br/>
(assert (not (bounded bk_1512 0 (- 0 1) 0 (- 1000 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val_1514,0,1000 - 1) &and; dom(idx_1513,0,1000 - 1) &and; dom(bk_1512,0,1000 - 1) &and; is_sparse_array(val_1514,idx_1513,bk_1512,0) &and; value_at(val_1514,idx_1513,bk_1512,0,7,b7_63'))  &#8866;  is_sparse_array(val_1514,idx_1513,bk_1512,0)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun b7_63_primed () Int)<br/>
(declare-fun val_1514 () (Array Int Int))<br/>
(declare-fun idx_1513 () (Array Int Int))<br/>
(declare-fun bk_1512 () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
;Antecedent<br/>
(assert (is_sparse_array val_1514 idx_1513 bk_1512 0))<br/>
(assert (value_at val_1514 idx_1513 bk_1512 0 7 b7_63_primed))<br/>
;Negation of Consequence<br/>
(assert (not (is_sparse_array val_1514 idx_1513 bk_1512 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul><b>true</b>  &#8866;  0 &le; 7
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
;Relations declarations<br/>
;Axioms assertions<br/>
;Antecedent<br/>
(assert true)<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= 0 7)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul><b>true</b>  &#8866;  7 &lt; 1000
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
;Relations declarations<br/>
;Axioms assertions<br/>
;Antecedent<br/>
(assert true)<br/>
;Negation of Consequence<br/>
(assert (not (&lt; 7 1000)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Precondition of procedure call 162::get$SparseArray~int(a_60,v_int_80_973) at <a href="#L80">line 80</a> holds<ul></ul></li>
<li class="Collapsed pre">
Precondition of procedure call 164::get$SparseArray~int(b_61,v_int_81_974) at <a href="#L81">line 81</a> holds<ul></ul></li>
<li class="Collapsed assert">
Assertion at <a href="#L82">line 82</a> holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val_1488,0,1000 - 1) &and; dom(idx_1487,0,1000 - 1) &and; dom(bk_1486,0,1000 - 1) &and; is_sparse_array(val_1488,idx_1487,bk_1486,0) &and; value_at(val_1488,idx_1487,bk_1486,0,5,a5_1611) &and; idexc(val_1488,idx_1487,bk_1486,0,valr_1572,idxr_1571,bkr_1570,nr_1569,5) &and; is_sparse_array(valr_1572,idxr_1571,bkr_1570,nr_1569) &and; value_at(valr_1572,idxr_1571,bkr_1570,nr_1569,5,1) &and; bounded(bkr_1570,0,nr_1569 - 1,0,1000 - 1) &and; ((is_modified(val_1488,idx_1487,bk_1486,0,5) &and; nr_1569 = 0) &or; ( &not; is_modified(val_1488,idx_1487,bk_1486,0,5) &and; nr_1569 = 1 + 0)) &and; nr_1569 &le; 1000 &and; 0 &le; nr_1569 &and; dom(bkr_1570,0,1000 - 1) &and; dom(idxr_1571,0,1000 - 1) &and; dom(valr_1572,0,1000 - 1) &and; value_at(valr_1572,idxr_1571,bkr_1570,nr_1569,5,a5_62'))  &#8866;  a5_62' = 1
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun a5_1611 () Int)<br/>
(declare-fun val_1488 () (Array Int Int))<br/>
(declare-fun idx_1487 () (Array Int Int))<br/>
(declare-fun bk_1486 () (Array Int Int))<br/>
(declare-fun valr_1572 () (Array Int Int))<br/>
(declare-fun idxr_1571 () (Array Int Int))<br/>
(declare-fun bkr_1570 () (Array Int Int))<br/>
(declare-fun nr_1569 () Int)<br/>
(declare-fun a5_62_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun idexc ((Array Int Int) (Array Int Int) (Array Int Int) Int (Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((i Int) (val2 (Array Int Int)) (idx2 (Array Int Int)) (bk2 (Array Int Int)) (n2 Int) (val1 (Array Int Int)) (idx1 (Array Int Int)) (bk1 (Array Int Int)) (n1 Int)) (= (idexc val1 idx1 bk1 n1 val2 idx2 bk2 n2 i) (forall ((k Int)) (or (= k i) (and (forall ((h Int)) (or (not (value_at val1 idx1 bk1 n1 k h)) (value_at val2 idx2 bk2 n2 k h))) (forall ((t Int)) (or (not (value_at val2 idx2 bk2 n2 k t)) (value_at val1 idx1 bk1 n1 k t)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (is_sparse_array val_1488 idx_1487 bk_1486 0))<br/>
(assert (value_at val_1488 idx_1487 bk_1486 0 5 a5_1611))<br/>
(assert (idexc val_1488 idx_1487 bk_1486 0 valr_1572 idxr_1571 bkr_1570 nr_1569 5))<br/>
(assert (is_sparse_array valr_1572 idxr_1571 bkr_1570 nr_1569))<br/>
(assert (value_at valr_1572 idxr_1571 bkr_1570 nr_1569 5 1))<br/>
(assert (bounded bkr_1570 0 (- nr_1569 1) 0 (- 1000 1)))<br/>
(assert (or (and (is_modified val_1488 idx_1487 bk_1486 0 5) (= nr_1569 0)) (and (not (is_modified val_1488 idx_1487 bk_1486 0 5)) (= nr_1569 (+ 1 0)))))<br/>
(assert (&lt;= nr_1569 1000))<br/>
(assert (&lt;= 0 nr_1569))<br/>
(assert (value_at valr_1572 idxr_1571 bkr_1570 nr_1569 5 a5_62_primed))<br/>
;Negation of Consequence<br/>
(assert (not (= a5_62_primed 1)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val_1514,0,1000 - 1) &and; dom(idx_1513,0,1000 - 1) &and; dom(bk_1512,0,1000 - 1) &and; is_sparse_array(val_1514,idx_1513,bk_1512,0) &and; value_at(val_1514,idx_1513,bk_1512,0,7,b7_1615) &and; idexc(val_1514,idx_1513,bk_1512,0,valr_1597,idxr_1596,bkr_1595,nr_1594,7) &and; is_sparse_array(valr_1597,idxr_1596,bkr_1595,nr_1594) &and; value_at(valr_1597,idxr_1596,bkr_1595,nr_1594,7,2) &and; bounded(bkr_1595,0,nr_1594 - 1,0,1000 - 1) &and; ((is_modified(val_1514,idx_1513,bk_1512,0,7) &and; nr_1594 = 0) &or; ( &not; is_modified(val_1514,idx_1513,bk_1512,0,7) &and; nr_1594 = 1 + 0)) &and; nr_1594 &le; 1000 &and; 0 &le; nr_1594 &and; dom(bkr_1595,0,1000 - 1) &and; dom(idxr_1596,0,1000 - 1) &and; dom(valr_1597,0,1000 - 1) &and; value_at(valr_1597,idxr_1596,bkr_1595,nr_1594,7,b7_63'))  &#8866;  b7_63' = 2
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun b7_1615 () Int)<br/>
(declare-fun val_1514 () (Array Int Int))<br/>
(declare-fun idx_1513 () (Array Int Int))<br/>
(declare-fun bk_1512 () (Array Int Int))<br/>
(declare-fun valr_1597 () (Array Int Int))<br/>
(declare-fun idxr_1596 () (Array Int Int))<br/>
(declare-fun bkr_1595 () (Array Int Int))<br/>
(declare-fun nr_1594 () Int)<br/>
(declare-fun b7_63_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun idexc ((Array Int Int) (Array Int Int) (Array Int Int) Int (Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((i Int) (val2 (Array Int Int)) (idx2 (Array Int Int)) (bk2 (Array Int Int)) (n2 Int) (val1 (Array Int Int)) (idx1 (Array Int Int)) (bk1 (Array Int Int)) (n1 Int)) (= (idexc val1 idx1 bk1 n1 val2 idx2 bk2 n2 i) (forall ((k Int)) (or (= k i) (and (forall ((h Int)) (or (not (value_at val1 idx1 bk1 n1 k h)) (value_at val2 idx2 bk2 n2 k h))) (forall ((t Int)) (or (not (value_at val2 idx2 bk2 n2 k t)) (value_at val1 idx1 bk1 n1 k t)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (is_sparse_array val_1514 idx_1513 bk_1512 0))<br/>
(assert (value_at val_1514 idx_1513 bk_1512 0 7 b7_1615))<br/>
(assert (idexc val_1514 idx_1513 bk_1512 0 valr_1597 idxr_1596 bkr_1595 nr_1594 7))<br/>
(assert (is_sparse_array valr_1597 idxr_1596 bkr_1595 nr_1594))<br/>
(assert (value_at valr_1597 idxr_1596 bkr_1595 nr_1594 7 2))<br/>
(assert (bounded bkr_1595 0 (- nr_1594 1) 0 (- 1000 1)))<br/>
(assert (or (and (is_modified val_1514 idx_1513 bk_1512 0 7) (= nr_1594 0)) (and (not (is_modified val_1514 idx_1513 bk_1512 0 7)) (= nr_1594 (+ 1 0)))))<br/>
(assert (&lt;= nr_1594 1000))<br/>
(assert (&lt;= 0 nr_1594))<br/>
(assert (value_at valr_1597 idxr_1596 bkr_1595 nr_1594 7 b7_63_primed))<br/>
;Negation of Consequence<br/>
(assert (not (= b7_63_primed 2)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Precondition of procedure call 166::get$SparseArray~int(a_60,v_int_83_983) at <a href="#L83">line 83</a> holds<ul></ul></li>
<li class="Collapsed pre">
Precondition of procedure call 167::get$SparseArray~int(b_61,v_int_84_984) at <a href="#L84">line 84</a> holds<ul></ul></li>
<li class="Collapsed assert">
Assertion at <a href="#L85">line 85</a> holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val_1488,0,1000 - 1) &and; dom(idx_1487,0,1000 - 1) &and; dom(bk_1486,0,1000 - 1) &and; is_sparse_array(val_1488,idx_1487,bk_1486,0) &and; value_at(val_1488,idx_1487,bk_1486,0,5,a5_1611) &and; value_at(valr_1572,idxr_1571,bkr_1570,nr_1569,5,a5_62') &and; idexc(val_1488,idx_1487,bk_1486,0,valr_1572,idxr_1571,bkr_1570,nr_1569,5) &and; is_sparse_array(valr_1572,idxr_1571,bkr_1570,nr_1569) &and; value_at(valr_1572,idxr_1571,bkr_1570,nr_1569,5,1) &and; bounded(bkr_1570,0,nr_1569 - 1,0,1000 - 1) &and; ((is_modified(val_1488,idx_1487,bk_1486,0,5) &and; nr_1569 = 0) &or; ( &not; is_modified(val_1488,idx_1487,bk_1486,0,5) &and; nr_1569 = 1 + 0)) &and; nr_1569 &le; 1000 &and; 0 &le; nr_1569 &and; dom(bkr_1570,0,1000 - 1) &and; dom(idxr_1571,0,1000 - 1) &and; dom(valr_1572,0,1000 - 1) &and; value_at(valr_1572,idxr_1571,bkr_1570,nr_1569,0,a0_64'))  &#8866;  a0_64' = 0
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun a5_1611 () Int)<br/>
(declare-fun a5_62_primed () Int)<br/>
(declare-fun val_1488 () (Array Int Int))<br/>
(declare-fun idx_1487 () (Array Int Int))<br/>
(declare-fun bk_1486 () (Array Int Int))<br/>
(declare-fun valr_1572 () (Array Int Int))<br/>
(declare-fun idxr_1571 () (Array Int Int))<br/>
(declare-fun bkr_1570 () (Array Int Int))<br/>
(declare-fun nr_1569 () Int)<br/>
(declare-fun a0_64_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun idexc ((Array Int Int) (Array Int Int) (Array Int Int) Int (Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((i Int) (val2 (Array Int Int)) (idx2 (Array Int Int)) (bk2 (Array Int Int)) (n2 Int) (val1 (Array Int Int)) (idx1 (Array Int Int)) (bk1 (Array Int Int)) (n1 Int)) (= (idexc val1 idx1 bk1 n1 val2 idx2 bk2 n2 i) (forall ((k Int)) (or (= k i) (and (forall ((h Int)) (or (not (value_at val1 idx1 bk1 n1 k h)) (value_at val2 idx2 bk2 n2 k h))) (forall ((t Int)) (or (not (value_at val2 idx2 bk2 n2 k t)) (value_at val1 idx1 bk1 n1 k t)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (is_sparse_array val_1488 idx_1487 bk_1486 0))<br/>
(assert (value_at val_1488 idx_1487 bk_1486 0 5 a5_1611))<br/>
(assert (value_at valr_1572 idxr_1571 bkr_1570 nr_1569 5 a5_62_primed))<br/>
(assert (idexc val_1488 idx_1487 bk_1486 0 valr_1572 idxr_1571 bkr_1570 nr_1569 5))<br/>
(assert (is_sparse_array valr_1572 idxr_1571 bkr_1570 nr_1569))<br/>
(assert (value_at valr_1572 idxr_1571 bkr_1570 nr_1569 5 1))<br/>
(assert (bounded bkr_1570 0 (- nr_1569 1) 0 (- 1000 1)))<br/>
(assert (or (and (is_modified val_1488 idx_1487 bk_1486 0 5) (= nr_1569 0)) (and (not (is_modified val_1488 idx_1487 bk_1486 0 5)) (= nr_1569 (+ 1 0)))))<br/>
(assert (&lt;= nr_1569 1000))<br/>
(assert (&lt;= 0 nr_1569))<br/>
(assert (value_at valr_1572 idxr_1571 bkr_1570 nr_1569 0 a0_64_primed))<br/>
;Negation of Consequence<br/>
(assert (not (= a0_64_primed 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(val_1514,0,1000 - 1) &and; dom(idx_1513,0,1000 - 1) &and; dom(bk_1512,0,1000 - 1) &and; is_sparse_array(val_1514,idx_1513,bk_1512,0) &and; value_at(val_1514,idx_1513,bk_1512,0,7,b7_1627) &and; value_at(valr_1597,idxr_1596,bkr_1595,nr_1594,7,b7_63') &and; idexc(val_1514,idx_1513,bk_1512,0,valr_1597,idxr_1596,bkr_1595,nr_1594,7) &and; is_sparse_array(valr_1597,idxr_1596,bkr_1595,nr_1594) &and; value_at(valr_1597,idxr_1596,bkr_1595,nr_1594,7,2) &and; bounded(bkr_1595,0,nr_1594 - 1,0,1000 - 1) &and; ((is_modified(val_1514,idx_1513,bk_1512,0,7) &and; nr_1594 = 0) &or; ( &not; is_modified(val_1514,idx_1513,bk_1512,0,7) &and; nr_1594 = 1 + 0)) &and; nr_1594 &le; 1000 &and; 0 &le; nr_1594 &and; dom(bkr_1595,0,1000 - 1) &and; dom(idxr_1596,0,1000 - 1) &and; dom(valr_1597,0,1000 - 1) &and; value_at(valr_1597,idxr_1596,bkr_1595,nr_1594,0,b0_65'))  &#8866;  b0_65' = 0
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun b7_1627 () Int)<br/>
(declare-fun b7_63_primed () Int)<br/>
(declare-fun val_1514 () (Array Int Int))<br/>
(declare-fun idx_1513 () (Array Int Int))<br/>
(declare-fun bk_1512 () (Array Int Int))<br/>
(declare-fun valr_1597 () (Array Int Int))<br/>
(declare-fun idxr_1596 () (Array Int Int))<br/>
(declare-fun bkr_1595 () (Array Int Int))<br/>
(declare-fun nr_1594 () Int)<br/>
(declare-fun b0_65_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun idexc ((Array Int Int) (Array Int Int) (Array Int Int) Int (Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun value_at ((Array Int Int) (Array Int Int) (Array Int Int) Int Int Int) Bool)<br/>
(declare-fun is_modified ((Array Int Int) (Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun is_sparse_array ((Array Int Int) (Array Int Int) (Array Int Int) Int) Bool)<br/>
(declare-fun bounded ((Array Int Int) Int Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((i Int) (val2 (Array Int Int)) (idx2 (Array Int Int)) (bk2 (Array Int Int)) (n2 Int) (val1 (Array Int Int)) (idx1 (Array Int Int)) (bk1 (Array Int Int)) (n1 Int)) (= (idexc val1 idx1 bk1 n1 val2 idx2 bk2 n2 i) (forall ((k Int)) (or (= k i) (and (forall ((h Int)) (or (not (value_at val1 idx1 bk1 n1 k h)) (value_at val2 idx2 bk2 n2 k h))) (forall ((t Int)) (or (not (value_at val2 idx2 bk2 n2 k t)) (value_at val1 idx1 bk1 n1 k t)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (n Int) (i Int) (v Int)) (= (value_at val idx bk n i v) (and (and (&lt;= 0 i) (&lt;= i (- 1000 1))) (or (and (is_modified val idx bk n i) (= v (select val i))) (and (not (is_modified val idx bk n i)) (= v 0)))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (bk (Array Int Int)) (idx (Array Int Int)) (i Int)) (= (is_modified val idx bk n i) (and (and (&lt;= 0 i) (&lt; i 1000)) (and (and (&lt;= 0 (select idx i)) (&lt; (select idx i) n)) (= (select bk (select idx i)) i))))))<br/>
(assert (forall ((val (Array Int Int)) (n Int) (idx (Array Int Int)) (bk (Array Int Int))) (= (is_sparse_array val idx bk n) (and (forall ((t Int)) (forall ((k Int)) (or (&lt; k 0) (or (&gt;= k n) (or (&lt; t 0) (or (&gt;= t n) (or (= t k) (not (= (select bk t) (select bk k)))))))))) (forall ((i Int)) (or (&lt; i 0) (or (&gt;= i n) (and (and (&lt;= 0 (select bk i)) (&lt; (select bk i) 1000)) (= (select idx (select bk i)) i)))))))))<br/>
(assert (forall ((val (Array Int Int)) (idx (Array Int Int)) (bk (Array Int Int)) (i Int)) (=&gt; (and (is_sparse_array val idx bk 1000) (and (&lt;= 0 i) (&lt; i 1000))) (is_modified val idx bk 1000 i))))<br/>
(assert (forall ((i Int) (j Int) (low Int) (a (Array Int Int)) (high Int)) (= (bounded a i j low high) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= low (select a k)) (&lt;= (select a k) high))))))))<br/>
;Antecedent<br/>
(assert (is_sparse_array val_1514 idx_1513 bk_1512 0))<br/>
(assert (value_at val_1514 idx_1513 bk_1512 0 7 b7_1627))<br/>
(assert (value_at valr_1597 idxr_1596 bkr_1595 nr_1594 7 b7_63_primed))<br/>
(assert (idexc val_1514 idx_1513 bk_1512 0 valr_1597 idxr_1596 bkr_1595 nr_1594 7))<br/>
(assert (is_sparse_array valr_1597 idxr_1596 bkr_1595 nr_1594))<br/>
(assert (value_at valr_1597 idxr_1596 bkr_1595 nr_1594 7 2))<br/>
(assert (bounded bkr_1595 0 (- nr_1594 1) 0 (- 1000 1)))<br/>
(assert (or (and (is_modified val_1514 idx_1513 bk_1512 0 7) (= nr_1594 0)) (and (not (is_modified val_1514 idx_1513 bk_1512 0 7)) (= nr_1594 (+ 1 0)))))<br/>
(assert (&lt;= nr_1594 1000))<br/>
(assert (&lt;= 0 nr_1594))<br/>
(assert (value_at valr_1597 idxr_1596 bkr_1595 nr_1594 0 b0_65_primed))<br/>
;Negation of Consequence<br/>
(assert (not (= b0_65_primed 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul></ul></li>
</ul></li>
<li class="Collapsed term">Termination of all procedures
<ul></ul></li>
</ul>
<script>
	SetupTreeView("ProofTree");
</script>
</body>
</html>