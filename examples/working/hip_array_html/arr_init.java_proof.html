<html>
<head>	<link rel="stylesheet" type="text/css" href="hipsleek.css" />	<script type="text/javascript" src="hipsleek.js"></script></head>
<body>
<h1>./hip/array/arr_init.java</h1>
<ul class="TreeView" id="ProofTree"><li class="Collapsed progsource">Source<ul><table><tr id="L1" class="OddSourceLine"><td>1</td><td><pre>/**</pre></td></tr>
<tr id="L2" class="EvenSourceLine"><td>2</td><td><pre> * Initialize an array with zeros.</pre></td></tr>
<tr id="L3" class="OddSourceLine"><td>3</td><td><pre> * </pre></td></tr>
<tr id="L4" class="EvenSourceLine"><td>4</td><td><pre> * @author Vu An Hoa</pre></td></tr>
<tr id="L5" class="OddSourceLine"><td>5</td><td><pre> */</pre></td></tr>
<tr id="L6" class="EvenSourceLine"><td>6</td><td><pre></pre></td></tr>
<tr id="L7" class="OddSourceLine"><td>7</td><td><pre>relation zeros(int[] a, int i, int j) == </pre></td></tr>
<tr id="L8" class="EvenSourceLine"><td>8</td><td><pre>	(i > j | forall ( k : (k < i | k > j | i <= k & k <= j & a[k] = 0))).</pre></td></tr>
<tr id="L9" class="OddSourceLine"><td>9</td><td><pre></pre></td></tr>
<tr id="L10" class="EvenSourceLine"><td>10</td><td><pre>/* a and b are identical except a[k] = 0 for all i <= k <= j */ </pre></td></tr>
<tr id="L11" class="OddSourceLine"><td>11</td><td><pre>relation identicalzeroes(int[] a, int[] b, int i, int j) == </pre></td></tr>
<tr id="L12" class="EvenSourceLine"><td>12</td><td><pre>	forall ( k : (k < i & a[k] = b[k] | k > j & a[k] = b[k] | i <= k & k <= j & a[k] = 0)).</pre></td></tr>
<tr id="L13" class="OddSourceLine"><td>13</td><td><pre></pre></td></tr>
<tr id="L14" class="EvenSourceLine"><td>14</td><td><pre>void zinit(ref int[] a, int i, int j) </pre></td></tr>
<tr id="L15" class="OddSourceLine"><td>15</td><td><pre>	requires [k,t] dom(a,k,t) & k <= i & j <= t</pre></td></tr>
<tr id="L16" class="EvenSourceLine"><td>16</td><td><pre>	ensures dom(a',k,t) & identicalzeroes(a',a,i,j);</pre></td></tr>
<tr id="L17" class="OddSourceLine"><td>17</td><td><pre>{</pre></td></tr>
<tr id="L18" class="EvenSourceLine"><td>18</td><td><pre>	if (i <= j)</pre></td></tr>
<tr id="L19" class="OddSourceLine"><td>19</td><td><pre>	{</pre></td></tr>
<tr id="L20" class="EvenSourceLine"><td>20</td><td><pre>/*		assume dom(a',k,t);*/</pre></td></tr>
<tr id="L21" class="OddSourceLine"><td>21</td><td><pre>		a[i] = 0;</pre></td></tr>
<tr id="L22" class="EvenSourceLine"><td>22</td><td><pre>/*		assume dom(a',i+1,j);*/</pre></td></tr>
<tr id="L23" class="OddSourceLine"><td>23</td><td><pre>		zinit(a,i+1,j);</pre></td></tr>
<tr id="L24" class="EvenSourceLine"><td>24</td><td><pre>	}</pre></td></tr>
<tr id="L25" class="OddSourceLine"><td>25</td><td><pre>}</pre></td></tr>
<tr id="L26" class="EvenSourceLine"><td>26</td><td><pre></pre></td></tr>
<tr id="L27" class="OddSourceLine"><td>27</td><td><pre>/*int main()</pre></td></tr>
<tr id="L28" class="EvenSourceLine"><td>28</td><td><pre>  requires true</pre></td></tr>
<tr id="L29" class="OddSourceLine"><td>29</td><td><pre>  ensures res = 1;</pre></td></tr>
<tr id="L30" class="EvenSourceLine"><td>30</td><td><pre>{</pre></td></tr>
<tr id="L31" class="OddSourceLine"><td>31</td><td><pre>  int[] a;</pre></td></tr>
<tr id="L32" class="EvenSourceLine"><td>32</td><td><pre>  assume a' = a & dom(a',0,5);</pre></td></tr>
<tr id="L33" class="OddSourceLine"><td>33</td><td><pre>  zinit(a,3,5);</pre></td></tr>
<tr id="L34" class="EvenSourceLine"><td>34</td><td><pre>  assert identicalzeroes(a',a,3,5);</pre></td></tr>
<tr id="L35" class="OddSourceLine"><td>35</td><td><pre>  return 1;</pre></td></tr>
<tr id="L36" class="EvenSourceLine"><td>36</td><td><pre>}*/</pre></td></tr>
</table></ul></li><li class="Collapsed proc">
Procedure zinit<ul><li class="Collapsed procdef">Internal representation
<ul>void zinit$int[]~int~int(  int[] a,  int i,  int j)<br/>
static  EBase exists (Expl)[k; t](Impl)[](ex)[]true &amp; dom(a,k,t) &amp; k&lt;=i &amp; j&lt;=t &amp;<br/>
       {FLOW,(31,31)=__norm}<br/>
         EAssume 1::ref [a]<br/>
           true &amp; dom(a&apos;,k,t) &amp; identicalzeroes(a&apos;,a,i,j) &amp;<br/>
           {FLOW,(31,31)=__norm}<br/>
dynamic  []<br/>
<br/>
ref a<br/>
boolean v_bool_18_619;<br/>
v_bool_18_619 = {<br/>
71::lte___$int~int(i,j)<br/>
};<br/>
67::if (v_bool_18_619) LABEL! 67,0: a = {<br/>
int v_int_21_616;<br/>
v_int_21_616 = 0;<br/>
68::update___1d$int~int[]~int(v_int_21_616,a,i)<br/>
};<br/>
{<br/>
int v_int_23_618;<br/>
v_int_23_618 = {<br/>
int v_int_23_617;<br/>
v_int_23_617 = 1;<br/>
70::add___$int~int(i,v_int_23_617)<br/>
};<br/>
69::zinit$int[]~int~int(a,v_int_23_618,j) rec<br/>
}<br/>
else LABEL! 67,1: <br/>
<br/>
<br/>
{(14,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pre">
Memory safety of array update at line <a href="#L21">line 21</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(j &le; ahaub &and; dom(a,ahalb,ahaub) &and; ahalb &le; i &and; i &le; j)  &#8866;   &exist; ahalb_641  &exist; ahaub_642 (dom(a,ahalb_641,ahaub_642) &and; ahalb_641 &le; i &and; i &le; ahaub_642)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun ahalb () Int)<br/>
(declare-fun j () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (&lt;= j ahaub))<br/>
(assert (dom a ahalb ahaub))<br/>
(assert (&lt;= ahalb i))<br/>
(assert (&lt;= i j))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_641 Int)) (exists ((ahaub_642 Int)) (and (dom a ahalb_641 ahaub_642) (and (&lt;= ahalb_641 i) (&lt;= i ahaub_642)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Precondition of procedure call 69::zinit$int[]~int~int(a,v_int_23_618,j) rec at <a href="#L23">line 23</a> holds<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(i &le; t_651 &and; k_650 &le; i &and; j &le; t_651 &and; i &le; j &and; dom(a,k_650,t_651) &and; dom(a',k_650,t_651) &and; update_array_1d(a,a',0,i) &and; v_int_23_618' = 1 + i)  &#8866;   &exist; k_658  &exist; t_659 (dom(a',k_658,t_659) &and; k_658 &le; v_int_23_618' &and; j &le; t_659)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun k_650 () Int)<br/>
(declare-fun t_651 () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun a_primed () (Array Int Int))<br/>
(declare-fun v_int_23_618_primed () Int)<br/>
(declare-fun j () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (&lt;= i t_651))<br/>
(assert (&lt;= k_650 i))<br/>
(assert (&lt;= j t_651))<br/>
(assert (&lt;= i j))<br/>
(assert (dom a k_650 t_651))<br/>
(assert (dom a_primed k_650 t_651))<br/>
(assert (= a_primed (store a i 0)))<br/>
(assert (= v_int_23_618_primed (+ 1 i)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((k_658 Int)) (exists ((t_659 Int)) (and (dom a_primed k_658 t_659) (and (&lt;= k_658 v_int_23_618_primed) (&lt;= j t_659)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(i &le; j &and; dom(a,k_650,t_651) &and; k_650 &le; i &and; i &le; t_651 &and; update_array_1d(a,a_661,0,i) &and; dom(a_661,k_650,t_651) &and; k_650 &le; 1 + i &and; j &le; t_651 &and; dom(a',k_650,t_651) &and; identicalzeroes(a',a_661,1 + i,j))  &#8866;  dom(a',k_650,t_651)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun a_661 () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun j () Int)<br/>
(declare-fun a_primed () (Array Int Int))<br/>
(declare-fun k_650 () Int)<br/>
(declare-fun t_651 () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun identicalzeroes ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((b (Array Int Int)) (i Int) (j Int) (a (Array Int Int))) (= (identicalzeroes a b i j) (forall ((k Int)) (or (and (&lt; k i) (= (select a k) (select b k))) (or (and (&gt; k j) (= (select a k) (select b k))) (and (&lt;= i k) (and (&lt;= k j) (= (select a k) 0)))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (&lt;= i j))<br/>
(assert (dom a k_650 t_651))<br/>
(assert (&lt;= k_650 i))<br/>
(assert (&lt;= i t_651))<br/>
(assert (= a_661 (store a i 0)))<br/>
(assert (dom a_661 k_650 t_651))<br/>
(assert (&lt;= k_650 (+ 1 i)))<br/>
(assert (&lt;= j t_651))<br/>
(assert (dom a_primed k_650 t_651))<br/>
(assert (identicalzeroes a_primed a_661 (+ 1 i) j))<br/>
;Negation of Consequence<br/>
(assert (not (dom a_primed k_650 t_651)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(a_661,k_650,t_651) &and; i &le; j &and; dom(a,k_650,t_651) &and; k_650 &le; i &and; i &le; t_651 &and; update_array_1d(a,a_661,0,i) &and; k_650 &le; 1 + i &and; j &le; t_651 &and; dom(a',k_650,t_651) &and; identicalzeroes(a',a_661,1 + i,j))  &#8866;  identicalzeroes(a',a,i,j)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun k_650 () Int)<br/>
(declare-fun t_651 () Int)<br/>
(declare-fun a_661 () (Array Int Int))<br/>
(declare-fun a_primed () (Array Int Int))<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun j () Int)<br/>
;Relations declarations<br/>
(declare-fun identicalzeroes ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((b (Array Int Int)) (i Int) (j Int) (a (Array Int Int))) (= (identicalzeroes a b i j) (forall ((k Int)) (or (and (&lt; k i) (= (select a k) (select b k))) (or (and (&gt; k j) (= (select a k) (select b k))) (and (&lt;= i k) (and (&lt;= k j) (= (select a k) 0)))))))))<br/>
(assert (forall ((b (Array Int Int)) (i Int) (j Int) (a (Array Int Int))) (= (identicalzeroes a b i j) (forall ((k Int)) (or (and (&lt; k i) (= (select a k) (select b k))) (or (and (&gt; k j) (= (select a k) (select b k))) (and (&lt;= i k) (and (&lt;= k j) (= (select a k) 0)))))))))<br/>
;Antecedent<br/>
(assert (&lt;= i j))<br/>
(assert (&lt;= k_650 i))<br/>
(assert (&lt;= i t_651))<br/>
(assert (= a_661 (store a i 0)))<br/>
(assert (&lt;= k_650 (+ 1 i)))<br/>
(assert (&lt;= j t_651))<br/>
(assert (identicalzeroes a_primed a_661 (+ 1 i) j))<br/>
;Negation of Consequence<br/>
(assert (not (identicalzeroes a_primed a i j)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(j &lt; i &and; dom(a,k,t) &and; k &le; i &and; j &le; t)  &#8866;  dom(a,k,t)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun i () Int)<br/>
(declare-fun j () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun k () Int)<br/>
(declare-fun t () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (&lt; j i))<br/>
(assert (dom a k t))<br/>
(assert (&lt;= k i))<br/>
(assert (&lt;= j t))<br/>
;Negation of Consequence<br/>
(assert (not (dom a k t)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(a,k,t) &and; k &le; i &and; j &le; t &and; j &lt; i)  &#8866;  identicalzeroes(a,a,i,j)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun k () Int)<br/>
(declare-fun t () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun j () Int)<br/>
;Relations declarations<br/>
(declare-fun identicalzeroes ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((b (Array Int Int)) (i Int) (j Int) (a (Array Int Int))) (= (identicalzeroes a b i j) (forall ((k Int)) (or (and (&lt; k i) (= (select a k) (select b k))) (or (and (&gt; k j) (= (select a k) (select b k))) (and (&lt;= i k) (and (&lt;= k j) (= (select a k) 0)))))))))<br/>
;Antecedent<br/>
(assert (&lt;= k i))<br/>
(assert (&lt;= j t))<br/>
(assert (&lt; j i))<br/>
;Negation of Consequence<br/>
(assert (not (identicalzeroes a a i j)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed term">Termination of all procedures
<ul></ul></li>
</ul>
<script>
	SetupTreeView("ProofTree");
</script>
</body>
</html>