<html>
<head>	<link rel="stylesheet" type="text/css" href="hipsleek.css" />	<script type="text/javascript" src="hipsleek.js"></script></head>
<body>
<h1>./hip/array/arr_sum.java</h1>
<ul class="TreeView" id="ProofTree"><li class="Collapsed progsource">Source<ul><table><tr id="L1" class="OddSourceLine"><td>1</td><td><pre>/**</pre></td></tr>
<tr id="L2" class="EvenSourceLine"><td>2</td><td><pre> * Find the sum of the elements of an array. This examples</pre></td></tr>
<tr id="L3" class="OddSourceLine"><td>3</td><td><pre> * show two ways of computing the sum and illustrates the use</pre></td></tr>
<tr id="L4" class="EvenSourceLine"><td>4</td><td><pre> * of induction.</pre></td></tr>
<tr id="L5" class="OddSourceLine"><td>5</td><td><pre> * </pre></td></tr>
<tr id="L6" class="EvenSourceLine"><td>6</td><td><pre> * @author Vu An Hoa</pre></td></tr>
<tr id="L7" class="OddSourceLine"><td>7</td><td><pre> */</pre></td></tr>
<tr id="L8" class="EvenSourceLine"><td>8</td><td><pre></pre></td></tr>
<tr id="L9" class="OddSourceLine"><td>9</td><td><pre>relation sumarray(int[] a, int i, int j, int s) == </pre></td></tr>
<tr id="L10" class="EvenSourceLine"><td>10</td><td><pre>	(i > j & s = 0 | i = j & s = a[i] | i < j & sumarray(a,i+1,j,s-a[i])).</pre></td></tr>
<tr id="L11" class="OddSourceLine"><td>11</td><td><pre></pre></td></tr>
<tr id="L12" class="EvenSourceLine"><td>12</td><td><pre>axiom i < j & sumarray(a,i,j-1,s-a[j]) ==> sumarray(a, i, j, s).</pre></td></tr>
<tr id="L13" class="OddSourceLine"><td>13</td><td><pre></pre></td></tr>
<tr id="L14" class="EvenSourceLine"><td>14</td><td><pre>//relation sumarray(int[] a, int i, int j, int s) == </pre></td></tr>
<tr id="L15" class="OddSourceLine"><td>15</td><td><pre>//	(i > j & s = 0 | i = j & s = a[i] | i < j & sumarray(a,i,j-1,s-a[j])).</pre></td></tr>
<tr id="L16" class="EvenSourceLine"><td>16</td><td><pre></pre></td></tr>
<tr id="L17" class="OddSourceLine"><td>17</td><td><pre>int sigmaright(int[] a, int i, int j) </pre></td></tr>
<tr id="L18" class="EvenSourceLine"><td>18</td><td><pre>	case {</pre></td></tr>
<tr id="L19" class="OddSourceLine"><td>19</td><td><pre>		i <= j -> variance (1) [j-i] </pre></td></tr>
<tr id="L20" class="EvenSourceLine"><td>20</td><td><pre>				requires dom(a,i,j) /* the allocation is from a[i..j] */</pre></td></tr>
<tr id="L21" class="OddSourceLine"><td>21</td><td><pre>				ensures sumarray(a,i,j,res);</pre></td></tr>
<tr id="L22" class="EvenSourceLine"><td>22</td><td><pre>		i > j -> variance (0)</pre></td></tr>
<tr id="L23" class="OddSourceLine"><td>23</td><td><pre>				requires true</pre></td></tr>
<tr id="L24" class="EvenSourceLine"><td>24</td><td><pre>			ensures sumarray(a,i,j,res);</pre></td></tr>
<tr id="L25" class="OddSourceLine"><td>25</td><td><pre>	}</pre></td></tr>
<tr id="L26" class="EvenSourceLine"><td>26</td><td><pre>{</pre></td></tr>
<tr id="L27" class="OddSourceLine"><td>27</td><td><pre>	if (i > j)</pre></td></tr>
<tr id="L28" class="EvenSourceLine"><td>28</td><td><pre>		return 0;</pre></td></tr>
<tr id="L29" class="OddSourceLine"><td>29</td><td><pre>	else </pre></td></tr>
<tr id="L30" class="EvenSourceLine"><td>30</td><td><pre>		return a[i] + sigmaright(a, i+1, j);</pre></td></tr>
<tr id="L31" class="OddSourceLine"><td>31</td><td><pre>}</pre></td></tr>
<tr id="L32" class="EvenSourceLine"><td>32</td><td><pre></pre></td></tr>
<tr id="L33" class="OddSourceLine"><td>33</td><td><pre>int sigmaleft(int[] a, int i, int j) </pre></td></tr>
<tr id="L34" class="EvenSourceLine"><td>34</td><td><pre>	requires [t,k] dom(a,t,k) & t <= i & j <= k</pre></td></tr>
<tr id="L35" class="OddSourceLine"><td>35</td><td><pre>	ensures sumarray(a,i,j,res);</pre></td></tr>
<tr id="L36" class="EvenSourceLine"><td>36</td><td><pre>{</pre></td></tr>
<tr id="L37" class="OddSourceLine"><td>37</td><td><pre>	if (i > j)</pre></td></tr>
<tr id="L38" class="EvenSourceLine"><td>38</td><td><pre>		return 0;</pre></td></tr>
<tr id="L39" class="OddSourceLine"><td>39</td><td><pre>	else </pre></td></tr>
<tr id="L40" class="EvenSourceLine"><td>40</td><td><pre>		return sigmaleft(a, i, j-1) + a[j];</pre></td></tr>
<tr id="L41" class="OddSourceLine"><td>41</td><td><pre>}</pre></td></tr>
<tr id="L42" class="EvenSourceLine"><td>42</td><td><pre></pre></td></tr>
<tr id="L43" class="OddSourceLine"><td>43</td><td><pre>void test()</pre></td></tr>
<tr id="L44" class="EvenSourceLine"><td>44</td><td><pre>	requires true</pre></td></tr>
<tr id="L45" class="OddSourceLine"><td>45</td><td><pre>	ensures true;</pre></td></tr>
<tr id="L46" class="EvenSourceLine"><td>46</td><td><pre>{</pre></td></tr>
<tr id="L47" class="OddSourceLine"><td>47</td><td><pre>	int x = 0;	</pre></td></tr>
<tr id="L48" class="EvenSourceLine"><td>48</td><td><pre>}</pre></td></tr>
</table></ul></li><li class="Collapsed proc">
Procedure test<ul><li class="Collapsed procdef">Internal representation
<ul>void test$()<br/>
static  EBase true &amp; true &amp; {FLOW,(32,32)=__norm}<br/>
         EAssume 10::<br/>
           true &amp; true &amp; {FLOW,(32,32)=__norm}<br/>
dynamic  []<br/>
int x_42;<br/>
x_42 = 0<br/>
<br/>
{(43,0),(0,-1)}<br/>
</ul></li><li class="Collapsed post">
Procedure post-condition holds
<ul></ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure sigmaleft<ul><li class="Collapsed procdef">Internal representation
<ul>int sigmaleft$int[]~int~int(  int[] a,  int i,  int j)<br/>
static  EBase exists (Expl)[t; k](Impl)[](ex)[]true &amp; dom(a,t,k) &amp; t&lt;=i &amp; j&lt;=k &amp;<br/>
       {FLOW,(32,32)=__norm}<br/>
         EAssume 6::<br/>
           true &amp; sumarray(a,i,j,res) &amp; {FLOW,(32,32)=__norm}<br/>
dynamic  []<br/>
boolean v_bool_37_624;<br/>
v_bool_37_624 = {<br/>
79::gt___$int~int(i,j)<br/>
};<br/>
73::if (v_bool_37_624) LABEL! 73,0: int v_int_38_618;<br/>
v_int_38_618 = 0;<br/>
78::return v_int_38_618<br/>
else LABEL! 73,1: int v_int_40_623;<br/>
v_int_40_623 = {<br/>
int v_int_40_622;<br/>
v_int_40_622 = {<br/>
int v_int_40_620;<br/>
v_int_40_620 = {<br/>
int v_int_40_619;<br/>
v_int_40_619 = 1;<br/>
77::minus___$int~int(j,v_int_40_619)<br/>
};<br/>
76::sigmaleft$int[]~int~int(a,i,v_int_40_620) rec<br/>
};<br/>
int v_int_40_621;<br/>
v_int_40_621 = {<br/>
array_get_elm_at___1d$int[]~int(a,j)<br/>
};<br/>
75::add___$int~int(v_int_40_622,v_int_40_621)<br/>
};<br/>
74::return v_int_40_623<br/>
<br/>
<br/>
{(33,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pre">
Precondition of procedure call 76::sigmaleft$int[]~int~int(a,i,v_int_40_620) rec at <a href="#L40">line 40</a> holds<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(j &le; k_665 &and; dom(a,t_664,k_665) &and; t_664 &le; i &and; i &le; j &and; v_int_40_620' + 1 = j)  &#8866;   &exist; t_672  &exist; k_673 (dom(a,t_672,k_673) &and; t_672 &le; i &and; v_int_40_620' &le; k_673)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun k_665 () Int)<br/>
(declare-fun t_664 () Int)<br/>
(declare-fun j () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun v_int_40_620_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (&lt;= j k_665))<br/>
(assert (dom a t_664 k_665))<br/>
(assert (&lt;= t_664 i))<br/>
(assert (&lt;= i j))<br/>
(assert (= (+ v_int_40_620_primed 1) j))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((t_672 Int)) (exists ((k_673 Int)) (and (dom a t_672 k_673) (and (&lt;= t_672 i) (&lt;= v_int_40_620_primed k_673)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Memory safety of array access at line <a href="#L40">line 40</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(v_int_40_680 &le; ahaub &and; ahalb &le; i &and; j &le; ahaub &and; i &le; j &and; v_int_40_680 + 1 = j &and; dom(a,ahalb,ahaub) &and; sumarray(a,i,v_int_40_680,v_int_40_622'))  &#8866;   &exist; ahalb_681  &exist; ahaub_682 (dom(a,ahalb_681,ahaub_682) &and; ahalb_681 &le; j &and; j &le; ahaub_682)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahalb () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun i () Int)<br/>
(declare-fun v_int_40_680 () Int)<br/>
(declare-fun v_int_40_622_primed () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun j () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun sumarray ((Array Int Int) Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((j Int) (s Int) (a (Array Int Int)) (i Int)) (= (sumarray a i j s) (or (and (&gt; i j) (= s 0)) (or (and (= i j) (= s (select a i))) (and (&lt; i j) (sumarray a (+ i 1) j (- s (select a i)))))))))<br/>
(assert (forall ((a (Array Int Int)) (i Int) (j Int) (s Int)) (=&gt; (and (&lt; i j) (sumarray a i (- j 1) (- s (select a j)))) (sumarray a i j s))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (&lt;= v_int_40_680 ahaub))<br/>
(assert (&lt;= ahalb i))<br/>
(assert (&lt;= j ahaub))<br/>
(assert (&lt;= i j))<br/>
(assert (= (+ v_int_40_680 1) j))<br/>
(assert (dom a ahalb ahaub))<br/>
(assert (sumarray a i v_int_40_680 v_int_40_622_primed))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_681 Int)) (exists ((ahaub_682 Int)) (and (dom a ahalb_681 ahaub_682) (and (&lt;= ahalb_681 j) (&lt;= j ahaub_682)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(a,t,k) &and; t &le; i &and; j &le; k &and; j &lt; i)  &#8866;  sumarray(a,i,j,0)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun t () Int)<br/>
(declare-fun k () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun j () Int)<br/>
;Relations declarations<br/>
(declare-fun sumarray ((Array Int Int) Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((j Int) (s Int) (a (Array Int Int)) (i Int)) (= (sumarray a i j s) (or (and (&gt; i j) (= s 0)) (or (and (= i j) (= s (select a i))) (and (&lt; i j) (sumarray a (+ i 1) j (- s (select a i)))))))))<br/>
(assert (forall ((a (Array Int Int)) (i Int) (j Int) (s Int)) (=&gt; (and (&lt; i j) (sumarray a i (- j 1) (- s (select a j)))) (sumarray a i j s))))<br/>
;Antecedent<br/>
(assert (&lt;= t i))<br/>
(assert (&lt;= j k))<br/>
(assert (&lt; j i))<br/>
;Negation of Consequence<br/>
(assert (not (sumarray a i j 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(v_int_40_680 &le; ahaub &and; i &le; j &and; v_int_40_680 + 1 = j &and; ahalb &le; i &and; sumarray(a,i,v_int_40_680,v_int_40_690) &and; dom(a,ahalb,ahaub) &and; ahalb &le; j &and; j &le; ahaub &and; v_int_40_623' = a[j] + v_int_40_690)  &#8866;  sumarray(a,i,j,v_int_40_623')
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_40_680 () Int)<br/>
(declare-fun ahalb () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun v_int_40_690 () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun j () Int)<br/>
(declare-fun v_int_40_623_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun sumarray ((Array Int Int) Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((j Int) (s Int) (a (Array Int Int)) (i Int)) (= (sumarray a i j s) (or (and (&gt; i j) (= s 0)) (or (and (= i j) (= s (select a i))) (and (&lt; i j) (sumarray a (+ i 1) j (- s (select a i)))))))))<br/>
(assert (forall ((a (Array Int Int)) (i Int) (j Int) (s Int)) (=&gt; (and (&lt; i j) (sumarray a i (- j 1) (- s (select a j)))) (sumarray a i j s))))<br/>
(assert (forall ((j Int) (s Int) (a (Array Int Int)) (i Int)) (= (sumarray a i j s) (or (and (&gt; i j) (= s 0)) (or (and (= i j) (= s (select a i))) (and (&lt; i j) (sumarray a (+ i 1) j (- s (select a i)))))))))<br/>
(assert (forall ((a (Array Int Int)) (i Int) (j Int) (s Int)) (=&gt; (and (&lt; i j) (sumarray a i (- j 1) (- s (select a j)))) (sumarray a i j s))))<br/>
;Antecedent<br/>
(assert (&lt;= v_int_40_680 ahaub))<br/>
(assert (&lt;= i j))<br/>
(assert (= (+ v_int_40_680 1) j))<br/>
(assert (&lt;= ahalb i))<br/>
(assert (sumarray a i v_int_40_680 v_int_40_690))<br/>
(assert (&lt;= ahalb j))<br/>
(assert (&lt;= j ahaub))<br/>
(assert (= v_int_40_623_primed (+ (select a j) v_int_40_690)))<br/>
;Negation of Consequence<br/>
(assert (not (sumarray a i j v_int_40_623_primed)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure sigmaright<ul><li class="Collapsed procdef">Internal representation
<ul>int sigmaright$int[]~int~int(  int[] a,  int i,  int j)<br/>
static  ECase case {i&lt;=j -&gt; EVariance (1) [  j - i@ 0 ] ==&gt; [  ]<br/>
                       EBase true &amp; dom(a,i,j) &amp; {FLOW,(32,32)=__norm}<br/>
                               EAssume 1::<br/>
                                 true &amp; sumarray(a,i,j,res) &amp;<br/>
                                 {FLOW,(32,32)=__norm}<br/>
             ;<br/>
        j&lt;i -&gt; EVariance (0) [ ] ==&gt; [  ]<br/>
                 EBase true &amp; true &amp; {FLOW,(32,32)=__norm}<br/>
                         EAssume 2::<br/>
                           true &amp; sumarray(a,i,j,res) &amp; {FLOW,(32,32)=__norm}<br/>
        }<br/>
dynamic  []<br/>
boolean v_bool_27_641;<br/>
v_bool_27_641 = {<br/>
86::gt___$int~int(i,j)<br/>
};<br/>
80::if (v_bool_27_641) LABEL! 80,0: int v_int_28_635;<br/>
v_int_28_635 = 0;<br/>
85::return v_int_28_635<br/>
else LABEL! 80,1: int v_int_30_640;<br/>
v_int_30_640 = {<br/>
int v_int_30_639;<br/>
v_int_30_639 = {<br/>
array_get_elm_at___1d$int[]~int(a,i)<br/>
};<br/>
int v_int_30_638;<br/>
v_int_30_638 = {<br/>
int v_int_30_637;<br/>
v_int_30_637 = {<br/>
int v_int_30_636;<br/>
v_int_30_636 = 1;<br/>
84::add___$int~int(i,v_int_30_636)<br/>
};<br/>
83::sigmaright$int[]~int~int(a,v_int_30_637,j) rec<br/>
};<br/>
82::add___$int~int(v_int_30_639,v_int_30_638)<br/>
};<br/>
81::return v_int_30_640<br/>
<br/>
<br/>
{(17,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pre">
Memory safety of array access at line <a href="#L30">line 30</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(a,ahalb,ahaub) &and; ahalb &le; ahaub)  &#8866;   &exist; ahalb_701  &exist; ahaub_702 (dom(a,ahalb_701,ahaub_702) &and; ahalb_701 &le; ahalb &and; ahalb &le; ahaub_702)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun ahalb () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom a ahalb ahaub))<br/>
(assert (&lt;= ahalb ahaub))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_701 Int)) (exists ((ahaub_702 Int)) (and (dom a ahalb_701 ahaub_702) (and (&lt;= ahalb_701 ahalb) (&lt;= ahalb ahaub_702)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Precondition of procedure call 83::sigmaright$int[]~int~int(a,v_int_30_637,j) rec at <a href="#L30">line 30</a> holds<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(ahalb &le; ahalb &and; dom(a,ahalb,ahaub) &and; ahalb &le; ahaub &and; v_int_30_639' = a[ahalb] &and; v_int_30_637' = 1 + ahalb &and; v_int_30_637' &le; ahaub)  &#8866;  dom(a,v_int_30_637',ahaub)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_30_639_primed () Int)<br/>
(declare-fun ahalb () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun v_int_30_637_primed () Int)<br/>
(declare-fun ahaub () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (&lt;= ahalb ahalb))<br/>
(assert (dom a ahalb ahaub))<br/>
(assert (&lt;= ahalb ahaub))<br/>
(assert (= v_int_30_639_primed (select a ahalb)))<br/>
(assert (= v_int_30_637_primed (+ 1 ahalb)))<br/>
(assert (&lt;= v_int_30_637_primed ahaub))<br/>
;Negation of Consequence<br/>
(assert (not (dom a v_int_30_637_primed ahaub)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(a,ahalb,ahaub) &and; ahalb &le; ahalb &and; ahalb &le; ahaub &and; sumarray(a,1 + ahalb,ahaub,v_int_30_726) &and; 1 + ahalb &le; ahaub &and; v_int_30_640' = v_int_30_726 + a[ahalb])  &#8866;  sumarray(a,ahalb,ahaub,v_int_30_640')
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_30_726 () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun ahalb () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun v_int_30_640_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun sumarray ((Array Int Int) Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((j Int) (s Int) (a (Array Int Int)) (i Int)) (= (sumarray a i j s) (or (and (&gt; i j) (= s 0)) (or (and (= i j) (= s (select a i))) (and (&lt; i j) (sumarray a (+ i 1) j (- s (select a i)))))))))<br/>
(assert (forall ((a (Array Int Int)) (i Int) (j Int) (s Int)) (=&gt; (and (&lt; i j) (sumarray a i (- j 1) (- s (select a j)))) (sumarray a i j s))))<br/>
(assert (forall ((j Int) (s Int) (a (Array Int Int)) (i Int)) (= (sumarray a i j s) (or (and (&gt; i j) (= s 0)) (or (and (= i j) (= s (select a i))) (and (&lt; i j) (sumarray a (+ i 1) j (- s (select a i)))))))))<br/>
(assert (forall ((a (Array Int Int)) (i Int) (j Int) (s Int)) (=&gt; (and (&lt; i j) (sumarray a i (- j 1) (- s (select a j)))) (sumarray a i j s))))<br/>
;Antecedent<br/>
(assert (&lt;= ahalb ahalb))<br/>
(assert (&lt;= ahalb ahaub))<br/>
(assert (sumarray a (+ 1 ahalb) ahaub v_int_30_726))<br/>
(assert (&lt;= (+ 1 ahalb) ahaub))<br/>
(assert (= v_int_30_640_primed (+ v_int_30_726 (select a ahalb))))<br/>
;Negation of Consequence<br/>
(assert (not (sumarray a ahalb ahaub v_int_30_640_primed)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(a,ahalb,ahaub) &and; ahalb &le; ahalb &and; ahalb &le; ahaub &and; sumarray(a,1 + ahalb,ahaub,v_int_30_727) &and; ahaub &lt; 1 + ahalb &and; v_int_30_640' = v_int_30_727 + a[ahalb])  &#8866;  sumarray(a,ahalb,ahaub,v_int_30_640')
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_30_727 () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun ahalb () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun v_int_30_640_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun sumarray ((Array Int Int) Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((j Int) (s Int) (a (Array Int Int)) (i Int)) (= (sumarray a i j s) (or (and (&gt; i j) (= s 0)) (or (and (= i j) (= s (select a i))) (and (&lt; i j) (sumarray a (+ i 1) j (- s (select a i)))))))))<br/>
(assert (forall ((a (Array Int Int)) (i Int) (j Int) (s Int)) (=&gt; (and (&lt; i j) (sumarray a i (- j 1) (- s (select a j)))) (sumarray a i j s))))<br/>
(assert (forall ((j Int) (s Int) (a (Array Int Int)) (i Int)) (= (sumarray a i j s) (or (and (&gt; i j) (= s 0)) (or (and (= i j) (= s (select a i))) (and (&lt; i j) (sumarray a (+ i 1) j (- s (select a i)))))))))<br/>
(assert (forall ((a (Array Int Int)) (i Int) (j Int) (s Int)) (=&gt; (and (&lt; i j) (sumarray a i (- j 1) (- s (select a j)))) (sumarray a i j s))))<br/>
;Antecedent<br/>
(assert (&lt;= ahalb ahalb))<br/>
(assert (&lt;= ahalb ahaub))<br/>
(assert (sumarray a (+ 1 ahalb) ahaub v_int_30_727))<br/>
(assert (&lt; ahaub (+ 1 ahalb)))<br/>
(assert (= v_int_30_640_primed (+ v_int_30_727 (select a ahalb))))<br/>
;Negation of Consequence<br/>
(assert (not (sumarray a ahalb ahaub v_int_30_640_primed)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Memory safety of array access at line <a href="#L30">line 30</a><ul></ul></li>
<li class="Collapsed pre">
Precondition of procedure call 83::sigmaright$int[]~int~int(a,v_int_30_637,j) rec at <a href="#L30">line 30</a> holds<ul></ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>j &lt; i  &#8866;  sumarray(a,i,j,0)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun j () Int)<br/>
;Relations declarations<br/>
(declare-fun sumarray ((Array Int Int) Int Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((j Int) (s Int) (a (Array Int Int)) (i Int)) (= (sumarray a i j s) (or (and (&gt; i j) (= s 0)) (or (and (= i j) (= s (select a i))) (and (&lt; i j) (sumarray a (+ i 1) j (- s (select a i)))))))))<br/>
(assert (forall ((a (Array Int Int)) (i Int) (j Int) (s Int)) (=&gt; (and (&lt; i j) (sumarray a i (- j 1) (- s (select a j)))) (sumarray a i j s))))<br/>
;Antecedent<br/>
(assert (&lt; j i))<br/>
;Negation of Consequence<br/>
(assert (not (sumarray a i j 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed term">Termination of all procedures
<ul></ul></li>
</ul>
<script>
	SetupTreeView("ProofTree");
</script>
</body>
</html>