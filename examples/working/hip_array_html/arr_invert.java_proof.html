<html>
<head>	<link rel="stylesheet" type="text/css" href="hipsleek.css" />	<script type="text/javascript" src="hipsleek.js"></script></head>
<body>
<h1>./hip/array/arr_invert.java</h1>
<ul class="TreeView" id="ProofTree"><li class="Collapsed progsource">Source<ul><table><tr id="L1" class="OddSourceLine"><td>1</td><td><pre>/**</pre></td></tr>
<tr id="L2" class="EvenSourceLine"><td>2</td><td><pre> * Problem 2 in VSComp 2010: Inverting an Injection</pre></td></tr>
<tr id="L3" class="OddSourceLine"><td>3</td><td><pre> * @author Vu An Hoa</pre></td></tr>
<tr id="L4" class="EvenSourceLine"><td>4</td><td><pre> * @date 24/06/2011</pre></td></tr>
<tr id="L5" class="OddSourceLine"><td>5</td><td><pre> **/</pre></td></tr>
<tr id="L6" class="EvenSourceLine"><td>6</td><td><pre></pre></td></tr>
<tr id="L7" class="OddSourceLine"><td>7</td><td><pre>relation dom(int[] a, int i, int j) == true.</pre></td></tr>
<tr id="L8" class="EvenSourceLine"><td>8</td><td><pre></pre></td></tr>
<tr id="L9" class="OddSourceLine"><td>9</td><td><pre>// b[-infty..infty] is a left inverse of a|{i..j}</pre></td></tr>
<tr id="L10" class="EvenSourceLine"><td>10</td><td><pre>// i.e. b \circ a (x) = x for all x in {i..j}</pre></td></tr>
<tr id="L11" class="OddSourceLine"><td>11</td><td><pre>relation IsLeftInverse(int[] a, int[] b, int i, int j) ==</pre></td></tr>
<tr id="L12" class="EvenSourceLine"><td>12</td><td><pre>	forall(k : (k < i | k > j | b[a[k]] = k)).</pre></td></tr>
<tr id="L13" class="OddSourceLine"><td>13</td><td><pre></pre></td></tr>
<tr id="L14" class="EvenSourceLine"><td>14</td><td><pre>relation IsInjective(int[] a, int i, int j) ==</pre></td></tr>
<tr id="L15" class="OddSourceLine"><td>15</td><td><pre>	forall(x,y : (x < i | x > j | y < i | y > j | x = y | a[x] != a[y])).</pre></td></tr>
<tr id="L16" class="EvenSourceLine"><td>16</td><td><pre></pre></td></tr>
<tr id="L17" class="OddSourceLine"><td>17</td><td><pre>// a[i..j] is a permutation of [l..h]</pre></td></tr>
<tr id="L18" class="EvenSourceLine"><td>18</td><td><pre>relation Permute(int[] a, int i, int j, int l, int h) ==</pre></td></tr>
<tr id="L19" class="OddSourceLine"><td>19</td><td><pre>	forall(k : (k < i | k > j | l <= a[k] & a[k] <= h)) & // range of values</pre></td></tr>
<tr id="L20" class="EvenSourceLine"><td>20</td><td><pre>	forall(u : u < l | u > h | ex(v: i <= v <= j & a[v] = u)) & // surjectivity</pre></td></tr>
<tr id="L21" class="OddSourceLine"><td>21</td><td><pre>	IsInjective(a,i,j). // injectivity</pre></td></tr>
<tr id="L22" class="EvenSourceLine"><td>22</td><td><pre></pre></td></tr>
<tr id="L23" class="OddSourceLine"><td>23</td><td><pre></pre></td></tr>
<tr id="L24" class="EvenSourceLine"><td>24</td><td><pre>// Construct inverse of a|{0..n-1} provided </pre></td></tr>
<tr id="L25" class="OddSourceLine"><td>25</td><td><pre>// (i)	range(a) = {0..n-1}</pre></td></tr>
<tr id="L26" class="EvenSourceLine"><td>26</td><td><pre>// (ii)	a is injective</pre></td></tr>
<tr id="L27" class="OddSourceLine"><td>27</td><td><pre>// i.e. a|{0..n-1} is a permutation of (0,1,...,n-1)</pre></td></tr>
<tr id="L28" class="EvenSourceLine"><td>28</td><td><pre>void Invert(int[] a, ref int[] b, int n)</pre></td></tr>
<tr id="L29" class="OddSourceLine"><td>29</td><td><pre>	requires dom(a,0,n-1) & dom(b,0,n-1) & Permute(a,0,n-1,0,n-1)</pre></td></tr>
<tr id="L30" class="EvenSourceLine"><td>30</td><td><pre>	ensures IsLeftInverse(a,b',0,n-1) & IsInjective(b',0,n-1); </pre></td></tr>
<tr id="L31" class="OddSourceLine"><td>31</td><td><pre>{</pre></td></tr>
<tr id="L32" class="EvenSourceLine"><td>32</td><td><pre>	// for(int i = 0; i < n; i++) b[a[i]] = i // equivalent iterative code</pre></td></tr>
<tr id="L33" class="OddSourceLine"><td>33</td><td><pre>	InvertHelper(a,b,n,0);</pre></td></tr>
<tr id="L34" class="EvenSourceLine"><td>34</td><td><pre>}</pre></td></tr>
<tr id="L35" class="OddSourceLine"><td>35</td><td><pre></pre></td></tr>
<tr id="L36" class="EvenSourceLine"><td>36</td><td><pre>// Tail recursive expansion of the loop</pre></td></tr>
<tr id="L37" class="OddSourceLine"><td>37</td><td><pre>void InvertHelper(int[] a, ref int[] b, int n, int i)</pre></td></tr>
<tr id="L38" class="EvenSourceLine"><td>38</td><td><pre>	requires 	dom(a,0,n-1) & dom(b,0,n-1)</pre></td></tr>
<tr id="L39" class="OddSourceLine"><td>39</td><td><pre>			 	& Permute(a,0,n-1,0,n-1)</pre></td></tr>
<tr id="L40" class="EvenSourceLine"><td>40</td><td><pre>				& IsLeftInverse(a,b,0,i-1)</pre></td></tr>
<tr id="L41" class="OddSourceLine"><td>41</td><td><pre>				& 0 <= i</pre></td></tr>
<tr id="L42" class="EvenSourceLine"><td>42</td><td><pre>	ensures 	IsLeftInverse(a,b',0,n-1);</pre></td></tr>
<tr id="L43" class="OddSourceLine"><td>43</td><td><pre>{</pre></td></tr>
<tr id="L44" class="EvenSourceLine"><td>44</td><td><pre>	if (i < n) {</pre></td></tr>
<tr id="L45" class="OddSourceLine"><td>45</td><td><pre>//		assert 0 <= a[i] <= n-1;</pre></td></tr>
<tr id="L46" class="EvenSourceLine"><td>46</td><td><pre>		b[a[i]] = i;</pre></td></tr>
<tr id="L47" class="OddSourceLine"><td>47</td><td><pre>//		assert IsLeftInverse(a,b',0,i);</pre></td></tr>
<tr id="L48" class="EvenSourceLine"><td>48</td><td><pre>		InvertHelper(a,b,n,i+1);</pre></td></tr>
<tr id="L49" class="OddSourceLine"><td>49</td><td><pre>	}</pre></td></tr>
<tr id="L50" class="EvenSourceLine"><td>50</td><td><pre>}</pre></td></tr>
</table></ul></li><li class="Collapsed proc">
Procedure InvertHelper<ul><li class="Collapsed procdef">Internal representation
<ul>void InvertHelper$int[]~int[]~int~int(  int[] a,  int[] b,  int n,  int i)<br/>
static  EBase true &amp; dom(a,0,n - 1) &amp; dom(b,0,n - 1) &amp; Permute(a,0,n - 1,0,n - 1) &amp; <br/>
       IsLeftInverse(a,b,0,i - 1) &amp; 0&lt;=i &amp; {FLOW,(32,32)=__norm}<br/>
         EAssume 2::ref [b]<br/>
           true &amp; IsLeftInverse(a,b&apos;,0,n - 1) &amp; {FLOW,(32,32)=__norm}<br/>
dynamic  []<br/>
<br/>
ref b<br/>
boolean v_bool_44_641;<br/>
v_bool_44_641 = {<br/>
72::lt___$int~int(i,n)<br/>
};<br/>
68::if (v_bool_44_641) LABEL! 68,0: b = {<br/>
int v_int_46_638;<br/>
v_int_46_638 = {<br/>
array_get_elm_at___1d$int[]~int(a,i)<br/>
};<br/>
69::update___1d$int~int[]~int(i,b,v_int_46_638)<br/>
};<br/>
{<br/>
int v_int_48_640;<br/>
v_int_48_640 = {<br/>
int v_int_48_639;<br/>
v_int_48_639 = 1;<br/>
71::add___$int~int(i,v_int_48_639)<br/>
};<br/>
70::InvertHelper$int[]~int[]~int~int(a,b,n,v_int_48_640) rec<br/>
}<br/>
else LABEL! 68,1: <br/>
<br/>
<br/>
{(37,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pre">
Memory safety of array access at line <a href="#L46">line 46</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(n - 1 = ahaub &and; dom(b,0,n - 1) &and; dom(a,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1) &and; IsLeftInverse(a,b,0,i - 1) &and; 0 &le; i &and; i &lt; n)  &#8866;   &exist; ahalb_677  &exist; ahaub_678 (dom(a,ahalb_677,ahaub_678) &and; ahalb_677 &le; i &and; i &le; ahaub_678)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun b () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun IsLeftInverse ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- n 1) ahaub))<br/>
(assert (dom b 0 (- n 1)))<br/>
(assert (dom a 0 (- n 1)))<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
(assert (IsLeftInverse a b 0 (- i 1)))<br/>
(assert (&lt;= 0 i))<br/>
(assert (&lt; i n))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_677 Int)) (exists ((ahaub_678 Int)) (and (dom a ahalb_677 ahaub_678) (and (&lt;= ahalb_677 i) (&lt;= i ahaub_678)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>(error &quot;line 13 column 47: invalid declaration, function &apos;dom&apos; (whith the given signature) already declared&quot;)<br/>
unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Memory safety of array update at line <a href="#L46">line 46</a><ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(n - 1 = ahaub_681 &and; i &le; ahaub &and; 0 &le; i &and; dom(a,0,ahaub) &and; n - 1 = ahaub &and; i &lt; n &and; Permute(a,0,n - 1,0,n - 1) &and; dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; IsLeftInverse(a,b,0,i - 1) &and; v_int_46_638' = a[i])  &#8866;   &exist; ahalb_688  &exist; ahaub_689 (dom(b,ahalb_688,ahaub_689) &and; ahalb_688 &le; v_int_46_638' &and; v_int_46_638' &le; ahaub_689)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub_681 () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun b () (Array Int Int))<br/>
(declare-fun v_int_46_638_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun IsLeftInverse ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= (- n 1) ahaub_681))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom a 0 ahaub))<br/>
(assert (= (- n 1) ahaub))<br/>
(assert (&lt; i n))<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
(assert (dom a 0 (- n 1)))<br/>
(assert (dom b 0 (- n 1)))<br/>
(assert (IsLeftInverse a b 0 (- i 1)))<br/>
(assert (= v_int_46_638_primed (select a i)))<br/>
;Negation of Consequence<br/>
(assert (not (exists ((ahalb_688 Int)) (exists ((ahaub_689 Int)) (and (dom b ahalb_688 ahaub_689) (and (&lt;= ahalb_688 v_int_46_638_primed) (&lt;= v_int_46_638_primed ahaub_689)))))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>(error &quot;line 15 column 47: invalid declaration, function &apos;dom&apos; (whith the given signature) already declared&quot;)<br/>
unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed pre">
Precondition of procedure call 70::InvertHelper$int[]~int[]~int~int(a,b,n,v_int_48_640) rec at <a href="#L48">line 48</a> holds<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(v_int_48_640' = 1 + i &and; dom(b',0,ahaub_681) &and; dom(b,0,ahaub_681) &and; i &le; ahaub &and; 0 &le; i &and; dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1) &and; IsLeftInverse(a,b,0,i - 1) &and; i &lt; n &and; n - 1 = ahaub &and; dom(a,0,ahaub) &and; n - 1 = ahaub_681 &and; 0 &le; a[i] &and; a[i] &le; ahaub_681 &and; update_array_1d(b,b',i,a[i]))  &#8866;  dom(a,0,n - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_48_640_primed () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun ahaub_681 () Int)<br/>
(declare-fun b () (Array Int Int))<br/>
(declare-fun b_primed () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun IsLeftInverse ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= v_int_48_640_primed (+ 1 i)))<br/>
(assert (dom b_primed 0 ahaub_681))<br/>
(assert (dom b 0 ahaub_681))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom a 0 (- n 1)))<br/>
(assert (dom b 0 (- n 1)))<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
(assert (IsLeftInverse a b 0 (- i 1)))<br/>
(assert (&lt; i n))<br/>
(assert (= (- n 1) ahaub))<br/>
(assert (dom a 0 ahaub))<br/>
(assert (= (- n 1) ahaub_681))<br/>
(assert (&lt;= 0 (select a i)))<br/>
(assert (&lt;= (select a i) ahaub_681))<br/>
(assert (= b_primed (store b (select a i) i)))<br/>
;Negation of Consequence<br/>
(assert (not (dom a 0 (- n 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>(error &quot;line 16 column 47: invalid declaration, function &apos;dom&apos; (whith the given signature) already declared&quot;)<br/>
unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(v_int_48_640' = 1 + i &and; a[i] &le; ahaub_681 &and; 0 &le; a[i] &and; i &le; ahaub &and; 0 &le; i &and; dom(a,0,ahaub) &and; dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1) &and; IsLeftInverse(a,b,0,i - 1) &and; i &lt; n &and; n - 1 = ahaub &and; n - 1 = ahaub_681 &and; dom(b,0,ahaub_681) &and; dom(b',0,ahaub_681) &and; update_array_1d(b,b',i,a[i]))  &#8866;  dom(b',0,n - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_48_640_primed () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun ahaub_681 () Int)<br/>
(declare-fun b () (Array Int Int))<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun b_primed () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun IsLeftInverse ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (= v_int_48_640_primed (+ 1 i)))<br/>
(assert (&lt;= (select a i) ahaub_681))<br/>
(assert (&lt;= 0 (select a i)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt;= 0 i))<br/>
(assert (dom a 0 ahaub))<br/>
(assert (dom a 0 (- n 1)))<br/>
(assert (dom b 0 (- n 1)))<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
(assert (IsLeftInverse a b 0 (- i 1)))<br/>
(assert (&lt; i n))<br/>
(assert (= (- n 1) ahaub))<br/>
(assert (= (- n 1) ahaub_681))<br/>
(assert (dom b 0 ahaub_681))<br/>
(assert (dom b_primed 0 ahaub_681))<br/>
(assert (= b_primed (store b (select a i) i)))<br/>
;Negation of Consequence<br/>
(assert (not (dom b_primed 0 (- n 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>(error &quot;line 16 column 47: invalid declaration, function &apos;dom&apos; (whith the given signature) already declared&quot;)<br/>
unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(v_int_48_640' = 1 + i &and; dom(b',0,ahaub_681) &and; dom(b,0,ahaub_681) &and; i &le; ahaub &and; 0 &le; i &and; dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1) &and; IsLeftInverse(a,b,0,i - 1) &and; i &lt; n &and; n - 1 = ahaub &and; dom(a,0,ahaub) &and; n - 1 = ahaub_681 &and; 0 &le; a[i] &and; a[i] &le; ahaub_681 &and; update_array_1d(b,b',i,a[i]))  &#8866;  Permute(a,0,n - 1,0,n - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun v_int_48_640_primed () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun ahaub_681 () Int)<br/>
(declare-fun b () (Array Int Int))<br/>
(declare-fun b_primed () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun IsLeftInverse ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
;Antecedent<br/>
(assert (= v_int_48_640_primed (+ 1 i)))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt;= 0 i))<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
(assert (IsLeftInverse a b 0 (- i 1)))<br/>
(assert (&lt; i n))<br/>
(assert (= (- n 1) ahaub))<br/>
(assert (= (- n 1) ahaub_681))<br/>
(assert (&lt;= 0 (select a i)))<br/>
(assert (&lt;= (select a i) ahaub_681))<br/>
(assert (= b_primed (store b (select a i) i)))<br/>
;Negation of Consequence<br/>
(assert (not (Permute a 0 (- n 1) 0 (- n 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(n - 1 = ahaub_681 &and; i &le; ahaub &and; 0 &le; i &and; n - 1 = ahaub &and; i &lt; n &and; dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1) &and; IsLeftInverse(a,b,0,i - 1) &and; dom(a,0,ahaub) &and; dom(b,0,ahaub_681) &and; 0 &le; a[i] &and; a[i] &le; ahaub_681 &and; dom(b',0,ahaub_681) &and; update_array_1d(b,b',i,a[i]) &and; v_int_48_640' = 1 + i)  &#8866;  IsLeftInverse(a,b',0,v_int_48_640' - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun ahaub_681 () Int)<br/>
(declare-fun b () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun b_primed () (Array Int Int))<br/>
(declare-fun v_int_48_640_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun IsLeftInverse ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
;Antecedent<br/>
(assert (= (- n 1) ahaub_681))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt;= 0 i))<br/>
(assert (= (- n 1) ahaub))<br/>
(assert (&lt; i n))<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
(assert (IsLeftInverse a b 0 (- i 1)))<br/>
(assert (&lt;= 0 (select a i)))<br/>
(assert (&lt;= (select a i) ahaub_681))<br/>
(assert (= b_primed (store b (select a i) i)))<br/>
(assert (= v_int_48_640_primed (+ 1 i)))<br/>
;Negation of Consequence<br/>
(assert (not (IsLeftInverse a b_primed 0 (- v_int_48_640_primed 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1) &and; update_array_1d(b,b',i,a[i]) &and; dom(b',0,ahaub_681) &and; a[i] &le; ahaub_681 &and; 0 &le; a[i] &and; dom(b,0,ahaub_681) &and; n - 1 = ahaub_681 &and; i &le; ahaub &and; 0 &le; i &and; dom(a,0,ahaub) &and; n - 1 = ahaub &and; i &lt; n &and; IsLeftInverse(a,b,0,i - 1) &and; v_int_48_640' = 1 + i)  &#8866;  0 &le; v_int_48_640'
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun b_primed () (Array Int Int))<br/>
(declare-fun ahaub_681 () Int)<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun n () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun b () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun v_int_48_640_primed () Int)<br/>
;Relations declarations<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun IsLeftInverse ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
;Antecedent<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
(assert (= b_primed (store b (select a i) i)))<br/>
(assert (&lt;= (select a i) ahaub_681))<br/>
(assert (&lt;= 0 (select a i)))<br/>
(assert (= (- n 1) ahaub_681))<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt;= 0 i))<br/>
(assert (= (- n 1) ahaub))<br/>
(assert (&lt; i n))<br/>
(assert (IsLeftInverse a b 0 (- i 1)))<br/>
(assert (= v_int_48_640_primed (+ 1 i)))<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= 0 v_int_48_640_primed)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(b_706,0,ahaub_681) &and; i &le; ahaub &and; 0 &le; i &and; dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1) &and; IsLeftInverse(a,b,0,i - 1) &and; i &lt; n &and; n - 1 = ahaub &and; dom(a,0,ahaub) &and; n - 1 = ahaub_681 &and; dom(b,0,ahaub_681) &and; 0 &le; a[i] &and; a[i] &le; ahaub_681 &and; update_array_1d(b,b_706,i,a[i]) &and; IsLeftInverse(a,b',0,n - 1))  &#8866;  IsLeftInverse(a,b',0,n - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun ahaub () Int)<br/>
(declare-fun ahaub_681 () Int)<br/>
(declare-fun b () (Array Int Int))<br/>
(declare-fun b_706 () (Array Int Int))<br/>
(declare-fun i () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun b_primed () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun IsLeftInverse ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
;Antecedent<br/>
(assert (&lt;= i ahaub))<br/>
(assert (&lt;= 0 i))<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
(assert (IsLeftInverse a b 0 (- i 1)))<br/>
(assert (&lt; i n))<br/>
(assert (= (- n 1) ahaub))<br/>
(assert (= (- n 1) ahaub_681))<br/>
(assert (&lt;= 0 (select a i)))<br/>
(assert (&lt;= (select a i) ahaub_681))<br/>
(assert (= b_706 (store b (select a i) i)))<br/>
(assert (IsLeftInverse a b_primed 0 (- n 1)))<br/>
;Negation of Consequence<br/>
(assert (not (IsLeftInverse a b_primed 0 (- n 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &le; i &and; dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1) &and; IsLeftInverse(a,b,0,i - 1) &and; n &le; i)  &#8866;  IsLeftInverse(a,b,0,n - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun i () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun b () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun IsLeftInverse ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
;Antecedent<br/>
(assert (&lt;= 0 i))<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
(assert (IsLeftInverse a b 0 (- i 1)))<br/>
(assert (&lt;= n i))<br/>
;Negation of Consequence<br/>
(assert (not (IsLeftInverse a b 0 (- n 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure Invert<ul><li class="Collapsed procdef">Internal representation
<ul>void Invert$int[]~int[]~int(  int[] a,  int[] b,  int n)<br/>
static  EBase true &amp; dom(a,0,n - 1) &amp; dom(b,0,n - 1) &amp; Permute(a,0,n - 1,0,n - 1) &amp;<br/>
       {FLOW,(32,32)=__norm}<br/>
         EAssume 1::ref [b]<br/>
           true &amp; IsLeftInverse(a,b&apos;,0,n - 1) &amp; IsInjective(b&apos;,0,n - 1) &amp;<br/>
           {FLOW,(32,32)=__norm}<br/>
dynamic  []<br/>
<br/>
ref b<br/>
{<br/>
int v_int_33_658;<br/>
v_int_33_658 = 0;<br/>
73::InvertHelper$int[]~int[]~int~int(a,b,n,v_int_33_658)<br/>
}<br/>
<br/>
{(28,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pre">
Precondition of procedure call 73::InvertHelper$int[]~int[]~int~int(a,b,n,v_int_33_658) at <a href="#L33">line 33</a> holds<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1))  &#8866;  dom(a,0,n - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun b () (Array Int Int))<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom a 0 (- n 1)))<br/>
(assert (dom b 0 (- n 1)))<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
;Negation of Consequence<br/>
(assert (not (dom a 0 (- n 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>(error &quot;line 10 column 47: invalid declaration, function &apos;dom&apos; (whith the given signature) already declared&quot;)<br/>
unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1))  &#8866;  dom(b,0,n - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun b () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun dom ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
(assert (forall ((low Int) (high Int) (a (Array Int Int)) (l Int) (h Int)) (=&gt; (and (dom a low high) (and (&lt;= low l) (&lt;= h high))) (dom a l h))))<br/>
;Antecedent<br/>
(assert (dom a 0 (- n 1)))<br/>
(assert (dom b 0 (- n 1)))<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
;Negation of Consequence<br/>
(assert (not (dom b 0 (- n 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>(error &quot;line 10 column 47: invalid declaration, function &apos;dom&apos; (whith the given signature) already declared&quot;)<br/>
unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1))  &#8866;  Permute(a,0,n - 1,0,n - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
;Antecedent<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
;Negation of Consequence<br/>
(assert (not (Permute a 0 (- n 1) 0 (- n 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1))  &#8866;  IsLeftInverse(a,b,0,0 - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun n () Int)<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun b () (Array Int Int))<br/>
;Relations declarations<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun IsLeftInverse ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
;Antecedent<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
;Negation of Consequence<br/>
(assert (not (IsLeftInverse a b 0 (- 0 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul><b>true</b>  &#8866;  0 &le; 0
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
;Relations declarations<br/>
;Axioms assertions<br/>
;Antecedent<br/>
(assert true)<br/>
;Negation of Consequence<br/>
(assert (not (&lt;= 0 0)))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1) &and; IsLeftInverse(a,b',0,n - 1))  &#8866;  IsLeftInverse(a,b',0,n - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun b_primed () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun IsLeftInverse ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
;Antecedent<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
(assert (IsLeftInverse a b_primed 0 (- n 1)))<br/>
;Negation of Consequence<br/>
(assert (not (IsLeftInverse a b_primed 0 (- n 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(dom(a,0,n - 1) &and; dom(b,0,n - 1) &and; Permute(a,0,n - 1,0,n - 1) &and; IsLeftInverse(a,b',0,n - 1))  &#8866;  IsInjective(b',0,n - 1)
<li class="Collapsed proverinput">Input to prover Z3
<ul>(set-logic AUFNIA)<br/>
;Variables declarations<br/>
(declare-fun a () (Array Int Int))<br/>
(declare-fun b_primed () (Array Int Int))<br/>
(declare-fun n () Int)<br/>
;Relations declarations<br/>
(declare-fun Permute ((Array Int Int) Int Int Int Int) Bool)<br/>
(declare-fun IsInjective ((Array Int Int) Int Int) Bool)<br/>
(declare-fun IsLeftInverse ((Array Int Int) (Array Int Int) Int Int) Bool)<br/>
;Axioms assertions<br/>
(assert (forall ((l Int) (h Int) (a (Array Int Int)) (i Int) (j Int)) (= (Permute a i j l h) (and (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (and (&lt;= l (select a k)) (&lt;= (select a k) h))))) (and (forall ((u Int)) (or (&lt; u l) (or (&gt; u h) (exists ((v Int)) (and (and (&lt;= i v) (&lt;= v j)) (= (select a v) u)))))) (IsInjective a i j))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
(assert (forall ((i Int) (j Int) (b (Array Int Int)) (a (Array Int Int))) (= (IsLeftInverse a b i j) (forall ((k Int)) (or (&lt; k i) (or (&gt; k j) (= (select b (select a k)) k)))))))<br/>
(assert (forall ((i Int) (j Int) (a (Array Int Int))) (= (IsInjective a i j) (forall ((y Int)) (forall ((x Int)) (or (&lt; x i) (or (&gt; x j) (or (&lt; y i) (or (&gt; y j) (or (= x y) (not (= (select a x) (select a y)))))))))))))<br/>
;Antecedent<br/>
(assert (Permute a 0 (- n 1) 0 (- n 1)))<br/>
(assert (IsLeftInverse a b_primed 0 (- n 1)))<br/>
;Negation of Consequence<br/>
(assert (not (IsInjective b_primed 0 (- n 1))))<br/>
(check-sat)</ul></li><li class="Collapsed proveroutput">Output of prover Z3
<ul>unsat</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed term">Termination of all procedures
<ul></ul></li>
</ul>
<script>
	SetupTreeView("ProofTree");
</script>
</body>
</html>