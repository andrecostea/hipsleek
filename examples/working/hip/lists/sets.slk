// prelude.slk should be kept in separate file.
relation induce(int value) == true.
relation dom(int[] a, int low, int high).
relation domb(bool[] a, int low, int high).
axiom dom(a,low,high) & low<=l & h<=high ==> dom(a,l,h).
axiom domb(a,low,high) & low<=l & h<=high ==> domb(a,l,h).
relation update_array_1d_b(bool[] a, bool[] b, bool val, int i).
relation update_array_1d(int[] a, int[] r, int val, int i).
relation update_array_2d(int[,] a, int[,] r, int val, int i, int j).
relation amodr(int[] a, int[] b, int i, int j) == 
    forall(k : (i<=k & k<=j | a[k] = b[k])).
relation bnd(int[] a, int i, int j, int low, int high) == 
 	(i > j | i<=j & forall ( k : (k < i | k > j | low <= a[k] <= high))).

// would it be better to use array of bool[]?

relation emptyset(int[] s).
axiom emptyset(s)  ==> forall(i: s[i] = 0).
axiom forall(i: s[i] = 0) ==> emptyset(s).

relation setunion(int[] a, int[] b, int[] c).
axiom setunion(a,b,c) ==> forall(i: ((c[i] = 1) & (a[i] = 1 | b[i] = 1))
      | ((c[i]=0) & (a[i]=0 & b[i]=0))).
//axiom setunion(a,b,c) ==> forall(i: !(a[i] = 1) | c[i] = 1).
//axiom setunion(a,b,c) ==> forall(i: !(b[i] = 1) | c[i] = 1).
//axiom setunion(a,b,c) ==> forall(i: !(a[i] = 0 & b[i] = 0) | (c[i]=0)).
axiom forall(i: ((c[i] = 1) & (a[i] = 1 | b[i] = 1))
      | ((c[i]=0) & (a[i]=0 & b[i]=0))) ==> setunion(a,b,c).

relation setinter(int[] a, int[] b, int[] c).
//axiom setinter(a,b,c) ==> forall(i: !(c[i] = 1) | (a[i] = 1 & b[i] = 1)).
//axiom setinter(a,b,c) ==> forall(i: !(a[i] = 0) | c[i] = 0).
//axiom setinter(a,b,c) ==> forall(i: !(b[i] = 0) | c[i] = 0).
//axiom setinter(a,b,c) ==> forall(i: !(a[i] = 1 & b[i] = 1) | (c[i]=1)).
axiom setinter(a,b,c) ==> forall(i: ((c[i] = 1) & (a[i] = 1 & b[i] = 1))
      | ((c[i]=0) & (a[i]=0 | b[i]=0))).
axiom forall(i: ((c[i] = 1) & (a[i] = 1 & b[i] = 1))
      | ((c[i]=0) & (a[i]=0 | b[i]=0))) ==> setinter(a,b,c).
 
checkentail s1[0] = 1 & s2[1] = 1 & setunion(s1,s2,s3) |- s3[1] = 1. //valid s3 = union s1 s2

checkentail s1[0] = 1 & s2[1] = 1 & setunion(s1,s2,s3) |- emptyset(s3). //invalid

checkentail s1[0] = 1 & s2[0] = 1 & setinter(s1,s2,s3) |- s3[0] = 1. //valid 

checkentail s1[0] = 0 & s2[0] = 0 & setunion(s1,s2,s3) |- s3[0] = 0. //valid s3 = union s1 s2

checkentail s1[0] = 1 & s2[0] = 0 & setinter(s1,s2,s3) |- s3[0] = 0. //valid 


checkentail s1[0] = 0 & s2[0] = 0 & setunion(s1,s2,s3) |- s3[0] = 1 . //invalid

// checkentail S1={a} & S2={b} & S3={a,b} |- S1=S2+S3
// guess need to use update_array..

checkentail emptyset(s0) & update_array_1d(s0,s1,1,a)
 & update_array_1d(s0,s2,1,b) & update_array_1d(s1,s3,1,b) 
 |- setunion(s1,s2,s3).

// checkentail S1={a} & S2={b} & S3={a,b} |- S2=S2/\S3
checkentail emptyset(s0) & update_array_1d(s0,s1,1,a)
 & update_array_1d(s0,s2,1,b) & update_array_1d(s1,s3,1,b) 
 |- setinter(s2,s3,s2).

// checkentail y in S & forall x in S. x>5 |- y>=3
checkentail s[y]=1 & forall(x: !(s[x]=1) | x>5) |- y>=3.
// valid

checkentail s[y]=1 & forall(x: !(s[x]=1) | x>5) |- y>6.
// invalid

