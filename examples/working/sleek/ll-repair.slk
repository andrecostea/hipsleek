data node {
     int val;
     node next
}.

pred ll<n> == self = null & n = 0
	or (exists v, q: self::node<v, q> * q::ll<n-1>).

// data node {
//      node next;
// }.

// synthesize [vars] pre ~> post;

// synthesize [int x, int b] x = a ~> x = b.
// PASS

// synthesize [int x, int t] x = a & t = b ~> x = b & t = b. 
// PASS

// synthesize [node x, int n2, node y] x::node<n1, a> * y::node<n3, b> & true ~>
// x::node<n2, a> * y::node<n3, b>.
// PASS

// synthesize [node y, node m]
// y::ll<n2> & m = null
// ~>
// m::ll<n2>.
// PASS

// Exists Rule
// synthesize [node x, node y]
// x::node<n1, m> * y::ll<n2> & m = null
// ~>
// (exists u: x::node<n1, u> * u::ll<n2>).
// PASS

// Pre-process step
synthesize [node x, node y]
x::node<v1, m> * y::ll<n2> & m = null & n1 = 1
~>
x::ll<n1+n2> & true.

