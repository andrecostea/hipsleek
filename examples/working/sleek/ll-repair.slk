data node {
     int val;
     node next
}.
// data node {
//      node next;
// }.

pred ll<n> == self = null & n = 0
	or (exists v, q: self::node<v, q> * q::ll<n-1>).

void append(node x, node y)
  requires x::ll<n1> * y::ll<n2> & x!=null 
  ensures exists n3: x::ll<n3> & n3 = n1 + n2;.

// synthesize [int x, int b] x = a ~> x = b.
// PASS

// synthesize [int x, int t] x = a & t = b ~> x = b & t = b. 
// PASS

// synthesize [node x, int n2, node y] x::node<n1, a> * y::node<n3, b> & true ~>
// x::node<n2, a> * y::node<n3, b>.
// PASS

// synthesize [node y, node m]
// y::ll<n2> & m = null
// ~>
// m::ll<n2>.
// PASS

// x.next = y
// synthesize [node x, node y]
// x::node<v1, m> * y::ll<n2> & m = null & n1 = 1
// ~>
// x::ll<n1+n2> & true.
// PASS

// function call f(x.next, y);
// synthesize [node x, node y]
// a::node<v1, m> * m::ll<n3> * b::ll<n2> & m != null & n1 = n3 + 1
// ~>
// a::ll<n1+n2> & true.

// function call f(x.next, y);
// synthesize [node x, node y]
// append(x,y)
// m::ll<a3> * b::ll<a2> & m != null & a1 = a3 + 1
// ~>
// (exists a4: m::ll<a4> & a4 = a1 + a2 -1).


synthesize [node x, node y]
// append(x.next, y)
x::node<v1, m> * m::ll<a3> * b::ll<a2> & m != null & a1 = a3 + 1
~>
(exists a4: x::ll<a4> & a4 = a1 + a2).
