
data node { int val ; node next }.
pred ll<n> == self = null & n = 0
	or self::node<next = r> * r::ll<n-1> 
	inv n >= 0.

checkentail (x::ll<n>@I * y::ll<m>@I) & n>0 & m=0  |-  x!=y. 
print residue.
// x * y
// Valid


checkentail (x::ll<n>@I * y::ll<m>@I) & n>0 & m>0  |- (y::ll<m1>@I & x::ll<n1>@I) . 
print residue.
// x * y
// Valid


checkentail (x::ll<n>@I * y::ll<m>@I) & n>0 & m>0  |- y!=x. 
print residue.
// Valid
// x * y



checkentail x::ll<n> * y::ll<m> & n>0 & m>0  |- y::ll<m1> * x::ll<n1> & y!=x.
print residue.
// true
// Valid


checkentail (x::ll<n>@I * y::ll<m>@I) & x!=null & y!=null  |- (y::ll<m1>@I & x::ll<n1>@I) & y!=x. 
print residue.
// x * y
// Valid

checkentail (x::ll<n>@I * y::ll<n>@I) & n>0  |-  x!=y. 
print residue.
// x * y
// Valid

checkentail x::ll<n> * x::ll<n> & n>0  |-  1=2. 
print residue.
// x * y
// Valid

checkentail x::ll<n> * x::ll<n> & n=0   |-  x=null & n=0.

checkentail x::ll<n> * x::ll<n> & n>0   |-  x=null & n=0.

checkentail x::ll<n> * x::ll<n> & x=null  
         or x::ll<n> * x::ll<n> & x!=null   |-  x=null & n=0.


checkentail x::ll<n> * x::ll<n>   |-  
    case {  x=null -> [] x=null & n=0;
            x!=null -> [] x=null & n=0; }. 
print residue.

/* parse error
checkentail x::ll<n> * x::ll<n> * (true & x=null or true & x!=null)   |- 
            x=null & n=0. 
*/
