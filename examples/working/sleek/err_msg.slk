data node { int val ; node next }.

pred ll<n> == self = null & n = 0
	or self::node<next = r> * r::ll<n - 1>
	inv n >= 0.

pred ll2<n> == case { self=null -> [] n=0;
           self!=null ->  [] self::node<_,r> * r::ll2<n-1>;}
	inv n >= 0.

pred ll3<n> == self::node<next = r> * r::ll2<n-1>
	inv n >= 1.

/********************************************************
Reason:
  1. Basic (lhs = /\ form):
      - Exception: MAY/MUST
      - Entail fails: MAY/MUST
         - pre is too strength
         - bugs in program
    + Core failure: pos(use interpolation/enumeration with SMT-Solver)
    + Sugesstion: weaken post
  2. AND
********************************************************/

/********************************************************/
/*
C1: lhs = pure; rhs = pure
*/
//C1.1
//checkentail n > 3 |- n > 5.
//MAY ERROR:  (n > 3 |- n > 5: SAT) and  (n > 3 |- not(n > 5): SAT), cex n = 4, ex n = 6
//-------------------------------------
//C1.2
//checkentail n > 3 |- n <1.
//MUST ERROR:  (n > 3 |- n < 1: UNSAT) and  (n > 3 |- not(n <1): SAT)


/********************************************************/
/*
C2: lhs = heap; rhs = empty_heap; over app. heap of lhs to pure??
*/
//C2.1
//checkentail x::ll<n> |-n>0.
//res: MAY error: (lhs ~ (n >=0)) and (n >=0  |- n>0: SAT) and (n>=0 |- not (n>0): SAT), cex x=null, ex x != null)
//-------------------------------------
//C2.1
//checkentail x::ll3<n> |-n=0.
//res: MUST error: (lhs ~ (n >=1))
//             and (n >=1  |- n=0: UNSAT) and (n>=1 |- not (n=0): SAT))
/********************************************************/
/*
C3: lhs = heap; rhs = heap; over app. heap of lhs to pure, rhs to pure, cmp heap of lhs and rhs??
*/
//C3.1
//checkentail x::ll<n> |- x=null.
//res: MUST error: (lhs ~ (n >=0)) and (rhs ~ n=0)
//            and (n >=0  |- n=0: SAT) and (n>=0 |- not (n=0): SAT), cex x::node<m>, ex x=null))
//-------------------------------------
//C3.2
checkentail x=null|- x::ll<n> & n>2.
//res: MUST error: (lhs ~ (n =1)) and (rhs ~ n>2)
//            and (n =0  |- n>2: UNSAT) and (n=0 |- not (n>2): SAT))
//-------------------------------------



/*
checkentail x::ll<2> or x::node<_,null> |- x::ll<n> & n>2.

checkentail x::ll<n> & n > 3 |- x::node<next = r1> * r1::node<next = r2> & r2=null.

checkentail x::ll<n> & n <=1 |- x::node<next = r1> * r1::node<next = r2> & r2=null.

checkentail x=null |- x::node<next = r1> * r1::node<next = r2> & r2=null.

checkentail x=null or x::node<_,null> |- x::node<next = r1> * r1::node<next = r2> & r2=null.

checkentail x::node<_,null> |- x=null or x::node<next = r1> * r1::node<next = r2> & r2=null.

checkentail x::ll<2> or x::node<_,null> |- x::node<next = r1> * r1::node<next = r2> & r2=null.

checkentail x::ll<n> & n<2 |- case { x=null -> [] x=null;
                                    x!=null ->  [] x::node<_,null>; }.

checkentail x::ll<2> or x::node<_,null> |- x::ll2<n> & n>2.

checkentail x::ll<n> & n<2 |- case { x=null -> [] x=null;
                                    x!=null ->  [] x::node<_,null>; }.

checkentail x::ll<n> & n<2 |- x=null or x::node<_,null>.
*/
/*

 left OR on ante
 para OR on conseq
 matching view/node
 fail to entail pure x=null in conseq;
  x::ll<n> & n<2 |- x=null 

OR 

 right OR on ante
 para OR on conseq; 
 folding x::ll<n> with n=1 (to add)
 fail to match x::node<_,null> of conseq
 x=null &n=0 |-/ x::node<_,null>

checkentail x::ll<2> or x::node<_,null> |- x::ll<n> & n>2.

*/


/*


 left \/ on ante;
 match x::ll<2> with x::ll<m>;
 fail to entail pure n>2;
 n=2 |- n>2

AND

 right \/ on ante;
 fold x::ll<n> with x::node<_,null> inst n=1
 fail to entail pure n>2
 x!=null & n=1 |- n>2


checkentail x::ll<n> & n<2 |- case { x=null -> [] x=null;
                                    x!=null ->  [] x::node<_,null>; }.

checkentail x::ll<2> or x::node<_,null> |- x::ll2<n> & n>2.

checkentail x::ll<n> & n<2 |- x=null or x::node<_,null>.

*/

