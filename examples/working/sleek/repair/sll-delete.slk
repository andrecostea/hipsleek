data node {
     node next
}.

pred ll<n> == self = null & n = 0
	or (exists q: self::node<q> * q::ll<n-1>).

void delete(node x, int a)
	requires x::ll<n> & n > a & a > 0 
	ensures (exists k: x::ll<k> & k = n-1);.

// synthesize [node x,int a]
// x::ll<n> & (1-n)<0 & a-1=0
// ~>
// (exists fr54,q_3: x::node<q_3> * q_3::ll<fr54> & a-1=0 & fr54=n-2).

// to synthesize x.next = x.next.next
// RlUnfoldPre  x::node<q_75> * q_75::ll<flted_6_74>&1<(0+n) & a=0+1 & flted_6_74+1=n
// [RlFRead(node x.next, node q_75)
// [RlUnfoldPre  q_75::node<q_84> * q_84::ll<flted_6_83> * x::node<q_75>&
// 1<(0+n) & a=0+1 & flted_6_74+1=n & flted_6_83+1=flted_6_74
// [RlFRead(node q_75.next, node q_84)
// [RlFramePred(node q_63, node q_84)
// [RlFWrite x, next, q_84
// [RlSkip
// []]]]]]]

synthesize [node q_84,node q_75,node x,int a]
q_75::node<q_84> * x::node<q_75> &
1<n & a=1 & flted_6_74+1=n & flted_6_83+1=flted_6_74
~>
x::node<q_84> & flted_6_83+2=n.

// synthesize [node x,int a]
//  x::ll<n> & a-1 !=0 & -a<0 & a-n<0
// ~>
// (exists fr60,q_3, q_27: q_3::node<q_27> * x::node<q_3> * q_27::ll<fr60>&a=a & fr60 = n-3).

// [RlFRead(node x.next, node q_79)
// [RlMkNull int a_94,  a-1
// [RlFuncCall delete$node~int([q_79,a_94])
// [RlSkip
