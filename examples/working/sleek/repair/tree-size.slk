data node2 {
	node2 left;
	node2 right; 
}.

pred tree1<m> == self = null & m = 0 
	or self::node2<p, q> * p::tree1<m1> * q::tree1<m2> & m = 1 + m1 + m2 
	inv m >= 0.

int count(node2 z)
	requires z::tree1<m>
	ensures z::tree1<m> & res = m & res >= 0;.

// synthesize [node2 z,int cleft,int cright]
// z::tree1<m>@M&v_bool_17_4425 & z=z & z=null
// ~>
//  emp&z=null & (-1*res)<=0 & m=res.

// synthesize [node2 z]
//  z::tree1<m>@M&v_bool_17_4407 & z=z & z=null
// ~>
//  emp&z=null & (-1*res)<=0 & m=res.


synthesize [node2 z]

 z::tree1<m> & z!=null
~>
 z::tree1<m>&m=res.m

