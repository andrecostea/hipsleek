data node {
  int val;
  node next;
}.

pred ll<n> == self=null & n = 0
  or self::node<v, r> * r::ll<n2> & n = 1 + n2.

int sum(node a)
  requires a::ll<m> ensures a::ll<m> & res = m;.

// append(x.next, y)
// synthesize [node x, int k]
// x::node<v_1917,r_1918> * r_1918::ll<n_1926> &
// n_1926= n - v_1917 & k=n & x !=null
// ~>
// x::ll<n> & res = n.

// synthesize [node x, int k]
// x::ll<n> & x != null
// ~>
// x::node<v_1917,r_1918> * r_1918::ll<n_1926> &
// n_1926= n - 1 & k=n & x !=null.


// synthesize [node x, int k, node r_57]
// x::node<v_56,r_57> * r_57::ll<n2> & n2 = n1 + 1 & x!=null
// ~>
// x::node<v_1917,r_1918> * r_1918::ll<n3> & n3= n - 1 & k=n & x !=null.

// synthesize [node x, int k, node r_57]
// x::node<v_56,r_57> * r_57::ll<n2> & n2 = n1 + 1 & x!=null
// ~>
// x::node<v_1917,r_1918> * r_1918::ll<n3> & n3= n - 1 & k=n & x !=null.

synthesize [node x, int k, node r, int y]
x::node<v1,r2> * r2::ll<n2> & n = n2 + 1 & x!=null & y = n2
~>
x::ll<n> & x != null & k = n.
// k = y + 1


