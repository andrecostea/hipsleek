<html>
<head>	<link rel="stylesheet" type="text/css" href="hipsleek.css" />	<script type="text/javascript" src="hipsleek.js"></script></head>
<body>
<h1>./hip/bll.ss</h1>
<ul class="TreeView" id="ProofTree"><li class="Collapsed progsource">Source<ul><table><tr id="L1" class="OddSourceLine"><td>1</td><td><pre>/* bounded lists */</pre></td></tr>
<tr id="L2" class="EvenSourceLine"><td>2</td><td><pre></pre></td></tr>
<tr id="L3" class="OddSourceLine"><td>3</td><td><pre>/* representation of a node */</pre></td></tr>
<tr id="L4" class="EvenSourceLine"><td>4</td><td><pre>data node {</pre></td></tr>
<tr id="L5" class="OddSourceLine"><td>5</td><td><pre>	int val; </pre></td></tr>
<tr id="L6" class="EvenSourceLine"><td>6</td><td><pre>	node next;	</pre></td></tr>
<tr id="L7" class="OddSourceLine"><td>7</td><td><pre>}</pre></td></tr>
<tr id="L8" class="EvenSourceLine"><td>8</td><td><pre></pre></td></tr>
<tr id="L9" class="OddSourceLine"><td>9</td><td><pre>/* view for bounded lists */</pre></td></tr>
<tr id="L10" class="EvenSourceLine"><td>10</td><td><pre>bndl<n, sm, bg> == self = null & n = 0 & sm <= bg</pre></td></tr>
<tr id="L11" class="OddSourceLine"><td>11</td><td><pre>	or self::node<d,p> * p::bndl<n-1, sm, bg> & sm <= d & d <= bg  </pre></td></tr>
<tr id="L12" class="EvenSourceLine"><td>12</td><td><pre>	inv sm <= bg & n >= 0;</pre></td></tr>
<tr id="L13" class="OddSourceLine"><td>13</td><td><pre></pre></td></tr>
<tr id="L14" class="EvenSourceLine"><td>14</td><td><pre>/* insert a node as the first one in a bounded list */</pre></td></tr>
<tr id="L15" class="OddSourceLine"><td>15</td><td><pre>node insert(node x, int v)</pre></td></tr>
<tr id="L16" class="EvenSourceLine"><td>16</td><td><pre></pre></td></tr>
<tr id="L17" class="OddSourceLine"><td>17</td><td><pre>	requires x::bndl<n, sm, bg> & sm <= v & v <= bg </pre></td></tr>
<tr id="L18" class="EvenSourceLine"><td>18</td><td><pre>	ensures res::bndl<n+1, sm, bg>;</pre></td></tr>
<tr id="L19" class="OddSourceLine"><td>19</td><td><pre></pre></td></tr>
<tr id="L20" class="EvenSourceLine"><td>20</td><td><pre>{</pre></td></tr>
<tr id="L21" class="OddSourceLine"><td>21</td><td><pre>	return new node(v,x);</pre></td></tr>
<tr id="L22" class="EvenSourceLine"><td>22</td><td><pre>}</pre></td></tr>
<tr id="L23" class="OddSourceLine"><td>23</td><td><pre></pre></td></tr>
<tr id="L24" class="EvenSourceLine"><td>24</td><td><pre>/* delete a node from a bounded list */</pre></td></tr>
<tr id="L25" class="OddSourceLine"><td>25</td><td><pre>node delete(node x)</pre></td></tr>
<tr id="L26" class="EvenSourceLine"><td>26</td><td><pre></pre></td></tr>
<tr id="L27" class="OddSourceLine"><td>27</td><td><pre>	requires x::bndl<n,sm,bg> & x != null</pre></td></tr>
<tr id="L28" class="EvenSourceLine"><td>28</td><td><pre>	ensures res::bndl<n-1, sm, bg>;</pre></td></tr>
<tr id="L29" class="OddSourceLine"><td>29</td><td><pre></pre></td></tr>
<tr id="L30" class="EvenSourceLine"><td>30</td><td><pre>{</pre></td></tr>
<tr id="L31" class="OddSourceLine"><td>31</td><td><pre>	return x.next;</pre></td></tr>
<tr id="L32" class="EvenSourceLine"><td>32</td><td><pre>}</pre></td></tr>
<tr id="L33" class="OddSourceLine"><td>33</td><td><pre></pre></td></tr>
</table></ul></li><li class="Collapsed proc">
Procedure delete<ul><li class="Collapsed procdef">Internal representation
<ul>node delete$node(  node x)<br/>
static  EBase exists (Expl)[](Impl)[n; sm; <br/>
       bg](ex)[]NN x::bndl&lt;n,sm,bg&gt;@M[Orig][LHSCase]@ rem br[{125}] &amp; (<br/>
       ([null!=x][0!=n &amp; 0&lt;=n][sm&lt;=bg])) &amp; {FLOW,(33,33)=__norm}<br/>
         EAssume 2::<br/>
           EXISTS(sm_49,bg_50,<br/>
           flted_28_48: NN res::bndl&lt;flted_28_48,sm_49,bg_50&gt;@M[Orig][LHSCase]@ rem br[{125,124}] &amp;<br/>
           (<br/>
           ([0&lt;=flted_28_48 &amp; 1+flted_28_48=n]<br/>
            [sm_49=sm &amp; bg=bg_50 &amp; sm_49&lt;=bg_50])) &amp;<br/>
           {FLOW,(33,33)=__norm})<br/>
dynamic  []<br/>
node v_node_31_692;<br/>
v_node_31_692 = 66::bind x to (val_31_690,next_31_691) in <br/>
{next_31_691<br/>
};<br/>
65::return v_node_31_692<br/>
<br/>
{(25,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; 1+flted_11_751=n &amp; 0&lt;=flted_11_751&#8866; 0=flted_11_751
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_11_751] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (1 + flted_11_751 = n)) &amp; (0 &lt;= flted_11_751))))  | (0 = flted_11_751)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; 1+flted_11_751=n &amp; 0&lt;=flted_11_751&#8866; 0!=flted_11_751
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_11_751] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (1 + flted_11_751 = n)) &amp; (0 &lt;= flted_11_751))))  | (0 != flted_11_751)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul> p_763=p_763&#8866; null=p_763
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[p_763] : (((p_763 != p_763) | (p_763 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[p_763]: 1 &lt;= p_763}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; 1+flted_11_761=n &amp; 0&lt;=flted_11_761&#8866; 0=flted_11_761
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_11_761] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (1 + flted_11_761 = n)) &amp; (0 &lt;= flted_11_761))))  | (0 = flted_11_761)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; 1+flted_11_761=n &amp; 0&lt;=flted_11_761&#8866; 0!=flted_11_761
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_11_761] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (1 + flted_11_761 = n)) &amp; (0 &lt;= flted_11_761))))  | (0 != flted_11_761)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> p_763=p_763&#8866; p_763!=null
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[p_763] : (((p_763 != p_763) | (p_763 &gt; 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[p_763]: p_763 &lt;= 0}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; 1+flted_11_761=n &amp; 0&lt;=flted_11_761&#8866; null=p_763 | 0=flted_11_761
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, p_763, flted_11_761] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (1 + flted_11_761 = n)) &amp; (0 &lt;= flted_11_761))))  | ((p_763 &lt; 1) | (0 = flted_11_761))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,p_763,n-1]: 2 &lt;= n &amp;&amp; 1 &lt;= p_763}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> sm_759&lt;=d_762 &amp; d_762&lt;=bg_760 &amp; sm_759&lt;=bg_760&#8866; bg_760=bg_760
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[d_762, sm_759, bg_760] : (( (not ((((sm_759 &lt;= d_762) &amp; (d_762 &lt;= bg_760)) &amp; (sm_759 &lt;= bg_760))))  | (bg_760 = bg_760)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[d_762,sm_759,bg_760]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> d_762&lt;=bg_760 &amp; sm_759&lt;=d_762 &amp; sm_759&lt;=bg_760&#8866; sm_759=sm_759
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[d_762, bg_760, sm_759] : (( (not ((((d_762 &lt;= bg_760) &amp; (sm_759 &lt;= d_762)) &amp; (sm_759 &lt;= bg_760))))  | (sm_759 = sm_759)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[d_762,bg_760,sm_759]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> 0!=n &amp; 1+flted_11_761=n &amp; 0&lt;=n &amp; 0&lt;=flted_11_761&#8866; 1+flted_11_761=n
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[flted_11_761, n] : (( (not (((((0 != n) &amp; (1 + flted_11_761 = n)) &amp; (0 &lt;= n)) &amp; (0 &lt;= flted_11_761))))  | (1 + flted_11_761 = n)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[flted_11_761,n]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure insert<ul><li class="Collapsed procdef">Internal representation
<ul>node insert$node~int(  node x,  int v)<br/>
static  EBase exists (Expl)[](Impl)[n; sm; <br/>
       bg](ex)[]NN x::bndl&lt;n,sm,bg&gt;@M[Orig][LHSCase]@ rem br[{125,124}] &amp; (<br/>
       ([v&lt;=bg &amp; sm&lt;=v][0&lt;=n])) &amp; {FLOW,(33,33)=__norm}<br/>
         EAssume 1::<br/>
           EXISTS(sm_53,bg_54,<br/>
           flted_18_52: NN res::bndl&lt;flted_18_52,sm_53,bg_54&gt;@M[Orig][LHSCase]@ rem br[{125,124}] &amp;<br/>
           (<br/>
           ([0&lt;=flted_18_52 &amp; -1+flted_18_52=n]<br/>
            [sm_53=sm &amp; bg=bg_54 &amp; sm_53&lt;=bg_54])) &amp;<br/>
           {FLOW,(33,33)=__norm})<br/>
dynamic  []<br/>
node v_node_21_720;<br/>
v_node_21_720 = {<br/>
newnode(v,x)<br/>
};<br/>
67::return v_node_21_720<br/>
<br/>
{(15,0),(0,-1)}<br/>
</ul></li><li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n&#8866; null=p_787 | 0=n
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[p_787, n] : (((0 &gt; n) | ((p_787 &lt; 1) | (0 = n))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[p_787,n]: 1 &lt;= n &amp;&amp; 1 &lt;= p_787}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> p_787=p_787&#8866; null=p_787
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[p_787] : (((p_787 != p_787) | (p_787 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[p_787]: 1 &lt;= p_787}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> sm&lt;=d_786 &amp; d_786&lt;=bg&#8866; d_786&lt;=bg
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[sm, d_786, bg] : (( (not (((sm &lt;= d_786) &amp; (d_786 &lt;= bg))))  | (d_786 &lt;= bg)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[sm,d_786,bg]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> sm&lt;=d_786 &amp; d_786&lt;=bg&#8866; sm&lt;=d_786
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[bg, sm, d_786] : (( (not (((sm &lt;= d_786) &amp; (d_786 &lt;= bg))))  | (sm &lt;= d_786)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[bg,sm,d_786]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> res!=null&#8866; null=res
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[res] : (((res &lt; 1) | (res &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[res]: 1 &lt;= res}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> d_786&lt;=bg &amp; sm&lt;=d_786&#8866; sm&lt;=d_786
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[bg, sm, d_786] : (( (not (((d_786 &lt;= bg) &amp; (sm &lt;= d_786))))  | (sm &lt;= d_786)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[bg,sm,d_786]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> d_786&lt;=bg &amp; sm&lt;=d_786&#8866; d_786&lt;=bg
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[sm, d_786, bg] : (( (not (((d_786 &lt;= bg) &amp; (sm &lt;= d_786))))  | (d_786 &lt;= bg)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[sm,d_786,bg]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> 0&lt;=n&#8866; 1+n=n+1
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n] : (((0 &gt; n) | (1 + n = n + 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed term">Termination of all procedures
<ul></ul></li>
</ul>
<script>
	SetupTreeView("ProofTree");
</script>
</body>
</html>