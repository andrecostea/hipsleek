<html>
<head>	<link rel="stylesheet" type="text/css" href="hipsleek.css" />	<script type="text/javascript" src="hipsleek.js"></script></head>
<body>
<h1>./hip/cll.ss</h1>
<ul class="TreeView" id="ProofTree"><li class="Collapsed progsource">Source<ul><table><tr id="L1" class="OddSourceLine"><td>1</td><td><pre>/* circular lists */</pre></td></tr>
<tr id="L2" class="EvenSourceLine"><td>2</td><td><pre></pre></td></tr>
<tr id="L3" class="OddSourceLine"><td>3</td><td><pre>/* representation of a node */</pre></td></tr>
<tr id="L4" class="EvenSourceLine"><td>4</td><td><pre>data node {</pre></td></tr>
<tr id="L5" class="OddSourceLine"><td>5</td><td><pre>	int val; </pre></td></tr>
<tr id="L6" class="EvenSourceLine"><td>6</td><td><pre>	node next;	</pre></td></tr>
<tr id="L7" class="OddSourceLine"><td>7</td><td><pre>}</pre></td></tr>
<tr id="L8" class="EvenSourceLine"><td>8</td><td><pre></pre></td></tr>
<tr id="L9" class="OddSourceLine"><td>9</td><td><pre>/* view for singly linked circular lists */</pre></td></tr>
<tr id="L10" class="EvenSourceLine"><td>10</td><td><pre>cll<p, n> == self = p & n = 0</pre></td></tr>
<tr id="L11" class="OddSourceLine"><td>11</td><td><pre>	or self::node<_, r> * r::cll<p, n-1> & self != p  </pre></td></tr>
<tr id="L12" class="EvenSourceLine"><td>12</td><td><pre>	inv n >= 0;</pre></td></tr>
<tr id="L13" class="OddSourceLine"><td>13</td><td><pre></pre></td></tr>
<tr id="L14" class="EvenSourceLine"><td>14</td><td><pre>hd<n> == self = null & n = 0</pre></td></tr>
<tr id="L15" class="OddSourceLine"><td>15</td><td><pre>	or self::node<_, r> * r::cll<self, n-1>  </pre></td></tr>
<tr id="L16" class="EvenSourceLine"><td>16</td><td><pre>	inv n >= 0;</pre></td></tr>
<tr id="L17" class="OddSourceLine"><td>17</td><td><pre></pre></td></tr>
<tr id="L18" class="EvenSourceLine"><td>18</td><td><pre></pre></td></tr>
<tr id="L19" class="OddSourceLine"><td>19</td><td><pre>node test() </pre></td></tr>
<tr id="L20" class="EvenSourceLine"><td>20</td><td><pre>	requires true</pre></td></tr>
<tr id="L21" class="OddSourceLine"><td>21</td><td><pre>	ensures true;</pre></td></tr>
<tr id="L22" class="EvenSourceLine"><td>22</td><td><pre>{</pre></td></tr>
<tr id="L23" class="OddSourceLine"><td>23</td><td><pre>	node null_tmp = null; </pre></td></tr>
<tr id="L24" class="EvenSourceLine"><td>24</td><td><pre>	node tmp = new node(10, null_tmp);</pre></td></tr>
<tr id="L25" class="OddSourceLine"><td>25</td><td><pre></pre></td></tr>
<tr id="L26" class="EvenSourceLine"><td>26</td><td><pre>	//assert tmp'::cll<_, 1>;</pre></td></tr>
<tr id="L27" class="OddSourceLine"><td>27</td><td><pre></pre></td></tr>
<tr id="L28" class="EvenSourceLine"><td>28</td><td><pre>	//assert tmp'::node<_, r> * r::cll<r, 0> assume;</pre></td></tr>
<tr id="L29" class="OddSourceLine"><td>29</td><td><pre></pre></td></tr>
<tr id="L30" class="EvenSourceLine"><td>30</td><td><pre>	tmp.next = tmp;</pre></td></tr>
<tr id="L31" class="OddSourceLine"><td>31</td><td><pre></pre></td></tr>
<tr id="L32" class="EvenSourceLine"><td>32</td><td><pre>	node tmp2 = new node(20, tmp.next);</pre></td></tr>
<tr id="L33" class="OddSourceLine"><td>33</td><td><pre>	tmp.next = tmp2;</pre></td></tr>
<tr id="L34" class="EvenSourceLine"><td>34</td><td><pre></pre></td></tr>
<tr id="L35" class="OddSourceLine"><td>35</td><td><pre>	//assert tmp'::hd<2>;</pre></td></tr>
<tr id="L36" class="EvenSourceLine"><td>36</td><td><pre></pre></td></tr>
<tr id="L37" class="OddSourceLine"><td>37</td><td><pre>	return tmp;</pre></td></tr>
<tr id="L38" class="EvenSourceLine"><td>38</td><td><pre>}</pre></td></tr>
<tr id="L39" class="OddSourceLine"><td>39</td><td><pre></pre></td></tr>
<tr id="L40" class="EvenSourceLine"><td>40</td><td><pre>void insert(node x, int v)</pre></td></tr>
<tr id="L41" class="OddSourceLine"><td>41</td><td><pre>	</pre></td></tr>
<tr id="L42" class="EvenSourceLine"><td>42</td><td><pre>	requires x::hd<n> & n > 0 </pre></td></tr>
<tr id="L43" class="OddSourceLine"><td>43</td><td><pre>	ensures x::hd<n+1>;</pre></td></tr>
<tr id="L44" class="EvenSourceLine"><td>44</td><td><pre>    //requires x::node<w,q> </pre></td></tr>
<tr id="L45" class="OddSourceLine"><td>45</td><td><pre>    //ensures x::node<w,r> * r::node<v,q>;</pre></td></tr>
<tr id="L46" class="EvenSourceLine"><td>46</td><td><pre>{</pre></td></tr>
<tr id="L47" class="OddSourceLine"><td>47</td><td><pre>	node tmp;</pre></td></tr>
<tr id="L48" class="EvenSourceLine"><td>48</td><td><pre></pre></td></tr>
<tr id="L49" class="OddSourceLine"><td>49</td><td><pre>	tmp = new node(v, x.next);</pre></td></tr>
<tr id="L50" class="EvenSourceLine"><td>50</td><td><pre>    //dprint;</pre></td></tr>
<tr id="L51" class="OddSourceLine"><td>51</td><td><pre>	x.next = tmp;</pre></td></tr>
<tr id="L52" class="EvenSourceLine"><td>52</td><td><pre>	//dprint;</pre></td></tr>
<tr id="L53" class="OddSourceLine"><td>53</td><td><pre>	//assert x'::hd<m>;</pre></td></tr>
<tr id="L54" class="EvenSourceLine"><td>54</td><td><pre>	//assume false;</pre></td></tr>
<tr id="L55" class="OddSourceLine"><td>55</td><td><pre>}</pre></td></tr>
<tr id="L56" class="EvenSourceLine"><td>56</td><td><pre></pre></td></tr>
<tr id="L57" class="OddSourceLine"><td>57</td><td><pre></pre></td></tr>
<tr id="L58" class="EvenSourceLine"><td>58</td><td><pre></pre></td></tr>
<tr id="L59" class="OddSourceLine"><td>59</td><td><pre>/* functions to count the number of nodes in a circular list */</pre></td></tr>
<tr id="L60" class="EvenSourceLine"><td>60</td><td><pre>int count_rest(node rest, node h)</pre></td></tr>
<tr id="L61" class="OddSourceLine"><td>61</td><td><pre></pre></td></tr>
<tr id="L62" class="EvenSourceLine"><td>62</td><td><pre>	requires rest::cll<p, n> & h = p </pre></td></tr>
<tr id="L63" class="OddSourceLine"><td>63</td><td><pre>	ensures rest::cll<p, n> & res = n; </pre></td></tr>
<tr id="L64" class="EvenSourceLine"><td>64</td><td><pre></pre></td></tr>
<tr id="L65" class="OddSourceLine"><td>65</td><td><pre>{</pre></td></tr>
<tr id="L66" class="EvenSourceLine"><td>66</td><td><pre>	int n;</pre></td></tr>
<tr id="L67" class="OddSourceLine"><td>67</td><td><pre>	</pre></td></tr>
<tr id="L68" class="EvenSourceLine"><td>68</td><td><pre>	if (rest == h)</pre></td></tr>
<tr id="L69" class="OddSourceLine"><td>69</td><td><pre>		return 0; </pre></td></tr>
<tr id="L70" class="EvenSourceLine"><td>70</td><td><pre>	else</pre></td></tr>
<tr id="L71" class="OddSourceLine"><td>71</td><td><pre>	{</pre></td></tr>
<tr id="L72" class="EvenSourceLine"><td>72</td><td><pre>		n = count_rest(rest.next, h);</pre></td></tr>
<tr id="L73" class="OddSourceLine"><td>73</td><td><pre>		n = n + 1;</pre></td></tr>
<tr id="L74" class="EvenSourceLine"><td>74</td><td><pre></pre></td></tr>
<tr id="L75" class="OddSourceLine"><td>75</td><td><pre>		return n;</pre></td></tr>
<tr id="L76" class="EvenSourceLine"><td>76</td><td><pre>	}</pre></td></tr>
<tr id="L77" class="OddSourceLine"><td>77</td><td><pre>}</pre></td></tr>
<tr id="L78" class="EvenSourceLine"><td>78</td><td><pre></pre></td></tr>
<tr id="L79" class="OddSourceLine"><td>79</td><td><pre>int count(node x)</pre></td></tr>
<tr id="L80" class="EvenSourceLine"><td>80</td><td><pre>	</pre></td></tr>
<tr id="L81" class="OddSourceLine"><td>81</td><td><pre>	requires x::hd<n></pre></td></tr>
<tr id="L82" class="EvenSourceLine"><td>82</td><td><pre>	ensures x::hd<n> & res = n; </pre></td></tr>
<tr id="L83" class="OddSourceLine"><td>83</td><td><pre>	</pre></td></tr>
<tr id="L84" class="EvenSourceLine"><td>84</td><td><pre>{</pre></td></tr>
<tr id="L85" class="OddSourceLine"><td>85</td><td><pre>	int n;</pre></td></tr>
<tr id="L86" class="EvenSourceLine"><td>86</td><td><pre></pre></td></tr>
<tr id="L87" class="OddSourceLine"><td>87</td><td><pre>	if (x == null)</pre></td></tr>
<tr id="L88" class="EvenSourceLine"><td>88</td><td><pre>		return 0;</pre></td></tr>
<tr id="L89" class="OddSourceLine"><td>89</td><td><pre>	else </pre></td></tr>
<tr id="L90" class="EvenSourceLine"><td>90</td><td><pre>	{</pre></td></tr>
<tr id="L91" class="OddSourceLine"><td>91</td><td><pre>		n = count_rest(x.next, x);</pre></td></tr>
<tr id="L92" class="EvenSourceLine"><td>92</td><td><pre>		n = n + 1;</pre></td></tr>
<tr id="L93" class="OddSourceLine"><td>93</td><td><pre></pre></td></tr>
<tr id="L94" class="EvenSourceLine"><td>94</td><td><pre>		return n;</pre></td></tr>
<tr id="L95" class="OddSourceLine"><td>95</td><td><pre>	}</pre></td></tr>
<tr id="L96" class="EvenSourceLine"><td>96</td><td><pre>}</pre></td></tr>
<tr id="L97" class="OddSourceLine"><td>97</td><td><pre></pre></td></tr>
<tr id="L98" class="EvenSourceLine"><td>98</td><td><pre></pre></td></tr>
<tr id="L99" class="OddSourceLine"><td>99</td><td><pre>/* function to delete the node after the head in a circular list */</pre></td></tr>
<tr id="L100" class="EvenSourceLine"><td>100</td><td><pre>void delete(ref node x)</pre></td></tr>
<tr id="L101" class="OddSourceLine"><td>101</td><td><pre></pre></td></tr>
<tr id="L102" class="EvenSourceLine"><td>102</td><td><pre>	requires x::hd<n> & n > 0</pre></td></tr>
<tr id="L103" class="OddSourceLine"><td>103</td><td><pre>	ensures x'::hd<n-1>;</pre></td></tr>
<tr id="L104" class="EvenSourceLine"><td>104</td><td><pre></pre></td></tr>
<tr id="L105" class="OddSourceLine"><td>105</td><td><pre>{</pre></td></tr>
<tr id="L106" class="EvenSourceLine"><td>106</td><td><pre>	node tmp;</pre></td></tr>
<tr id="L107" class="OddSourceLine"><td>107</td><td><pre></pre></td></tr>
<tr id="L108" class="EvenSourceLine"><td>108</td><td><pre>	if (x.next == x)</pre></td></tr>
<tr id="L109" class="OddSourceLine"><td>109</td><td><pre>		x = null;</pre></td></tr>
<tr id="L110" class="EvenSourceLine"><td>110</td><td><pre>	else</pre></td></tr>
<tr id="L111" class="OddSourceLine"><td>111</td><td><pre>	{</pre></td></tr>
<tr id="L112" class="EvenSourceLine"><td>112</td><td><pre>		tmp = x.next.next;</pre></td></tr>
<tr id="L113" class="OddSourceLine"><td>113</td><td><pre>		x.next = tmp;</pre></td></tr>
<tr id="L114" class="EvenSourceLine"><td>114</td><td><pre>	}</pre></td></tr>
<tr id="L115" class="OddSourceLine"><td>115</td><td><pre>}</pre></td></tr>
<tr id="L116" class="EvenSourceLine"><td>116</td><td><pre></pre></td></tr>
<tr id="L117" class="OddSourceLine"><td>117</td><td><pre></pre></td></tr>
</table></ul></li><li class="Collapsed proc">
Procedure delete<ul><li class="Collapsed procdef">Internal representation
<ul>void delete$node(  node x)<br/>
static  EBase exists (Expl)[](Impl)[n](ex)[]NN x::hd&lt;n&gt;@M[Orig][LHSCase]@ rem br[{179}] &amp;<br/>
       (([0!=n &amp; 0&lt;=n][null!=x])) &amp; {FLOW,(41,41)=__norm}<br/>
         EAssume 17::ref [x]<br/>
           EXISTS(flted_103_58: NN x&apos;::hd&lt;flted_103_58&gt;@M[Orig][LHSCase]@ rem br[{179,178}] &amp;<br/>
           (([0&lt;=flted_103_58 &amp; 1+flted_103_58=n])) &amp; {FLOW,(41,41)=__norm})<br/>
dynamic  []<br/>
<br/>
ref x<br/>
node tmp_59;<br/>
tmp_59 = null;<br/>
boolean v_bool_108_715;<br/>
v_bool_108_715 = {<br/>
node v_node_108_707;<br/>
v_node_108_707 = 91::bind x to (val_108_705,next_108_706) in <br/>
{next_108_706<br/>
};<br/>
90::eq___$node~node(v_node_108_707,x)<br/>
};<br/>
84::if (v_bool_108_715) LABEL! 84,0: x = null<br/>
else LABEL! 84,1: tmp_59 = {<br/>
node v_node_112_710;<br/>
v_node_112_710 = 86::bind x to (val_112_708,next_112_709) in <br/>
{next_112_709<br/>
};<br/>
86::bind v_node_112_710 to (val_112_711,next_112_712) in <br/>
{next_112_712<br/>
}<br/>
};<br/>
88::bind x to (val_113_713,next_113_714) in <br/>
{next_113_714 = tmp_59<br/>
}<br/>
<br/>
<br/>
{(100,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_15_820=n &amp; 0&lt;=flted_15_820&#8866; 0=flted_15_820
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_820] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_15_820 = n)) &amp; (0 &lt;= flted_15_820))))  | (0 = flted_15_820)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_15_820=n &amp; 0&lt;=flted_15_820&#8866; 0!=flted_15_820
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_820] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_15_820 = n)) &amp; (0 &lt;= flted_15_820))))  | (0 != flted_15_820)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_15_828=n &amp; 0&lt;=flted_15_828&#8866; 0=flted_15_828
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_828] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_15_828 = n)) &amp; (0 &lt;= flted_15_828))))  | (0 = flted_15_828)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_15_828=n &amp; 0&lt;=flted_15_828&#8866; 0!=flted_15_828
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_828] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_15_828 = n)) &amp; (0 &lt;= flted_15_828))))  | (0 != flted_15_828)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> self_826!=null &amp; v_node_108_707&apos;!=self_826&#8866; v_node_108_707&apos;=null
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[self_826, v_node_108_707PRMD] : (( (not (((self_826 &gt; 0) &amp; (v_node_108_707PRMD != self_826))))  | (v_node_108_707PRMD &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[self_826,v_node_108_707PRMD]: 1 &lt;= v_node_108_707PRMD &lt; self_826}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_15_828=n &amp; 0&lt;=flted_15_828 &amp; 0!=flted_15_828 &amp; 1+<br/>
flted_11_858=flted_15_828 &amp; 0&lt;=flted_11_858&#8866; 0=flted_11_858
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_828, flted_11_858] : (( (not ((((((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_15_828 = n)) &amp; (0 &lt;= flted_15_828)) &amp; (0 != flted_15_828)) &amp; (1 + flted_11_858 = flted_15_828)) &amp; (0 &lt;= flted_11_858))))  | (0 = flted_11_858)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1,n-2]: 3 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_15_828=n &amp; 0&lt;=flted_15_828 &amp; 0!=flted_15_828 &amp; 1+<br/>
flted_11_858=flted_15_828 &amp; 0&lt;=flted_11_858&#8866; 0!=flted_11_858
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_828, flted_11_858] : (( (not ((((((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_15_828 = n)) &amp; (0 &lt;= flted_15_828)) &amp; (0 != flted_15_828)) &amp; (1 + flted_11_858 = flted_15_828)) &amp; (0 &lt;= flted_11_858))))  | (0 != flted_11_858)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[2,1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> tmp_59&apos;=tmp_59&apos;&#8866; tmp_59&apos;=null
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[tmp_59PRMD] : (((tmp_59PRMD != tmp_59PRMD) | (tmp_59PRMD &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[tmp_59PRMD]: 1 &lt;= tmp_59PRMD}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 0!=flted_15_828 &amp; 0&lt;=flted_15_828 &amp; 1+flted_15_828=n &amp; <br/>
0&lt;=flted_11_866 &amp; 1+flted_11_866=flted_15_828&#8866; 0=flted_11_866
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_828, flted_11_866] : (( (not ((((((((0 != n) &amp; (0 &lt;= n)) &amp; (0 != flted_15_828)) &amp; (0 &lt;= flted_15_828)) &amp; (1 + flted_15_828 = n)) &amp; (0 &lt;= flted_11_866)) &amp; (1 + flted_11_866 = flted_15_828))))  | (0 = flted_11_866)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1,n-2]: 3 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 0!=flted_15_828 &amp; 0&lt;=flted_15_828 &amp; 1+flted_15_828=n &amp; <br/>
0&lt;=flted_11_866 &amp; 1+flted_11_866=flted_15_828&#8866; 0!=flted_11_866
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_828, flted_11_866] : (( (not ((((((((0 != n) &amp; (0 &lt;= n)) &amp; (0 != flted_15_828)) &amp; (0 &lt;= flted_15_828)) &amp; (1 + flted_15_828 = n)) &amp; (0 &lt;= flted_11_866)) &amp; (1 + flted_11_866 = flted_15_828))))  | (0 != flted_11_866)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[2,1,0]}</li></ul></ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul> r_867=r_867&#8866; r_867=null
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[r_867] : (((r_867 != r_867) | (r_867 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[r_867]: 1 &lt;= r_867}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> null=x&apos;&#8866; null=x&apos;
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[xPRMD] : (((xPRMD &gt; 0) | (xPRMD &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[xPRMD]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> 0&lt;=n &amp; 1+0=n &amp; 0!=n&#8866; 1+0=n
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n] : (( (not ((((0 &lt;= n) &amp; (1 + 0 = n)) &amp; (0 != n))))  | (1 + 0 = n)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 1&lt;=n &amp; 0&lt;=n &amp; 0!=flted_15_828 &amp; 0&lt;=flted_15_828 &amp; 1+flted_15_828=n &amp; <br/>
r_829!=null &amp; p_864!=r_829 &amp; p_864!=null &amp; 0&lt;=flted_11_866 &amp; 1+<br/>
flted_11_866=flted_15_828&#8866; p_864=tmp_59&apos; | 0=flted_11_866
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, r_829, flted_15_828, p_864, tmp_59PRMD, flted_11_866] : (( (not ((((((((((((0 != n) &amp; (1 &lt;= n)) &amp; (0 &lt;= n)) &amp; (0 != flted_15_828)) &amp; (0 &lt;= flted_15_828)) &amp; (1 + flted_15_828 = n)) &amp; (r_829 &gt; 0)) &amp; (p_864 != r_829)) &amp; (p_864 &gt; 0)) &amp; (0 &lt;= flted_11_866)) &amp; (1 + flted_11_866 = flted_15_828))))  | ((p_864 = tmp_59PRMD) | (0 = flted_11_866))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[n,r_829,n-1,p_864,tmp_59PRMD,n-2]: tmp_59PRMD+1, 1 &lt;= p_864 &lt; r_829 &amp;&amp; 3 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> r_829!=null &amp; p_864!=r_829 &amp; p_864!=null&#8866; p_864=p_864
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[r_829, p_864] : (( (not ((((r_829 &gt; 0) &amp; (p_864 != r_829)) &amp; (p_864 &gt; 0))))  | (p_864 = p_864)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[r_829,p_864]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> r_829!=null &amp; p_864!=r_829 &amp; p_864!=null&#8866; tmp_59&apos;=p_864
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[r_829, tmp_59PRMD, p_864] : (( (not ((((r_829 &gt; 0) &amp; (p_864 != r_829)) &amp; (p_864 &gt; 0))))  | (tmp_59PRMD = p_864)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[r_829,tmp_59PRMD,p_864]: 1 &lt;= p_864 &lt;= tmp_59PRMD-1, r_829-1}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> r_829!=null &amp; p_864!=r_829 &amp; p_864!=null&#8866; null=p_864
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[r_829, p_864] : (( (not ((((r_829 &gt; 0) &amp; (p_864 != r_829)) &amp; (p_864 &gt; 0))))  | (p_864 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[r_829,p_864]: 1 &lt;= p_864 &lt; r_829}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> 0!=flted_15_828 &amp; 0&lt;=flted_15_828 &amp; 1+flted_15_828=n &amp; 0&lt;=flted_11_866 &amp; 1+<br/>
flted_11_866=flted_15_828 &amp; 0&lt;=n &amp; 0!=n&#8866; 1+flted_11_866+1=n
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[flted_15_828, flted_11_866, n] : (( (not ((((((((0 != flted_15_828) &amp; (0 &lt;= flted_15_828)) &amp; (1 + flted_15_828 = n)) &amp; (0 &lt;= flted_11_866)) &amp; (1 + flted_11_866 = flted_15_828)) &amp; (0 &lt;= n)) &amp; (0 != n))))  | (1 + flted_11_866 + 1 = n)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[flted_15_828,flted_11_866,n]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure count<ul><li class="Collapsed procdef">Internal representation
<ul>int count$node(  node x)<br/>
static  EBase exists (Expl)[](Impl)[n](ex)[]NN x::hd&lt;n&gt;@M[Orig][LHSCase]@ rem br[{179,178}] &amp;<br/>
       (([0&lt;=n])) &amp; {FLOW,(41,41)=__norm}<br/>
         EAssume 12::<br/>
           EXISTS(n_60: NN x::hd&lt;n_60&gt;@M[Orig][LHSCase]@ rem br[{179,178}] &amp;<br/>
           (([n=res &amp; n=n_60 &amp; 0&lt;=n_60])) &amp; {FLOW,(41,41)=__norm})<br/>
dynamic  []<br/>
int n_61;<br/>
n_61 = 0;<br/>
boolean v_bool_87_732;<br/>
v_bool_87_732 = {<br/>
100::is_null___$node(x)<br/>
};<br/>
92::if (v_bool_87_732) LABEL! 92,0: int v_int_88_726;<br/>
v_int_88_726 = 0;<br/>
99::return v_int_88_726<br/>
else LABEL! 92,1: n_61 = {<br/>
node v_node_91_729;<br/>
v_node_91_729 = 95::bind x to (val_91_727,next_91_728) in <br/>
{next_91_728<br/>
};<br/>
94::count_rest$node~node(v_node_91_729,x)<br/>
};<br/>
n_61 = {<br/>
int v_int_92_730;<br/>
v_int_92_730 = 1;<br/>
97::add___$int~int(n_61,v_int_92_730)<br/>
};<br/>
int v_int_94_731;<br/>
v_int_94_731 = n_61;<br/>
98::return v_int_94_731<br/>
<br/>
<br/>
{(79,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pre">
Precondition of procedure call 100::is_null___$node(x) at <a href="#L87">line 87</a> holds<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul> null=x&apos; &amp; null=x&#8866; null=x
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[xPRMD, x] : (( (not (((xPRMD &lt; 1) &amp; (x &lt; 1))))  | (x &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[xPRMD,x]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> null=x&apos; &amp; null=x&#8866; x!=null
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[xPRMD, x] : (( (not (((xPRMD &lt; 1) &amp; (x &lt; 1))))  | (x &gt; 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[xPRMD,x]: xPRMD &lt;= 0 &amp;&amp; x &lt;= 0}</li></ul></ul></li>
</ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; 1+flted_15_914=n &amp; 0&lt;=flted_15_914&#8866; 0=flted_15_914
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_914] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (1 + flted_15_914 = n)) &amp; (0 &lt;= flted_15_914))))  | (0 = flted_15_914)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; 1+flted_15_914=n &amp; 0&lt;=flted_15_914&#8866; 0!=flted_15_914
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_914] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (1 + flted_15_914 = n)) &amp; (0 &lt;= flted_15_914))))  | (0 != flted_15_914)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pre">
Precondition of procedure call 94::count_rest$node~node(v_node_91_729,x) at <a href="#L91">line 91</a> holds<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; 1+flted_15_922=n &amp; 0&lt;=flted_15_922 &amp; self_920!=null&#8866; self_920=r_923 | 0=flted_15_922
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, self_920, r_923, flted_15_922] : (( (not ((((((0 &lt;= n) &amp; (0 != n)) &amp; (1 + flted_15_922 = n)) &amp; (0 &lt;= flted_15_922)) &amp; (self_920 &gt; 0))))  | ((self_920 = r_923) | (0 = flted_15_922))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[n,self_920,r_923,n-1]: r_923 &lt; self_920 &amp;&amp; 2 &lt;= n &amp;&amp; 1 &lt;= self_920}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> r_923=r_923&#8866; r_923=r_923
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[r_923] : (((r_923 != r_923) | (r_923 = r_923)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[r_923]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> p!=null&#8866; p=p
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[p] : (((p &lt; 1) | (p = p)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[p]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> self_920!=null&#8866; r_923=self_920
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[r_923, self_920] : (((self_920 &lt; 1) | (r_923 = self_920)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[r_923,self_920]: 1 &lt;= self_920 &lt; r_923}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> r_923=r_923&#8866; r_923=null
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[r_923] : (((r_923 != r_923) | (r_923 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[r_923]: 1 &lt;= r_923}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_15_922=n &amp; 0&lt;=flted_15_922&#8866; 0=flted_15_922
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_922] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_15_922 = n)) &amp; (0 &lt;= flted_15_922))))  | (0 = flted_15_922)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_15_922=n &amp; 0&lt;=flted_15_922&#8866; 0!=flted_15_922
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_922] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_15_922 = n)) &amp; (0 &lt;= flted_15_922))))  | (0 != flted_15_922)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
</ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; res=n_61&apos;+1 &amp; 0&lt;=n_61&apos; &amp; 1+n_61&apos;=n&#8866; 0=n_61&apos;
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[res, n, n_61PRMD] : (( (not ((((((0 &lt;= n) &amp; (0 != n)) &amp; (res = n_61PRMD + 1)) &amp; (0 &lt;= n_61PRMD)) &amp; (1 + n_61PRMD = n))))  | (0 = n_61PRMD)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[res,res,res-1]: 2 &lt;= res}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; res=n_61&apos;+1 &amp; 0&lt;=n_61&apos; &amp; 1+n_61&apos;=n&#8866; 0!=n_61&apos;
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[res, n, n_61PRMD] : (( (not ((((((0 &lt;= n) &amp; (0 != n)) &amp; (res = n_61PRMD + 1)) &amp; (0 &lt;= n_61PRMD)) &amp; (1 + n_61PRMD = n))))  | (0 != n_61PRMD)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,1,0]}</li></ul></ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_15_922=n &amp; res=flted_15_922+1 &amp; 0&lt;=flted_15_922&#8866; 0=flted_15_922
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, res, flted_15_922] : (( (not ((((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_15_922 = n)) &amp; (res = flted_15_922 + 1)) &amp; (0 &lt;= flted_15_922))))  | (0 = flted_15_922)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_15_922=n &amp; res=flted_15_922+1 &amp; 0&lt;=flted_15_922&#8866; 0!=flted_15_922
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, res, flted_15_922] : (( (not ((((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_15_922 = n)) &amp; (res = flted_15_922 + 1)) &amp; (0 &lt;= flted_15_922))))  | (0 != flted_15_922)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> null=x&#8866; null=x | 0=0
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[x] : (((x &gt; 0) | ((x &lt; 1) | (0 = 0))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[x]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> x=null&#8866; null=x
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[x] : (((x &gt; 0) | (x &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[x]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> null=x&#8866; null=x
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[x] : (((x &gt; 0) | (x &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[x]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; p!=null &amp; 1+flted_15_922=n &amp; res=flted_15_922+1 &amp; <br/>
0&lt;=flted_15_922&#8866; p=r_951 | 0=flted_15_922
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, res, p, r_951, flted_15_922] : (( (not (((((((0 != n) &amp; (0 &lt;= n)) &amp; (p &gt; 0)) &amp; (1 + flted_15_922 = n)) &amp; (res = flted_15_922 + 1)) &amp; (0 &lt;= flted_15_922))))  | ((p = r_951) | (0 = flted_15_922))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[n,n,p,r_951,n-1]: r_951 &lt; p &amp;&amp; 2 &lt;= n &amp;&amp; 1 &lt;= p}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> p!=null&#8866; r_951=p
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[r_951, p] : (((p &lt; 1) | (r_951 = p)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[r_951,p]: 1 &lt;= p &lt; r_951}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> p!=null&#8866; null=p
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[p] : (((p &lt; 1) | (p &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[p]: 1 &lt;= p}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> 0&lt;=flted_15_922 &amp; 1+flted_15_922=n &amp; res=flted_15_922+1 &amp; 0&lt;=n &amp; 0!=n&#8866; n=res
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[flted_15_922, n, res] : (( (not ((((((0 &lt;= flted_15_922) &amp; (1 + flted_15_922 = n)) &amp; (res = flted_15_922 + 1)) &amp; (0 &lt;= n)) &amp; (0 != n))))  | (n = res)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[flted_15_922,n,res]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_15_922=n &amp; res=flted_15_922+1 &amp; 0&lt;=flted_15_922&#8866; 1+flted_15_922=res
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_922, res] : (( (not ((((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_15_922 = n)) &amp; (res = flted_15_922 + 1)) &amp; (0 &lt;= flted_15_922))))  | (1 + flted_15_922 = res)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,flted_15_922,res]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure count_rest<ul><li class="Collapsed procdef">Internal representation
<ul>int count_rest$node~node(  node rest,  node h)<br/>
static  EBase exists (Expl)[](Impl)[p; <br/>
       n](ex)[]NN rest::cll&lt;p,n&gt;@M[Orig][LHSCase]@ rem br[{177,176}] &amp; (<br/>
       ([p=h][0&lt;=n])) &amp; {FLOW,(41,41)=__norm}<br/>
         EAssume 7::<br/>
           EXISTS(p_62,<br/>
           n_63: NN rest::cll&lt;p_62,n_63&gt;@M[Orig][LHSCase]@ rem br[{177,176}] &amp;<br/>
           (([n=res &amp; n=n_63 &amp; 0&lt;=n_63][p=p_62])) &amp; {FLOW,(41,41)=__norm})<br/>
dynamic  []<br/>
int n_64;<br/>
n_64 = 0;<br/>
boolean v_bool_68_758;<br/>
v_bool_68_758 = {<br/>
109::eq___$node~node(rest,h)<br/>
};<br/>
101::if (v_bool_68_758) LABEL! 101,0: int v_int_69_752;<br/>
v_int_69_752 = 0;<br/>
108::return v_int_69_752<br/>
else LABEL! 101,1: n_64 = {<br/>
node v_node_72_755;<br/>
v_node_72_755 = 104::bind rest to (val_72_753,next_72_754) in <br/>
{next_72_754<br/>
};<br/>
103::count_rest$node~node(v_node_72_755,h) rec<br/>
};<br/>
n_64 = {<br/>
int v_int_73_756;<br/>
v_int_73_756 = 1;<br/>
106::add___$int~int(n_64,v_int_73_756)<br/>
};<br/>
int v_int_75_757;<br/>
v_int_75_757 = n_64;<br/>
107::return v_int_75_757<br/>
<br/>
<br/>
{(60,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pureimplyinvalid">Verification condition
<ul> h=h&#8866; h=null
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[h] : (((h != h) | (h &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[h]: 1 &lt;= h}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> rest&apos;!=h&apos;&#8866; rest&apos;=null
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[hPRMD, restPRMD] : (((restPRMD = hPRMD) | (restPRMD &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[hPRMD,restPRMD]: hPRMD &lt; restPRMD &amp;&amp; 1 &lt;= restPRMD}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; 1+flted_11_992=n &amp; 0&lt;=flted_11_992&#8866; 0=flted_11_992
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_11_992] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (1 + flted_11_992 = n)) &amp; (0 &lt;= flted_11_992))))  | (0 = flted_11_992)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; 1+flted_11_992=n &amp; 0&lt;=flted_11_992&#8866; 0!=flted_11_992
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_11_992] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (1 + flted_11_992 = n)) &amp; (0 &lt;= flted_11_992))))  | (0 != flted_11_992)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pre">
Precondition of procedure call 103::count_rest$node~node(v_node_72_755,h) rec at <a href="#L72">line 72</a> holds<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul> rest&apos;!=null &amp; 0&lt;=n &amp; 0!=n &amp; 1+flted_11_1000=n &amp; 0&lt;=flted_11_1000 &amp; <br/>
p_998!=rest&apos;&#8866; p_998=r_1001 | 0=flted_11_1000
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, restPRMD, p_998, r_1001, flted_11_1000] : (( (not (((((((restPRMD &gt; 0) &amp; (0 &lt;= n)) &amp; (0 != n)) &amp; (1 + flted_11_1000 = n)) &amp; (0 &lt;= flted_11_1000)) &amp; (p_998 != restPRMD))))  | ((p_998 = r_1001) | (0 = flted_11_1000))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[n,restPRMD,p_998,r_1001,n-1]: r_1001+1 &lt;= p_998 &lt; restPRMD &amp;&amp; 1 &lt;= restPRMD &amp;&amp; 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> r_1001=r_1001&#8866; r_1001=r_1001
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[r_1001] : (((r_1001 != r_1001) | (r_1001 = r_1001)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[r_1001]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> rest&apos;!=null &amp; p_1004!=rest&apos;&#8866; p_1004=p_1004
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[restPRMD, p_1004] : (( (not (((restPRMD &gt; 0) &amp; (p_1004 != restPRMD))))  | (p_1004 = p_1004)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[restPRMD,p_1004]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> rest&apos;!=null &amp; p_998!=rest&apos;&#8866; r_1001=p_998
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[restPRMD, r_1001, p_998] : (( (not (((restPRMD &gt; 0) &amp; (p_998 != restPRMD))))  | (r_1001 = p_998)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[restPRMD,r_1001,p_998]: p_998 &lt;= r_1001-1, restPRMD-1 &amp;&amp; 1 &lt;= restPRMD}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> r_1001=r_1001&#8866; r_1001=null
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[r_1001] : (((r_1001 != r_1001) | (r_1001 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[r_1001]: 1 &lt;= r_1001}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_11_1000=n &amp; 0&lt;=flted_11_1000&#8866; 0=flted_11_1000
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_11_1000] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_11_1000 = n)) &amp; (0 &lt;= flted_11_1000))))  | (0 = flted_11_1000)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_11_1000=n &amp; 0&lt;=flted_11_1000&#8866; 0!=flted_11_1000
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_11_1000] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_11_1000 = n)) &amp; (0 &lt;= flted_11_1000))))  | (0 != flted_11_1000)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
</ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; res=n_64&apos;+1 &amp; 0&lt;=n_64&apos; &amp; 1+n_64&apos;=n&#8866; 0=n_64&apos;
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[res, n, n_64PRMD] : (( (not ((((((0 &lt;= n) &amp; (0 != n)) &amp; (res = n_64PRMD + 1)) &amp; (0 &lt;= n_64PRMD)) &amp; (1 + n_64PRMD = n))))  | (0 = n_64PRMD)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[res,res,res-1]: 2 &lt;= res}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; res=n_64&apos;+1 &amp; 0&lt;=n_64&apos; &amp; 1+n_64&apos;=n&#8866; 0!=n_64&apos;
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[res, n, n_64PRMD] : (( (not ((((((0 &lt;= n) &amp; (0 != n)) &amp; (res = n_64PRMD + 1)) &amp; (0 &lt;= n_64PRMD)) &amp; (1 + n_64PRMD = n))))  | (0 != n_64PRMD)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,1,0]}</li></ul></ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_11_1000=n &amp; res=flted_11_1000+1 &amp; 0&lt;=flted_11_1000&#8866; 0=flted_11_1000
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, res, flted_11_1000] : (( (not ((((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_11_1000 = n)) &amp; (res = flted_11_1000 + 1)) &amp; (0 &lt;= flted_11_1000))))  | (0 = flted_11_1000)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_11_1000=n &amp; res=flted_11_1000+1 &amp; 0&lt;=flted_11_1000&#8866; 0!=flted_11_1000
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, res, flted_11_1000] : (( (not ((((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_11_1000 = n)) &amp; (res = flted_11_1000 + 1)) &amp; (0 &lt;= flted_11_1000))))  | (0 != flted_11_1000)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> true&#8866; h=h | 0=0
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[h] : (((h = h) | (0 = 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[h]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> h=h&#8866; h=h
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[h] : (((h != h) | (h = h)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[h]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> rest!=null &amp; 0!=n &amp; 0&lt;=n &amp; 1+flted_11_1000=n &amp; res=flted_11_1000+1 &amp; <br/>
0&lt;=flted_11_1000 &amp; p_1004!=rest&#8866; p_1004=r_1033 | 0=flted_11_1000
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, res, rest, p_1004, r_1033, flted_11_1000] : (( (not ((((((((rest &gt; 0) &amp; (0 != n)) &amp; (0 &lt;= n)) &amp; (1 + flted_11_1000 = n)) &amp; (res = flted_11_1000 + 1)) &amp; (0 &lt;= flted_11_1000)) &amp; (p_1004 != rest))))  | ((p_1004 = r_1033) | (0 = flted_11_1000))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[n,n,rest,p_1004,r_1033,n-1]: r_1033 &lt; p_1004 &lt; rest &amp;&amp; 1 &lt;= rest &amp;&amp; 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> rest!=null &amp; p_1004!=rest&#8866; rest!=p_1004
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[rest, p_1004] : (( (not (((rest &gt; 0) &amp; (p_1004 != rest))))  | (rest != p_1004)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[rest,p_1004]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> rest!=null &amp; p_1004!=rest&#8866; rest!=r_1033
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[p_1004, rest, r_1033] : (( (not (((rest &gt; 0) &amp; (p_1004 != rest))))  | (rest != r_1033)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[p_1004,rest,rest]: p_1004 &lt; rest &amp;&amp; 1 &lt;= rest}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> p_1004!=rest &amp; rest!=null&#8866; rest!=r_1033
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[p_1004, rest, r_1033] : (( (not (((p_1004 != rest) &amp; (rest &gt; 0))))  | (rest != r_1033)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[p_1004,rest,rest]: p_1004 &lt; rest &amp;&amp; 1 &lt;= rest}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> p_1004!=rest &amp; rest!=null&#8866; rest!=p_1004
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[rest, p_1004] : (( (not (((p_1004 != rest) &amp; (rest &gt; 0))))  | (rest != p_1004)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[rest,p_1004]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> 0&lt;=flted_11_1000 &amp; 1+flted_11_1000=n &amp; res=flted_11_1000+1 &amp; 0&lt;=n &amp; 0!=n&#8866; n=res
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[flted_11_1000, n, res] : (( (not ((((((0 &lt;= flted_11_1000) &amp; (1 + flted_11_1000 = n)) &amp; (res = flted_11_1000 + 1)) &amp; (0 &lt;= n)) &amp; (0 != n))))  | (n = res)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[flted_11_1000,n,res]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_11_1000=n &amp; res=flted_11_1000+1 &amp; 0&lt;=flted_11_1000&#8866; 1+flted_11_1000=res
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_11_1000, res] : (( (not ((((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_11_1000 = n)) &amp; (res = flted_11_1000 + 1)) &amp; (0 &lt;= flted_11_1000))))  | (1 + flted_11_1000 = res)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,flted_11_1000,res]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> rest!=null &amp; p_1004!=rest&#8866; p_1004=p_1004
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[rest, p_1004] : (( (not (((rest &gt; 0) &amp; (p_1004 != rest))))  | (p_1004 = p_1004)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[rest,p_1004]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> 0&lt;=flted_11_1000 &amp; 1+flted_11_1000=n &amp; res=flted_11_1000+1 &amp; 0&lt;=n &amp; 0!=n&#8866; res=n
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[flted_11_1000, res, n] : (( (not ((((((0 &lt;= flted_11_1000) &amp; (1 + flted_11_1000 = n)) &amp; (res = flted_11_1000 + 1)) &amp; (0 &lt;= n)) &amp; (0 != n))))  | (res = n)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[flted_11_1000,res,n]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=flted_11_1000 &amp; 0&lt;=n &amp; 1+flted_11_1000=n &amp; res=flted_11_1000+1&#8866; res=0
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_11_1000, res] : (( (not ((((((0 != n) &amp; (0 &lt;= flted_11_1000)) &amp; (0 &lt;= n)) &amp; (1 + flted_11_1000 = n)) &amp; (res = flted_11_1000 + 1))))  | (res = 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1,n]: 1 &lt;= n}</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure insert<ul><li class="Collapsed procdef">Internal representation
<ul>void insert$node~int(  node x,  int v)<br/>
static  EBase exists (Expl)[](Impl)[n](ex)[]NN x::hd&lt;n&gt;@M[Orig][LHSCase]@ rem br[{179}] &amp;<br/>
       (([0!=n &amp; 0&lt;=n][null!=x])) &amp; {FLOW,(41,41)=__norm}<br/>
         EAssume 4::<br/>
           EXISTS(flted_43_66: NN x::hd&lt;flted_43_66&gt;@M[Orig][LHSCase]@ rem br[{179,178}] &amp;<br/>
           (([0&lt;=flted_43_66 &amp; -1+flted_43_66=n])) &amp; {FLOW,(41,41)=__norm})<br/>
dynamic  []<br/>
node tmp_67;<br/>
tmp_67 = null;<br/>
tmp_67 = {<br/>
node v_node_49_774;<br/>
v_node_49_774 = 111::bind x to (val_49_772,next_49_773) in <br/>
{next_49_773<br/>
};<br/>
newnode(v,v_node_49_774)<br/>
};<br/>
113::bind x to (val_51_775,next_51_776) in <br/>
{next_51_776 = tmp_67<br/>
}<br/>
<br/>
{(40,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_15_1067=n &amp; 0&lt;=flted_15_1067&#8866; 0=flted_15_1067
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_1067] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_15_1067 = n)) &amp; (0 &lt;= flted_15_1067))))  | (0 = flted_15_1067)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=n &amp; 1+flted_15_1067=n &amp; 0&lt;=flted_15_1067&#8866; 0!=flted_15_1067
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_1067] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_15_1067 = n)) &amp; (0 &lt;= flted_15_1067))))  | (0 != flted_15_1067)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; 0&lt;=flted_15_1075 &amp; 1+flted_15_1075=n&#8866; 0=flted_15_1075
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_1075] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (0 &lt;= flted_15_1075)) &amp; (1 + flted_15_1075 = n))))  | (0 = flted_15_1075)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> 0&lt;=n &amp; 0!=n &amp; 0&lt;=flted_15_1075 &amp; 1+flted_15_1075=n&#8866; 0!=flted_15_1075
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_15_1075] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (0 &lt;= flted_15_1075)) &amp; (1 + flted_15_1075 = n))))  | (0 != flted_15_1075)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul> 1&lt;=n &amp; 0&lt;=n &amp; 0!=n &amp; self_1073!=null &amp; 0&lt;=flted_15_1075 &amp; 1+flted_15_1075=n&#8866; self_1073=r_1094 | 0=flted_15_1075
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, self_1073, r_1094, flted_15_1075] : (( (not (((((((1 &lt;= n) &amp; (0 &lt;= n)) &amp; (0 != n)) &amp; (self_1073 &gt; 0)) &amp; (0 &lt;= flted_15_1075)) &amp; (1 + flted_15_1075 = n))))  | ((self_1073 = r_1094) | (0 = flted_15_1075))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[n,self_1073,r_1094,n-1]: r_1094 &lt; self_1073 &amp;&amp; 2 &lt;= n &amp;&amp; 1 &lt;= self_1073}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> r_1084!=null&#8866; r_1084!=r_1094
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[r_1084, r_1094] : (((r_1084 &lt; 1) | (r_1084 != r_1094)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[r_1084,r_1084]: 1 &lt;= r_1084}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> tmp_67&apos;!=null &amp; self_1073!=null &amp; tmp_67&apos;!=self_1073&#8866; self_1073=self_1073
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[tmp_67PRMD, self_1073] : (( (not ((((tmp_67PRMD &gt; 0) &amp; (self_1073 &gt; 0)) &amp; (tmp_67PRMD != self_1073))))  | (self_1073 = self_1073)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[tmp_67PRMD,self_1073]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> r_1084!=null &amp; self_1073!=null&#8866; r_1084=self_1073
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[r_1084, self_1073] : (( (not (((r_1084 &gt; 0) &amp; (self_1073 &gt; 0))))  | (r_1084 = self_1073)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[r_1084,self_1073]: 1 &lt;= self_1073 &lt; r_1084}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> self_1073!=null &amp; r_1084!=null&#8866; r_1084=self_1073
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[r_1084, self_1073] : (( (not (((self_1073 &gt; 0) &amp; (r_1084 &gt; 0))))  | (r_1084 = self_1073)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul> {[r_1084,self_1073]: 1 &lt;= self_1073 &lt; r_1084}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul> self_1073!=null&#8866; null=self_1073
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[self_1073] : (((self_1073 &lt; 1) | (self_1073 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[self_1073]: 1 &lt;= self_1073}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul> 0!=n &amp; 0&lt;=flted_15_1075 &amp; 0&lt;=n &amp; 1+flted_15_1075=n&#8866; 2+flted_15_1075=n+1
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[flted_15_1075, n] : (( (not (((((0 != n) &amp; (0 &lt;= flted_15_1075)) &amp; (0 &lt;= n)) &amp; (1 + flted_15_1075 = n))))  | (2 + flted_15_1075 = n + 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[flted_15_1075,n]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure test<ul><li class="Collapsed procdef">Internal representation
<ul>node test$()<br/>
static  EBase true &amp; (()) &amp; {FLOW,(41,41)=__norm}<br/>
         EAssume 1::<br/>
           true &amp; (()) &amp; {FLOW,(41,41)=__norm}<br/>
dynamic  []<br/>
node null_68;<br/>
null_68 = null;<br/>
node tmp_69;<br/>
tmp_69 = {<br/>
int v_int_24_778;<br/>
v_int_24_778 = 10;<br/>
newnode(v_int_24_778,null_68)<br/>
};<br/>
115::bind tmp_69 to (val_30_779,next_30_780) in <br/>
{next_30_780 = tmp_69<br/>
};<br/>
node tmp2_70;<br/>
tmp2_70 = {<br/>
int v_int_32_784;<br/>
v_int_32_784 = 20;<br/>
node v_node_32_783;<br/>
v_node_32_783 = 116::bind tmp_69 to (val_32_781,next_32_782) in <br/>
{next_32_782<br/>
};<br/>
newnode(v_int_32_784,v_node_32_783)<br/>
};<br/>
118::bind tmp_69 to (val_33_785,next_33_786) in <br/>
{next_33_786 = tmp2_70<br/>
};<br/>
node v_node_37_787;<br/>
v_node_37_787 = tmp_69;<br/>
119::return v_node_37_787<br/>
<br/>
{(19,0),(0,-1)}<br/>
</ul></li><li class="Collapsed post">
Procedure post-condition holds
<ul></ul></li>
</ul></li>
<li class="Collapsed term">Termination of all procedures
<ul></ul></li>
</ul>
<script>
	SetupTreeView("ProofTree");
</script>
</body>
</html>