<html>
<head>	<link rel="stylesheet" type="text/css" href="hipsleek.css" />	<script type="text/javascript" src="hipsleek.js"></script></head>
<body>
<h1>./hip/ll.ss</h1>
<ul class="TreeView" id="ProofTree"><li class="Collapsed progsource">Source<ul><table><tr id="L1" class="OddSourceLine"><td>1</td><td><pre>/* singly linked lists */</pre></td></tr>
<tr id="L2" class="EvenSourceLine"><td>2</td><td><pre></pre></td></tr>
<tr id="L3" class="OddSourceLine"><td>3</td><td><pre>/* representation of a node */</pre></td></tr>
<tr id="L4" class="EvenSourceLine"><td>4</td><td><pre></pre></td></tr>
<tr id="L5" class="OddSourceLine"><td>5</td><td><pre>data node {</pre></td></tr>
<tr id="L6" class="EvenSourceLine"><td>6</td><td><pre>	int val; </pre></td></tr>
<tr id="L7" class="OddSourceLine"><td>7</td><td><pre>	node next;	</pre></td></tr>
<tr id="L8" class="EvenSourceLine"><td>8</td><td><pre>}</pre></td></tr>
<tr id="L9" class="OddSourceLine"><td>9</td><td><pre></pre></td></tr>
<tr id="L10" class="EvenSourceLine"><td>10</td><td><pre></pre></td></tr>
<tr id="L11" class="OddSourceLine"><td>11</td><td><pre>/* view for a singly linked list */</pre></td></tr>
<tr id="L12" class="EvenSourceLine"><td>12</td><td><pre></pre></td></tr>
<tr id="L13" class="OddSourceLine"><td>13</td><td><pre>ll<n> == self = null & n = 0 </pre></td></tr>
<tr id="L14" class="EvenSourceLine"><td>14</td><td><pre>	or self::node<_, q> * q::ll<n-1> </pre></td></tr>
<tr id="L15" class="OddSourceLine"><td>15</td><td><pre>  inv n >= 0;</pre></td></tr>
<tr id="L16" class="EvenSourceLine"><td>16</td><td><pre></pre></td></tr>
<tr id="L17" class="OddSourceLine"><td>17</td><td><pre>	</pre></td></tr>
<tr id="L18" class="EvenSourceLine"><td>18</td><td><pre>	</pre></td></tr>
<tr id="L19" class="OddSourceLine"><td>19</td><td><pre>/*ll1<S> == self = null & S = {} </pre></td></tr>
<tr id="L20" class="EvenSourceLine"><td>20</td><td><pre>	or self::node<v, q> * q::ll1<S1> & S = union(S1, {v});*/</pre></td></tr>
<tr id="L21" class="OddSourceLine"><td>21</td><td><pre></pre></td></tr>
<tr id="L22" class="EvenSourceLine"><td>22</td><td><pre>/*ll2<n, S> == self=null & n=0 & S={}</pre></td></tr>
<tr id="L23" class="OddSourceLine"><td>23</td><td><pre>	or self::node<v, r> * r::ll2<m, S1> & n=m+1   & S=union(S1, {v});*/</pre></td></tr>
<tr id="L24" class="EvenSourceLine"><td>24</td><td><pre></pre></td></tr>
<tr id="L25" class="OddSourceLine"><td>25</td><td><pre>/* append two singly linked lists */</pre></td></tr>
<tr id="L26" class="EvenSourceLine"><td>26</td><td><pre>void append2(node x, node y)</pre></td></tr>
<tr id="L27" class="OddSourceLine"><td>27</td><td><pre>  requires x::ll<n1> * y::ll<n2> & x!=null // & n1>0 //x!=null // & n1>0 & x != null</pre></td></tr>
<tr id="L28" class="EvenSourceLine"><td>28</td><td><pre>  ensures x::ll<n1+n2>;</pre></td></tr>
<tr id="L29" class="OddSourceLine"><td>29</td><td><pre>{    </pre></td></tr>
<tr id="L30" class="EvenSourceLine"><td>30</td><td><pre>	if (x.next == null) </pre></td></tr>
<tr id="L31" class="OddSourceLine"><td>31</td><td><pre>           x.next = y;</pre></td></tr>
<tr id="L32" class="EvenSourceLine"><td>32</td><td><pre>	else</pre></td></tr>
<tr id="L33" class="OddSourceLine"><td>33</td><td><pre>           append2(x.next, y);</pre></td></tr>
<tr id="L34" class="EvenSourceLine"><td>34</td><td><pre>}</pre></td></tr>
<tr id="L35" class="OddSourceLine"><td>35</td><td><pre></pre></td></tr>
<tr id="L36" class="EvenSourceLine"><td>36</td><td><pre>void append(node x, node y)</pre></td></tr>
<tr id="L37" class="OddSourceLine"><td>37</td><td><pre>  requires x::ll<n1> * y::ll<n2> & n1>0 // & x!=null // & n1>0 & x != null</pre></td></tr>
<tr id="L38" class="EvenSourceLine"><td>38</td><td><pre>  ensures x::ll<n1+n2>;</pre></td></tr>
<tr id="L39" class="OddSourceLine"><td>39</td><td><pre>{</pre></td></tr>
<tr id="L40" class="EvenSourceLine"><td>40</td><td><pre>	if (x.next == null)</pre></td></tr>
<tr id="L41" class="OddSourceLine"><td>41</td><td><pre>	      x.next = y;</pre></td></tr>
<tr id="L42" class="EvenSourceLine"><td>42</td><td><pre>	else </pre></td></tr>
<tr id="L43" class="OddSourceLine"><td>43</td><td><pre>		append(x.next, y);</pre></td></tr>
<tr id="L44" class="EvenSourceLine"><td>44</td><td><pre>}</pre></td></tr>
<tr id="L45" class="OddSourceLine"><td>45</td><td><pre></pre></td></tr>
<tr id="L46" class="EvenSourceLine"><td>46</td><td><pre>/* return the first element of a singly linked list */</pre></td></tr>
<tr id="L47" class="OddSourceLine"><td>47</td><td><pre>node ret_first(node x)</pre></td></tr>
<tr id="L48" class="EvenSourceLine"><td>48</td><td><pre></pre></td></tr>
<tr id="L49" class="OddSourceLine"><td>49</td><td><pre>	requires x::ll<n> * y::ll<m> & n < m </pre></td></tr>
<tr id="L50" class="EvenSourceLine"><td>50</td><td><pre>	ensures x::ll<n>;</pre></td></tr>
<tr id="L51" class="OddSourceLine"><td>51</td><td><pre></pre></td></tr>
<tr id="L52" class="EvenSourceLine"><td>52</td><td><pre>{</pre></td></tr>
<tr id="L53" class="OddSourceLine"><td>53</td><td><pre>	return x;</pre></td></tr>
<tr id="L54" class="EvenSourceLine"><td>54</td><td><pre>}</pre></td></tr>
<tr id="L55" class="OddSourceLine"><td>55</td><td><pre></pre></td></tr>
<tr id="L56" class="EvenSourceLine"><td>56</td><td><pre>/* return the tail of a singly linked list */</pre></td></tr>
<tr id="L57" class="OddSourceLine"><td>57</td><td><pre>node get_next(node x)</pre></td></tr>
<tr id="L58" class="EvenSourceLine"><td>58</td><td><pre></pre></td></tr>
<tr id="L59" class="OddSourceLine"><td>59</td><td><pre>	requires x::ll<n> & n > 0</pre></td></tr>
<tr id="L60" class="EvenSourceLine"><td>60</td><td><pre>	ensures x::ll<1> * res::ll<n-1>; </pre></td></tr>
<tr id="L61" class="OddSourceLine"><td>61</td><td><pre></pre></td></tr>
<tr id="L62" class="EvenSourceLine"><td>62</td><td><pre>{</pre></td></tr>
<tr id="L63" class="OddSourceLine"><td>63</td><td><pre>  //dprint;</pre></td></tr>
<tr id="L64" class="EvenSourceLine"><td>64</td><td><pre>	node tmp = x.next;</pre></td></tr>
<tr id="L65" class="OddSourceLine"><td>65</td><td><pre>    //assume false;</pre></td></tr>
<tr id="L66" class="EvenSourceLine"><td>66</td><td><pre>	x.next = null;</pre></td></tr>
<tr id="L67" class="OddSourceLine"><td>67</td><td><pre>	return tmp;</pre></td></tr>
<tr id="L68" class="EvenSourceLine"><td>68</td><td><pre>}</pre></td></tr>
<tr id="L69" class="OddSourceLine"><td>69</td><td><pre></pre></td></tr>
<tr id="L70" class="EvenSourceLine"><td>70</td><td><pre></pre></td></tr>
<tr id="L71" class="OddSourceLine"><td>71</td><td><pre>/* function to set the tail of a list */</pre></td></tr>
<tr id="L72" class="EvenSourceLine"><td>72</td><td><pre> void set_next(node x, node y)</pre></td></tr>
<tr id="L73" class="OddSourceLine"><td>73</td><td><pre></pre></td></tr>
<tr id="L74" class="EvenSourceLine"><td>74</td><td><pre>	requires x::ll<i> * y::ll<j> & i > 0 </pre></td></tr>
<tr id="L75" class="OddSourceLine"><td>75</td><td><pre>	ensures x::ll<j+1>; </pre></td></tr>
<tr id="L76" class="EvenSourceLine"><td>76</td><td><pre></pre></td></tr>
<tr id="L77" class="OddSourceLine"><td>77</td><td><pre>{</pre></td></tr>
<tr id="L78" class="EvenSourceLine"><td>78</td><td><pre>	x.next = y;</pre></td></tr>
<tr id="L79" class="OddSourceLine"><td>79</td><td><pre>}</pre></td></tr>
<tr id="L80" class="EvenSourceLine"><td>80</td><td><pre></pre></td></tr>
<tr id="L81" class="OddSourceLine"><td>81</td><td><pre>void set_null2(node x)</pre></td></tr>
<tr id="L82" class="EvenSourceLine"><td>82</td><td><pre></pre></td></tr>
<tr id="L83" class="OddSourceLine"><td>83</td><td><pre>	requires x::ll<i> & i > 0 </pre></td></tr>
<tr id="L84" class="EvenSourceLine"><td>84</td><td><pre>	ensures x::ll<1>;</pre></td></tr>
<tr id="L85" class="OddSourceLine"><td>85</td><td><pre></pre></td></tr>
<tr id="L86" class="EvenSourceLine"><td>86</td><td><pre>{</pre></td></tr>
<tr id="L87" class="OddSourceLine"><td>87</td><td><pre>	if (4>3) </pre></td></tr>
<tr id="L88" class="EvenSourceLine"><td>88</td><td><pre>		x.next = null;</pre></td></tr>
<tr id="L89" class="OddSourceLine"><td>89</td><td><pre>	else </pre></td></tr>
<tr id="L90" class="EvenSourceLine"><td>90</td><td><pre>		x.next = null;</pre></td></tr>
<tr id="L91" class="OddSourceLine"><td>91</td><td><pre>}	</pre></td></tr>
<tr id="L92" class="EvenSourceLine"><td>92</td><td><pre></pre></td></tr>
<tr id="L93" class="OddSourceLine"><td>93</td><td><pre></pre></td></tr>
<tr id="L94" class="EvenSourceLine"><td>94</td><td><pre>/* function to set null the tail of a list */</pre></td></tr>
<tr id="L95" class="OddSourceLine"><td>95</td><td><pre>void set_null(node x)</pre></td></tr>
<tr id="L96" class="EvenSourceLine"><td>96</td><td><pre></pre></td></tr>
<tr id="L97" class="OddSourceLine"><td>97</td><td><pre>	requires x::ll<i> & i > 0 </pre></td></tr>
<tr id="L98" class="EvenSourceLine"><td>98</td><td><pre>	ensures x::ll<1>;</pre></td></tr>
<tr id="L99" class="OddSourceLine"><td>99</td><td><pre></pre></td></tr>
<tr id="L100" class="EvenSourceLine"><td>100</td><td><pre>{</pre></td></tr>
<tr id="L101" class="OddSourceLine"><td>101</td><td><pre>	x.next = null;</pre></td></tr>
<tr id="L102" class="EvenSourceLine"><td>102</td><td><pre>    //dprint;</pre></td></tr>
<tr id="L103" class="OddSourceLine"><td>103</td><td><pre>}</pre></td></tr>
<tr id="L104" class="EvenSourceLine"><td>104</td><td><pre></pre></td></tr>
<tr id="L105" class="OddSourceLine"><td>105</td><td><pre>/* function to get the third element of a list */</pre></td></tr>
<tr id="L106" class="EvenSourceLine"><td>106</td><td><pre>node get_next_next(node x) </pre></td></tr>
<tr id="L107" class="OddSourceLine"><td>107</td><td><pre></pre></td></tr>
<tr id="L108" class="EvenSourceLine"><td>108</td><td><pre>	requires x::ll<n> & n > 1</pre></td></tr>
<tr id="L109" class="OddSourceLine"><td>109</td><td><pre>	ensures res::ll<n-2>;</pre></td></tr>
<tr id="L110" class="EvenSourceLine"><td>110</td><td><pre></pre></td></tr>
<tr id="L111" class="OddSourceLine"><td>111</td><td><pre>{</pre></td></tr>
<tr id="L112" class="EvenSourceLine"><td>112</td><td><pre>	return x.next.next;</pre></td></tr>
<tr id="L113" class="OddSourceLine"><td>113</td><td><pre>}</pre></td></tr>
<tr id="L114" class="EvenSourceLine"><td>114</td><td><pre></pre></td></tr>
<tr id="L115" class="OddSourceLine"><td>115</td><td><pre>/* function to insert a node in a singly linked list */</pre></td></tr>
<tr id="L116" class="EvenSourceLine"><td>116</td><td><pre>void insert(node x, int a)</pre></td></tr>
<tr id="L117" class="OddSourceLine"><td>117</td><td><pre>	requires x::ll<n> & n > 0 </pre></td></tr>
<tr id="L118" class="EvenSourceLine"><td>118</td><td><pre>	ensures x::ll<n+1>;</pre></td></tr>
<tr id="L119" class="OddSourceLine"><td>119</td><td><pre>{</pre></td></tr>
<tr id="L120" class="EvenSourceLine"><td>120</td><td><pre>			//dprint;</pre></td></tr>
<tr id="L121" class="OddSourceLine"><td>121</td><td><pre>      node tmp = null;</pre></td></tr>
<tr id="L122" class="EvenSourceLine"><td>122</td><td><pre>	if (x.next == null)</pre></td></tr>
<tr id="L123" class="OddSourceLine"><td>123</td><td><pre>		x.next = new node(a, tmp);</pre></td></tr>
<tr id="L124" class="EvenSourceLine"><td>124</td><td><pre>	else </pre></td></tr>
<tr id="L125" class="OddSourceLine"><td>125</td><td><pre>		insert(x.next, a);</pre></td></tr>
<tr id="L126" class="EvenSourceLine"><td>126</td><td><pre>} </pre></td></tr>
<tr id="L127" class="OddSourceLine"><td>127</td><td><pre></pre></td></tr>
<tr id="L128" class="EvenSourceLine"><td>128</td><td><pre>/* function to delete the a-th node in a singly linked list */</pre></td></tr>
<tr id="L129" class="OddSourceLine"><td>129</td><td><pre>void delete(node x, int a)</pre></td></tr>
<tr id="L130" class="EvenSourceLine"><td>130</td><td><pre>	requires x::ll<n> & n > a & a > 0 </pre></td></tr>
<tr id="L131" class="OddSourceLine"><td>131</td><td><pre>	ensures x::ll<n - 1>;</pre></td></tr>
<tr id="L132" class="EvenSourceLine"><td>132</td><td><pre>{</pre></td></tr>
<tr id="L133" class="OddSourceLine"><td>133</td><td><pre>        if (a == 1)</pre></td></tr>
<tr id="L134" class="EvenSourceLine"><td>134</td><td><pre>	{</pre></td></tr>
<tr id="L135" class="OddSourceLine"><td>135</td><td><pre>		//node tmp = x.next.next;</pre></td></tr>
<tr id="L136" class="EvenSourceLine"><td>136</td><td><pre>		//x.next = tmp;</pre></td></tr>
<tr id="L137" class="OddSourceLine"><td>137</td><td><pre>                  x.next = x.next.next;</pre></td></tr>
<tr id="L138" class="EvenSourceLine"><td>138</td><td><pre>	}</pre></td></tr>
<tr id="L139" class="OddSourceLine"><td>139</td><td><pre>	else</pre></td></tr>
<tr id="L140" class="EvenSourceLine"><td>140</td><td><pre>	{</pre></td></tr>
<tr id="L141" class="OddSourceLine"><td>141</td><td><pre>		delete(x.next, a-1);</pre></td></tr>
<tr id="L142" class="EvenSourceLine"><td>142</td><td><pre>	}	</pre></td></tr>
<tr id="L143" class="OddSourceLine"><td>143</td><td><pre>}</pre></td></tr>
<tr id="L144" class="EvenSourceLine"><td>144</td><td><pre></pre></td></tr>
<tr id="L145" class="OddSourceLine"><td>145</td><td><pre>/*node delete1(node x, int a)</pre></td></tr>
<tr id="L146" class="EvenSourceLine"><td>146</td><td><pre>	requires x::ll1<S>  </pre></td></tr>
<tr id="L147" class="OddSourceLine"><td>147</td><td><pre>	ensures res::ll1<S1> & ((a notin S | S=union(S1, {a})) | S = S1);</pre></td></tr>
<tr id="L148" class="EvenSourceLine"><td>148</td><td><pre>{</pre></td></tr>
<tr id="L149" class="OddSourceLine"><td>149</td><td><pre>	if (x == null) </pre></td></tr>
<tr id="L150" class="EvenSourceLine"><td>150</td><td><pre>		return x;</pre></td></tr>
<tr id="L151" class="OddSourceLine"><td>151</td><td><pre>	else {</pre></td></tr>
<tr id="L152" class="EvenSourceLine"><td>152</td><td><pre>		if (x.val == a) return x.next;</pre></td></tr>
<tr id="L153" class="OddSourceLine"><td>153</td><td><pre>		else return new node(x.val, delete1(x.next, a));</pre></td></tr>
<tr id="L154" class="EvenSourceLine"><td>154</td><td><pre>	}</pre></td></tr>
<tr id="L155" class="OddSourceLine"><td>155</td><td><pre>}*/</pre></td></tr>
<tr id="L156" class="EvenSourceLine"><td>156</td><td><pre></pre></td></tr>
<tr id="L157" class="OddSourceLine"><td>157</td><td><pre>/* function to create a singly linked list with a nodes */</pre></td></tr>
<tr id="L158" class="EvenSourceLine"><td>158</td><td><pre>node create_list(int a)</pre></td></tr>
<tr id="L159" class="OddSourceLine"><td>159</td><td><pre>	requires a >= 0 </pre></td></tr>
<tr id="L160" class="EvenSourceLine"><td>160</td><td><pre>	ensures res::ll<a>;</pre></td></tr>
<tr id="L161" class="OddSourceLine"><td>161</td><td><pre></pre></td></tr>
<tr id="L162" class="EvenSourceLine"><td>162</td><td><pre>{</pre></td></tr>
<tr id="L163" class="OddSourceLine"><td>163</td><td><pre>	node tmp;</pre></td></tr>
<tr id="L164" class="EvenSourceLine"><td>164</td><td><pre></pre></td></tr>
<tr id="L165" class="OddSourceLine"><td>165</td><td><pre>	if (a == 0) {</pre></td></tr>
<tr id="L166" class="EvenSourceLine"><td>166</td><td><pre>      // assume false;</pre></td></tr>
<tr id="L167" class="OddSourceLine"><td>167</td><td><pre>		return null;</pre></td></tr>
<tr id="L168" class="EvenSourceLine"><td>168</td><td><pre>	}</pre></td></tr>
<tr id="L169" class="OddSourceLine"><td>169</td><td><pre>	else {    </pre></td></tr>
<tr id="L170" class="EvenSourceLine"><td>170</td><td><pre>		a  = a - 1;</pre></td></tr>
<tr id="L171" class="OddSourceLine"><td>171</td><td><pre>        //    dprint;</pre></td></tr>
<tr id="L172" class="EvenSourceLine"><td>172</td><td><pre>		tmp = create_list(a);</pre></td></tr>
<tr id="L173" class="OddSourceLine"><td>173</td><td><pre>        //    dprint;</pre></td></tr>
<tr id="L174" class="EvenSourceLine"><td>174</td><td><pre>		return new node (0, tmp);</pre></td></tr>
<tr id="L175" class="OddSourceLine"><td>175</td><td><pre>	}</pre></td></tr>
<tr id="L176" class="EvenSourceLine"><td>176</td><td><pre>		</pre></td></tr>
<tr id="L177" class="OddSourceLine"><td>177</td><td><pre>}</pre></td></tr>
<tr id="L178" class="EvenSourceLine"><td>178</td><td><pre></pre></td></tr>
<tr id="L179" class="OddSourceLine"><td>179</td><td><pre>/* function to reverse a singly linked list */</pre></td></tr>
<tr id="L180" class="EvenSourceLine"><td>180</td><td><pre>void reverse(ref node xs, ref node ys)</pre></td></tr>
<tr id="L181" class="OddSourceLine"><td>181</td><td><pre>	requires xs::ll<n> * ys::ll<m> </pre></td></tr>
<tr id="L182" class="EvenSourceLine"><td>182</td><td><pre>	ensures ys'::ll<n+m> & xs' = null;</pre></td></tr>
<tr id="L183" class="OddSourceLine"><td>183</td><td><pre>{</pre></td></tr>
<tr id="L184" class="EvenSourceLine"><td>184</td><td><pre>	if (xs != null) {</pre></td></tr>
<tr id="L185" class="OddSourceLine"><td>185</td><td><pre>		node tmp;</pre></td></tr>
<tr id="L186" class="EvenSourceLine"><td>186</td><td><pre>		tmp = xs.next;</pre></td></tr>
<tr id="L187" class="OddSourceLine"><td>187</td><td><pre>    //dprint;</pre></td></tr>
<tr id="L188" class="EvenSourceLine"><td>188</td><td><pre>		xs.next = ys;</pre></td></tr>
<tr id="L189" class="OddSourceLine"><td>189</td><td><pre>		ys = xs;</pre></td></tr>
<tr id="L190" class="EvenSourceLine"><td>190</td><td><pre>		xs = tmp;</pre></td></tr>
<tr id="L191" class="OddSourceLine"><td>191</td><td><pre>    //dprint;</pre></td></tr>
<tr id="L192" class="EvenSourceLine"><td>192</td><td><pre>		reverse(xs, ys);</pre></td></tr>
<tr id="L193" class="OddSourceLine"><td>193</td><td><pre>	}</pre></td></tr>
<tr id="L194" class="EvenSourceLine"><td>194</td><td><pre>}</pre></td></tr>
<tr id="L195" class="OddSourceLine"><td>195</td><td><pre>/*</pre></td></tr>
<tr id="L196" class="EvenSourceLine"><td>196</td><td><pre>void reverse1(ref node xs, ref node ys)</pre></td></tr>
<tr id="L197" class="OddSourceLine"><td>197</td><td><pre>	requires xs::ll1<S1> * ys::ll1<S2> </pre></td></tr>
<tr id="L198" class="EvenSourceLine"><td>198</td><td><pre>	ensures ys'::ll1<S3> & S3 = union(S1, S2) & xs' = null;</pre></td></tr>
<tr id="L199" class="OddSourceLine"><td>199</td><td><pre>{</pre></td></tr>
<tr id="L200" class="EvenSourceLine"><td>200</td><td><pre>	if (xs != null) {</pre></td></tr>
<tr id="L201" class="OddSourceLine"><td>201</td><td><pre>		node tmp;</pre></td></tr>
<tr id="L202" class="EvenSourceLine"><td>202</td><td><pre>		tmp = xs.next;</pre></td></tr>
<tr id="L203" class="OddSourceLine"><td>203</td><td><pre>		xs.next = ys;</pre></td></tr>
<tr id="L204" class="EvenSourceLine"><td>204</td><td><pre>		ys = xs;</pre></td></tr>
<tr id="L205" class="OddSourceLine"><td>205</td><td><pre>		xs = tmp;</pre></td></tr>
<tr id="L206" class="EvenSourceLine"><td>206</td><td><pre>		reverse1(xs, ys);</pre></td></tr>
<tr id="L207" class="OddSourceLine"><td>207</td><td><pre>	}</pre></td></tr>
<tr id="L208" class="EvenSourceLine"><td>208</td><td><pre>}*/</pre></td></tr>
<tr id="L209" class="OddSourceLine"><td>209</td><td><pre>/*</pre></td></tr>
<tr id="L210" class="EvenSourceLine"><td>210</td><td><pre>void test(node x)</pre></td></tr>
<tr id="L211" class="OddSourceLine"><td>211</td><td><pre>	requires x::ll<n> & n>=2 ensures x::ll<n-1>;</pre></td></tr>
<tr id="L212" class="EvenSourceLine"><td>212</td><td><pre>{</pre></td></tr>
<tr id="L213" class="OddSourceLine"><td>213</td><td><pre>	node tmp = x.next.next;</pre></td></tr>
<tr id="L214" class="EvenSourceLine"><td>214</td><td><pre>	x.next = tmp;</pre></td></tr>
<tr id="L215" class="OddSourceLine"><td>215</td><td><pre>}</pre></td></tr>
<tr id="L216" class="EvenSourceLine"><td>216</td><td><pre>*/</pre></td></tr>
</table></ul></li><li class="Collapsed proc">
Procedure reverse<ul><li class="Collapsed procdef">Internal representation
<ul>void reverse$node~node(  node xs,  node ys)<br/>
static  EBase exists (Expl)[](Impl)[n; <br/>
       m](ex)[]NN xs::ll&lt;n&gt;@M[Orig][LHSCase]@ rem br[{219,218}] * <br/>
       NN ys::ll&lt;m&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp; (([0&lt;=n][0&lt;=m])) &amp;<br/>
       {FLOW,(49,49)=__norm}<br/>
         EAssume 31::ref [xs;ys]<br/>
           EXISTS(flted_182_62: NN ys&apos;::ll&lt;flted_182_62&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp;<br/>
           (([0&lt;=flted_182_62 &amp; flted_182_62=m+n][null=xs&apos;])) &amp;<br/>
           {FLOW,(49,49)=__norm})<br/>
dynamic  []<br/>
<br/>
ref xs, ys<br/>
boolean v_bool_184_705;<br/>
v_bool_184_705 = {<br/>
107::is_not_null___$node(xs)<br/>
};<br/>
99::if (v_bool_184_705) LABEL! 99,0: node tmp_63;<br/>
tmp_63 = null;<br/>
tmp_63 = 101::bind xs to (val_186_701,next_186_702) in <br/>
{next_186_702<br/>
};<br/>
103::bind xs to (val_188_703,next_188_704) in <br/>
{next_188_704 = ys<br/>
};<br/>
ys = xs;<br/>
xs = tmp_63;<br/>
{<br/>
106::reverse$node~node(xs,ys) rec<br/>
}<br/>
else LABEL! 99,1: <br/>
<br/>
<br/>
{(180,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pureimplyvalid">Verification condition
<ul>(<b>null</b> = xs' &and; <b>null</b> = xs)  &#8866;  <b>null</b> = xs
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[xsPRMD, xs] : (( (not (((xsPRMD &lt; 1) &amp; (xs &lt; 1))))  | (xs &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[xsPRMD,xs]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(<b>null</b> = xs' &and; <b>null</b> = xs)  &#8866;  xs &ne; <b>null</b>
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[xsPRMD, xs] : (( (not (((xsPRMD &lt; 1) &amp; (xs &lt; 1))))  | (xs &gt; 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[xsPRMD,xs]: xsPRMD &lt;= 0 &amp;&amp; xs &lt;= 0}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>ys' = ys'  &#8866;  <b>null</b> = ys'
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[ysPRMD] : (((ysPRMD != ysPRMD) | (ysPRMD &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[ysPRMD]: 1 &lt;= ysPRMD}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>ys' = ys'  &#8866;  ys' &ne; <b>null</b>
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[ysPRMD] : (((ysPRMD != ysPRMD) | (ysPRMD &gt; 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[ysPRMD]: ysPRMD &lt;= 0}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; n &and; 0 &le; n &and; 1 + flted_14_980 = n &and; 0 &le; flted_14_980)  &#8866;  0 = flted_14_980
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_980] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_14_980 = n)) &amp; (0 &lt;= flted_14_980))))  | (0 = flted_14_980)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; n &and; 0 &le; n &and; 1 + flted_14_980 = n &and; 0 &le; flted_14_980)  &#8866;  0 &ne; flted_14_980
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_980] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_14_980 = n)) &amp; (0 &lt;= flted_14_980))))  | (0 != flted_14_980)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>ys = ys  &#8866;  ys &ne; <b>null</b>
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[ys] : (((ys != ys) | (ys &gt; 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[ys]: ys &lt;= 0}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>ys = ys  &#8866;  <b>null</b> = ys
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[ys] : (((ys != ys) | (ys &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[ys]: 1 &lt;= ys}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>tmp_63' = tmp_63'  &#8866;  <b>null</b> = tmp_63'
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[tmp_63PRMD] : (((tmp_63PRMD != tmp_63PRMD) | (tmp_63PRMD &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[tmp_63PRMD]: 1 &lt;= tmp_63PRMD}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n &and; 0 &ne; n &and; 0 &le; flted_14_986 &and; 1 + flted_14_986 = n)  &#8866;  0 = flted_14_986
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_986] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (0 &lt;= flted_14_986)) &amp; (1 + flted_14_986 = n))))  | (0 = flted_14_986)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n &and; 0 &ne; n &and; 0 &le; flted_14_986 &and; 1 + flted_14_986 = n)  &#8866;  0 &ne; flted_14_986
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_986] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (0 &lt;= flted_14_986)) &amp; (1 + flted_14_986 = n))))  | (0 != flted_14_986)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>tmp_63' = tmp_63'  &#8866;  tmp_63' &ne; <b>null</b>
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[tmp_63PRMD] : (((tmp_63PRMD != tmp_63PRMD) | (tmp_63PRMD &gt; 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[tmp_63PRMD]: tmp_63PRMD &lt;= 0}</li></ul></ul></li>
<li class="Collapsed pre">
Precondition of procedure call 106::reverse$node~node(xs,ys) rec at <a href="#L192">line 192</a> holds<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n &and; 0 &ne; n &and; 0 &le; flted_14_986 &and; 1 + flted_14_986 = n)  &#8866;  (<b>null</b> = xs' &or; 0 = flted_14_986)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, xsPRMD, flted_14_986] : (( (not (((((0 &lt;= n) &amp; (0 != n)) &amp; (0 &lt;= flted_14_986)) &amp; (1 + flted_14_986 = n))))  | ((xsPRMD &lt; 1) | (0 = flted_14_986))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,xsPRMD,n-1]: 2 &lt;= n &amp;&amp; 1 &lt;= xsPRMD}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>0 &le; m  &#8866;  (<b>null</b> = q_1000 &or; 0 = m)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1000, m] : (((0 &gt; m) | ((q_1000 &lt; 1) | (0 = m))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1000,m]: 1 &lt;= m &amp;&amp; 1 &lt;= q_1000}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>q_1000 = q_1000  &#8866;  <b>null</b> = q_1000
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1000] : (((q_1000 != q_1000) | (q_1000 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1000]: 1 &lt;= q_1000}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>ys' &ne; <b>null</b>  &#8866;  <b>null</b> = ys'
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[ysPRMD] : (((ysPRMD &lt; 1) | (ysPRMD &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[ysPRMD]: 1 &lt;= ysPRMD}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1 + m = m_995 &and; 0 &le; m)  &#8866;  1 + m = m_995
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[m, m_995] : (( (not (((1 + m = m_995) &amp; (0 &lt;= m))))  | (1 + m = m_995)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[m,m_995]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>xs' = xs'  &#8866;  <b>null</b> = xs'
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[xsPRMD] : (((xsPRMD != xsPRMD) | (xsPRMD &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[xsPRMD]: 1 &lt;= xsPRMD}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; m &and; 0 &le; n_994 &and; 1 + m = m_995 &and; 0 &le; n &and; 0 &ne; n &and; 1 + n_994 = n &and; 0 &le; m_995 &and; flted_182_1019 = m_995 + n_994 &and; 0 &le; flted_182_1019)  &#8866;  0 = flted_182_1019
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[m, n, m_995, n_994, flted_182_1019] : (( (not ((((((((((0 &lt;= m) &amp; (0 &lt;= n_994)) &amp; (1 + m = m_995)) &amp; (0 &lt;= n)) &amp; (0 != n)) &amp; (1 + n_994 = n)) &amp; (0 &lt;= m_995)) &amp; (flted_182_1019 = m_995 + n_994)) &amp; (0 &lt;= flted_182_1019))))  | (0 = flted_182_1019)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[m,n,m+1,n-1,m+n]: 0 &lt;= m &amp;&amp; 1 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &le; m &and; 0 &le; n_994 &and; 1 + m = m_995 &and; 0 &le; n &and; 0 &ne; n &and; 1 + n_994 = n &and; 0 &le; m_995 &and; flted_182_1019 = m_995 + n_994 &and; 0 &le; flted_182_1019)  &#8866;  0 &ne; flted_182_1019
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[m, n, m_995, n_994, flted_182_1019] : (( (not ((((((((((0 &lt;= m) &amp; (0 &lt;= n_994)) &amp; (1 + m = m_995)) &amp; (0 &lt;= n)) &amp; (0 != n)) &amp; (1 + n_994 = n)) &amp; (0 &lt;= m_995)) &amp; (flted_182_1019 = m_995 + n_994)) &amp; (0 &lt;= flted_182_1019))))  | (0 != flted_182_1019)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[m,n,m_995,n_994,flted_182_1019]  : FALSE }</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; n &and; 0 &le; n &and; 0 &le; m &and; 1 + m = m_995 &and; 1 + n_994 = n &and; 0 &le; n_994 &and; 0 &le; m_995 &and; <b>null</b> &ne; ys' &and; 0 &ne; flted_182_1021 &and; flted_182_1021 = m_995 + n_994 &and; 0 &le; flted_182_1021)  &#8866;  (<b>null</b> = ys' &or; 0 = flted_182_1021)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[m, n, m_995, n_994, ysPRMD, flted_182_1021] : (( (not ((((((((((((0 != n) &amp; (0 &lt;= n)) &amp; (0 &lt;= m)) &amp; (1 + m = m_995)) &amp; (1 + n_994 = n)) &amp; (0 &lt;= n_994)) &amp; (0 &lt;= m_995)) &amp; (ysPRMD &gt; 0)) &amp; (0 != flted_182_1021)) &amp; (flted_182_1021 = m_995 + n_994)) &amp; (0 &lt;= flted_182_1021))))  | ((ysPRMD &lt; 1) | (0 = flted_182_1021))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[m,n,m+1,n-1,ysPRMD,m+n]: 1 &lt;= n &amp;&amp; 0 &lt;= m &amp;&amp; 1 &lt;= ysPRMD}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul><b>null</b> &ne; ys'  &#8866;  <b>null</b> = ys'
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[ysPRMD] : (((ysPRMD &lt; 1) | (ysPRMD &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[ysPRMD]: 1 &lt;= ysPRMD}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul><b>null</b> = xs'  &#8866;  <b>null</b> = xs'
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[xsPRMD] : (((xsPRMD &gt; 0) | (xsPRMD &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[xsPRMD]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &le; n_994 &and; 0 &le; m_995 &and; 0 &ne; flted_182_1021 &and; flted_182_1021 = m_995 + n_994 &and; 0 &le; flted_182_1021 &and; 0 &ne; n &and; 0 &le; n &and; 0 &le; m &and; 1 + n_994 = n &and; 1 + m = m_995)  &#8866;  flted_182_1021 = m + n
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n_994, m_995, flted_182_1021, m, n] : (( (not (((((((((((0 &lt;= n_994) &amp; (0 &lt;= m_995)) &amp; (0 != flted_182_1021)) &amp; (flted_182_1021 = m_995 + n_994)) &amp; (0 &lt;= flted_182_1021)) &amp; (0 != n)) &amp; (0 &lt;= n)) &amp; (0 &lt;= m)) &amp; (1 + n_994 = n)) &amp; (1 + m = m_995))))  | (flted_182_1021 = m + n)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n_994,m_995,flted_182_1021,m,n]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>0 &le; m  &#8866;  (<b>null</b> = ys' &or; 0 = m)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[ysPRMD, m] : (((0 &gt; m) | ((ysPRMD &lt; 1) | (0 = m))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[ysPRMD,m]: 1 &lt;= m &amp;&amp; 1 &lt;= ysPRMD}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(<b>null</b> = xs' &and; <b>null</b> = xs)  &#8866;  <b>null</b> = xs'
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[xs, xsPRMD] : (( (not (((xsPRMD &lt; 1) &amp; (xs &lt; 1))))  | (xsPRMD &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[xs,xsPRMD]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>0 &le; m  &#8866;  m = m + 0
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[m] : (((0 &gt; m) | (m = m + 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[m]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure create_list<ul><li class="Collapsed procdef">Internal representation
<ul>node create_list$int(  int a)<br/>
static  EBase true &amp; (([0&lt;=a])) &amp; {FLOW,(49,49)=__norm}<br/>
         EAssume 26::<br/>
           EXISTS(a_64: NN res::ll&lt;a_64&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp;<br/>
           (([a=a_64 &amp; 0&lt;=a_64])) &amp; {FLOW,(49,49)=__norm})<br/>
dynamic  []<br/>
node tmp_65;<br/>
tmp_65 = null;<br/>
boolean v_bool_165_720;<br/>
v_bool_165_720 = {<br/>
int v_int_165_715;<br/>
v_int_165_715 = 0;<br/>
115::eq___$int~int(a,v_int_165_715)<br/>
};<br/>
108::if (v_bool_165_720) LABEL! 108,0: null v_null_167_716;<br/>
v_null_167_716 = null;<br/>
114::return v_null_167_716<br/>
else LABEL! 108,1: a = {<br/>
int v_int_170_717;<br/>
v_int_170_717 = 1;<br/>
110::minus___$int~int(a,v_int_170_717)<br/>
};<br/>
tmp_65 = {<br/>
112::create_list$int(a) rec<br/>
};<br/>
node v_node_174_719;<br/>
v_node_174_719 = {<br/>
int v_int_174_718;<br/>
v_int_174_718 = 0;<br/>
newnode(v_int_174_718,tmp_65)<br/>
};<br/>
113::return v_node_174_719<br/>
<br/>
<br/>
{(158,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pre">
Precondition of procedure call 112::create_list$int(a) rec at <a href="#L172">line 172</a> holds<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>(1 + a' = a &and; a &ne; 0 &and; 0 &le; a)  &#8866;  0 &le; a'
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[a, aPRMD] : (( (not ((((1 + aPRMD = a) &amp; (a != 0)) &amp; (0 &lt;= a))))  | (0 &lt;= aPRMD)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[a,aPRMD]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(a &ne; 0 &and; 0 &le; a &and; 0 &le; a_1051 &and; 1 + a_1051 = a)  &#8866;  0 = a_1051
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[a, a_1051] : (( (not (((((a != 0) &amp; (0 &lt;= a)) &amp; (0 &lt;= a_1051)) &amp; (1 + a_1051 = a))))  | (0 = a_1051)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[a,a-1]: 2 &lt;= a}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(a &ne; 0 &and; 0 &le; a &and; 0 &le; a_1051 &and; 1 + a_1051 = a)  &#8866;  0 &ne; a_1051
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[a, a_1051] : (( (not (((((a != 0) &amp; (0 &lt;= a)) &amp; (0 &lt;= a_1051)) &amp; (1 + a_1051 = a))))  | (0 != a_1051)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(a &ne; 0 &and; 1 + a' = a &and; 0 &le; a &and; 0 &le; a')  &#8866;  0 = a'
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[a, aPRMD] : (( (not (((((a != 0) &amp; (1 + aPRMD = a)) &amp; (0 &lt;= a)) &amp; (0 &lt;= aPRMD))))  | (0 = aPRMD)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[a,a-1]: 2 &lt;= a}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(a &ne; 0 &and; 1 + a' = a &and; 0 &le; a &and; 0 &le; a')  &#8866;  0 &ne; a'
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[a, aPRMD] : (( (not (((((a != 0) &amp; (1 + aPRMD = a)) &amp; (0 &lt;= a)) &amp; (0 &lt;= aPRMD))))  | (0 != aPRMD)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>v_null_167_716' = <b>null</b>  &#8866;  <b>null</b> = v_null_167_716'
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[v_null_167_716PRMD] : (((v_null_167_716PRMD &gt; 0) | (v_null_167_716PRMD &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[v_null_167_716PRMD]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; a &and; a &ne; 0 &and; 1 + a_1062 = a &and; 0 &le; a_1062)  &#8866;  (<b>null</b> = q_1064 &or; 0 = a_1062)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[a, q_1064, a_1062] : (( (not (((((0 &lt;= a) &amp; (a != 0)) &amp; (1 + a_1062 = a)) &amp; (0 &lt;= a_1062))))  | ((q_1064 &lt; 1) | (0 = a_1062))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[a,q_1064,a-1]: 2 &lt;= a &amp;&amp; 1 &lt;= q_1064}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>q_1064 = q_1064  &#8866;  <b>null</b> = q_1064
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1064] : (((q_1064 != q_1064) | (q_1064 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1064]: 1 &lt;= q_1064}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>res &ne; <b>null</b>  &#8866;  <b>null</b> = res
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[res] : (((res &lt; 1) | (res &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[res]: 1 &lt;= res}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(a &ne; 0 &and; 1 + a_1062 = a &and; 0 &le; a &and; 0 &le; a_1062)  &#8866;  1 + a_1062 = a
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[a_1062, a] : (( (not (((((a != 0) &amp; (1 + a_1062 = a)) &amp; (0 &lt;= a)) &amp; (0 &lt;= a_1062))))  | (1 + a_1062 = a)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[a_1062,a]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure delete<ul><li class="Collapsed procdef">Internal representation
<ul>void delete$node~int(  node x,  int a)<br/>
static  EBase exists (Expl)[](Impl)[n](ex)[]NN x::ll&lt;n&gt;@M[Orig][LHSCase]@ rem br[{219}] &amp;<br/>
       (([(1+a)&lt;=n &amp; 1&lt;=a][null!=x])) &amp; {FLOW,(49,49)=__norm}<br/>
         EAssume 22::<br/>
           EXISTS(flted_131_67: NN x::ll&lt;flted_131_67&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp;<br/>
           (([0&lt;=flted_131_67 &amp; 1+flted_131_67=n])) &amp; {FLOW,(49,49)=__norm})<br/>
dynamic  []<br/>
boolean v_bool_133_750;<br/>
v_bool_133_750 = {<br/>
int v_int_133_736;<br/>
v_int_133_736 = 1;<br/>
123::eq___$int~int(a,v_int_133_736)<br/>
};<br/>
116::if (v_bool_133_750) LABEL! 116,0: {<br/>
node v_node_137_742;<br/>
v_node_137_742 = {<br/>
node v_node_137_739;<br/>
v_node_137_739 = 121::bind x to (val_137_737,next_137_738) in <br/>
{next_137_738<br/>
};<br/>
121::bind v_node_137_739 to (val_137_740,next_137_741) in <br/>
{next_137_741<br/>
}<br/>
};<br/>
122::bind x to (val_137_743,next_137_744) in <br/>
{next_137_744 = v_node_137_742<br/>
}<br/>
}<br/>
else LABEL! 116,1: {<br/>
node v_node_141_749;<br/>
v_node_141_749 = 118::bind x to (val_141_745,next_141_746) in <br/>
{next_141_746<br/>
};<br/>
int v_int_141_748;<br/>
v_int_141_748 = {<br/>
int v_int_141_747;<br/>
v_int_141_747 = 1;<br/>
119::minus___$int~int(a,v_int_141_747)<br/>
};<br/>
117::delete$node~int(v_node_141_749,v_int_141_748) rec<br/>
}<br/>
<br/>
<br/>
{(129,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(1 + 1 &le; n &and; 1 + flted_14_1093 = n &and; 0 &le; flted_14_1093)  &#8866;  0 = flted_14_1093
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_1093] : (( (not ((((1 + 1 &lt;= n) &amp; (1 + flted_14_1093 = n)) &amp; (0 &lt;= flted_14_1093))))  | (0 = flted_14_1093)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(1 + 1 &le; n &and; 1 + flted_14_1093 = n &and; 0 &le; flted_14_1093)  &#8866;  0 &ne; flted_14_1093
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_1093] : (( (not ((((1 + 1 &lt;= n) &amp; (1 + flted_14_1093 = n)) &amp; (0 &lt;= flted_14_1093))))  | (0 != flted_14_1093)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,flted_14_1093]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(1 + 1 &le; n &and; 1 + flted_14_1099 = n &and; 0 &le; flted_14_1099 &and; 0 &ne; flted_14_1099 &and; 1 + flted_14_1113 = flted_14_1099 &and; 0 &le; flted_14_1113)  &#8866;  0 = flted_14_1113
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_1099, flted_14_1113] : (( (not (((((((1 + 1 &lt;= n) &amp; (1 + flted_14_1099 = n)) &amp; (0 &lt;= flted_14_1099)) &amp; (0 != flted_14_1099)) &amp; (1 + flted_14_1113 = flted_14_1099)) &amp; (0 &lt;= flted_14_1113))))  | (0 = flted_14_1113)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1,n-2]: 3 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(1 + 1 &le; n &and; 1 + flted_14_1099 = n &and; 0 &le; flted_14_1099 &and; 0 &ne; flted_14_1099 &and; 1 + flted_14_1113 = flted_14_1099 &and; 0 &le; flted_14_1113)  &#8866;  0 &ne; flted_14_1113
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_1099, flted_14_1113] : (( (not (((((((1 + 1 &lt;= n) &amp; (1 + flted_14_1099 = n)) &amp; (0 &lt;= flted_14_1099)) &amp; (0 != flted_14_1099)) &amp; (1 + flted_14_1113 = flted_14_1099)) &amp; (0 &lt;= flted_14_1113))))  | (0 != flted_14_1113)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[2,1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>q_1120 = q_1120  &#8866;  <b>null</b> = q_1120
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1120] : (((q_1120 != q_1120) | (q_1120 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1120]: 1 &lt;= q_1120}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(1 + 1 &le; n &and; 1 + flted_14_1099 = n &and; 0 &le; flted_14_1099 &and; 0 &ne; flted_14_1099 &and; 1 + flted_14_1119 = flted_14_1099 &and; 0 &le; flted_14_1119)  &#8866;  0 = flted_14_1119
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_1099, flted_14_1119] : (( (not (((((((1 + 1 &lt;= n) &amp; (1 + flted_14_1099 = n)) &amp; (0 &lt;= flted_14_1099)) &amp; (0 != flted_14_1099)) &amp; (1 + flted_14_1119 = flted_14_1099)) &amp; (0 &lt;= flted_14_1119))))  | (0 = flted_14_1119)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1,n-2]: 3 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(1 + 1 &le; n &and; 1 + flted_14_1099 = n &and; 0 &le; flted_14_1099 &and; 0 &ne; flted_14_1099 &and; 1 + flted_14_1119 = flted_14_1099 &and; 0 &le; flted_14_1119)  &#8866;  0 &ne; flted_14_1119
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_1099, flted_14_1119] : (( (not (((((((1 + 1 &lt;= n) &amp; (1 + flted_14_1099 = n)) &amp; (0 &lt;= flted_14_1099)) &amp; (0 != flted_14_1099)) &amp; (1 + flted_14_1119 = flted_14_1099)) &amp; (0 &lt;= flted_14_1119))))  | (0 != flted_14_1119)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[2,1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>q_1120 = q_1120  &#8866;  q_1120 &ne; <b>null</b>
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1120] : (((q_1120 != q_1120) | (q_1120 &gt; 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1120]: q_1120 &lt;= 0}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(a' &ne; 1 &and; 1 &le; a' &and; 1 + a' &le; n &and; 1 + flted_14_1132 = n &and; 0 &le; flted_14_1132)  &#8866;  0 = flted_14_1132
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[aPRMD, n, flted_14_1132] : (( (not ((((((aPRMD != 1) &amp; (1 &lt;= aPRMD)) &amp; (1 + aPRMD &lt;= n)) &amp; (1 + flted_14_1132 = n)) &amp; (0 &lt;= flted_14_1132))))  | (0 = flted_14_1132)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[aPRMD,n,n-1]: 2 &lt;= aPRMD &lt; n}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(a' &ne; 1 &and; 1 &le; a' &and; 1 + a' &le; n &and; 1 + flted_14_1132 = n &and; 0 &le; flted_14_1132)  &#8866;  0 &ne; flted_14_1132
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[aPRMD, n, flted_14_1132] : (( (not ((((((aPRMD != 1) &amp; (1 &lt;= aPRMD)) &amp; (1 + aPRMD &lt;= n)) &amp; (1 + flted_14_1132 = n)) &amp; (0 &lt;= flted_14_1132))))  | (0 != flted_14_1132)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[aPRMD,n,flted_14_1132]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pre">
Precondition of procedure call 117::delete$node~int(v_node_141_749,v_int_141_748) rec at <a href="#L141">line 141</a> holds<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(1 + v_int_141_748' = a' &and; 0 &ne; n &and; 0 &le; n &and; a' &ne; 1 &and; 1 &le; a' &and; 1 + a' &le; n &and; 0 &le; flted_14_1138 &and; 1 + flted_14_1138 = n &and; 0 &ne; flted_14_1138 &and; <b>null</b> &ne; q_1139)  &#8866;  (<b>null</b> = q_1139 &or; 0 = flted_14_1138)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[v_int_141_748PRMD, aPRMD, n, q_1139, flted_14_1138] : (( (not (((((((((((1 + v_int_141_748PRMD = aPRMD) &amp; (0 != n)) &amp; (0 &lt;= n)) &amp; (aPRMD != 1)) &amp; (1 &lt;= aPRMD)) &amp; (1 + aPRMD &lt;= n)) &amp; (0 &lt;= flted_14_1138)) &amp; (1 + flted_14_1138 = n)) &amp; (0 != flted_14_1138)) &amp; (q_1139 &gt; 0))))  | ((q_1139 &lt; 1) | (0 = flted_14_1138))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[v_int_141_748PRMD,v_int_141_748PRMD+1,n,q_1139,n-1]: 1 &lt;= v_int_141_748PRMD &lt;= n-2 &amp;&amp; 1 &lt;= q_1139}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(a &ne; 1 &and; 1 &le; a &and; 1 + a &le; n &and; 1 + v_int_141_748' = a &and; 0 &le; n_1148 &and; 0 &ne; n_1148 &and; 1 + n_1148 = n)  &#8866;  1 + v_int_141_748' &le; n_1148
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[a, n, v_int_141_748PRMD, n_1148] : (( (not ((((((((a != 1) &amp; (1 &lt;= a)) &amp; (1 + a &lt;= n)) &amp; (1 + v_int_141_748PRMD = a)) &amp; (0 &lt;= n_1148)) &amp; (0 != n_1148)) &amp; (1 + n_1148 = n))))  | (1 + v_int_141_748PRMD &lt;= n_1148)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[a,n,v_int_141_748PRMD,n_1148]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &le; n_1148 &and; 0 &ne; n_1148 &and; 1 + n_1148 = n &and; a &ne; 1 &and; 1 &le; a &and; 1 + a &le; n &and; 1 + v_int_141_748' = a)  &#8866;  1 &le; v_int_141_748'
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n_1148, n, a, v_int_141_748PRMD] : (( (not ((((((((0 &lt;= n_1148) &amp; (0 != n_1148)) &amp; (1 + n_1148 = n)) &amp; (a != 1)) &amp; (1 &lt;= a)) &amp; (1 + a &lt;= n)) &amp; (1 + v_int_141_748PRMD = a))))  | (1 &lt;= v_int_141_748PRMD)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n_1148,n,a,v_int_141_748PRMD]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(a &ne; 1 &and; 1 &le; a &and; 0 &le; n_1148 &and; 1 + v_int_141_748' = a &and; 0 &ne; n_1148 &and; 1 + a &le; n &and; 1 + n_1148 = n &and; 1 + flted_131_1155 = n_1148 &and; 0 &le; flted_131_1155)  &#8866;  0 = flted_131_1155
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[v_int_141_748PRMD, a, n, n_1148, flted_131_1155] : (( (not ((((((((((a != 1) &amp; (1 &lt;= a)) &amp; (0 &lt;= n_1148)) &amp; (1 + v_int_141_748PRMD = a)) &amp; (0 != n_1148)) &amp; (1 + a &lt;= n)) &amp; (1 + n_1148 = n)) &amp; (1 + flted_131_1155 = n_1148)) &amp; (0 &lt;= flted_131_1155))))  | (0 = flted_131_1155)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[v_int_141_748PRMD,v_int_141_748PRMD+1,n,n-1,n-2]: 1 &lt;= v_int_141_748PRMD &lt;= n-2}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(a &ne; 1 &and; 1 &le; a &and; 0 &le; n_1148 &and; 1 + v_int_141_748' = a &and; 0 &ne; n_1148 &and; 1 + a &le; n &and; 1 + n_1148 = n &and; 1 + flted_131_1155 = n_1148 &and; 0 &le; flted_131_1155)  &#8866;  0 &ne; flted_131_1155
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[v_int_141_748PRMD, a, n, n_1148, flted_131_1155] : (( (not ((((((((((a != 1) &amp; (1 &lt;= a)) &amp; (0 &lt;= n_1148)) &amp; (1 + v_int_141_748PRMD = a)) &amp; (0 != n_1148)) &amp; (1 + a &lt;= n)) &amp; (1 + n_1148 = n)) &amp; (1 + flted_131_1155 = n_1148)) &amp; (0 &lt;= flted_131_1155))))  | (0 != flted_131_1155)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[v_int_141_748PRMD,a,n,n_1148,flted_131_1155]  : FALSE }</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(1 + 1 &le; n &and; 0 &le; n &and; 0 &ne; n &and; 1 + flted_14_1099 = n &and; 0 &le; flted_14_1099 &and; 0 &ne; flted_14_1099 &and; 1 + flted_14_1119 = flted_14_1099 &and; 0 &le; flted_14_1119)  &#8866;  (<b>null</b> = q_1157 &or; 0 = flted_14_1119)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_1099, q_1157, flted_14_1119] : (( (not (((((((((1 + 1 &lt;= n) &amp; (0 &lt;= n)) &amp; (0 != n)) &amp; (1 + flted_14_1099 = n)) &amp; (0 &lt;= flted_14_1099)) &amp; (0 != flted_14_1099)) &amp; (1 + flted_14_1119 = flted_14_1099)) &amp; (0 &lt;= flted_14_1119))))  | ((q_1157 &lt; 1) | (0 = flted_14_1119))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1,q_1157,n-2]: 3 &lt;= n &amp;&amp; 1 &lt;= q_1157}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>q_1157 = q_1157  &#8866;  <b>null</b> = q_1157
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1157] : (((q_1157 != q_1157) | (q_1157 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1157]: 1 &lt;= q_1157}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>x &ne; <b>null</b>  &#8866;  <b>null</b> = x
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[x] : (((x &lt; 1) | (x &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[x]: 1 &lt;= x}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &le; flted_14_1099 &and; 0 &ne; flted_14_1099 &and; 1 + flted_14_1119 = flted_14_1099 &and; 1 + 1 &le; n &and; 1 + flted_14_1099 = n &and; 0 &le; flted_14_1119)  &#8866;  1 + flted_14_1119 + 1 = n
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[flted_14_1099, flted_14_1119, n] : (( (not (((((((0 &lt;= flted_14_1099) &amp; (0 != flted_14_1099)) &amp; (1 + flted_14_1119 = flted_14_1099)) &amp; (1 + 1 &lt;= n)) &amp; (1 + flted_14_1099 = n)) &amp; (0 &lt;= flted_14_1119))))  | (1 + flted_14_1119 + 1 = n)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[flted_14_1099,flted_14_1119,n]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n &and; 1 + v_int_141_1175 = a &and; 1 &le; a &and; a &ne; 1 &and; 1 + a &le; n &and; 0 &ne; n &and; 1 + n_1148 = n &and; 0 &ne; n_1148 &and; 0 &le; n_1148 &and; <b>null</b> &ne; q_1177 &and; 1 + flted_131_1174 = n_1148 &and; 0 &le; flted_131_1174 &and; 0 &ne; flted_131_1174)  &#8866;  (<b>null</b> = q_1177 &or; 0 = flted_131_1174)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[v_int_141_1175, a, n, n_1148, q_1177, flted_131_1174] : (( (not ((((((((((((((0 &lt;= n) &amp; (1 + v_int_141_1175 = a)) &amp; (1 &lt;= a)) &amp; (a != 1)) &amp; (1 + a &lt;= n)) &amp; (0 != n)) &amp; (1 + n_1148 = n)) &amp; (0 != n_1148)) &amp; (0 &lt;= n_1148)) &amp; (q_1177 &gt; 0)) &amp; (1 + flted_131_1174 = n_1148)) &amp; (0 &lt;= flted_131_1174)) &amp; (0 != flted_131_1174))))  | ((q_1177 &lt; 1) | (0 = flted_131_1174))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[v_int_141_1175,v_int_141_1175+1,n,n-1,q_1177,n-2]: 1 &lt;= v_int_141_1175 &lt;= n-2 &amp;&amp; 1 &lt;= q_1177}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul><b>null</b> &ne; q_1177  &#8866;  <b>null</b> = q_1177
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1177] : (((q_1177 &lt; 1) | (q_1177 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1177]: 1 &lt;= q_1177}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(a &ne; 1 &and; 0 &ne; n_1148 &and; 1 &le; a &and; 1 + v_int_141_1175 = a &and; 0 &le; n_1148 &and; 1 + flted_131_1174 = n_1148 &and; 0 &le; flted_131_1174 &and; 1 + n_1148 = n &and; 1 + a &le; n &and; 0 &ne; flted_131_1174)  &#8866;  1 + flted_131_1174 + 1 = n
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[v_int_141_1175, n_1148, a, flted_131_1174, n] : (( (not (((((((((((a != 1) &amp; (0 != n_1148)) &amp; (1 &lt;= a)) &amp; (1 + v_int_141_1175 = a)) &amp; (0 &lt;= n_1148)) &amp; (1 + flted_131_1174 = n_1148)) &amp; (0 &lt;= flted_131_1174)) &amp; (1 + n_1148 = n)) &amp; (1 + a &lt;= n)) &amp; (0 != flted_131_1174))))  | (1 + flted_131_1174 + 1 = n)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[v_int_141_1175,n_1148,a,flted_131_1174,n]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure insert<ul><li class="Collapsed procdef">Internal representation
<ul>void insert$node~int(  node x,  int a)<br/>
static  EBase exists (Expl)[](Impl)[n](ex)[]NN x::ll&lt;n&gt;@M[Orig][LHSCase]@ rem br[{219}] &amp;<br/>
       (([0!=n &amp; 0&lt;=n][null!=x])) &amp; {FLOW,(49,49)=__norm}<br/>
         EAssume 19::<br/>
           EXISTS(flted_118_69: NN x::ll&lt;flted_118_69&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp;<br/>
           (([0&lt;=flted_118_69 &amp; -1+flted_118_69=n])) &amp; {FLOW,(49,49)=__norm})<br/>
dynamic  []<br/>
node tmp_70;<br/>
tmp_70 = null;<br/>
boolean v_bool_122_773;<br/>
v_bool_122_773 = {<br/>
node v_node_122_766;<br/>
v_node_122_766 = 130::bind x to (val_122_764,next_122_765) in <br/>
{next_122_765<br/>
};<br/>
129::is_null___$node(v_node_122_766)<br/>
};<br/>
124::if (v_bool_122_773) LABEL! 124,0: {<br/>
node v_node_123_767;<br/>
v_node_123_767 = {<br/>
newnode(a,tmp_70)<br/>
};<br/>
128::bind x to (val_123_768,next_123_769) in <br/>
{next_123_769 = v_node_123_767<br/>
}<br/>
}<br/>
else LABEL! 124,1: {<br/>
node v_node_125_772;<br/>
v_node_125_772 = 126::bind x to (val_125_770,next_125_771) in <br/>
{next_125_771<br/>
};<br/>
125::insert$node~int(v_node_125_772,a) rec<br/>
}<br/>
<br/>
<br/>
{(116,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pureimplyvalid">Verification condition
<ul><b>null</b> = q_1207  &#8866;  <b>null</b> = q_1207
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1207] : (((q_1207 &gt; 0) | (q_1207 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1207]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; n &and; 0 &le; n &and; 1 + flted_14_1206 = n &and; 0 &le; flted_14_1206)  &#8866;  0 = flted_14_1206
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_1206] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_14_1206 = n)) &amp; (0 &lt;= flted_14_1206))))  | (0 = flted_14_1206)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; n &and; 0 &le; n &and; 1 + flted_14_1206 = n &and; 0 &le; flted_14_1206)  &#8866;  0 &ne; flted_14_1206
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_1206] : (( (not (((((0 != n) &amp; (0 &lt;= n)) &amp; (1 + flted_14_1206 = n)) &amp; (0 &lt;= flted_14_1206))))  | (0 != flted_14_1206)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul><b>null</b> = q_1207  &#8866;  q_1207 &ne; <b>null</b>
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1207] : (((q_1207 &gt; 0) | (q_1207 &gt; 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1207]: q_1207 &lt;= 0}</li></ul></ul></li>
<li class="Collapsed pre">
Precondition of procedure call 125::insert$node~int(v_node_125_772,a) rec at <a href="#L125">line 125</a> holds<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n &and; 1 &le; n &and; 0 &ne; n &and; <b>null</b> &ne; q_1207 &and; 0 &ne; flted_14_1206 &and; 0 &le; flted_14_1206 &and; 1 + flted_14_1206 = n)  &#8866;  (<b>null</b> = q_1207 &or; 0 = flted_14_1206)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, q_1207, flted_14_1206] : (( (not ((((((((0 &lt;= n) &amp; (1 &lt;= n)) &amp; (0 != n)) &amp; (q_1207 &gt; 0)) &amp; (0 != flted_14_1206)) &amp; (0 &lt;= flted_14_1206)) &amp; (1 + flted_14_1206 = n))))  | ((q_1207 &lt; 1) | (0 = flted_14_1206))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,q_1207,n-1]: 2 &lt;= n &amp;&amp; 1 &lt;= q_1207}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n &and; 0 &ne; n &and; 0 &ne; n_1220 &and; 1 + n_1220 = n &and; 0 &le; n_1220 &and; -1 + flted_118_1227 = n_1220 &and; 0 &le; flted_118_1227)  &#8866;  0 = flted_118_1227
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, n_1220, flted_118_1227] : (( (not ((((((((0 &lt;= n) &amp; (0 != n)) &amp; (0 != n_1220)) &amp; (1 + n_1220 = n)) &amp; (0 &lt;= n_1220)) &amp; (-1 + flted_118_1227 = n_1220)) &amp; (0 &lt;= flted_118_1227))))  | (0 = flted_118_1227)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1,n]: 2 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &le; n &and; 0 &ne; n &and; 0 &ne; n_1220 &and; 1 + n_1220 = n &and; 0 &le; n_1220 &and; -1 + flted_118_1227 = n_1220 &and; 0 &le; flted_118_1227)  &#8866;  0 &ne; flted_118_1227
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, n_1220, flted_118_1227] : (( (not ((((((((0 &lt;= n) &amp; (0 != n)) &amp; (0 != n_1220)) &amp; (1 + n_1220 = n)) &amp; (0 &lt;= n_1220)) &amp; (-1 + flted_118_1227 = n_1220)) &amp; (0 &lt;= flted_118_1227))))  | (0 != flted_118_1227)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n_1220,flted_118_1227]  : FALSE }</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyvalid">Verification condition
<ul>q_1239 = <b>null</b>  &#8866;  <b>null</b> = q_1239
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1239] : (((q_1239 &gt; 0) | (q_1239 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1239]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>q_1231 &ne; <b>null</b>  &#8866;  <b>null</b> = q_1231
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1231] : (((q_1231 &lt; 1) | (q_1231 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1231]: 1 &lt;= q_1231}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &le; n &and; 1 + 0 = n &and; 0 &ne; n)  &#8866;  -1 + 2 = n
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n] : (( (not ((((0 &lt;= n) &amp; (1 + 0 = n)) &amp; (0 != n))))  | (-1 + 2 = n)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n &and; 0 &ne; n_1220 &and; 0 &ne; n &and; 1 &le; n &and; 0 &le; n_1220 &and; 1 + n_1220 = n &and; 0 &ne; flted_118_1254 &and; 0 &le; flted_118_1254 &and; -1 + flted_118_1254 = n_1220 &and; <b>null</b> &ne; q_1256)  &#8866;  (<b>null</b> = q_1256 &or; 0 = flted_118_1254)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, n_1220, q_1256, flted_118_1254] : (( (not (((((((((((0 &lt;= n) &amp; (0 != n_1220)) &amp; (0 != n)) &amp; (1 &lt;= n)) &amp; (0 &lt;= n_1220)) &amp; (1 + n_1220 = n)) &amp; (0 != flted_118_1254)) &amp; (0 &lt;= flted_118_1254)) &amp; (-1 + flted_118_1254 = n_1220)) &amp; (q_1256 &gt; 0))))  | ((q_1256 &lt; 1) | (0 = flted_118_1254))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1,q_1256,n]: 2 &lt;= n &amp;&amp; 1 &lt;= q_1256}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul><b>null</b> &ne; q_1256  &#8866;  <b>null</b> = q_1256
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1256] : (((q_1256 &lt; 1) | (q_1256 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1256]: 1 &lt;= q_1256}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &ne; n_1220 &and; 0 &le; n_1220 &and; 0 &ne; flted_118_1254 &and; 0 &le; flted_118_1254 &and; 0 &le; n &and; 1 + n_1220 = n &and; 0 &ne; n &and; -1 + flted_118_1254 = n_1220)  &#8866;  1 + flted_118_1254 = n + 1
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n_1220, flted_118_1254, n] : (( (not (((((((((0 != n_1220) &amp; (0 &lt;= n_1220)) &amp; (0 != flted_118_1254)) &amp; (0 &lt;= flted_118_1254)) &amp; (0 &lt;= n)) &amp; (1 + n_1220 = n)) &amp; (0 != n)) &amp; (-1 + flted_118_1254 = n_1220))))  | (1 + flted_118_1254 = n + 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n_1220,flted_118_1254,n]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure get_next_next<ul><li class="Collapsed procdef">Internal representation
<ul>node get_next_next$node(  node x)<br/>
static  EBase exists (Expl)[](Impl)[n](ex)[]NN x::ll&lt;n&gt;@M[Orig][LHSCase]@ rem br[{219}] &amp;<br/>
       (([2&lt;=n][null!=x])) &amp; {FLOW,(49,49)=__norm}<br/>
         EAssume 18::<br/>
           EXISTS(flted_109_72: NN res::ll&lt;flted_109_72&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp;<br/>
           (([0&lt;=flted_109_72 &amp; 2+flted_109_72=n])) &amp; {FLOW,(49,49)=__norm})<br/>
dynamic  []<br/>
node v_node_112_791;<br/>
v_node_112_791 = {<br/>
node v_node_112_788;<br/>
v_node_112_788 = 132::bind x to (val_112_786,next_112_787) in <br/>
{next_112_787<br/>
};<br/>
132::bind v_node_112_788 to (val_112_789,next_112_790) in <br/>
{next_112_790<br/>
}<br/>
};<br/>
131::return v_node_112_791<br/>
<br/>
{(106,0),(0,-1)}<br/>
</ul></li><li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>q_1305 = q_1305  &#8866;  <b>null</b> = q_1305
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1305] : (((q_1305 != q_1305) | (q_1305 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1305]: 1 &lt;= q_1305}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(2 &le; n &and; 1 + flted_14_1284 = n &and; 0 &le; flted_14_1284 &and; 0 &ne; flted_14_1284 &and; 1 + flted_14_1304 = flted_14_1284 &and; 0 &le; flted_14_1304)  &#8866;  0 = flted_14_1304
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_1284, flted_14_1304] : (( (not (((((((2 &lt;= n) &amp; (1 + flted_14_1284 = n)) &amp; (0 &lt;= flted_14_1284)) &amp; (0 != flted_14_1284)) &amp; (1 + flted_14_1304 = flted_14_1284)) &amp; (0 &lt;= flted_14_1304))))  | (0 = flted_14_1304)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1,n-2]: 3 &lt;= n}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(2 &le; n &and; 1 + flted_14_1284 = n &and; 0 &le; flted_14_1284 &and; 0 &ne; flted_14_1284 &and; 1 + flted_14_1304 = flted_14_1284 &and; 0 &le; flted_14_1304)  &#8866;  0 &ne; flted_14_1304
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_1284, flted_14_1304] : (( (not (((((((2 &lt;= n) &amp; (1 + flted_14_1284 = n)) &amp; (0 &lt;= flted_14_1284)) &amp; (0 != flted_14_1284)) &amp; (1 + flted_14_1304 = flted_14_1284)) &amp; (0 &lt;= flted_14_1304))))  | (0 != flted_14_1304)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[2,1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>q_1305 = q_1305  &#8866;  q_1305 &ne; <b>null</b>
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1305] : (((q_1305 != q_1305) | (q_1305 &gt; 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1305]: q_1305 &lt;= 0}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; n &and; 0 &le; n &and; 2 &le; n &and; 1 + flted_14_1284 = n &and; 0 &le; flted_14_1284 &and; 0 &ne; flted_14_1284 &and; 1 + flted_14_1304 = flted_14_1284 &and; 0 &le; flted_14_1304)  &#8866;  (<b>null</b> = q_1305 &or; 0 = flted_14_1304)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, flted_14_1284, q_1305, flted_14_1304] : (( (not (((((((((0 != n) &amp; (0 &lt;= n)) &amp; (2 &lt;= n)) &amp; (1 + flted_14_1284 = n)) &amp; (0 &lt;= flted_14_1284)) &amp; (0 != flted_14_1284)) &amp; (1 + flted_14_1304 = flted_14_1284)) &amp; (0 &lt;= flted_14_1304))))  | ((q_1305 &lt; 1) | (0 = flted_14_1304))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,n-1,q_1305,n-2]: 3 &lt;= n &amp;&amp; 1 &lt;= q_1305}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &le; flted_14_1284 &and; 0 &ne; flted_14_1284 &and; 1 + flted_14_1304 = flted_14_1284 &and; 0 &le; flted_14_1304 &and; 1 + flted_14_1284 = n &and; 2 &le; n)  &#8866;  2 + flted_14_1304 = n
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[flted_14_1284, flted_14_1304, n] : (( (not (((((((0 &lt;= flted_14_1284) &amp; (0 != flted_14_1284)) &amp; (1 + flted_14_1304 = flted_14_1284)) &amp; (0 &lt;= flted_14_1304)) &amp; (1 + flted_14_1284 = n)) &amp; (2 &lt;= n))))  | (2 + flted_14_1304 = n)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[flted_14_1284,flted_14_1304,n]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure set_null<ul><li class="Collapsed procdef">Internal representation
<ul>void set_null$node(  node x)<br/>
static  EBase exists (Expl)[](Impl)[i](ex)[]NN x::ll&lt;i&gt;@M[Orig][LHSCase]@ rem br[{219}] &amp;<br/>
       (([0!=i &amp; 0&lt;=i][null!=x])) &amp; {FLOW,(49,49)=__norm}<br/>
         EAssume 16::<br/>
           EXISTS(flted_98_74: NN x::ll&lt;flted_98_74&gt;@M[Orig][LHSCase]@ rem br[{219}] &amp;<br/>
           (([1=flted_98_74][null!=x])) &amp; {FLOW,(49,49)=__norm})<br/>
dynamic  []<br/>
{<br/>
null v_null_101_804;<br/>
v_null_101_804 = null;<br/>
134::bind x to (val_101_805,next_101_806) in <br/>
{next_101_806 = v_null_101_804<br/>
}<br/>
}<br/>
<br/>
{(95,0),(0,-1)}<br/>
</ul></li><li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; i &and; 0 &le; i &and; 1 + flted_14_1328 = i &and; 0 &le; flted_14_1328)  &#8866;  0 = flted_14_1328
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[i, flted_14_1328] : (( (not (((((0 != i) &amp; (0 &lt;= i)) &amp; (1 + flted_14_1328 = i)) &amp; (0 &lt;= flted_14_1328))))  | (0 = flted_14_1328)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[i,i-1]: 2 &lt;= i}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; i &and; 0 &le; i &and; 1 + flted_14_1328 = i &and; 0 &le; flted_14_1328)  &#8866;  0 &ne; flted_14_1328
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[i, flted_14_1328] : (( (not (((((0 != i) &amp; (0 &lt;= i)) &amp; (1 + flted_14_1328 = i)) &amp; (0 &lt;= flted_14_1328))))  | (0 != flted_14_1328)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>q_1332 = <b>null</b>  &#8866;  <b>null</b> = q_1332
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1332] : (((q_1332 &gt; 0) | (q_1332 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1332]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure set_null2<ul><li class="Collapsed procdef">Internal representation
<ul>void set_null2$node(  node x)<br/>
static  EBase exists (Expl)[](Impl)[i](ex)[]NN x::ll&lt;i&gt;@M[Orig][LHSCase]@ rem br[{219}] &amp;<br/>
       (([0!=i &amp; 0&lt;=i][null!=x])) &amp; {FLOW,(49,49)=__norm}<br/>
         EAssume 12::<br/>
           EXISTS(flted_84_76: NN x::ll&lt;flted_84_76&gt;@M[Orig][LHSCase]@ rem br[{219}] &amp;<br/>
           (([1=flted_84_76][null!=x])) &amp; {FLOW,(49,49)=__norm})<br/>
dynamic  []<br/>
boolean v_bool_87_827;<br/>
v_bool_87_827 = {<br/>
int v_int_87_820;<br/>
v_int_87_820 = 4;<br/>
int v_int_87_819;<br/>
v_int_87_819 = 3;<br/>
140::gt___$int~int(v_int_87_820,v_int_87_819)<br/>
};<br/>
135::if (v_bool_87_827) LABEL! 135,0: {<br/>
null v_null_88_821;<br/>
v_null_88_821 = null;<br/>
139::bind x to (val_88_822,next_88_823) in <br/>
{next_88_823 = v_null_88_821<br/>
}<br/>
}<br/>
else LABEL! 135,1: {<br/>
null v_null_90_824;<br/>
v_null_90_824 = null;<br/>
137::bind x to (val_90_825,next_90_826) in <br/>
{next_90_826 = v_null_90_824<br/>
}<br/>
}<br/>
<br/>
<br/>
{(81,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; i &and; 0 &le; i &and; 1 + flted_14_1359 = i &and; 0 &le; flted_14_1359)  &#8866;  0 = flted_14_1359
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[i, flted_14_1359] : (( (not (((((0 != i) &amp; (0 &lt;= i)) &amp; (1 + flted_14_1359 = i)) &amp; (0 &lt;= flted_14_1359))))  | (0 = flted_14_1359)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[i,i-1]: 2 &lt;= i}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; i &and; 0 &le; i &and; 1 + flted_14_1359 = i &and; 0 &le; flted_14_1359)  &#8866;  0 &ne; flted_14_1359
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[i, flted_14_1359] : (( (not (((((0 != i) &amp; (0 &lt;= i)) &amp; (1 + flted_14_1359 = i)) &amp; (0 &lt;= flted_14_1359))))  | (0 != flted_14_1359)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; i &and; 0 &le; i &and; 1 + flted_14_1365 = i &and; 0 &le; flted_14_1365)  &#8866;  0 = flted_14_1365
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[i, flted_14_1365] : (( (not (((((0 != i) &amp; (0 &lt;= i)) &amp; (1 + flted_14_1365 = i)) &amp; (0 &lt;= flted_14_1365))))  | (0 = flted_14_1365)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[i,i-1]: 2 &lt;= i}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; i &and; 0 &le; i &and; 1 + flted_14_1365 = i &and; 0 &le; flted_14_1365)  &#8866;  0 &ne; flted_14_1365
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[i, flted_14_1365] : (( (not (((((0 != i) &amp; (0 &lt;= i)) &amp; (1 + flted_14_1365 = i)) &amp; (0 &lt;= flted_14_1365))))  | (0 != flted_14_1365)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>q_1372 = <b>null</b>  &#8866;  <b>null</b> = q_1372
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1372] : (((q_1372 &gt; 0) | (q_1372 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1372]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure set_next<ul><li class="Collapsed procdef">Internal representation
<ul>void set_next$node~node(  node x,  node y)<br/>
static  EBase exists (Expl)[](Impl)[i; <br/>
       j](ex)[]NN x::ll&lt;i&gt;@M[Orig][LHSCase]@ rem br[{219}] * <br/>
       NN y::ll&lt;j&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp; (<br/>
       ([null!=x][0!=i &amp; 0&lt;=i][0&lt;=j])) &amp; {FLOW,(49,49)=__norm}<br/>
         EAssume 10::<br/>
           EXISTS(flted_75_78: NN x::ll&lt;flted_75_78&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp;<br/>
           (([0&lt;=flted_75_78 &amp; -1+flted_75_78=j])) &amp; {FLOW,(49,49)=__norm})<br/>
dynamic  []<br/>
142::bind x to (val_78_846,next_78_847) in <br/>
{next_78_847 = y<br/>
}<br/>
<br/>
{(72,1),(0,-1)}<br/>
</ul></li><li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; i &and; 0 &ne; i &and; 1 + flted_14_1400 = i &and; 0 &le; flted_14_1400)  &#8866;  0 = flted_14_1400
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[i, flted_14_1400] : (( (not (((((0 &lt;= i) &amp; (0 != i)) &amp; (1 + flted_14_1400 = i)) &amp; (0 &lt;= flted_14_1400))))  | (0 = flted_14_1400)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[i,i-1]: 2 &lt;= i}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; i &and; 0 &ne; i &and; 1 + flted_14_1400 = i &and; 0 &le; flted_14_1400)  &#8866;  0 &ne; flted_14_1400
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[i, flted_14_1400] : (( (not (((((0 &lt;= i) &amp; (0 != i)) &amp; (1 + flted_14_1400 = i)) &amp; (0 &lt;= flted_14_1400))))  | (0 != flted_14_1400)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>0 &le; j  &#8866;  (<b>null</b> = q_1404 &or; 0 = j)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1404, j] : (((0 &gt; j) | ((q_1404 &lt; 1) | (0 = j))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1404,j]: 1 &lt;= j &amp;&amp; 1 &lt;= q_1404}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>q_1404 = q_1404  &#8866;  <b>null</b> = q_1404
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1404] : (((q_1404 != q_1404) | (q_1404 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1404]: 1 &lt;= q_1404}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>0 &le; j  &#8866;  1 + j = j + 1
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[j] : (((0 &gt; j) | (1 + j = j + 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[j]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure get_next<ul><li class="Collapsed procdef">Internal representation
<ul>node get_next$node(  node x)<br/>
static  EBase exists (Expl)[](Impl)[n](ex)[]NN x::ll&lt;n&gt;@M[Orig][LHSCase]@ rem br[{219}] &amp;<br/>
       (([0!=n &amp; 0&lt;=n][null!=x])) &amp; {FLOW,(49,49)=__norm}<br/>
         EAssume 8::<br/>
           EXISTS(flted_60_81,<br/>
           flted_60_82: NN x::ll&lt;flted_60_82&gt;@M[Orig][LHSCase]@ rem br[{219}] * <br/>
           NN res::ll&lt;flted_60_81&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp; (<br/>
           ([null!=x][1=flted_60_82][0&lt;=flted_60_81 &amp; 1+flted_60_81=n])) &amp;<br/>
           {FLOW,(49,49)=__norm})<br/>
dynamic  []<br/>
node tmp_83;<br/>
tmp_83 = 143::bind x to (val_64_865,next_64_866) in <br/>
{next_64_866<br/>
};<br/>
{<br/>
null v_null_66_867;<br/>
v_null_66_867 = null;<br/>
145::bind x to (val_66_868,next_66_869) in <br/>
{next_66_869 = v_null_66_867<br/>
}<br/>
};<br/>
node v_node_67_870;<br/>
v_node_67_870 = tmp_83;<br/>
146::return v_node_67_870<br/>
<br/>
{(57,0),(0,-1)}<br/>
</ul></li><li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>res = res  &#8866;  <b>null</b> = res
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[res] : (((res != res) | (res &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[res]: 1 &lt;= res}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>res = res  &#8866;  res &ne; <b>null</b>
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[res] : (((res != res) | (res &gt; 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[res]: res &lt;= 0}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>q_1442 = <b>null</b>  &#8866;  <b>null</b> = q_1442
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1442] : (((q_1442 &gt; 0) | (q_1442 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1442]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; n &and; 0 &le; n &and; 1 &le; n &and; 0 &le; flted_14_1432 &and; 1 + flted_14_1432 = n)  &#8866;  (<b>null</b> = res &or; 0 = flted_14_1432)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n, res, flted_14_1432] : (( (not ((((((0 != n) &amp; (0 &lt;= n)) &amp; (1 &lt;= n)) &amp; (0 &lt;= flted_14_1432)) &amp; (1 + flted_14_1432 = n))))  | ((res &lt; 1) | (0 = flted_14_1432))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n,res,n-1]: 2 &lt;= n &amp;&amp; 1 &lt;= res}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &le; flted_14_1432 &and; 0 &le; n &and; 1 + flted_14_1432 = n &and; 0 &ne; n)  &#8866;  1 + flted_14_1432 = n
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[flted_14_1432, n] : (( (not (((((0 &lt;= flted_14_1432) &amp; (0 &lt;= n)) &amp; (1 + flted_14_1432 = n)) &amp; (0 != n))))  | (1 + flted_14_1432 = n)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[flted_14_1432,n]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure ret_first<ul><li class="Collapsed procdef">Internal representation
<ul>node ret_first$node(  node x)<br/>
static  EBase exists (Expl)[](Impl)[n; y; <br/>
       m](ex)[]NN x::ll&lt;n&gt;@M[Orig][LHSCase]@ rem br[{219,218}] * <br/>
       NN y::ll&lt;m&gt;@M[Orig][LHSCase]@ rem br[{219}] &amp; (<br/>
       ([0&lt;=n &amp; (1+n)&lt;=m][null!=y])) &amp; {FLOW,(49,49)=__norm}<br/>
         EAssume 7::<br/>
           EXISTS(n_84: NN x::ll&lt;n_84&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp;<br/>
           (([n=n_84 &amp; 0&lt;=n_84])) &amp; {FLOW,(49,49)=__norm})<br/>
dynamic  []<br/>
node v_node_53_885;<br/>
v_node_53_885 = x;<br/>
147::return v_node_53_885<br/>
<br/>
{(47,0),(0,-1)}<br/>
</ul></li><li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; m &and; 0 &ne; m &and; 0 &le; n &and; 1 + n &le; m)  &#8866;  (<b>null</b> = res &or; 0 = n)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[m, res, n] : (( (not (((((0 &lt;= m) &amp; (0 != m)) &amp; (0 &lt;= n)) &amp; (1 + n &lt;= m))))  | ((res &lt; 1) | (0 = n))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[m,res,n]: 1 &lt;= n &lt; m &amp;&amp; 1 &lt;= res}</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure append<ul><li class="Collapsed procdef">Internal representation
<ul>void append$node~node(  node x,  node y)<br/>
static  EBase exists (Expl)[](Impl)[n1; <br/>
       n2](ex)[]NN x::ll&lt;n1&gt;@M[Orig][LHSCase]@ rem br[{219}] * <br/>
       NN y::ll&lt;n2&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp; (<br/>
       ([null!=x][0!=n1 &amp; 0&lt;=n1][0&lt;=n2])) &amp; {FLOW,(49,49)=__norm}<br/>
         EAssume 4::<br/>
           EXISTS(flted_38_86: NN x::ll&lt;flted_38_86&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp;<br/>
           (([0&lt;=flted_38_86 &amp; flted_38_86=n1+n2])) &amp; {FLOW,(49,49)=__norm})<br/>
dynamic  []<br/>
boolean v_bool_40_912;<br/>
v_bool_40_912 = {<br/>
node v_node_40_906;<br/>
v_node_40_906 = 154::bind x to (val_40_904,next_40_905) in <br/>
{next_40_905<br/>
};<br/>
153::is_null___$node(v_node_40_906)<br/>
};<br/>
148::if (v_bool_40_912) LABEL! 148,0: 152::bind x to (val_41_907,next_41_908) in <br/>
{next_41_908 = y<br/>
}<br/>
else LABEL! 148,1: {<br/>
node v_node_43_911;<br/>
v_node_43_911 = 150::bind x to (val_43_909,next_43_910) in <br/>
{next_43_910<br/>
};<br/>
149::append$node~node(v_node_43_911,y) rec<br/>
}<br/>
<br/>
<br/>
{(36,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pureimplyvalid">Verification condition
<ul><b>null</b> = q_1485  &#8866;  <b>null</b> = q_1485
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1485] : (((q_1485 &gt; 0) | (q_1485 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1485]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n1 &and; 0 &ne; n1 &and; 1 + flted_14_1484 = n1 &and; 0 &le; flted_14_1484)  &#8866;  0 = flted_14_1484
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n1, flted_14_1484] : (( (not (((((0 &lt;= n1) &amp; (0 != n1)) &amp; (1 + flted_14_1484 = n1)) &amp; (0 &lt;= flted_14_1484))))  | (0 = flted_14_1484)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n1,n1-1]: 2 &lt;= n1}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n1 &and; 0 &ne; n1 &and; 1 + flted_14_1484 = n1 &and; 0 &le; flted_14_1484)  &#8866;  0 &ne; flted_14_1484
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n1, flted_14_1484] : (( (not (((((0 &lt;= n1) &amp; (0 != n1)) &amp; (1 + flted_14_1484 = n1)) &amp; (0 &lt;= flted_14_1484))))  | (0 != flted_14_1484)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul><b>null</b> = q_1485  &#8866;  q_1485 &ne; <b>null</b>
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1485] : (((q_1485 &gt; 0) | (q_1485 &gt; 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1485]: q_1485 &lt;= 0}</li></ul></ul></li>
<li class="Collapsed pre">
Precondition of procedure call 149::append$node~node(v_node_43_911,y) rec at <a href="#L43">line 43</a> holds<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n1 &and; 0 &ne; n1 &and; 1 &le; n1 &and; <b>null</b> &ne; q_1485 &and; 0 &ne; flted_14_1484 &and; 0 &le; flted_14_1484 &and; 1 + flted_14_1484 = n1)  &#8866;  (<b>null</b> = q_1485 &or; 0 = flted_14_1484)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n1, q_1485, flted_14_1484] : (( (not ((((((((0 &lt;= n1) &amp; (0 != n1)) &amp; (1 &lt;= n1)) &amp; (q_1485 &gt; 0)) &amp; (0 != flted_14_1484)) &amp; (0 &lt;= flted_14_1484)) &amp; (1 + flted_14_1484 = n1))))  | ((q_1485 &lt; 1) | (0 = flted_14_1484))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n1,q_1485,n1-1]: 2 &lt;= n1 &amp;&amp; 1 &lt;= q_1485}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>0 &le; n2  &#8866;  (<b>null</b> = y' &or; 0 = n2)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[yPRMD, n2] : (((0 &gt; n2) | ((yPRMD &lt; 1) | (0 = n2))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[yPRMD,n2]: 1 &lt;= n2 &amp;&amp; 1 &lt;= yPRMD}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; n1 &and; 0 &le; n1 &and; 0 &ne; flted_14_1484 &and; 1 + flted_14_1484 = n1 &and; 0 &le; flted_14_1484 &and; 0 &le; n2_1498 &and; flted_38_1507 = flted_14_1484 + n2_1498 &and; 0 &le; flted_38_1507)  &#8866;  0 = flted_38_1507
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n1, flted_14_1484, n2_1498, flted_38_1507] : (( (not (((((((((0 != n1) &amp; (0 &lt;= n1)) &amp; (0 != flted_14_1484)) &amp; (1 + flted_14_1484 = n1)) &amp; (0 &lt;= flted_14_1484)) &amp; (0 &lt;= n2_1498)) &amp; (flted_38_1507 = flted_14_1484 + n2_1498)) &amp; (0 &lt;= flted_38_1507))))  | (0 = flted_38_1507)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n1,n1-1,n2_1498,n1+n2_1498-1]: 2 &lt;= n1 &amp;&amp; 0 &lt;= n2_1498}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &ne; n1 &and; 0 &le; n1 &and; 0 &ne; flted_14_1484 &and; 1 + flted_14_1484 = n1 &and; 0 &le; flted_14_1484 &and; 0 &le; n2_1498 &and; flted_38_1507 = flted_14_1484 + n2_1498 &and; 0 &le; flted_38_1507)  &#8866;  0 &ne; flted_38_1507
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n1, flted_14_1484, n2_1498, flted_38_1507] : (( (not (((((((((0 != n1) &amp; (0 &lt;= n1)) &amp; (0 != flted_14_1484)) &amp; (1 + flted_14_1484 = n1)) &amp; (0 &lt;= flted_14_1484)) &amp; (0 &lt;= n2_1498)) &amp; (flted_38_1507 = flted_14_1484 + n2_1498)) &amp; (0 &lt;= flted_38_1507))))  | (0 != flted_38_1507)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n1,flted_14_1484,n2_1498,flted_38_1507]  : FALSE }</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>0 &le; n2  &#8866;  (<b>null</b> = q_1509 &or; 0 = n2)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1509, n2] : (((0 &gt; n2) | ((q_1509 &lt; 1) | (0 = n2))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1509,n2]: 1 &lt;= n2 &amp;&amp; 1 &lt;= q_1509}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>q_1509 = q_1509  &#8866;  <b>null</b> = q_1509
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1509] : (((q_1509 != q_1509) | (q_1509 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1509]: 1 &lt;= q_1509}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &le; n2 &and; 0 &le; n1 &and; 1 + 0 = n1 &and; 0 &ne; n1)  &#8866;  n2 + 1 = n2 + n1
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n2, n1] : (( (not (((((0 &lt;= n2) &amp; (0 &lt;= n1)) &amp; (1 + 0 = n1)) &amp; (0 != n1))))  | (n2 + 1 = n2 + n1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n2,n1]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n1 &and; 0 &ne; n1 &and; 0 &ne; flted_14_1484 &and; 0 &le; flted_14_1484 &and; 1 &le; n1 &and; 1 + flted_14_1484 = n1 &and; 0 &le; n2_1498 &and; <b>null</b> &ne; q_1527 &and; 0 &ne; flted_38_1525 &and; 0 &le; flted_38_1525 &and; flted_38_1525 = flted_14_1484 + n2_1498)  &#8866;  (<b>null</b> = q_1527 &or; 0 = flted_38_1525)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n1, flted_14_1484, n2_1498, q_1527, flted_38_1525] : (( (not ((((((((((((0 &lt;= n1) &amp; (0 != n1)) &amp; (0 != flted_14_1484)) &amp; (0 &lt;= flted_14_1484)) &amp; (1 &lt;= n1)) &amp; (1 + flted_14_1484 = n1)) &amp; (0 &lt;= n2_1498)) &amp; (q_1527 &gt; 0)) &amp; (0 != flted_38_1525)) &amp; (0 &lt;= flted_38_1525)) &amp; (flted_38_1525 = flted_14_1484 + n2_1498))))  | ((q_1527 &lt; 1) | (0 = flted_38_1525))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n1,n1-1,n2_1498,q_1527,n1+n2_1498-1]: 2 &lt;= n1 &amp;&amp; 0 &lt;= n2_1498 &amp;&amp; 1 &lt;= q_1527}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul><b>null</b> &ne; q_1527  &#8866;  <b>null</b> = q_1527
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1527] : (((q_1527 &lt; 1) | (q_1527 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1527]: 1 &lt;= q_1527}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &ne; flted_14_1484 &and; 0 &le; flted_14_1484 &and; 0 &ne; flted_38_1525 &and; 0 &le; flted_38_1525 &and; 0 &le; n1 &and; 0 &ne; n1 &and; 0 &le; n2_1498 &and; 1 + flted_14_1484 = n1 &and; flted_38_1525 = flted_14_1484 + n2_1498)  &#8866;  flted_38_1525 + 1 = n2_1498 + n1
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[flted_14_1484, flted_38_1525, n2_1498, n1] : (( (not ((((((((((0 != flted_14_1484) &amp; (0 &lt;= flted_14_1484)) &amp; (0 != flted_38_1525)) &amp; (0 &lt;= flted_38_1525)) &amp; (0 &lt;= n1)) &amp; (0 != n1)) &amp; (0 &lt;= n2_1498)) &amp; (1 + flted_14_1484 = n1)) &amp; (flted_38_1525 = flted_14_1484 + n2_1498))))  | (flted_38_1525 + 1 = n2_1498 + n1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[flted_14_1484,flted_38_1525,n2_1498,n1]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed proc">
Procedure append2<ul><li class="Collapsed procdef">Internal representation
<ul>void append2$node~node(  node x,  node y)<br/>
static  EBase exists (Expl)[](Impl)[n1; <br/>
       n2](ex)[]NN x::ll&lt;n1&gt;@M[Orig][LHSCase]@ rem br[{219}] * <br/>
       NN y::ll&lt;n2&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp; (<br/>
       ([0!=n1 &amp; 0&lt;=n1][null!=x][0&lt;=n2])) &amp; {FLOW,(49,49)=__norm}<br/>
         EAssume 1::<br/>
           EXISTS(flted_28_88: NN x::ll&lt;flted_28_88&gt;@M[Orig][LHSCase]@ rem br[{219,218}] &amp;<br/>
           (([0&lt;=flted_28_88 &amp; flted_28_88=n1+n2])) &amp; {FLOW,(49,49)=__norm})<br/>
dynamic  []<br/>
boolean v_bool_30_939;<br/>
v_bool_30_939 = {<br/>
node v_node_30_933;<br/>
v_node_30_933 = 161::bind x to (val_30_931,next_30_932) in <br/>
{next_30_932<br/>
};<br/>
160::is_null___$node(v_node_30_933)<br/>
};<br/>
155::if (v_bool_30_939) LABEL! 155,0: 159::bind x to (val_31_934,next_31_935) in <br/>
{next_31_935 = y<br/>
}<br/>
else LABEL! 155,1: {<br/>
node v_node_33_938;<br/>
v_node_33_938 = 157::bind x to (val_33_936,next_33_937) in <br/>
{next_33_937<br/>
};<br/>
156::append2$node~node(v_node_33_938,y) rec<br/>
}<br/>
<br/>
<br/>
{(26,0),(0,-1)}<br/>
</ul></li><li class="Collapsed pureimplyvalid">Verification condition
<ul><b>null</b> = q_1559  &#8866;  <b>null</b> = q_1559
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1559] : (((q_1559 &gt; 0) | (q_1559 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1559]  : FALSE }</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n1 &and; 0 &ne; n1 &and; 1 + flted_14_1558 = n1 &and; 0 &le; flted_14_1558)  &#8866;  0 = flted_14_1558
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n1, flted_14_1558] : (( (not (((((0 &lt;= n1) &amp; (0 != n1)) &amp; (1 + flted_14_1558 = n1)) &amp; (0 &lt;= flted_14_1558))))  | (0 = flted_14_1558)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n1,n1-1]: 2 &lt;= n1}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n1 &and; 0 &ne; n1 &and; 1 + flted_14_1558 = n1 &and; 0 &le; flted_14_1558)  &#8866;  0 &ne; flted_14_1558
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n1, flted_14_1558] : (( (not (((((0 &lt;= n1) &amp; (0 != n1)) &amp; (1 + flted_14_1558 = n1)) &amp; (0 &lt;= flted_14_1558))))  | (0 != flted_14_1558)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[1,0]}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul><b>null</b> = q_1559  &#8866;  q_1559 &ne; <b>null</b>
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1559] : (((q_1559 &gt; 0) | (q_1559 &gt; 0)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1559]: q_1559 &lt;= 0}</li></ul></ul></li>
<li class="Collapsed pre">
Precondition of procedure call 156::append2$node~node(v_node_33_938,y) rec at <a href="#L33">line 33</a> holds<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n1 &and; 0 &ne; n1 &and; <b>null</b> &ne; q_1559 &and; 0 &ne; flted_14_1558 &and; 0 &le; flted_14_1558 &and; 1 + flted_14_1558 = n1)  &#8866;  (<b>null</b> = q_1559 &or; 0 = flted_14_1558)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n1, q_1559, flted_14_1558] : (( (not (((((((0 &lt;= n1) &amp; (0 != n1)) &amp; (q_1559 &gt; 0)) &amp; (0 != flted_14_1558)) &amp; (0 &lt;= flted_14_1558)) &amp; (1 + flted_14_1558 = n1))))  | ((q_1559 &lt; 1) | (0 = flted_14_1558))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n1,q_1559,n1-1]: 2 &lt;= n1 &amp;&amp; 1 &lt;= q_1559}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &ne; n1 &and; 0 &le; n1 &and; 1 + flted_14_1558 = n1 &and; 0 &ne; flted_14_1558 &and; 0 &le; flted_14_1558 &and; 0 &le; n2_1572 &and; flted_28_1581 = flted_14_1558 + n2_1572 &and; 0 &le; flted_28_1581)  &#8866;  0 = flted_28_1581
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n1, flted_14_1558, n2_1572, flted_28_1581] : (( (not (((((((((0 != n1) &amp; (0 &lt;= n1)) &amp; (1 + flted_14_1558 = n1)) &amp; (0 != flted_14_1558)) &amp; (0 &lt;= flted_14_1558)) &amp; (0 &lt;= n2_1572)) &amp; (flted_28_1581 = flted_14_1558 + n2_1572)) &amp; (0 &lt;= flted_28_1581))))  | (0 = flted_28_1581)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n1,n1-1,n2_1572,n1+n2_1572-1]: 2 &lt;= n1 &amp;&amp; 0 &lt;= n2_1572}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &ne; n1 &and; 0 &le; n1 &and; 1 + flted_14_1558 = n1 &and; 0 &ne; flted_14_1558 &and; 0 &le; flted_14_1558 &and; 0 &le; n2_1572 &and; flted_28_1581 = flted_14_1558 + n2_1572 &and; 0 &le; flted_28_1581)  &#8866;  0 &ne; flted_28_1581
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n1, flted_14_1558, n2_1572, flted_28_1581] : (( (not (((((((((0 != n1) &amp; (0 &lt;= n1)) &amp; (1 + flted_14_1558 = n1)) &amp; (0 != flted_14_1558)) &amp; (0 &lt;= flted_14_1558)) &amp; (0 &lt;= n2_1572)) &amp; (flted_28_1581 = flted_14_1558 + n2_1572)) &amp; (0 &lt;= flted_28_1581))))  | (0 != flted_28_1581)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n1,flted_14_1558,n2_1572,flted_28_1581]  : FALSE }</li></ul></ul></li>
</ul></li>
<li class="Collapsed post">
Procedure post-condition holds
<ul><li class="Collapsed pureimplyinvalid">Verification condition
<ul>0 &le; n2  &#8866;  (<b>null</b> = q_1583 &or; 0 = n2)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1583, n2] : (((0 &gt; n2) | ((q_1583 &lt; 1) | (0 = n2))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1583,n2]: 1 &lt;= n2 &amp;&amp; 1 &lt;= q_1583}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>q_1583 = q_1583  &#8866;  <b>null</b> = q_1583
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1583] : (((q_1583 != q_1583) | (q_1583 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1583]: 1 &lt;= q_1583}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul>(0 &le; n1 &and; 0 &ne; n1 &and; 0 &le; flted_14_1558 &and; 0 &ne; flted_14_1558 &and; 0 &le; n2_1572 &and; 1 + flted_14_1558 = n1 &and; <b>null</b> &ne; q_1601 &and; 0 &ne; flted_28_1599 &and; 0 &le; flted_28_1599 &and; flted_28_1599 = flted_14_1558 + n2_1572)  &#8866;  (<b>null</b> = q_1601 &or; 0 = flted_28_1599)
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[n1, flted_14_1558, n2_1572, q_1601, flted_28_1599] : (( (not (((((((((((0 &lt;= n1) &amp; (0 != n1)) &amp; (0 &lt;= flted_14_1558)) &amp; (0 != flted_14_1558)) &amp; (0 &lt;= n2_1572)) &amp; (1 + flted_14_1558 = n1)) &amp; (q_1601 &gt; 0)) &amp; (0 != flted_28_1599)) &amp; (0 &lt;= flted_28_1599)) &amp; (flted_28_1599 = flted_14_1558 + n2_1572))))  | ((q_1601 &lt; 1) | (0 = flted_28_1599))))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[n1,n1-1,n2_1572,q_1601,n1+n2_1572-1]: 2 &lt;= n1 &amp;&amp; 1 &lt;= q_1601 &amp;&amp; 0 &lt;= n2_1572}</li></ul></ul></li>
<li class="Collapsed pureimplyinvalid">Verification condition
<ul><b>null</b> &ne; q_1601  &#8866;  <b>null</b> = q_1601
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[q_1601] : (((q_1601 &lt; 1) | (q_1601 &lt; 1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[q_1601]: 1 &lt;= q_1601}</li></ul></ul></li>
<li class="Collapsed pureimplyvalid">Verification condition
<ul>(0 &le; flted_14_1558 &and; 0 &ne; flted_14_1558 &and; 0 &ne; flted_28_1599 &and; 0 &le; n1 &and; 1 + flted_14_1558 = n1 &and; 0 &le; flted_28_1599 &and; 0 &le; n2_1572 &and; flted_28_1599 = flted_14_1558 + n2_1572 &and; 0 &ne; n1)  &#8866;  flted_28_1599 + 1 = n2_1572 + n1
<li class="Collapsed proverinput">Input to prover OMEGA CALCULATOR
<ul>complement {[flted_14_1558, flted_28_1599, n2_1572, n1] : (( (not ((((((((((0 &lt;= flted_14_1558) &amp; (0 != flted_14_1558)) &amp; (0 != flted_28_1599)) &amp; (0 &lt;= n1)) &amp; (1 + flted_14_1558 = n1)) &amp; (0 &lt;= flted_28_1599)) &amp; (0 &lt;= n2_1572)) &amp; (flted_28_1599 = flted_14_1558 + n2_1572)) &amp; (0 != n1))))  | (flted_28_1599 + 1 = n2_1572 + n1)))};<br/>
</ul></li><li class="Collapsed proveroutput">Output of prover OMEGA CALCULATOR
<ul>{[flted_14_1558,flted_28_1599,n2_1572,n1]  : FALSE }</li></ul></ul></li>
</ul></li>
</ul></li>
<li class="Collapsed term">Termination of all procedures
<ul></ul></li>
</ul>
<script>
	SetupTreeView("ProofTree");
</script>
</body>
</html>