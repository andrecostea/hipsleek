Starting Omega...oc
Translating global variables to procedure parameters...

trans_global_to_param@1
trans_global_to_param inp1 :class Object extends  {



}

class String extends Object {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}





relation amodr
relation update_array_2d
relation update_array_1d
relation update_array_1d_b
relation domb
relation dom
relation induce
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


int[] aalloc___(int dim)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 302,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 301,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)
static 

(None,[]): EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 300,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)
static 

(None,[]): EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 299,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 298,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 297,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 296,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 295,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join(int id)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 294,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 293,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 292,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)
static 

(None,[]): EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 291,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)
static 

(None,[]): EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 290,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 289,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)
static 

(None,[]): case{ECase:

	 !(a)->

(None,[]): EAssume: 288,:(emp)*(res)( FLOW __norm)

	 a->

(None,[]): EAssume: 287,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)
static 

(None,[]): case{ECase:

	 !(a)->

(None,[]): case{ECase:

	 !(b)->

(None,[]): EAssume: 286,:(emp)*(!(res))( FLOW __norm)

	 b->

(None,[]): EAssume: 285,:(emp)*(res)( FLOW __norm)
}

	 a->

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 284,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)
static 

(None,[]): case{ECase:

	 !(a)->

(None,[]): EAssume: 283,:(emp)*(!(res))( FLOW __norm)

	 a->

(None,[]): case{ECase:

	 !(b)->

(None,[]): EAssume: 282,:(emp)*(!(res))( FLOW __norm)

	 b->

(None,[]): EAssume: 281,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)
static 

(None,[]): case{ECase:

	 a < b->

(None,[]): EAssume: 280,:(emp)*(!(res))( FLOW __norm)

	 a >= b->

(None,[]): EAssume: 279,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)
static 

(None,[]): case{ECase:

	 a <= b->

(None,[]): EAssume: 278,:(emp)*(!(res))( FLOW __norm)

	 a > b->

(None,[]): EAssume: 277,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)
static 

(None,[]): case{ECase:

	 a > b->

(None,[]): EAssume: 276,:(emp)*(!(res))( FLOW __norm)

	 a <= b->

(None,[]): EAssume: 275,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)
static 

(None,[]): case{ECase:

	 a >= b->

(None,[]): EAssume: 274,:(emp)*(!(res))( FLOW __norm)

	 a < b->

(None,[]): EAssume: 273,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)
static 

(None,[]): case{ECase:

	 a != b->

(None,[]): EAssume: 272,:(emp)*(res)( FLOW __norm)

	 a = b->

(None,[]): EAssume: 271,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)
static 

(None,[]): case{ECase:

	 a != b->

(None,[]): EAssume: 270,:(emp)*(res)( FLOW __norm)

	 a = b->

(None,[]): EAssume: 269,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(boolean a, boolean b)
static 

(None,[]): case{ECase:

	 a != b->

(None,[]): EAssume: 268,:(emp)*(!(res))( FLOW __norm)

	 a = b->

(None,[]): EAssume: 267,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)
static 

(None,[]): case{ECase:

	 a != b->

(None,[]): EAssume: 266,:(emp)*(!(res))( FLOW __norm)

	 a = b->

(None,[]): EAssume: 265,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)
static 

(None,[]): case{ECase:

	 a < 0->

(None,[]): case{ECase:

	 ((0-1) < b) & (b < 1)->

(None,[]): EAssume: 264,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->

(None,[]): EAssume: 263,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->

(None,[]): EAssume: 262,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->

(None,[]): case{ECase:

	 ((0-1) < b) & (b < 1)->

(None,[]): EAssume: 261,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->

(None,[]): EAssume: 260,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->

(None,[]): case{ECase:

	 a >= b->

(None,[]): case{ECase:

	 a >= (2) * (b)->

(None,[]): EAssume: 259,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->

(None,[]): EAssume: 258,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->

(None,[]): EAssume: 257,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)
static 

(None,[]): EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 256,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)
static 

(None,[]): case{ECase:

	 b != 0->

(None,[]): EAssume: 255,:(emp)*(true)( FLOW __norm)

	 b = 0->

(None,[]): EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 254,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->

(None,[]): EAssume: 253,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->

(None,[]): EAssume: 252,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)
static 

(None,[]): case{ECase:

	 a < 0->

(None,[]): case{ECase:

	 ((0-1) < b) & (b < 1)->

(None,[]): EAssume: 251,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->

(None,[]): EAssume: 250,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->

(None,[]): EAssume: 249,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->

(None,[]): case{ECase:

	 ((0-1) < b) & (b < 1)->

(None,[]): EAssume: 248,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->

(None,[]): EAssume: 247,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->

(None,[]): EAssume: 246,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 0) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 245,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 244,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 243,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 


trans_global_to_param@1 EXIT out :class Object extends  {



}

class String extends Object {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}





relation amodr
relation update_array_2d
relation update_array_1d
relation update_array_1d_b
relation domb
relation dom
relation induce
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


int[] aalloc___(int dim)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 302,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 301,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)
static 

(None,[]): EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 300,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)
static 

(None,[]): EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 299,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 298,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 297,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 296,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 295,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join(int id)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 294,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 293,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 292,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)
static 

(None,[]): EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 291,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)
static 

(None,[]): EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 290,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 289,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)
static 

(None,[]): case{ECase:

	 !(a)->

(None,[]): EAssume: 288,:(emp)*(res)( FLOW __norm)

	 a->

(None,[]): EAssume: 287,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)
static 

(None,[]): case{ECase:

	 !(a)->

(None,[]): case{ECase:

	 !(b)->

(None,[]): EAssume: 286,:(emp)*(!(res))( FLOW __norm)

	 b->

(None,[]): EAssume: 285,:(emp)*(res)( FLOW __norm)
}

	 a->

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 284,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)
static 

(None,[]): case{ECase:

	 !(a)->

(None,[]): EAssume: 283,:(emp)*(!(res))( FLOW __norm)

	 a->

(None,[]): case{ECase:

	 !(b)->

(None,[]): EAssume: 282,:(emp)*(!(res))( FLOW __norm)

	 b->

(None,[]): EAssume: 281,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)
static 

(None,[]): case{ECase:

	 a < b->

(None,[]): EAssume: 280,:(emp)*(!(res))( FLOW __norm)

	 a >= b->

(None,[]): EAssume: 279,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)
static 

(None,[]): case{ECase:

	 a <= b->

(None,[]): EAssume: 278,:(emp)*(!(res))( FLOW __norm)

	 a > b->

(None,[]): EAssume: 277,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)
static 

(None,[]): case{ECase:

	 a > b->

(None,[]): EAssume: 276,:(emp)*(!(res))( FLOW __norm)

	 a <= b->

(None,[]): EAssume: 275,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)
static 

(None,[]): case{ECase:

	 a >= b->

(None,[]): EAssume: 274,:(emp)*(!(res))( FLOW __norm)

	 a < b->

(None,[]): EAssume: 273,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)
static 

(None,[]): case{ECase:

	 a != b->

(None,[]): EAssume: 272,:(emp)*(res)( FLOW __norm)

	 a = b->

(None,[]): EAssume: 271,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)
static 

(None,[]): case{ECase:

	 a != b->

(None,[]): EAssume: 270,:(emp)*(res)( FLOW __norm)

	 a = b->

(None,[]): EAssume: 269,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(boolean a, boolean b)
static 

(None,[]): case{ECase:

	 a != b->

(None,[]): EAssume: 268,:(emp)*(!(res))( FLOW __norm)

	 a = b->

(None,[]): EAssume: 267,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)
static 

(None,[]): case{ECase:

	 a != b->

(None,[]): EAssume: 266,:(emp)*(!(res))( FLOW __norm)

	 a = b->

(None,[]): EAssume: 265,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)
static 

(None,[]): case{ECase:

	 a < 0->

(None,[]): case{ECase:

	 ((0-1) < b) & (b < 1)->

(None,[]): EAssume: 264,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->

(None,[]): EAssume: 263,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->

(None,[]): EAssume: 262,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->

(None,[]): case{ECase:

	 ((0-1) < b) & (b < 1)->

(None,[]): EAssume: 261,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->

(None,[]): EAssume: 260,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->

(None,[]): case{ECase:

	 a >= b->

(None,[]): case{ECase:

	 a >= (2) * (b)->

(None,[]): EAssume: 259,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->

(None,[]): EAssume: 258,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->

(None,[]): EAssume: 257,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)
static 

(None,[]): EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 256,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)
static 

(None,[]): case{ECase:

	 b != 0->

(None,[]): EAssume: 255,:(emp)*(true)( FLOW __norm)

	 b = 0->

(None,[]): EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 254,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->

(None,[]): EAssume: 253,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->

(None,[]): EAssume: 252,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)
static 

(None,[]): case{ECase:

	 a < 0->

(None,[]): case{ECase:

	 ((0-1) < b) & (b < 1)->

(None,[]): EAssume: 251,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->

(None,[]): EAssume: 250,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->

(None,[]): EAssume: 249,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->

(None,[]): case{ECase:

	 ((0-1) < b) & (b < 1)->

(None,[]): EAssume: 248,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->

(None,[]): EAssume: 247,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->

(None,[]): EAssume: 246,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 0) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 245,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 244,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 243,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 



trans_global_to_param@2
trans_global_to_param inp1 :class Object extends  {



}

class String extends Object {



}

global boolean Climb_Inhibit;
global int Other_Capability;
global int Other_RAC;
global int Down_Separation;
global int Up_Separation;
global int Alt_Layer_Value;
global int Other_Tracked_Alt;
global int Own_Tracked_Alt_Rate;
global int Own_Tracked_Alt;
global boolean Two_of_Three_Reports_Valid;
global boolean High_Confidence;
global int Cur_Vertical_Sep;



relation dom



int main(int argc, ref int[] Positive_RA_Alt_Thresh)
static 

(None,[]): EBase: [][](emp)*(dom(Positive_RA_Alt_Thresh,0,3))( FLOW __norm) {EAssume: 238,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{if (argc < 13) { 
  {return 1}
;
};
initialize(Positive_RA_Alt_Thresh);;
 :assert  assume: (emp)*((Alt_Layer_Value >= 0) & (Alt_Layer_Value <= 3))( FLOW __norm)
;;
 :assert  assume: (emp)*((Other_RAC >= 0) & (Other_RAC <= 2))( FLOW __norm)
;;
 :assert  assume: (emp)*((Other_Capability = 1) | (Other_Capability = 2))( FLOW __norm)
;;
alt_sep_test(Positive_RA_Alt_Thresh);;
return 0;}

}
int alt_sep_test(ref int[] arr)
static 

(None,[]): EBase: [][](emp)*((dom(arr,0,3)) & ((Alt_Layer_Value >= 0) & (Alt_Layer_Value <= 3)))( FLOW __norm) {case{ECase:

	 (!(High_Confidence)) | ((Own_Tracked_Alt_Rate > 600) | (Cur_Vertical_Sep <= 600))->

(None,[]): EAssume: 213,:(emp)*(res = 4)( FLOW __norm)

	 (High_Confidence) & ((Own_Tracked_Alt_Rate <= 600) & (Cur_Vertical_Sep > 600))->

(None,[]): case{ECase:

	 ((!(Two_of_Three_Reports_Valid)) | (Other_RAC != 0)) & (Other_Capability = 1)->

(None,[]): EAssume: 212,:(emp)*(res = 4)( FLOW __norm)

	 ((Other_Capability = 1) & ((Two_of_Three_Reports_Valid) & (Other_RAC = 0))) | (Other_Capability != 1)->

(None,[]): case{ECase:

	 ((!(Climb_Inhibit)) & (Up_Separation > Down_Separation)) | ((Climb_Inhibit) & ((Up_Separation+100) > Down_Separation))->

(None,[]): case{ECase:

	 Own_Tracked_Alt >= Other_Tracked_Alt->

(None,[]): EAssume: 211,:(emp)*(res = 0)( FLOW __norm)

	 Own_Tracked_Alt < Other_Tracked_Alt->

(None,[]): case{ECase:

	 Down_Separation < arr[Alt_Layer_Value]->

(None,[]): EAssume: 210,:(emp)*(res = 1)( FLOW __norm)

	 Down_Separation >= arr[Alt_Layer_Value]->

(None,[]): EAssume: 209,:(emp)*(res = 0)( FLOW __norm)
}
}

	 ((!(Climb_Inhibit)) & (Up_Separation <= Down_Separation)) | ((Climb_Inhibit) & ((Up_Separation+100) <= Down_Separation))->

(None,[]): case{ECase:

	 Own_Tracked_Alt > Other_Tracked_Alt->

(None,[]): case{ECase:

	 Up_Separation < arr[Alt_Layer_Value]->

(None,[]): EAssume: 208,:(emp)*(res = 0)( FLOW __norm)

	 Up_Separation >= arr[Alt_Layer_Value]->

(None,[]): EAssume: 207,:(emp)*(res = 2)( FLOW __norm)
}

	 Own_Tracked_Alt <= Other_Tracked_Alt->

(None,[]): EAssume: 206,:(emp)*((arr' = arr) & (res = 0))( FLOW __norm)
}
}
}
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{boolean enabled, tcas_equipped, intent_not_known;;
boolean need_upward_RA, need_downward_RA;;;
int alt_sep;;;
enabled = (High_Confidence && Own_Tracked_Alt_Rate <= 600) && (Cur_Vertical_Sep > 600);;
tcas_equipped = Other_Capability == 1;;
intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == 0;;
alt_sep = 4;;
if (enabled && (tcas_equipped && intent_not_known) || (!tcas_equipped)) { 
  {need_upward_RA = (Non_Crossing_Biased_Climb(arr)) && (Own_Below_Threat());
need_downward_RA = (Non_Crossing_Biased_Descend(arr)) && (Own_Above_Threat());;
if (need_upward_RA && need_downward_RA) { 
  alt_sep = 3;
}
else { 
  if (need_upward_RA) { 
  alt_sep = 1;
}
else { 
  if (need_downward_RA) { 
  alt_sep = 2;
}
else { 
  alt_sep = 0;
};
};
};}
;
};;
return alt_sep;}

}
boolean Own_Above_Threat()
static 

(None,[]): case{ECase:

	 Other_Tracked_Alt >= Own_Tracked_Alt->

(None,[]): EAssume: 204,:(emp)*((!(res)) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & (Own_Tracked_Alt' = Own_Tracked_Alt)))( FLOW __norm)

	 Other_Tracked_Alt < Own_Tracked_Alt->

(None,[]): EAssume: 203,:(emp)*((res) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & (Own_Tracked_Alt' = Own_Tracked_Alt)))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{return Other_Tracked_Alt < Own_Tracked_Alt}

}
boolean Own_Below_Threat()
static 

(None,[]): case{ECase:

	 Own_Tracked_Alt >= Other_Tracked_Alt->

(None,[]): EAssume: 201,:(emp)*((!(res)) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & (Own_Tracked_Alt' = Own_Tracked_Alt)))( FLOW __norm)

	 Own_Tracked_Alt < Other_Tracked_Alt->

(None,[]): EAssume: 200,:(emp)*((res) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & (Own_Tracked_Alt' = Own_Tracked_Alt)))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{return Own_Tracked_Alt < Other_Tracked_Alt}

}
boolean Non_Crossing_Biased_Descend(ref int[] arr)
static 

(None,[]): EBase: [][](emp)*((dom(arr,0,3)) & ((Alt_Layer_Value >= 0) & (Alt_Layer_Value <= 3)))( FLOW __norm) {case{ECase:

	 ((!(Climb_Inhibit)) & (Up_Separation > Down_Separation)) | ((Climb_Inhibit) & ((Up_Separation+100) > Down_Separation))->

(None,[]): case{ECase:

	 Other_Tracked_Alt > Own_Tracked_Alt->

(None,[]): case{ECase:

	 Down_Separation < arr[Alt_Layer_Value]->

(None,[]): EAssume: 187,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)

	 Down_Separation >= arr[Alt_Layer_Value]->

(None,[]): case{ECase:

	 Cur_Vertical_Sep < 300->

(None,[]): EAssume: 186,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)

	 Cur_Vertical_Sep >= 300->

(None,[]): EAssume: 185,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (res))))))( FLOW __norm)
}
}

	 Other_Tracked_Alt <= Own_Tracked_Alt->

(None,[]): EAssume: 184,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)
}

	 ((!(Climb_Inhibit)) & (Up_Separation <= Down_Separation)) | ((Climb_Inhibit) & ((Up_Separation+100) <= Down_Separation))->

(None,[]): case{ECase:

	 Other_Tracked_Alt >= Own_Tracked_Alt->

(None,[]): EAssume: 183,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (res))))))( FLOW __norm)

	 Other_Tracked_Alt < Own_Tracked_Alt->

(None,[]): case{ECase:

	 Up_Separation < arr[Alt_Layer_Value]->

(None,[]): EAssume: 182,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)

	 Up_Separation >= arr[Alt_Layer_Value]->

(None,[]): EAssume: 181,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (res))))))( FLOW __norm)
}
}
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{boolean upward_preferred;;
int upward_crossing_situation;;;
boolean result;;;
upward_preferred = (Inhibit_Biased_Climb()) > Down_Separation;;
if (upward_preferred) { 
  {result = ((Own_Below_Threat()) && (Cur_Vertical_Sep >= 300)) && (Down_Separation >= ALIM(arr, Alt_Layer_Value))}
;
}
else { 
  {result = (!(Own_Above_Threat())) || ((Own_Above_Threat()) && (Up_Separation >= ALIM(arr, Alt_Layer_Value)))}
;
};;
return result;}

}
boolean Non_Crossing_Biased_Climb(ref int[] arr)
static 

(None,[]): EBase: [][](emp)*((dom(arr,0,3)) & ((Alt_Layer_Value >= 0) & (Alt_Layer_Value <= 3)))( FLOW __norm) {case{ECase:

	 ((!(Climb_Inhibit)) & (Up_Separation > Down_Separation)) | ((Climb_Inhibit) & ((Up_Separation+100) > Down_Separation))->

(None,[]): case{ECase:

	 Other_Tracked_Alt > Own_Tracked_Alt->

(None,[]): case{ECase:

	 Down_Separation < arr[Alt_Layer_Value]->

(None,[]): EAssume: 167,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (res))))))( FLOW __norm)

	 Down_Separation >= arr[Alt_Layer_Value]->

(None,[]): EAssume: 166,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)
}

	 Other_Tracked_Alt <= Own_Tracked_Alt->

(None,[]): EAssume: 165,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (res))))))( FLOW __norm)
}

	 ((!(Climb_Inhibit)) & (Up_Separation <= Down_Separation)) | ((Climb_Inhibit) & ((Up_Separation+100) <= Down_Separation))->

(None,[]): case{ECase:

	 Other_Tracked_Alt >= Own_Tracked_Alt->

(None,[]): EAssume: 164,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)

	 Other_Tracked_Alt < Own_Tracked_Alt->

(None,[]): case{ECase:

	 Up_Separation < arr[Alt_Layer_Value]->

(None,[]): EAssume: 163,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)

	 Up_Separation >= arr[Alt_Layer_Value]->

(None,[]): case{ECase:

	 Cur_Vertical_Sep < 300->

(None,[]): EAssume: 162,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)

	 Cur_Vertical_Sep >= 300->

(None,[]): EAssume: 161,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (res))))))( FLOW __norm)
}
}
}
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{boolean upward_preferred;;
int upward_crossing_situation;;;
boolean result;;;
upward_preferred = (Inhibit_Biased_Climb()) > Down_Separation;;
if (upward_preferred) { 
  {result = (!(Own_Below_Threat())) || ((Own_Below_Threat()) && (!(Down_Separation >= ALIM(arr, Alt_Layer_Value))))}
;
}
else { 
  {result = ((Own_Above_Threat()) && (Cur_Vertical_Sep >= 300)) && (Up_Separation >= ALIM(arr, Alt_Layer_Value))}
;
};;
return result;}

}
int Inhibit_Biased_Climb()
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 Climb_Inhibit->

(None,[]): EAssume: 159,:(emp)*((res = Up_Separation+100) & ((Up_Separation' = Up_Separation) & (Climb_Inhibit' = Climb_Inhibit)))( FLOW __norm)

	 !(Climb_Inhibit)->

(None,[]): EAssume: 158,:(emp)*((res = Up_Separation) & ((Up_Separation' = Up_Separation) & (Climb_Inhibit' = Climb_Inhibit)))( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{if (Climb_Inhibit) { 
  return Up_Separation + 100;
}
else { 
  return Up_Separation;
}}

}
int ALIM(int[] arr, int i)
static 

(None,[]): EBase: [][](emp)*((dom(arr,0,3)) & ((0 <= i) & (i <= 3)))( FLOW __norm) {EAssume: 157,:(emp)*(res = arr[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{int k = arr[i];;
return k;}

}
void initialize(ref int[] Positive_RA_Alt_Thresh)
static 

(None,[]): EBase: [][](emp)*(dom(Positive_RA_Alt_Thresh,0,3))( FLOW __norm) {EAssume: 152,:(emp)*((dom(Positive_RA_Alt_Thresh',0,3)) & (((Positive_RA_Alt_Thresh'[0]) = 400) & (((Positive_RA_Alt_Thresh'[1]) = 500) & (((Positive_RA_Alt_Thresh'[2]) = 640) & ((Positive_RA_Alt_Thresh'[3]) = 740)))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{Positive_RA_Alt_Thresh[0] = 400;
Positive_RA_Alt_Thresh[1] = 500;;
Positive_RA_Alt_Thresh[2] = 640;;
Positive_RA_Alt_Thresh[3] = 740;}

}

trans_global_to_param@2 EXIT out :class Object extends  {



}

class String extends Object {



}

global boolean Climb_Inhibit;
global int Other_Capability;
global int Other_RAC;
global int Down_Separation;
global int Up_Separation;
global int Alt_Layer_Value;
global int Other_Tracked_Alt;
global int Own_Tracked_Alt_Rate;
global int Own_Tracked_Alt;
global boolean Two_of_Three_Reports_Valid;
global boolean High_Confidence;
global int Cur_Vertical_Sep;



relation dom



int main(int argc, ref int[] Positive_RA_Alt_Thresh, ref boolean Climb_Inhibit, ref int Up_Separation, ref int Other_Tracked_Alt, ref int Own_Tracked_Alt)
static 

(None,[]): EBase: [][](emp)*(dom(Positive_RA_Alt_Thresh,0,3))( FLOW __norm) {EAssume: 238,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{if (argc < 13) { 
  {return 1}
;
};
initialize(Positive_RA_Alt_Thresh);;
 :assert  assume: (emp)*((Alt_Layer_Value >= 0) & (Alt_Layer_Value <= 3))( FLOW __norm)
;;
 :assert  assume: (emp)*((Other_RAC >= 0) & (Other_RAC <= 2))( FLOW __norm)
;;
 :assert  assume: (emp)*((Other_Capability = 1) | (Other_Capability = 2))( FLOW __norm)
;;
alt_sep_test(Positive_RA_Alt_Thresh, Climb_Inhibit, Up_Separation, Other_Tracked_Alt, Own_Tracked_Alt);;
return 0;}

}
int alt_sep_test(ref int[] arr, ref boolean Climb_Inhibit, ref int Up_Separation, ref int Other_Tracked_Alt, ref int Own_Tracked_Alt)
static 

(None,[]): EBase: [][](emp)*((dom(arr,0,3)) & ((Alt_Layer_Value >= 0) & (Alt_Layer_Value <= 3)))( FLOW __norm) {case{ECase:

	 (!(High_Confidence)) | ((Own_Tracked_Alt_Rate > 600) | (Cur_Vertical_Sep <= 600))->

(None,[]): EAssume: 213,:(emp)*(res = 4)( FLOW __norm)

	 (High_Confidence) & ((Own_Tracked_Alt_Rate <= 600) & (Cur_Vertical_Sep > 600))->

(None,[]): case{ECase:

	 ((!(Two_of_Three_Reports_Valid)) | (Other_RAC != 0)) & (Other_Capability = 1)->

(None,[]): EAssume: 212,:(emp)*(res = 4)( FLOW __norm)

	 ((Other_Capability = 1) & ((Two_of_Three_Reports_Valid) & (Other_RAC = 0))) | (Other_Capability != 1)->

(None,[]): case{ECase:

	 ((!(Climb_Inhibit)) & (Up_Separation > Down_Separation)) | ((Climb_Inhibit) & ((Up_Separation+100) > Down_Separation))->

(None,[]): case{ECase:

	 Own_Tracked_Alt >= Other_Tracked_Alt->

(None,[]): EAssume: 211,:(emp)*(res = 0)( FLOW __norm)

	 Own_Tracked_Alt < Other_Tracked_Alt->

(None,[]): case{ECase:

	 Down_Separation < arr[Alt_Layer_Value]->

(None,[]): EAssume: 210,:(emp)*(res = 1)( FLOW __norm)

	 Down_Separation >= arr[Alt_Layer_Value]->

(None,[]): EAssume: 209,:(emp)*(res = 0)( FLOW __norm)
}
}

	 ((!(Climb_Inhibit)) & (Up_Separation <= Down_Separation)) | ((Climb_Inhibit) & ((Up_Separation+100) <= Down_Separation))->

(None,[]): case{ECase:

	 Own_Tracked_Alt > Other_Tracked_Alt->

(None,[]): case{ECase:

	 Up_Separation < arr[Alt_Layer_Value]->

(None,[]): EAssume: 208,:(emp)*(res = 0)( FLOW __norm)

	 Up_Separation >= arr[Alt_Layer_Value]->

(None,[]): EAssume: 207,:(emp)*(res = 2)( FLOW __norm)
}

	 Own_Tracked_Alt <= Other_Tracked_Alt->

(None,[]): EAssume: 206,:(emp)*((arr' = arr) & (res = 0))( FLOW __norm)
}
}
}
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{boolean enabled, tcas_equipped, intent_not_known;;
boolean need_upward_RA, need_downward_RA;;;
int alt_sep;;;
enabled = (High_Confidence && Own_Tracked_Alt_Rate <= 600) && (Cur_Vertical_Sep > 600);;
tcas_equipped = Other_Capability == 1;;
intent_not_known = Two_of_Three_Reports_Valid && Other_RAC == 0;;
alt_sep = 4;;
if (enabled && (tcas_equipped && intent_not_known) || (!tcas_equipped)) { 
  {need_upward_RA = (Non_Crossing_Biased_Climb(arr, Climb_Inhibit, Up_Separation, Other_Tracked_Alt, Own_Tracked_Alt)) && (Own_Below_Threat(Other_Tracked_Alt, Own_Tracked_Alt));
need_downward_RA = (Non_Crossing_Biased_Descend(arr, Climb_Inhibit, Up_Separation, Other_Tracked_Alt, Own_Tracked_Alt)) && (Own_Above_Threat(Other_Tracked_Alt, Own_Tracked_Alt));;
if (need_upward_RA && need_downward_RA) { 
  alt_sep = 3;
}
else { 
  if (need_upward_RA) { 
  alt_sep = 1;
}
else { 
  if (need_downward_RA) { 
  alt_sep = 2;
}
else { 
  alt_sep = 0;
};
};
};}
;
};;
return alt_sep;}

}
boolean Own_Above_Threat(ref int Other_Tracked_Alt, ref int Own_Tracked_Alt)
static 

(None,[]): case{ECase:

	 Other_Tracked_Alt >= Own_Tracked_Alt->

(None,[]): EAssume: 204,:(emp)*((!(res)) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & (Own_Tracked_Alt' = Own_Tracked_Alt)))( FLOW __norm)

	 Other_Tracked_Alt < Own_Tracked_Alt->

(None,[]): EAssume: 203,:(emp)*((res) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & (Own_Tracked_Alt' = Own_Tracked_Alt)))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{return Other_Tracked_Alt < Own_Tracked_Alt}

}
boolean Own_Below_Threat(ref int Other_Tracked_Alt, ref int Own_Tracked_Alt)
static 

(None,[]): case{ECase:

	 Own_Tracked_Alt >= Other_Tracked_Alt->

(None,[]): EAssume: 201,:(emp)*((!(res)) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & (Own_Tracked_Alt' = Own_Tracked_Alt)))( FLOW __norm)

	 Own_Tracked_Alt < Other_Tracked_Alt->

(None,[]): EAssume: 200,:(emp)*((res) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & (Own_Tracked_Alt' = Own_Tracked_Alt)))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{return Own_Tracked_Alt < Other_Tracked_Alt}

}
boolean Non_Crossing_Biased_Descend(ref int[] arr, ref boolean Climb_Inhibit, ref int Up_Separation, ref int Other_Tracked_Alt, ref int Own_Tracked_Alt)
static 

(None,[]): EBase: [][](emp)*((dom(arr,0,3)) & ((Alt_Layer_Value >= 0) & (Alt_Layer_Value <= 3)))( FLOW __norm) {case{ECase:

	 ((!(Climb_Inhibit)) & (Up_Separation > Down_Separation)) | ((Climb_Inhibit) & ((Up_Separation+100) > Down_Separation))->

(None,[]): case{ECase:

	 Other_Tracked_Alt > Own_Tracked_Alt->

(None,[]): case{ECase:

	 Down_Separation < arr[Alt_Layer_Value]->

(None,[]): EAssume: 187,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)

	 Down_Separation >= arr[Alt_Layer_Value]->

(None,[]): case{ECase:

	 Cur_Vertical_Sep < 300->

(None,[]): EAssume: 186,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)

	 Cur_Vertical_Sep >= 300->

(None,[]): EAssume: 185,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (res))))))( FLOW __norm)
}
}

	 Other_Tracked_Alt <= Own_Tracked_Alt->

(None,[]): EAssume: 184,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)
}

	 ((!(Climb_Inhibit)) & (Up_Separation <= Down_Separation)) | ((Climb_Inhibit) & ((Up_Separation+100) <= Down_Separation))->

(None,[]): case{ECase:

	 Other_Tracked_Alt >= Own_Tracked_Alt->

(None,[]): EAssume: 183,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (res))))))( FLOW __norm)

	 Other_Tracked_Alt < Own_Tracked_Alt->

(None,[]): case{ECase:

	 Up_Separation < arr[Alt_Layer_Value]->

(None,[]): EAssume: 182,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)

	 Up_Separation >= arr[Alt_Layer_Value]->

(None,[]): EAssume: 181,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (res))))))( FLOW __norm)
}
}
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{boolean upward_preferred;;
int upward_crossing_situation;;;
boolean result;;;
upward_preferred = (Inhibit_Biased_Climb(Climb_Inhibit, Up_Separation)) > Down_Separation;;
if (upward_preferred) { 
  {result = ((Own_Below_Threat(Other_Tracked_Alt, Own_Tracked_Alt)) && (Cur_Vertical_Sep >= 300)) && (Down_Separation >= ALIM(arr, Alt_Layer_Value))}
;
}
else { 
  {result = (!(Own_Above_Threat(Other_Tracked_Alt, Own_Tracked_Alt))) || ((Own_Above_Threat(Other_Tracked_Alt, Own_Tracked_Alt)) && (Up_Separation >= ALIM(arr, Alt_Layer_Value)))}
;
};;
return result;}

}
boolean Non_Crossing_Biased_Climb(ref int[] arr, ref boolean Climb_Inhibit, ref int Up_Separation, ref int Other_Tracked_Alt, ref int Own_Tracked_Alt)
static 

(None,[]): EBase: [][](emp)*((dom(arr,0,3)) & ((Alt_Layer_Value >= 0) & (Alt_Layer_Value <= 3)))( FLOW __norm) {case{ECase:

	 ((!(Climb_Inhibit)) & (Up_Separation > Down_Separation)) | ((Climb_Inhibit) & ((Up_Separation+100) > Down_Separation))->

(None,[]): case{ECase:

	 Other_Tracked_Alt > Own_Tracked_Alt->

(None,[]): case{ECase:

	 Down_Separation < arr[Alt_Layer_Value]->

(None,[]): EAssume: 167,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (res))))))( FLOW __norm)

	 Down_Separation >= arr[Alt_Layer_Value]->

(None,[]): EAssume: 166,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)
}

	 Other_Tracked_Alt <= Own_Tracked_Alt->

(None,[]): EAssume: 165,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (res))))))( FLOW __norm)
}

	 ((!(Climb_Inhibit)) & (Up_Separation <= Down_Separation)) | ((Climb_Inhibit) & ((Up_Separation+100) <= Down_Separation))->

(None,[]): case{ECase:

	 Other_Tracked_Alt >= Own_Tracked_Alt->

(None,[]): EAssume: 164,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)

	 Other_Tracked_Alt < Own_Tracked_Alt->

(None,[]): case{ECase:

	 Up_Separation < arr[Alt_Layer_Value]->

(None,[]): EAssume: 163,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)

	 Up_Separation >= arr[Alt_Layer_Value]->

(None,[]): case{ECase:

	 Cur_Vertical_Sep < 300->

(None,[]): EAssume: 162,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (!(res)))))))( FLOW __norm)

	 Cur_Vertical_Sep >= 300->

(None,[]): EAssume: 161,:(emp)*((arr' = arr) & ((Climb_Inhibit' = Climb_Inhibit) & ((Up_Separation' = Up_Separation) & ((Other_Tracked_Alt' = Other_Tracked_Alt) & ((Own_Tracked_Alt' = Own_Tracked_Alt) & (res))))))( FLOW __norm)
}
}
}
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{boolean upward_preferred;;
int upward_crossing_situation;;;
boolean result;;;
upward_preferred = (Inhibit_Biased_Climb(Climb_Inhibit, Up_Separation)) > Down_Separation;;
if (upward_preferred) { 
  {result = (!(Own_Below_Threat(Other_Tracked_Alt, Own_Tracked_Alt))) || ((Own_Below_Threat(Other_Tracked_Alt, Own_Tracked_Alt)) && (!(Down_Separation >= ALIM(arr, Alt_Layer_Value))))}
;
}
else { 
  {result = ((Own_Above_Threat(Other_Tracked_Alt, Own_Tracked_Alt)) && (Cur_Vertical_Sep >= 300)) && (Up_Separation >= ALIM(arr, Alt_Layer_Value))}
;
};;
return result;}

}
int Inhibit_Biased_Climb(ref boolean Climb_Inhibit, ref int Up_Separation)
static 

(None,[]): EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 Climb_Inhibit->

(None,[]): EAssume: 159,:(emp)*((res = Up_Separation+100) & ((Up_Separation' = Up_Separation) & (Climb_Inhibit' = Climb_Inhibit)))( FLOW __norm)

	 !(Climb_Inhibit)->

(None,[]): EAssume: 158,:(emp)*((res = Up_Separation) & ((Up_Separation' = Up_Separation) & (Climb_Inhibit' = Climb_Inhibit)))( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{if (Climb_Inhibit) { 
  return Up_Separation + 100;
}
else { 
  return Up_Separation;
}}

}
int ALIM(int[] arr, int i)
static 

(None,[]): EBase: [][](emp)*((dom(arr,0,3)) & ((0 <= i) & (i <= 3)))( FLOW __norm) {EAssume: 157,:(emp)*(res = arr[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{int k = arr[i];;
return k;}

}
void initialize(ref int[] Positive_RA_Alt_Thresh)
static 

(None,[]): EBase: [][](emp)*(dom(Positive_RA_Alt_Thresh,0,3))( FLOW __norm) {EAssume: 152,:(emp)*((dom(Positive_RA_Alt_Thresh',0,3)) & (((Positive_RA_Alt_Thresh'[0]) = 400) & (((Positive_RA_Alt_Thresh'[1]) = 500) & (((Positive_RA_Alt_Thresh'[2]) = 640) & ((Positive_RA_Alt_Thresh'[3]) = 740)))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{Positive_RA_Alt_Thresh[0] = 400;
Positive_RA_Alt_Thresh[1] = 500;;
Positive_RA_Alt_Thresh[2] = 640;;
Positive_RA_Alt_Thresh[3] = 740;}

}

Stop Omega... 28 invocations caught

Exception occurred: Globals.Illegal_Prover_Format("Omega.omega_of_exp: array, bag or list constraint  arr[Alt_Layer_Value]")
Error(s) detected at main 
