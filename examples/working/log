
======================================

!!!Full processing file "./hip/eps.ss"
Parsing file "./hip/eps.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_17


}

class int_ptr extends Object {
int valVAL_18


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_19


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_20


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
lseg{}[]<p,n> == 

(None,[]): EBase: [][](emp)*((self = p) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<Anon_13,q>@M[HeapNode1]) * (q::lseg{}<p,n-1>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []
ll{}[]<n> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<Anon_12,q>@M[HeapNode1]) * (q::ll{}<n-1>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 78,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 65,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 64,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 63,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 62,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 61,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 60,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 59,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 57,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 56,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 55,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 54,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 53,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 52,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 51,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 50,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 49,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 48,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 47,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 46,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 45,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 43,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 33,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 32,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 30,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 29,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 27,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 26,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 25,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 24,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 23,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 22,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 21,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 20,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 19,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 17,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 16,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 14,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 13,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 11,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 10,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 8,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 6,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

node get_next_next(node x)[]
static EBase: [][](emp ; (emp ; (x::lseg{}<r,2>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 3,:(emp)*(res = r)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node t
node t = member access x~~>next~~>next;
(84, ):return t}
}
node get_next(node x)[]
static EBase: [][](emp ; (emp ; (x::ll{}<1>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp)*(res = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node t
node t = member access x~~>next;
 :assert_inexact EBase: [][](emp)*(t' = null)( FLOW __norm) 
 assume: 
;
(87, ):return t}
}
@@prog4


Checking procedure get_next$node... 
assert:./hip/eps.ss:26: 8:  : ok


Procedure get_next$node SUCCESS.

Checking procedure get_next_next$node... 
Procedure get_next_next$node SUCCESS.
Stop Omega... 130 invocations 
0 false contexts at: ()

!!! log(small):(0.107851,356)
Total verification time: 0.51423 second(s)
	Time spent in main process: 0.446143 second(s)
	Time spent in child processes: 0.068087 second(s)


======================================

!!!Full processing file "./hip/append.ss"
Parsing file "./hip/append.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_18


}

class int_ptr extends Object {
int valVAL_19


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_20


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_21


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
clist{}[]<n> == EBase: [][](emp ; (emp ; ((self::node{}<Anon_14,p>@M[HeapNode1]) * (p::lseg{}<self,n-1>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 1 inv_lock: None view_data_name:  view_imm_map: []
lseg{}[]<p,n> == 

(None,[]): EBase: [][](emp)*((self = p) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<Anon_13,q>@M[HeapNode1]) * (q::lseg{}<p,n-1>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []
ll{}[]<n> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<Anon_12,q>@M[HeapNode1]) * (q::ll{}<n-1>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 81,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 80,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 79,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 70,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 69,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 67,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 66,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 65,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 64,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 63,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 62,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 59,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 58,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 51,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 50,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 49,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 48,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 45,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 36,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 35,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 34,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 33,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 32,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 30,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 29,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 28,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 27,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 26,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 25,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 24,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 23,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 22,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 21,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 20,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 19,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 17,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 16,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 15,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 14,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 13,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 11,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 9,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 8,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 7,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void append(node x, node y)[]
static 

(None,[]): EBase: [][](emp ; (emp ; (x::ll{}<n>@M[HeapNode1])))*(x != null)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (x::lseg{}<y,n>@M[HeapNode1])))*(true)( FLOW __norm)}
||
(None,[]): EBase: [][](emp ; (emp ; (x::ll{}<n>@M[HeapNode1])))*((y = x) & (n > 0))( FLOW __norm) {EAssume: 2,:(emp ; (emp ; (x::clist{}<n>@M[HeapNode1])))*(true)( FLOW __norm)}
||
(None,[]): EBase: [][](emp ; (emp ; ((x::ll{}<n>@M[HeapNode1]) * (y::ll{}<m>@M[HeapNode1]))))*(n > 0)( FLOW __norm) {EAssume: 3,:(emp ; (emp ; (x::ll{}<e>@M[HeapNode1])))*(e = n+m)( FLOW __norm)}
||
(None,[]): EBase: [][](emp ; (emp ; ((x::lseg{}<r,n>@M[HeapNode1]) * (r::node{}<b,null>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 4,:(emp ; (emp ; ((x::lseg{}<r,n>@M[HeapNode1]) * (r::node{}<b,y>@M[HeapNode1]))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp,boolean fl
node tmp = member access x~~>next;
boolean fl = tmp != null;
(88, ):if (fl) { 
  (88, ):{(92, ):append(member access x~~>next, y);
(94, ):return };
} else { 
  (88, ):{member access x~~>next = y;
(91, ):return }
}}
}
@@prog4


Checking procedure append$node~node... 
Procedure append$node~node SUCCESS.
Stop Omega... 386 invocations 
0 false contexts at: ()

!!! log(small):(1.259303,1625)
Total verification time: 1.438361 second(s)
	Time spent in main process: 1.254594 second(s)
	Time spent in child processes: 0.183767 second(s)


======================================

!!!Full processing file "./hip/append-tail.ss"
Parsing file "./hip/append-tail.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_19


}

class int_ptr extends Object {
int valVAL_20


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_21


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_22


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
ll_tail2{}[]<tx,n> == 

(None,[]): EBase: [][](emp ; (emp ; (self::node{}<Anon_13,null>@M[HeapNode1])))*((tx = self) & (n = 1))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<Anon_14,r>@M[HeapNode1]) * (r::ll_tail2{}<tx,n-1>@M[HeapNode1]))))*(r != null)( FLOW __flow)  inv (self != null) & ((tx != null) & (n >= 1)) inv_lock: None view_data_name:  view_imm_map: []
lseg2{}[]<p,n> == 

(None,[]): EBase: [][](emp)*((self = p) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<Anon_12,r>@M[HeapNode1]) * (r::lseg2{}<p,n-1>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)

lemmas(to be proved and saved)[
<=>coerc ll_tail2
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; (self::ll_tail2{}<t,n>@M[HeapNode1])))*(true)( FLOW __norm)
	 body:(emp ; (emp ; ((self::lseg2{}<t,n-1>@M[HeapNode1]) * (t::node{}<Anon_15,null>@M[HeapNode1]))))*(true)( FLOW __norm)
]

lemmas(to be proved and saved)[
<=coerc lseg2
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; (self::lseg2{}<p,n>@M[HeapNode1])))*(true)( FLOW __norm)
	 body:(emp ; (emp ; ((self::lseg2{}<q,n1>@M[HeapNode1]) * (q::lseg2{}<p,n2>@M[HeapNode1]))))*(n = n1+n2)( FLOW __norm)
]

boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 65,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 63,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 62,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 43,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 42,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 33,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 27,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 26,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 25,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 24,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 22,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 20,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 16,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 14,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 13,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 8,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 6,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void append(node x, node tx, node y, node ty)[]
static EBase: [][](emp ; (emp ; ((x::ll_tail2{}<tx,n>@M[HeapNode1]) * (y::ll_tail2{}<ty,m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (x::ll_tail2{}<ty,q>@M[HeapNode1])))*(q = m+n)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{member access tx~~>next = y}
}
@@prog4


Checking procedure append$node~node~node~node... 
Procedure append$node~node~node~node SUCCESS.
Stop Omega... 291 invocations 
0 false contexts at: ()

!!! log(small):(2.363922,1545)
!!! log(big)(>0.5s)(3):(1.721852,[(sleek-hec,0.53647);(sleek-hec,0.539118);(sleek-hec,0.646264)])
Total verification time: 1.333548 second(s)
	Time spent in main process: 1.197273 second(s)
	Time spent in child processes: 0.136275 second(s)


======================================

!!!Full processing file "./hip/avl-bind.ss"
Parsing file "./hip/avl-bind.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_23


}

class int_ptr extends Object {
int valVAL_24


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_25


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_13;
int heightVAL_12;
node leftREC_11;
node rightREC_26


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
avl{}[]<m,n> == 

(None,[]): EBase: [][](emp)*((self = null) & ((m = 0) & (n = 0)))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; (((self::node{}<Anon_14,n,p,q>@M[HeapNode1]) * (p::avl{}<m1,n1>@M[HeapNode1])) * (q::avl{}<m2,n2>@M[HeapNode1]))))*((m = (1+m1)+m2) & ((((0-1) <= (n1-n2)) & ((n1-n2) <= 1)) & (n = max(n1,n2)+1)))( FLOW __flow)  inv (m >= 0) & (n >= 0) inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 146,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 145,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 144,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 143,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 142,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 141,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 140,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 139,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 138,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 137,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 136,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 135,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 134,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 133,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 132,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 131,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 130,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 129,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 128,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 127,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 126,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 125,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 124,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 123,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 122,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 121,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 120,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 119,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 118,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 117,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 116,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 115,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 114,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 113,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 112,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 111,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 110,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 109,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 108,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 107,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 106,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 105,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 104,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 103,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 102,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 101,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 100,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 99,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 98,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 97,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 96,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 95,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 94,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 93,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 92,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 91,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 90,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 89,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 88,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 87,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 86,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 85,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 84,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 83,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 82,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 81,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 80,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 79,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 78,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 77,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 76,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 75,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 74,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 73,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 72,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 71,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

node insert(node x, int a)[]
static EBase: [][](emp ; (emp ; (x::avl{}<m,n>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 51,:(emp ; (emp ; (res::avl{}<m+1,Anon_19>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp,node tmp_null
node tmp, tmp_null = null;
(147, ):if (x == null) { 
  (147, ):(207, ):return new node(a, 1, tmp_null, tmp_null);
} else { 
  (147, ):{(148, ):bind x to (xval, xheight, xleft, xright) in
{(149, ):if (a <= xval) { 
  (149, ):{tmp = xleft;
xleft = (180, ):insert(tmp, a);
(181, ):if ((((205, ):height(xleft)) - ((204, ):height(xright))) == 2) { 
  (181, ):{(184, ):bind xleft to (xleftval, xleftheight, xleftleft, xleftright) in
{(185, ):if (((201, ):height(xleftleft)) > ((200, ):height(xleftright))) { 
  (185, ):{(197, ):return (198, ):rotate_right(xleftleft, xleftright, xright)};
} else { 
  (185, ):{(186, ):if (((196, ):height(xleftleft)) == (((195, ):height(xleftright)) - 1)) { 
  (186, ):(189, ):return (190, ):rotate_double_left(xleftleft, member access xleftright~~>left, member access xleftright~~>right, xright, 1, 1, 1);
} else { 
  (186, ):(187, ):return (188, ):node_error()
}}
}}};
} else { 
  (181, ):(182, ):return (183, ):node_error()
}};
} else { 
  (149, ):{tmp = xright;
xright = (152, ):insert(tmp, a);
(153, ):if ((((177, ):height(xright)) - ((176, ):height(xleft))) == 2) { 
  (153, ):{(156, ):bind xright to (xrightval, xrightheight, xrightleft, xrightright) in
{(157, ):if (((173, ):height(xrightright)) > ((172, ):height(xrightleft))) { 
  (157, ):{(169, ):return (170, ):rotate_left(xleft, xrightleft, xrightright)};
} else { 
  (157, ):{(158, ):if ((((168, ):height(xrightleft)) - 1) == ((166, ):height(xrightright))) { 
  (158, ):(161, ):return (162, ):rotate_double_right(xleft, member access xrightleft~~>left, member access xrightleft~~>right, xrightright, 1, 1, 1);
} else { 
  (158, ):(159, ):return (160, ):node_error()
}}
}}};
} else { 
  (153, ):(154, ):return (155, ):node_error()
}}
}}}
}}
}
node node_error()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(hfalse)*(false)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void build_avl2(node x, node y, node z)[]
static EBase: [][](emp ; (emp ; (((y::avl{}<my,ny>@M[HeapNode1]) * (z::avl{}<mz,ny>@M[HeapNode1])) * (x::node{}<Anon_15,Anon_16,Anon_17,Anon_18>@M[HeapNode1]))))*(y != null)( FLOW __norm) {EAssume: 45,:(emp ; (emp ; (x::avl{}<(1+my)+mz,1+ny>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int tmp
int tmp;
member access x~~>left = y;
member access x~~>right = z;
member access x~~>height = member access y~~>height + 1}
}
node build_avl1(node x, node y)[]
static EBase: [][](emp ; (emp ; ((x::avl{}<mx,nx>@M[HeapNode1]) * (y::avl{}<my,nx>@M[HeapNode1]))))*(x != null)( FLOW __norm) {EAssume: 41,:(emp ; (emp ; (res::avl{}<(1+mx)+my,1+nx>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int v,int tmp
int v = 0;
int tmp;
tmp = member access x~~>height;
tmp = tmp + 1;
(221, ):return new node(v, tmp, x, y)}
}
node rotate_double_right(node a, node b, node c, node d, int v1, int v2, int v3)[]
static EBase: [][](emp ; (emp ; ((((a::avl{}<am,an>@M[HeapNode1]) * (b::avl{}<bm,bn>@M[HeapNode1])) * (c::avl{}<cm,cn>@M[HeapNode1])) * (d::avl{}<dm,an>@M[HeapNode1]))))*((an = max(bn,cn)) & (((0-1) <= (cn-bn)) & ((cn-bn) <= 1)))( FLOW __norm) {EAssume: 29,:(emp ; (emp ; (res::avl{}<(((3+am)+bm)+cm)+dm,2+an>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp1,node tmp2,int h
node tmp1, tmp2;
int h;
h = (223, ):get_max((224, ):height(a), (225, ):height(b));
h = h + 1;
tmp1 = new node(v3, h, a, b);
h = (230, ):get_max((231, ):height(c), (232, ):height(d));
h = h + 1;
tmp2 = new node(v1, h, c, d);
h = (237, ):get_max((238, ):height(tmp1), (239, ):height(tmp2));
h = h + 1;
(242, ):return new node(v2, h, tmp1, tmp2)}
}
node rotate_double_left(node a, node b, node c, node d, int v1, int v2, int v3)[]
static EBase: [][](emp ; (emp ; ((((a::avl{}<am,an>@M[HeapNode1]) * (b::avl{}<bm,bn>@M[HeapNode1])) * (c::avl{}<cm,cn>@M[HeapNode1])) * (d::avl{}<dm,an>@M[HeapNode1]))))*((an = max(bn,cn)) & (((0-1) <= (bn-cn)) & ((bn-cn) <= 1)))( FLOW __norm) {EAssume: 17,:(emp ; (emp ; (res::avl{}<(((3+am)+bm)+cm)+dm,an+2>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp1,node tmp2,int h
node tmp1, tmp2;
int h;
h = (244, ):get_max((245, ):height(a), (246, ):height(b));
h = h + 1;
tmp1 = new node(v1, h, a, b);
h = (251, ):get_max((252, ):height(c), (253, ):height(d));
h = h + 1;
tmp2 = new node(v3, h, c, d);
h = (258, ):get_max((259, ):height(tmp1), (260, ):height(tmp2));
h = h + 1;
(263, ):return new node(v2, h, tmp1, tmp2)}
}
int get_max(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 15,:(emp)*(res = max(a,b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(264, ):if (a >= b) { 
  (264, ):(266, ):return a;
} else { 
  (264, ):(265, ):return b
}}
}
node rotate_right(node ll, node lr, node r)[]
static EBase: [][](emp ; (emp ; (((ll::avl{}<llm,lln>@M[HeapNode1]) * (lr::avl{}<lrm,lln-1>@M[HeapNode1])) * (r::avl{}<rm,lln-1>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 9,:(emp ; (emp ; (res::avl{}<((2+llm)+lrm)+rm,1+lln>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp,int v,int h
node tmp;
int v = 10, h;
h = ((270, ):height(r)) + 1;
tmp = new node(v, h, lr, r);
h = h + 1;
(274, ):return new node(v, h, ll, tmp)}
}
node rotate_left(node l, node rl, node rr)[]
static EBase: [][](emp ; (emp ; (((l::avl{}<lm,ln>@M[HeapNode1]) * (rl::avl{}<rlm,ln>@M[HeapNode1])) * (rr::avl{}<rrm,ln+1>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 3,:(emp ; (emp ; (res::avl{}<((2+lm)+rlm)+rrm,2+ln>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp,int v,int h
node tmp;
int v = 10, h;
h = ((277, ):height(l)) + 1;
tmp = new node(v, h, l, rl);
h = h + 1;
(281, ):return new node(v, h, tmp, rr)}
}
int height(node x)[]
static EBase: [][](emp ; (emp ; (x::avl{}<m,n>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (x::avl{}<m,n>@M[HeapNode1])))*(res = n)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(282, ):if (x == null) { 
  (282, ):(285, ):return 0;
} else { 
  (282, ):(283, ):return member access x~~>height
}}
}
@@prog4


Checking procedure build_avl1$node~node... 
Procedure build_avl1$node~node SUCCESS.

Checking procedure build_avl2$node~node~node... 
Procedure build_avl2$node~node~node SUCCESS.

Checking procedure get_max$int~int... 
Procedure get_max$int~int SUCCESS.

Checking procedure height$node... 
Procedure height$node SUCCESS.

Checking procedure rotate_double_left$node~node~node~node~int~int~int... 
Procedure rotate_double_left$node~node~node~node~int~int~int SUCCESS.

Checking procedure rotate_double_right$node~node~node~node~int~int~int... 
Procedure rotate_double_right$node~node~node~node~int~int~int SUCCESS.

Checking procedure rotate_left$node~node~node... 
Procedure rotate_left$node~node~node SUCCESS.

Checking procedure rotate_right$node~node~node... 
Procedure rotate_right$node~node~node SUCCESS.

Checking procedure insert$node~int... 
Procedure insert$node~int SUCCESS.
Stop Omega... 1382 invocations 
4 false contexts at: ( (215,4)  (210,6)  (192,11)  (187,6) )

!!! log(small):(12.862253,7689)
Total verification time: 11.909191 second(s)
	Time spent in main process: 9.891791 second(s)
	Time spent in child processes: 2.0174 second(s)


======================================

!!!Full processing file "./hip/avl.ss"
Parsing file "./hip/avl.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_24


}

class int_ptr extends Object {
int valVAL_25


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_26


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_13;
int heightVAL_12;
node leftREC_11;
node rightREC_27


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
avl{}[]<size,height> == 

(None,[]): EBase: [][](emp)*((self = null) & ((size = 0) & (height = 0)))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; (((self::node{}<Anon_14,height,p,q>@M[HeapNode1]) * (p::avl{}<size1,height1>@M[HeapNode1])) * (q::avl{}<size2,height2>@M[HeapNode1]))))*((size = (1+size1)+size2) & ((height2 <= height1+1) & ((height1 <= height2+1) & (height = max(height1,height2)+1))))( FLOW __flow)  inv (size >= 0) & (height >= 0) inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 232,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 231,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 230,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 229,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 228,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 227,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 226,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 225,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 224,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 223,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 222,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 221,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 220,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 219,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 218,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 217,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 216,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 215,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 214,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 213,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 212,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 211,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 210,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 209,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 208,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 207,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 206,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 205,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 204,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 203,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 202,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 201,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 200,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 199,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 198,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 197,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 196,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 195,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 194,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 193,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 192,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 191,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 190,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 189,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 188,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 187,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 186,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 185,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 184,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 183,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 182,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 181,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 180,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 179,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 178,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 177,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 176,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 175,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 174,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 173,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 172,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 171,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 170,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 169,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 168,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 167,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 166,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 165,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 164,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 163,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 162,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 161,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 160,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 159,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 158,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 157,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 156,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 155,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 154,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

node merge(node t1, node t2)[]
static case{ECase:

	 t1 != null->EBase: [][](emp ; (emp ; ((t1::avl{}<s1,h1>@M[HeapNode1]) * (t2::avl{}<s2,h2>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 152,:(emp ; (emp ; (res::avl{}<s1+s2,Anon_20>@M[HeapNode1])))*(true)( FLOW __norm)}

	 t1 = null->EBase: [][](emp ; (emp ; (t2::avl{}<s2,h2>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 151,:(emp ; (emp ; (res::avl{}<s2,h2>@M[HeapNode1])))*(true)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(233, ):if (t1 == null) { 
  (233, ):(241, ):return t2;
} else { 
  (233, ):{local: node tmp,node tmp1
node tmp = (234, ):insert(t2, member access t1~~>val);
node tmp1 = (236, ):merge(tmp, member access t1~~>left);
(238, ):return (239, ):merge(tmp1, member access t1~~>right)}
}}
}
node insert_inline(node x, int a)[]
static EBase: [][](emp ; (emp ; (x::avl{}<m,n>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 68,:(emp ; (emp ; (res::avl{}<m+1,n1>@M[HeapNode1])))*((n <= n1) & (n1 <= n+1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node k1,node tmp,node k2,node tmp_null,int h,int hl,int hr,int hlt
node k1, tmp, k2, tmp_null = null;
int h, hl, hr, hlt;
(243, ):if (x == null) { 
  (243, ):(451, ):return new node(a, 1, tmp_null, tmp_null);
} else { 
  (243, ):{(244, ):if (a <= member access x~~>val) { 
  (244, ):{tmp = member access x~~>left;
member access x~~>left = (352, ):insert_inline(tmp, a);
(354, ):if ((((447, ):height(member access x~~>left)) - ((445, ):height(member access x~~>right))) == 2) { 
  (354, ):{k1 = member access x~~>left;
(359, ):if (((441, ):height(member access k1~~>left)) > ((439, ):height(member access k1~~>right))) { 
  (359, ):{member access x~~>left = member access k1~~>right;
h = (418, ):get_max((419, ):height(member access k1~~>right), (421, ):height(member access x~~>right));
member access k1~~>right = x;
h = h + 1;
member access x~~>height = h;
h = (430, ):get_max((431, ):height(member access k1~~>left), h);
h = h + 1;
member access k1~~>height = h;
(437, ):return k1};
} else { 
  (359, ):{(360, ):if (((412, ):height(member access k1~~>left)) == (((410, ):height(member access k1~~>right)) - 1)) { 
  (360, ):{k2 = member access k1~~>right;
member access x~~>left = member access k2~~>right;
member access k1~~>right = member access k2~~>left;
hr = (372, ):height(member access k2~~>left);
member access k2~~>left = k1;
hlt = (377, ):height(member access k2~~>right);
member access k2~~>right = x;
hl = (382, ):height(member access k1~~>left);
h = (385, ):get_max(hl, hr);
h = h + 1;
member access k1~~>height = h;
hr = (391, ):height(member access x~~>right);
h = (394, ):get_max(hlt, hr);
h = h + 1;
member access x~~>height = h;
h = (400, ):get_max((401, ):height(k1), member access x~~>height);
h = h + 1;
member access k2~~>height = h;
(407, ):return k2};
} else { 
  (360, ):(361, ):return (362, ):node_error()
}}
}};
} else { 
  (354, ):(355, ):return (356, ):node_error()
}};
} else { 
  (244, ):{tmp = member access x~~>right;
member access x~~>right = (248, ):insert_inline(tmp, a);
(250, ):if ((((347, ):height(member access x~~>right)) - ((345, ):height(member access x~~>left))) == 2) { 
  (250, ):{k1 = member access x~~>right;
(255, ):if (((341, ):height(member access k1~~>right)) > ((339, ):height(member access k1~~>left))) { 
  (255, ):{member access x~~>right = member access k1~~>left;
hr = (314, ):height(member access k1~~>left);
member access k1~~>left = x;
hl = (319, ):height(member access x~~>left);
h = (322, ):get_max(hr, hl);
h = h + 1;
member access x~~>height = h;
hr = (328, ):height(member access k1~~>right);
h = (331, ):get_max((332, ):height(x), hr);
h = h + 1;
member access k1~~>height = h;
(337, ):return k1};
} else { 
  (255, ):{(256, ):if ((((308, ):height(member access k1~~>left)) - 1) == ((305, ):height(member access k1~~>right))) { 
  (256, ):{k2 = member access k1~~>left;
member access x~~>right = member access k2~~>left;
member access k1~~>left = member access k2~~>right;
hr = (268, ):height(member access k2~~>left);
member access k2~~>left = x;
hlt = (273, ):height(member access k2~~>right);
member access k2~~>right = k1;
hl = (278, ):height(member access x~~>left);
h = (281, ):get_max(hl, hr);
h = h + 1;
member access x~~>height = h;
hr = (287, ):height(member access k1~~>right);
h = (290, ):get_max(hlt, hr);
h = h + 1;
member access k1~~>height = h;
h = (296, ):get_max((297, ):height(x), (298, ):height(k1));
member access k2~~>height = ++h;
(303, ):return k2};
} else { 
  (256, ):(257, ):return (258, ):node_error()
}}
}};
} else { 
  (250, ):(251, ):return (252, ):node_error()
}}
}}
}}
}
node insert(node x, int a)[]
static EBase: [][](emp ; (emp ; (x::avl{}<m,n>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 51,:(emp ; (emp ; (res::avl{}<m+1,Anon_19>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp,node tmp_null
node tmp, tmp_null = null;
(453, ):if (x == null) { 
  (453, ):(537, ):return new node(a, 1, tmp_null, tmp_null);
} else { 
  (453, ):{(454, ):if (a <= member access x~~>val) { 
  (454, ):{tmp = member access x~~>left;
member access x~~>left = (498, ):insert(tmp, a);
(500, ):if ((((533, ):height(member access x~~>left)) - ((531, ):height(member access x~~>right))) == 2) { 
  (500, ):{(503, ):if (((527, ):height(member access x~~>left~~>left)) > ((525, ):height(member access x~~>left~~>right))) { 
  (503, ):{(519, ):return (520, ):rotate_right(member access x~~>left~~>left, member access x~~>left~~>right, member access x~~>right)};
} else { 
  (503, ):{(504, ):if (((517, ):height(member access x~~>left~~>left)) == (((515, ):height(member access x~~>left~~>right)) - 1)) { 
  (504, ):(507, ):return (508, ):rotate_double_left(member access x~~>left~~>left, member access x~~>left~~>right~~>left, member access x~~>left~~>right~~>right, member access x~~>right, 1, 1, 1);
} else { 
  (504, ):(505, ):return (506, ):node_error()
}}
}};
} else { 
  (500, ):(501, ):return (502, ):node_error()
}};
} else { 
  (454, ):{tmp = member access x~~>right;
member access x~~>right = (458, ):insert(tmp, a);
(460, ):if ((((493, ):height(member access x~~>right)) - ((491, ):height(member access x~~>left))) == 2) { 
  (460, ):{(463, ):if (((487, ):height(member access x~~>right~~>right)) > ((485, ):height(member access x~~>right~~>left))) { 
  (463, ):{(479, ):return (480, ):rotate_left(member access x~~>left, member access x~~>right~~>left, member access x~~>right~~>right)};
} else { 
  (463, ):{(464, ):if ((((477, ):height(member access x~~>right~~>left)) - 1) == ((474, ):height(member access x~~>right~~>right))) { 
  (464, ):(467, ):return (468, ):rotate_double_right(member access x~~>left, member access x~~>right~~>left~~>left, member access x~~>right~~>left~~>right, member access x~~>right~~>right, 1, 1, 1);
} else { 
  (464, ):(465, ):return (466, ):node_error()
}}
}};
} else { 
  (460, ):(461, ):return (462, ):node_error()
}}
}}
}}
}
node node_error()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(hfalse)*(false)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void build_avl2(node x, node y, node z)[]
static EBase: [][](emp ; (emp ; (((y::avl{}<my,ny>@M[HeapNode1]) * (z::avl{}<mz,ny>@M[HeapNode1])) * (x::node{}<Anon_15,Anon_16,Anon_17,Anon_18>@M[HeapNode1]))))*(y != null)( FLOW __norm) {EAssume: 45,:(emp ; (emp ; (x::avl{}<(1+my)+mz,1+ny>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int tmp
int tmp;
member access x~~>left = y;
member access x~~>right = z;
member access x~~>height = member access y~~>height + 1}
}
node build_avl1(node x, node y)[]
static EBase: [][](emp ; (emp ; ((x::avl{}<mx,nx>@M[HeapNode1]) * (y::avl{}<my,nx>@M[HeapNode1]))))*(x != null)( FLOW __norm) {EAssume: 41,:(emp ; (emp ; (res::avl{}<(1+mx)+my,1+nx>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int v,int tmp
int v = 0;
int tmp;
tmp = member access x~~>height;
tmp = tmp + 1;
(551, ):return new node(v, tmp, x, y)}
}
node rotate_double_right(node a, node b, node c, node d, int v1, int v2, int v3)[]
static EBase: [][](emp ; (emp ; ((((a::avl{}<am,an>@M[HeapNode1]) * (b::avl{}<bm,bn>@M[HeapNode1])) * (c::avl{}<cm,cn>@M[HeapNode1])) * (d::avl{}<dm,an>@M[HeapNode1]))))*((an = max(bn,cn)) & (((0-1) <= (cn-bn)) & ((cn-bn) <= 1)))( FLOW __norm) {EAssume: 29,:(emp ; (emp ; (res::avl{}<(((3+am)+bm)+cm)+dm,2+an>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp1,node tmp2,int h
node tmp1, tmp2;
int h;
h = (553, ):get_max((554, ):height(a), (555, ):height(b));
h = h + 1;
tmp1 = new node(v3, h, a, b);
h = (560, ):get_max((561, ):height(c), (562, ):height(d));
h = h + 1;
tmp2 = new node(v1, h, c, d);
h = (567, ):get_max((568, ):height(tmp1), (569, ):height(tmp2));
h = h + 1;
(572, ):return new node(v2, h, tmp1, tmp2)}
}
node rotate_double_left(node a, node b, node c, node d, int v1, int v2, int v3)[]
static EBase: [][](emp ; (emp ; ((((a::avl{}<am,an>@M[HeapNode1]) * (b::avl{}<bm,bn>@M[HeapNode1])) * (c::avl{}<cm,cn>@M[HeapNode1])) * (d::avl{}<dm,an>@M[HeapNode1]))))*((an = max(bn,cn)) & (((0-1) <= (bn-cn)) & ((bn-cn) <= 1)))( FLOW __norm) {EAssume: 17,:(emp ; (emp ; (res::avl{}<(((3+am)+bm)+cm)+dm,an+2>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp1,node tmp2,int h
node tmp1, tmp2;
int h;
h = (574, ):get_max((575, ):height(a), (576, ):height(b));
h = h + 1;
tmp1 = new node(v1, h, a, b);
h = (581, ):get_max((582, ):height(c), (583, ):height(d));
h = h + 1;
tmp2 = new node(v3, h, c, d);
h = (588, ):get_max((589, ):height(tmp1), (590, ):height(tmp2));
h = h + 1;
(593, ):return new node(v2, h, tmp1, tmp2)}
}
int get_max(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 15,:(emp)*(res = max(a,b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(594, ):if (a >= b) { 
  (594, ):(596, ):return a;
} else { 
  (594, ):(595, ):return b
}}
}
node rotate_right(node ll, node lr, node r)[]
static EBase: [][](emp ; (emp ; (((ll::avl{}<llm,lln>@M[HeapNode1]) * (lr::avl{}<lrm,lln-1>@M[HeapNode1])) * (r::avl{}<rm,lln-1>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 9,:(emp ; (emp ; (res::avl{}<((2+llm)+lrm)+rm,1+lln>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp,int v,int h
node tmp;
int v = 10, h;
h = ((600, ):height(r)) + 1;
tmp = new node(v, h, lr, r);
h = h + 1;
(604, ):return new node(v, h, ll, tmp)}
}
node rotate_left(node l, node rl, node rr)[]
static EBase: [][](emp ; (emp ; (((l::avl{}<lm,ln>@M[HeapNode1]) * (rl::avl{}<rlm,ln>@M[HeapNode1])) * (rr::avl{}<rrm,ln+1>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 3,:(emp ; (emp ; (res::avl{}<((2+lm)+rlm)+rrm,2+ln>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp,int v,int h
node tmp;
int v = 10, h;
h = ((607, ):height(l)) + 1;
tmp = new node(v, h, l, rl);
h = h + 1;
(611, ):return new node(v, h, tmp, rr)}
}
int height(node x)[]
static EBase: [][](emp ; (emp ; (x::avl{}<m,n>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (x::avl{}<m,n>@M[HeapNode1])))*(res = n)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(612, ):if (x == null) { 
  (612, ):(615, ):return 0;
} else { 
  (612, ):(613, ):return member access x~~>height
}}
}
@@prog4


Checking procedure build_avl1$node~node... 
Procedure build_avl1$node~node SUCCESS.

Checking procedure build_avl2$node~node~node... 
Procedure build_avl2$node~node~node SUCCESS.

Checking procedure get_max$int~int... 
Procedure get_max$int~int SUCCESS.

Checking procedure height$node... 
Procedure height$node SUCCESS.

Checking procedure rotate_double_left$node~node~node~node~int~int~int... 
Procedure rotate_double_left$node~node~node~node~int~int~int SUCCESS.

Checking procedure rotate_double_right$node~node~node~node~int~int~int... 
Procedure rotate_double_right$node~node~node~node~int~int~int SUCCESS.

Checking procedure rotate_left$node~node~node... 
Procedure rotate_left$node~node~node SUCCESS.

Checking procedure rotate_right$node~node~node... 
Procedure rotate_right$node~node~node SUCCESS.

Checking procedure insert$node~int... 
Procedure insert$node~int SUCCESS.

Checking procedure insert_inline$node~int... 
Procedure insert_inline$node~int SUCCESS.

Checking procedure merge$node~node... 
Procedure merge$node~node SUCCESS.

Termination checking result: SUCCESS

Stop Omega... 3683 invocations 
19 false contexts at: ( (465,17)  (469,3)  (469,22)  (469,10)  (468,15)  (468,27)  (468,8)  (467,14)  (467,25)  (467,8)  (466,9)  (344,4)  (340,6)  (284,4)  (280,6)  (211,4)  (207,6)  (190,11)  (186,6) )

!!! log(small):(35.643639,15823)
!!! log(big)(>0.5s)(5):(3.044142,[(sleek-hec,0.507201);(sleek-hec,0.577608);(sleek-hec,0.594195);(sleek-hec,0.840108);(sleek-hec,0.52503)])
Total verification time: 36.803999 second(s)
	Time spent in main process: 30.386812 second(s)
	Time spent in child processes: 6.417187 second(s)


======================================

!!!Full processing file "./hip/avl-orig-2.ss"
Parsing file "./hip/avl-orig-2.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_70


}

class int_ptr extends Object {
int valVAL_71


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_72


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int eleVAL_13;
int heightVAL_12;
node leftREC_11;
node rightREC_73


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
avl{}[]<m,n,bal> == 

(None,[]): EBase: [][](emp)*((self = null) & ((m = 0) & ((n = 0) & (bal = 1))))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; (((self::node{}<Anon_14,n,p,q>@M[HeapNode1]) * (p::avl{}<m1,n1,Anon_15>@M[HeapNode1])) * (q::avl{}<m2,n2,Anon_16>@M[HeapNode1]))))*((m = (1+m1)+m2) & ((n = 1+max(n1,n2)) & ((((0-1) <= (n1-n2)) & ((n1-n2) <= 1)) & (bal = (n1-n2)+1))))( FLOW __flow)  inv (m >= 0) & ((n >= 0) & ((0 <= bal) & (bal <= 2))) inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 118,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 117,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 116,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 115,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 114,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 113,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 112,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 111,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 110,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 109,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 108,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 107,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 106,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 105,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 104,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 103,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 102,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 101,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 100,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 99,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 98,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 97,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 96,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 95,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 94,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 93,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 92,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 91,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 90,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 89,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 88,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 87,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 86,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 85,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 84,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 83,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 82,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 81,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 80,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 79,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 69,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 68,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 67,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 66,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 65,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 64,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 63,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 62,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 61,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 60,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 59,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 58,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 57,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 56,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 55,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 54,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 53,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 52,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 51,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 50,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 49,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 48,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 47,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 46,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 45,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 44,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 43,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

node rotate_right_child(node k1)[]
static EBase: [][](emp ; (emp ; (((((k1::node{}<Anon_55,Anon_56,l,r>@M[HeapNode1]) * (l::avl{}<am,an,Anon_57>@M[HeapNode1])) * (r::node{}<Anon_58,Anon_59,rl,rr>@M[HeapNode1])) * (rl::avl{}<bm,bn,Anon_60>@M[HeapNode1])) * (rr::avl{}<cm,cn,Anon_61>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 33,:(emp ; (emp ; (((((res::node{}<Anon_62,resn,resl,resr>@M[HeapNode1]) * (resl::node{}<Anon_63,resln,resll,reslr>@M[HeapNode1])) * (resr::avl{}<cm,cn,Anon_64>@M[HeapNode1])) * (resll::avl{}<am,an,Anon_65>@M[HeapNode1])) * (reslr::avl{}<bm,bn,Anon_66>@M[HeapNode1]))))*((resln = tmp1+1) & ((tmp1 = max(an,bn)) & ((resn = tmp2+1) & (tmp2 = max(resln,cn)))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node k2
node k2 = member access k1~~>right;
member access k1~~>right = member access k2~~>left;
member access k2~~>left = k1;
member access k1~~>height = ((127, ):get_max((128, ):height(member access k1~~>left), (130, ):height(member access k1~~>right))) + 1;
member access k2~~>height = ((135, ):get_max((136, ):height(member access k2~~>right), member access k1~~>height)) + 1;
(140, ):return k2}
}
node rotate_left_child(node k2)[]
static EBase: [][](emp ; (emp ; (((((k2::node{}<Anon_43,Anon_44,l,r>@M[HeapNode1]) * (r::avl{}<cm,cn,Anon_45>@M[HeapNode1])) * (l::node{}<Anon_46,Anon_47,ll,lr>@M[HeapNode1])) * (ll::avl{}<am,an,Anon_48>@M[HeapNode1])) * (lr::avl{}<bm,bn,Anon_49>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 26,:(emp ; (emp ; (((((res::node{}<Anon_50,resn,resl,resr>@M[HeapNode1]) * (resl::avl{}<am,an,Anon_51>@M[HeapNode1])) * (resr::node{}<Anon_52,resrn,resrl,resrr>@M[HeapNode1])) * (resrl::avl{}<bm,bn,Anon_53>@M[HeapNode1])) * (resrr::avl{}<cm,cn,Anon_54>@M[HeapNode1]))))*((resrn = tmp1+1) & ((tmp1 = max(cn,bn)) & ((resn = tmp2+1) & (tmp2 = max(an,resrn)))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node k1
node k1 = member access k2~~>left;
member access k2~~>left = member access k1~~>right;
member access k1~~>right = k2;
member access k2~~>height = ((149, ):get_max((150, ):height(member access k2~~>left), (152, ):height(member access k2~~>right))) + 1;
member access k1~~>height = ((157, ):get_max((158, ):height(member access k1~~>left), member access k2~~>height)) + 1;
(162, ):return k1}
}
node double_right_child(node k1)[]
static EBase: [][](emp ; (emp ; (((((((k1::node{}<Anon_30,Anon_31,a,k2>@M[HeapNode1]) * (a::avl{}<am,an,Anon_32>@M[HeapNode1])) * (k2::node{}<Anon_33,Anon_34,k3,d>@M[HeapNode1])) * (d::avl{}<dm,dn,Anon_35>@M[HeapNode1])) * (k3::node{}<Anon_36,Anon_37,b,c>@M[HeapNode1])) * (b::avl{}<bm,bn,Anon_38>@M[HeapNode1])) * (c::avl{}<cm,cn,Anon_39>@M[HeapNode1]))))*((bn <= 1+an) & ((an <= 1+bn) & ((cn <= 1+dn) & (dn <= 1+cn))))( FLOW __norm) {EAssume: 24,:(emp ; (emp ; (((res::node{}<Anon_40,h,ss1,ss3>@M[HeapNode1]) * (ss1::avl{}<(am+bm)+1,h1,Anon_41>@M[HeapNode1])) * (ss3::avl{}<(cm+dm)+1,h2,Anon_42>@M[HeapNode1]))))*((h = 1+t) & ((t = max(h1,h2)) & ((h1 = 1+t1) & ((t1 = max(an,bn)) & ((h2 = 1+t2) & (t2 = max(cn,dn)))))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
member access k1~~>right = (164, ):rotate_left_child(member access k1~~>right);
node tmp = (167, ):rotate_right_child(k1);
(168, ):return tmp}
}
node double_left_child(node k3)[]
static EBase: [][](emp ; (emp ; (((((((k3::node{}<Anon_17,Anon_18,k1,d>@M[HeapNode1]) * (d::avl{}<dm,dn,Anon_19>@M[HeapNode1])) * (k1::node{}<Anon_20,Anon_21,a,k2>@M[HeapNode1])) * (a::avl{}<am,an,Anon_22>@M[HeapNode1])) * (k2::node{}<Anon_23,Anon_24,b,c>@M[HeapNode1])) * (b::avl{}<bm,bn,Anon_25>@M[HeapNode1])) * (c::avl{}<cm,cn,Anon_26>@M[HeapNode1]))))*((bn <= 1+an) & ((an <= 1+bn) & ((cn <= 1+dn) & (dn <= 1+cn))))( FLOW __norm) {EAssume: 22,:(emp ; (emp ; (((res::node{}<Anon_27,h,ss1,ss2>@M[HeapNode1]) * (ss1::avl{}<(am+bm)+1,h1,Anon_28>@M[HeapNode1])) * (ss2::avl{}<(cm+dm)+1,h2,Anon_29>@M[HeapNode1]))))*((h = 1+t) & ((t = max(h1,h2)) & ((h1 = 1+t1) & ((t1 = max(an,bn)) & ((h2 = 1+t2) & (t2 = max(cn,dn)))))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node t2,node tmp
node t2 = member access k3~~>left;
member access k3~~>left = (171, ):rotate_right_child(t2);
node tmp = (173, ):rotate_left_child(k3);
(174, ):return tmp}
}
node insert(node t, int x)[]
static EBase: [][](emp ; (emp ; (t::avl{}<tm,tn,b>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 5,:(emp ; (emp ; (res::avl{}<tm+1,resn,resb>@M[HeapNode1])))*((t != null) & ((tm > 0) & ((tn > 0) & ((tn = resn) | ((resn = tn+1) & (resb != 1))))))( FLOW __norm)
or(emp ; (emp ; (res::avl{}<1,1,1>@M[HeapNode1])))*((tn = 0) & ((tm = 0) & (t = null)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp = null;
(175, ):if (t == null) { 
  (175, ):{(230, ):return new node(x, 1, tmp, tmp)};
} else { 
  (175, ):{(176, ):if (x < member access t~~>ele) { 
  (176, ):{member access t~~>left = (199, ):insert(member access t~~>left, x);
(202, ):if ((((217, ):height(member access t~~>left)) - ((215, ):height(member access t~~>right))) == 2) { 
  (202, ):{(203, ):if (((211, ):height(member access t~~>left~~>left)) > ((209, ):height(member access t~~>left~~>right))) { 
  (203, ):{t = (207, ):rotate_left_child(t)};
} else { 
  (203, ):{t = (205, ):double_left_child(t)}
}};
} else { 
  (202, ):
}};
} else { 
  (176, ):{member access t~~>right = (178, ):insert(member access t~~>right, x);
(181, ):if ((((196, ):height(member access t~~>right)) - ((194, ):height(member access t~~>left))) == 2) { 
  (181, ):{(182, ):if (((190, ):height(member access t~~>right~~>right)) > ((188, ):height(member access t~~>right~~>left))) { 
  (182, ):{t = (186, ):rotate_right_child(t)};
} else { 
  (182, ):{t = (184, ):double_right_child(t)}
}};
} else { 
  (181, ):
}}
};
member access t~~>height = ((223, ):get_max((224, ):height(member access t~~>left), (226, ):height(member access t~~>right))) + 1;
(229, ):return t}
}}
}
int get_max(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*((res = a) & (a >= b))( FLOW __norm)
or(emp)*((res = b) & (b > a))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(232, ):if (a >= b) { 
  (232, ):(234, ):return a;
} else { 
  (232, ):(233, ):return b
}}
}
int height(node x)[]
static EBase: [][](emp ; (emp ; (x::avl{}<m,n,b>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (x::avl{}<m,n,b>@M[HeapNode1])))*(res = n)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(236, ):if (x == null) { 
  (236, ):(239, ):return 0;
} else { 
  (236, ):(237, ):return member access x~~>height
}}
}
@@prog4


Checking procedure get_max$int~int... 
Procedure get_max$int~int SUCCESS.

Checking procedure height$node... 
Procedure height$node SUCCESS.

Checking procedure rotate_left_child$node... 
Procedure rotate_left_child$node SUCCESS.

Checking procedure rotate_right_child$node... 
Procedure rotate_right_child$node SUCCESS.

Checking procedure double_left_child$node... 
Procedure double_left_child$node SUCCESS.

Checking procedure double_right_child$node... 
Procedure double_right_child$node SUCCESS.

Checking procedure insert$node~int... 
Procedure insert$node~int SUCCESS.
Stop Omega... 2234 invocations 
0 false contexts at: ()

!!! log(small):(43.245496,13669)
!!! log(big)(>0.5s)(13):(10.035777,[(SAT,1.356409);(SAT,2.775931);(sleek-hec,0.505005);(sleek-hec,0.519533);(sleek-hec,0.541782);(sleek-hec,0.550496);(sleek-hec,0.508019);(sleek-hec,0.520702);(sleek-hec,0.543087);(sleek-hec,0.552365);(sleek-hec,0.560425);(sleek-hec,0.517685);(sleek-hec,0.584338)])
Total verification time: 38.201392 second(s)
	Time spent in main process: 28.170618 second(s)
	Time spent in child processes: 10.030774 second(s)


======================================

!!!Full processing file "./hip/avl-orig3.ss"
Parsing file "./hip/avl-orig3.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_54


}

class int_ptr extends Object {
int valVAL_55


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_56


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int eleVAL_13;
int heightVAL_12;
node leftREC_11;
node rightREC_57


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
avl{}[]<m,n,bal> == 

(None,[]): EBase: [][](emp)*((self = null) & ((m = 0) & ((n = 0) & (bal = 1))))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; (((self::node{}<Anon_14,n,p,q>@M[HeapNode1]) * (p::avl{}<m1,n1,Anon_15>@M[HeapNode1])) * (q::avl{}<m2,n2,Anon_16>@M[HeapNode1]))))*((m = (1+m1)+m2) & ((n = max(n1,n2)+1) & (((n2+bal) = (n1+1)) & ((n2 <= n1+1) & (n1 <= 1+n2)))))( FLOW __flow)  inv (m >= 0) & ((n >= 0) & ((0 <= bal) & (bal <= 2))) inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 118,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 117,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 116,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 115,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 114,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 113,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 112,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 111,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 110,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 109,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 108,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 107,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 106,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 105,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 104,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 103,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 102,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 101,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 100,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 99,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 98,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 97,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 96,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 95,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 94,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 93,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 92,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 91,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 90,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 89,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 88,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 87,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 86,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 85,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 84,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 83,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 82,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 81,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 80,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 79,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 69,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 68,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 67,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 66,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 65,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 64,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 63,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 62,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 61,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 60,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 59,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 58,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 57,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 56,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 55,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 54,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 53,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 52,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 51,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 50,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 49,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 48,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 47,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 46,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 45,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 44,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 43,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

node rotate_right_child(node k1)[]
static EBase: [][](emp ; (emp ; (((((k1::node{}<Anon_45,Anon_46,l,r>@M[HeapNode1]) * (l::avl{}<am,an,ba1>@M[HeapNode1])) * (r::node{}<Anon_47,Anon_48,rl,rr>@M[HeapNode1])) * (rl::avl{}<bm,bn,ba2>@M[HeapNode1])) * (rr::avl{}<cm,cn,ba3>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 33,:(emp ; (emp ; (((((res::node{}<Anon_49,resn,resl,resr>@M[HeapNode1]) * (resl::node{}<Anon_50,resln,resll,reslr>@M[HeapNode1])) * (resr::avl{}<cm,cn,ba3>@M[HeapNode1])) * (resll::avl{}<am,an,ba1>@M[HeapNode1])) * (reslr::avl{}<bm,bn,ba2>@M[HeapNode1]))))*((resln = tmp1+1) & ((tmp1 = max(an,bn)) & ((resn = tmp2+1) & (tmp2 = max(resln,cn)))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node k2
node k2 = member access k1~~>right;
member access k1~~>right = member access k2~~>left;
member access k2~~>left = k1;
member access k1~~>height = ((127, ):get_max((128, ):height(member access k1~~>left), (130, ):height(member access k1~~>right))) + 1;
member access k2~~>height = ((135, ):get_max((136, ):height(member access k2~~>right), member access k1~~>height)) + 1;
(140, ):return k2}
}
node rotate_left_child(node k2)[]
static EBase: [][](emp ; (emp ; (((((k2::node{}<Anon_39,Anon_40,l,r>@M[HeapNode1]) * (r::avl{}<cm,cn,ba3>@M[HeapNode1])) * (l::node{}<Anon_41,Anon_42,ll,lr>@M[HeapNode1])) * (ll::avl{}<am,an,ba1>@M[HeapNode1])) * (lr::avl{}<bm,bn,ba2>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 26,:(emp ; (emp ; (((((res::node{}<Anon_43,resn,resl,resr>@M[HeapNode1]) * (resl::avl{}<am,an,ba1>@M[HeapNode1])) * (resr::node{}<Anon_44,resrn,resrl,resrr>@M[HeapNode1])) * (resrl::avl{}<bm,bn,ba2>@M[HeapNode1])) * (resrr::avl{}<cm,cn,ba3>@M[HeapNode1]))))*((resrn = tmp1+1) & ((tmp1 = max(cn,bn)) & ((resn = tmp2+1) & (tmp2 = max(an,resrn)))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node k1
node k1 = member access k2~~>left;
member access k2~~>left = member access k1~~>right;
member access k1~~>right = k2;
member access k2~~>height = ((149, ):get_max((150, ):height(member access k2~~>left), (152, ):height(member access k2~~>right))) + 1;
member access k1~~>height = ((157, ):get_max((158, ):height(member access k1~~>left), member access k2~~>height)) + 1;
(162, ):return k1}
}
node double_right_child(node k1)[]
static EBase: [][](emp ; (emp ; (((((((k1::node{}<Anon_28,Anon_29,a,k2>@M[HeapNode1]) * (a::avl{}<am,an,Anon_30>@M[HeapNode1])) * (k2::node{}<Anon_31,Anon_32,k3,d>@M[HeapNode1])) * (d::avl{}<dm,dn,Anon_33>@M[HeapNode1])) * (k3::node{}<Anon_34,Anon_35,b,c>@M[HeapNode1])) * (b::avl{}<bm,bn,Anon_36>@M[HeapNode1])) * (c::avl{}<cm,cn,Anon_37>@M[HeapNode1]))))*((bn <= 1+an) & ((an <= 1+bn) & ((cn <= 1+dn) & (dn <= 1+cn))))( FLOW __norm) {EAssume: 24,:(emp ; (emp ; (((res::node{}<Anon_38,h,ss1,ss3>@M[HeapNode1]) * (ss1::avl{}<(am+bm)+1,h1,bb1>@M[HeapNode1])) * (ss3::avl{}<(cm+dm)+1,h2,bb2>@M[HeapNode1]))))*((h = 1+t) & ((t = max(h1,h2)) & ((h1 = 1+t1) & ((t1 = max(an,bn)) & ((h2 = 1+t2) & (t2 = max(cn,dn)))))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
member access k1~~>right = (164, ):rotate_left_child(member access k1~~>right);
node tmp = (167, ):rotate_right_child(k1);
(168, ):return tmp}
}
node double_left_child(node k3)[]
static EBase: [][](emp ; (emp ; (((((((k3::node{}<Anon_17,Anon_18,k1,d>@M[HeapNode1]) * (d::avl{}<dm,dn,Anon_19>@M[HeapNode1])) * (k1::node{}<Anon_20,Anon_21,a,k2>@M[HeapNode1])) * (a::avl{}<am,an,Anon_22>@M[HeapNode1])) * (k2::node{}<Anon_23,Anon_24,b,c>@M[HeapNode1])) * (b::avl{}<bm,bn,Anon_25>@M[HeapNode1])) * (c::avl{}<cm,cn,Anon_26>@M[HeapNode1]))))*((bn <= 1+an) & ((an <= 1+bn) & ((cn <= 1+dn) & (dn <= 1+cn))))( FLOW __norm) {EAssume: 22,:(emp ; (emp ; (((res::node{}<Anon_27,h,ss1,ss2>@M[HeapNode1]) * (ss1::avl{}<(am+bm)+1,h1,bb1>@M[HeapNode1])) * (ss2::avl{}<(cm+dm)+1,h2,bb2>@M[HeapNode1]))))*((h = 1+t) & ((t = max(h1,h2)) & ((h1 = 1+t1) & ((t1 = max(an,bn)) & ((h2 = 1+t2) & (t2 = max(cn,dn)))))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node t2,node tmp
node t2 = member access k3~~>left;
member access k3~~>left = (171, ):rotate_right_child(t2);
node tmp = (173, ):rotate_left_child(k3);
(174, ):return tmp}
}
node insert(node t, int x)[]
static EBase: [][](emp ; (emp ; (t::avl{}<tm,tn,b>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 5,:(emp ; (emp ; (res::avl{}<tm+1,resn,resb>@M[HeapNode1])))*((t != null) & ((tm > 0) & ((tn > 0) & ((tn = resn) | ((resn = tn+1) & (resb != 1))))))( FLOW __norm)
or(emp ; (emp ; (res::avl{}<1,1,1>@M[HeapNode1])))*((tn = 0) & ((tm = 0) & (t = null)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp = null;
(175, ):if (t == null) { 
  (175, ):(221, ):return new node(x, 1, tmp, tmp);
} else { 
  (175, ):(176, ):if (x < member access t~~>ele) { 
  (176, ):{member access t~~>left = (199, ):insert(member access t~~>left, x);
(202, ):if ((((217, ):height(member access t~~>left)) - ((215, ):height(member access t~~>right))) == 2) { 
  (202, ):{(203, ):if (((211, ):height(member access t~~>left~~>left)) > ((209, ):height(member access t~~>left~~>right))) { 
  (203, ):{t = (207, ):rotate_left_child(t)};
} else { 
  (203, ):{t = (205, ):double_left_child(t)}
}};
} else { 
  (202, ):
}};
} else { 
  (176, ):{member access t~~>right = (178, ):insert(member access t~~>right, x);
(181, ):if ((((196, ):height(member access t~~>right)) - ((194, ):height(member access t~~>left))) == 2) { 
  (181, ):{(182, ):if (((190, ):height(member access t~~>right~~>right)) > ((188, ):height(member access t~~>right~~>left))) { 
  (182, ):{t = (186, ):rotate_right_child(t)};
} else { 
  (182, ):{t = (184, ):double_right_child(t)}
}};
} else { 
  (181, ):
}}
}
};
member access t~~>height = ((225, ):get_max((226, ):height(member access t~~>left), (228, ):height(member access t~~>right))) + 1;
(231, ):return t}
}
int get_max(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*((res = a) & (a >= b))( FLOW __norm)
or(emp)*((res = b) & (b > a))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(232, ):if (a >= b) { 
  (232, ):(234, ):return a;
} else { 
  (232, ):(233, ):return b
}}
}
int height(node x)[]
static EBase: [][](emp ; (emp ; (x::avl{}<m,n,b>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (x::avl{}<m,n,b>@M[HeapNode1])))*(res = n)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{dprint;
(236, ):if (x == null) { 
  (236, ):(239, ):return 0;
} else { 
  (236, ):(237, ):return member access x~~>height
}}
}
@@prog4


Checking procedure get_max$int~int... 
Procedure get_max$int~int SUCCESS.

Checking procedure height$node... 
dprint: ./hip/avl-orig3.ss:27: ctx:  List of Failesc Context: [FEC(0, 0, 1  [])]

Successful States:
[
 Label: []
 State:x::avl{}<m,n,b>@ rem br[{361,362}]&(([x=x'][0<=m][0<=n][0<=b & b<=2]
                                            [MayLoop[]]))&{FLOW,(4,5)=__norm#E}[]
       es_ho_vars_map: []x::avl<m,n,b>@ rem br[{361,362}]&(([x=x'][0<=m]
                                                            [0<=n]
                                                            [0<=b & b<=2]
                                                            [MayLoop[]]))

 ]

Procedure height$node SUCCESS.

Checking procedure rotate_left_child$node... 
Procedure rotate_left_child$node SUCCESS.

Checking procedure rotate_right_child$node... 
Procedure rotate_right_child$node SUCCESS.

Checking procedure double_left_child$node... 
Procedure double_left_child$node SUCCESS.

Checking procedure double_right_child$node... 
Procedure double_right_child$node SUCCESS.

Checking procedure insert$node~int... 
Procedure insert$node~int SUCCESS.
Stop Omega... 2239 invocations 
0 false contexts at: ()

!!! log(small):(43.640825,13335)
!!! log(big)(>0.5s)(6):(3.344142,[(SAT,0.721379);(sleek-hec,0.519998);(sleek-hec,0.528444);(sleek-hec,0.507792);(sleek-hec,0.529169);(sleek-hec,0.53736)])
Total verification time: 33.188258 second(s)
	Time spent in main process: 26.636596 second(s)
	Time spent in child processes: 6.551662 second(s)


======================================

!!!Full processing file "./hip/bll.ss"
Parsing file "./hip/bll.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_15


}

class int_ptr extends Object {
int valVAL_16


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_17


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_18


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
bndl{}[]<n,sm,bg> == 

(None,[]): EBase: [][](emp)*((self = null) & ((n = 0) & (sm <= bg)))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<d,p>@M[HeapNode1]) * (p::bndl{}<n-1,sm,bg>@M[HeapNode1]))))*((sm <= d) & (d <= bg))( FLOW __flow)  inv (sm <= bg) & (n >= 0) inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 65,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 63,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 62,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 43,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 42,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 33,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 27,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 26,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 25,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 24,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 22,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 20,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 16,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 14,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 13,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 8,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 6,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

node delete(node x)[]
static EBase: [][](emp ; (emp ; (x::bndl{}<n,sm,bg>@M[HeapNode1])))*(x != null)( FLOW __norm) {EAssume: 2,:(emp ; (emp ; (res::bndl{}<n-1,sm,bg>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(82, ):return member access x~~>next}
}
node insert(node x, int v)[]
static EBase: [][](emp ; (emp ; (x::bndl{}<n,sm,bg>@M[HeapNode1])))*((sm <= v) & (v <= bg))( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (res::bndl{}<n+1,sm,bg>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(84, ):return new node(v, x)}
}
@@prog4


Checking procedure delete$node... 
Procedure delete$node SUCCESS.

Checking procedure insert$node~int... 
Procedure insert$node~int SUCCESS.
Stop Omega... 136 invocations 
0 false contexts at: ()

!!! log(small):(0.118822,347)
Total verification time: 0.445231 second(s)
	Time spent in main process: 0.40518 second(s)
	Time spent in child processes: 0.040051 second(s)


======================================

!!!Full processing file "./hip/bubble.ss"
Parsing file "./hip/bubble.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_19


}

class int_ptr extends Object {
int valVAL_20


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_21


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_22


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
ll{}[]<n> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<Anon_12,r>@M[HeapNode1]) * (r::ll{}<n-1>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []
bnd{}[]<n,sm,bg> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<d,p>@M[HeapNode1]) * (p::bnd{}<n-1,sm,bg>@M[HeapNode1]))))*((sm <= d) & (d < bg))( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []
sll{}[]<n,sm,lg> == 

(None,[]): EBase: [][](emp ; (emp ; (self::node{}<sm,null>@M[HeapNode1])))*((sm = lg) & (n = 1))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<sm,q>@M[HeapNode1]) * (q::sll{}<n-1,qs,lg>@M[HeapNode1]))))*((q != null) & (sm <= qs))( FLOW __flow)  inv (n >= 1) & (sm <= lg) inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)

lemmas(to be proved and saved)[
=>coerc lem_13
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; (self::sll{}<n,sm,lg>@M[HeapNode1])))*(true)( FLOW __norm)
	 body:(emp ; (emp ; (self::ll{}<n>@M[HeapNode1])))*(true)( FLOW __norm)
]

boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 95,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 94,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 93,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 92,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 91,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 90,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 89,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 88,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 80,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 79,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 77,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 76,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 75,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 74,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 72,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 71,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 70,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 69,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 68,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 67,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 66,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 65,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 64,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 63,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 62,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 61,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 60,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 59,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 58,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 55,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 54,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 53,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 52,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 51,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 49,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 48,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 46,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 45,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 44,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 43,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 42,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 41,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 40,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 39,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 38,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 37,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 36,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 35,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 34,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 33,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 32,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 31,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 30,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 29,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 28,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 27,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 26,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 25,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 24,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 23,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 22,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 21,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 20,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 19,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 18,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 17,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void skip()[]
static 
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void bsort(node xs)[]
static EBase: [][](emp ; (emp ; (xs::ll{}<n>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 15,:(emp ; (emp ; (xs::sll{}<n,Anon_14,Anon_15>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: boolean b
boolean b;
b = (97, ):bubble(xs);
(98, ):if (b) { 
  (98, ):{(99, ):bsort(xs)};
} else { 
  (98, ):
}}
}
boolean bubble(node xs)[]
static EBase: [][](emp ; (emp ; (xs::ll{}<n>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 6,:(emp ; (emp ; (xs::sll{}<n,s,l>@M[HeapNode1])))*(!(res))( FLOW __norm)
or(emp ; (emp ; (xs::ll{}<n>@M[HeapNode1])))*(res)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int aux,int tmp1,boolean tmp,boolean flag
int aux, tmp1;
boolean tmp, flag;
(100, ):if (member access xs~~>next == null) { 
  (100, ):{(116, ):return false};
} else { 
  (100, ):{local: int xv,int xnv
tmp = (102, ):bubble(member access xs~~>next);
int xv = member access xs~~>val;
int xnv = member access xs~~>next~~>val;
(106, ):if (xv <= xnv) { 
  (106, ):flag = false;
} else { 
  (106, ):{member access xs~~>val = xnv;
member access xs~~>next~~>val = xv;
flag = true}
};
(114, ):return flag || tmp}
}}
}
void id3(node x)[]
static EBase: [][](emp ; (emp ; (x::sll{}<n,sm,lg>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 4,:(emp ; (emp ; (x::ll{}<n>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node y
node y = member access x~~>next;
(120, ):if (y != null) { 
  (120, ):{(121, ):id3(y)};
} else { 
  (120, ):
}}
}
node id2(node xs)[]
static EBase: [][](emp ; (emp ; (xs::sll{}<n,sm,lg>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (res::ll{}<n>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(123, ):if (member access xs~~>next != null) { 
  (123, ):{local: node tmp
node tmp = member access xs~~>next;
member access xs~~>next = (126, ):id2(tmp)};
} else { 
  (123, ):
};
(130, ):return xs}
}
@@prog4


Checking procedure bubble$node... 
Procedure bubble$node SUCCESS.

Checking procedure bsort$node... 
Procedure bsort$node SUCCESS.

Checking procedure id2$node... 
Procedure id2$node SUCCESS.

Checking procedure id3$node... 
Procedure id3$node SUCCESS.
Stop Omega... 543 invocations 
0 false contexts at: ()

!!! log(small):(3.198998,2824)
Total verification time: 2.02233 second(s)
	Time spent in main process: 1.892604 second(s)
	Time spent in child processes: 0.129726 second(s)


======================================

!!!Full processing file "./hip/cll.ss"
Parsing file "./hip/cll.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_17


}

class int_ptr extends Object {
int valVAL_18


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_19


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_20


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
hd{}[]<n> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<Anon_13,r>@M[HeapNode1]) * (r::cll{}<self,n-1>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []
cll{}[]<p,n> == 

(None,[]): EBase: [][](emp)*((self = p) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<Anon_12,r>@M[HeapNode1]) * (r::cll{}<p,n-1>@M[HeapNode1]))))*(self != p)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 100,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 99,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 98,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 97,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 96,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 95,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 94,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 93,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 92,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 91,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 85,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 84,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 82,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 81,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 80,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 79,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 77,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 76,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 75,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 74,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 73,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 72,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 71,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 70,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 69,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 68,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 67,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 66,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 65,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 64,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 63,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 62,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 61,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 60,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 58,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 57,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 56,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 55,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 54,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 53,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 52,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 51,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 50,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 49,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 48,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 47,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 46,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 45,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 44,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 43,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 42,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 41,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 40,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 39,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 38,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 37,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 36,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 35,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 34,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 33,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 32,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 31,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 30,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 29,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 28,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 27,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 26,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 25,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 24,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 23,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 22,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete(node@R x)[]
static EBase: [][](emp ; (emp ; (x::hd{}<n>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 17,:(emp ; (emp ; (x'::hd{}<n-1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
(101, ):if (member access x~~>next == x) { 
  (101, ):x = null;
} else { 
  (101, ):{tmp = member access x~~>next~~>next;
member access x~~>next = tmp}
}}
}
int count(node x)[]
static EBase: [][](emp ; (emp ; (x::hd{}<n>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 12,:(emp ; (emp ; (x::hd{}<n>@M[HeapNode1])))*(res = n)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int n
int n;
(109, ):if (x == null) { 
  (109, ):(116, ):return 0;
} else { 
  (109, ):{n = (111, ):count_rest(member access x~~>next, x);
n = n + 1;
(115, ):return n}
}}
}
int count_rest(node rest, node h)[]
static EBase: [][](emp ; (emp ; (rest::cll{}<p,n>@M[HeapNode1])))*(h = p)( FLOW __norm) {EAssume: 7,:(emp ; (emp ; (rest::cll{}<p,n>@M[HeapNode1])))*(res = n)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int n
int n;
(118, ):if (rest == h) { 
  (118, ):(125, ):return 0;
} else { 
  (118, ):{n = (120, ):count_rest(member access rest~~>next, h);
n = n + 1;
(124, ):return n}
}}
}
void insert(node x, int v)[]
static EBase: [][](emp ; (emp ; (x::hd{}<n>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 4,:(emp ; (emp ; (x::hd{}<n+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
tmp = new node(v, member access x~~>next);
member access x~~>next = tmp}
}
node test()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 1,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node null_tmp,node tmp,node tmp2
node null_tmp = null;
node tmp = new node(10, null_tmp);
member access tmp~~>next = tmp;
node tmp2 = new node(20, member access tmp~~>next);
member access tmp~~>next = tmp2;
(136, ):return tmp}
}
@@prog4


Checking procedure count_rest$node~node... 
Procedure count_rest$node~node SUCCESS.

Checking procedure count$node... 
Procedure count$node SUCCESS.

Checking procedure delete$node... 
Procedure delete$node SUCCESS.

Checking procedure insert$node~int... 
Procedure insert$node~int SUCCESS.

Checking procedure test$... 
Procedure test$ SUCCESS.
Stop Omega... 279 invocations 
0 false contexts at: ()

!!! log(small):(0.577784,860)
Total verification time: 0.826215 second(s)
	Time spent in main process: 0.737157 second(s)
	Time spent in child processes: 0.089058 second(s)


======================================

!!!Full processing file "./hip/complete.ss"
Parsing file "./hip/complete.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_18


}

class int_ptr extends Object {
int valVAL_19


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_20


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node2 extends Object {
int valVAL_12;
node2 leftREC_11;
node2 rightREC_21


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
complete{}[]<n,nmin> == 

(None,[]): 

(None,[]): EBase: [][](emp)*((self = null) & ((n = 0) & (nmin = 0)))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; (((self::node2{}<Anon_13,l,r>@M[HeapNode1]) * (l::complete{}<n-1,nmin1>@M[HeapNode1])) * (r::complete{}<n-2,nmin2>@M[HeapNode1]))))*(nmin = min(nmin1,nmin2)+1)( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; (((self::node2{}<Anon_14,l,r>@M[HeapNode1]) * (l::complete{}<n-1,nmin1>@M[HeapNode1])) * (r::complete{}<n-1,nmin2>@M[HeapNode1]))))*(nmin = min(nmin1,nmin2)+1)( FLOW __flow)  inv (nmin >= 0) & (n >= nmin) inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 104,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 103,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 102,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 101,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 100,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 99,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 98,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 97,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 96,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 95,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 94,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 93,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 92,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 91,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 89,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 88,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 86,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 85,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 84,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 83,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 81,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 80,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 79,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 78,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 77,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 76,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 75,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 74,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 73,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 72,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 71,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 70,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 69,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 68,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 67,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 66,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 65,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 63,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 62,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 61,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 60,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 58,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 57,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 56,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 55,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 54,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 53,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 52,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 51,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 50,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 49,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 48,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 47,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 46,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 45,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 44,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 43,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 42,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 41,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 40,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 39,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 38,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 37,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 36,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 35,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 34,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 33,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 32,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 31,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 30,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 29,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 28,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 27,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 26,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void insert(node2@R t, int v)[]
static 

(None,[]): EBase: [][](emp ; (emp ; (t::complete{}<n,nmin>@M[HeapNode1])))*(nmin < n)( FLOW __norm) {EAssume: 11,:(emp ; (emp ; (t'::complete{}<n,nmin1>@M[HeapNode1])))*((nmin1 = nmin) | (nmin1 = nmin+1))( FLOW __norm)}
||
(None,[]): EBase: [][](emp ; (emp ; (t::complete{}<n,nmin>@M[HeapNode1])))*(nmin = n)( FLOW __norm) {EAssume: 12,:(emp ; (emp ; (t'::complete{}<n+1,nmin1>@M[HeapNode1])))*((nmin1 = nmin) | (nmin1 = nmin+1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 aux
node2 aux;
(105, ):if (t == null) { 
  (105, ):{t = new node2(v, null, null);
(150, ):return };
} else { 
  (105, ):{(106, ):if (((147, ):min_height(member access t~~>left)) < ((145, ):height(member access t~~>left))) { 
  (106, ):{aux = member access t~~>left;
(140, ):insert(aux, v);
member access t~~>left = aux;
(143, ):return };
} else { 
  (106, ):{(107, ):if (((136, ):min_height(member access t~~>right)) < ((134, ):height(member access t~~>right))) { 
  (107, ):{aux = member access t~~>right;
(129, ):insert(aux, v);
member access t~~>right = aux;
(132, ):return };
} else { 
  (107, ):{local: node2 tmp
node2 tmp = member access t~~>right;
(109, ):if (((125, ):height(member access t~~>left)) == ((123, ):height(member access t~~>right))) { 
  (109, ):{aux = member access t~~>left;
(118, ):insert(aux, v);
member access t~~>left = aux;
(121, ):return };
} else { 
  (109, ):{aux = member access t~~>right;
(112, ):insert(aux, v);
member access t~~>right = aux;
(115, ):return }
}}
}}
}}
}}
}
int min_height(node2 t)[]
static EBase: [][](emp ; (emp ; (t::complete{}<n,nmin>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 8,:(emp ; (emp ; (t::complete{}<n,nmin>@M[HeapNode1])))*(res = nmin)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(152, ):if (t != null) { 
  (152, ):(154, ):return ((156, ):minim((157, ):min_height(member access t~~>left), (159, ):min_height(member access t~~>right))) + 1;
} else { 
  (152, ):(153, ):return 0
}}
}
int height(node2 t)[]
static EBase: [][](emp ; (emp ; (t::complete{}<n,nmin>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 5,:(emp ; (emp ; (t::complete{}<n,nmin>@M[HeapNode1])))*(res = n)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(162, ):if (t != null) { 
  (162, ):(164, ):return ((166, ):maxim((167, ):height(member access t~~>left), (169, ):height(member access t~~>right))) + 1;
} else { 
  (162, ):(163, ):return 0
}}
}
int minim(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(((a < b) | (res = b)) & ((a >= b) | (res = a)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(172, ):if (a >= b) { 
  (172, ):(174, ):return b;
} else { 
  (172, ):(173, ):return a
}}
}
int maxim(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 1,:(emp)*(((a < b) | (res = a)) & ((a >= b) | (res = b)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(176, ):if (a >= b) { 
  (176, ):(178, ):return a;
} else { 
  (176, ):(177, ):return b
}}
}
@@prog4


Checking procedure maxim$int~int... 
Procedure maxim$int~int SUCCESS.

Checking procedure height$node2... 
Procedure height$node2 SUCCESS.

Checking procedure minim$int~int... 
Procedure minim$int~int SUCCESS.

Checking procedure min_height$node2... 
Procedure min_height$node2 SUCCESS.

Checking procedure insert$node2~int... 
Procedure insert$node2~int SUCCESS.

Termination checking result: SUCCESS

Stop Omega... 1197 invocations 
30 false contexts at: ( (113,5)  (112,10)  (111,5)  (110,16)  (110,10)  (109,9)  (99,4)  (98,4)  (97,4)  (96,14)  (96,8)  (95,48)  (92,3)  (91,3)  (90,3)  (89,12)  (89,6)  (88,42)  (107,5)  (106,5)  (105,5)  (104,11)  (104,5)  (103,45)  (85,2)  (84,25)  (84,19)  (84,6)  (84,2)  (83,15) )

!!! log(small):(9.521035,4084)
Total verification time: 6.915606 second(s)
	Time spent in main process: 5.849685 second(s)
	Time spent in child processes: 1.065921 second(s)


======================================

!!!Full processing file "./hip/dll.ss"
Parsing file "./hip/dll.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_31


}

class int_ptr extends Object {
int valVAL_32


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_33


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node2 extends Object {
int valVAL_12;
node2 prevREC_11;
node2 nextREC_34


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
dll{}[]<p,n> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node2{}<Anon_13,p,q>@M[HeapNode1]) * (q::dll{}<self,n-1>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 129,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 128,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 127,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 126,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 125,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 124,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 123,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 122,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 121,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 120,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 119,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 118,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 117,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 116,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 115,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 114,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 113,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 112,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 111,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 110,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 109,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 108,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 107,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 106,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 105,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 104,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 103,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 102,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 101,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 100,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 99,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 98,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 97,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 96,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 95,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 94,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 93,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 92,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 91,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 90,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 80,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 79,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 78,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 77,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 76,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 75,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 74,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 73,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 71,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 70,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 69,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 68,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 67,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 66,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 65,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 64,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 63,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 62,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 61,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 60,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 59,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 58,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 57,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 56,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 55,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 54,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 53,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 52,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 51,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void f2(node2 x)[]
static EBase: [][](emp ; (emp ; (x::dll{}<q,m>@M[HeapNode1])))*(m > 0)( FLOW __norm) {EAssume: 50,:(emp ; (emp ; (x::dll{}<q,m>@M[HeapNode1])))*(m > 0)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(130, ):f1(x)}
}
void f1(node2 x)[]
static EBase: [][](emp ; (emp ; (x::dll{}<q,m>@M[HeapNode1])))*(m > 0)( FLOW __norm) {EAssume: 47,:(emp ; (emp ; (x::dll{}<q,m>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int t
int t = 0;
t = t + 1}
}
void append2(node2 x, node2 y)[]
static EBase: [][](emp ; (emp ; ((x::dll{}<q,m>@M[HeapNode1]) * (y::dll{}<p,n>@M[HeapNode1]))))*(m > 0)( FLOW __norm) {EAssume: 42,:(emp ; (emp ; (x::dll{}<q,m+n>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 tmp
node2 tmp;
(133, ):if (member access x~~>next == null) { 
  (133, ):{member access x~~>next = y;
(138, ):if (y != null) { 
  (138, ):{member access y~~>prev = x};
} else { 
  (138, ):
}};
} else { 
  (133, ):{(134, ):append2(member access x~~>next, y)}
}}
}
node2 append1(node2 x, node2 y)[]
static EBase: [][](emp ; (emp ; ((x::dll{}<q,m>@M[HeapNode1]) * (y::dll{}<p,n>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 37,:(emp ; (emp ; (res::dll{}<Anon_27,m+n>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(144, ):if (x == null) { 
  (144, ):(154, ):return y;
} else { 
  (144, ):{local: node2 tmp
node2 tmp = (145, ):append1(member access x~~>next, y);
(147, ):if (tmp != null) { 
  (147, ):member access tmp~~>prev = x;
} else { 
  (147, ):
};
member access x~~>next = tmp;
(153, ):return x}
}}
}
node2 append(node2 x, node2 y)[]
static EBase: [][](emp ; (emp ; ((x::dll{}<q,m>@M[HeapNode1]) * (y::dll{}<p,n>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 29,:(emp ; (emp ; (res::dll{}<Anon_26,m+n>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 tmp
node2 tmp;
(156, ):if (x == null) { 
  (156, ):(170, ):return y;
} else { 
  (156, ):{tmp = member access x~~>next;
tmp = (160, ):append(tmp, y);
(161, ):if (tmp != null) { 
  (161, ):{member access x~~>next = tmp;
member access tmp~~>prev = x};
} else { 
  (161, ):{member access x~~>next = null}
};
(169, ):return x}
}}
}
node2 test_fold()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 26,:(emp ; (emp ; (res::dll{}<Anon_25,3>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 tmp_null,node2 tmp1,node2 tmp2,node2 tmp3
node2 tmp_null = null;
node2 tmp1 = new node2(10, tmp_null, tmp_null);
node2 tmp2 = new node2(20, tmp_null, tmp1);
member access tmp1~~>prev = tmp2;
node2 tmp3 = new node2(30, tmp_null, tmp2);
member access tmp2~~>prev = tmp3;
(176, ):return tmp3}
}
void test_del2(node2 x, node2 tmp2)[]
static EBase: [][](emp ; (emp ; ((x::node2{}<Anon_16,Anon_17,Anon_18>@M[HeapNode1]) * (tmp2::dll{}<x,Anon_19>@M[HeapNode1]))))*(tmp2 != null)( FLOW __norm)
or(emp ; (emp ; (x::node2{}<Anon_20,Anon_21,Anon_22>@M[HeapNode1])))*(tmp2 = null)( FLOW __norm) {EAssume: 22,:(emp ; (emp ; (x::dll{}<Anon_23,Anon_24>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(177, ):if (tmp2 != null) { 
  (177, ):{member access tmp2~~>prev = x};
} else { 
  (177, ):
};
member access x~~>next = tmp2}
}
void test_del(node2 x)[]
static EBase: [][](emp ; (emp ; (x::dll{}<p,n>@M[HeapNode1])))*(n > 1)( FLOW __norm) {EAssume: 18,:(emp ; (emp ; (x::dll{}<Anon_14,Anon_15>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 tmp1,node2 tmp2
node2 tmp1 = member access x~~>next;
node2 tmp2 = member access tmp1~~>next;
(185, ):if (tmp2 != null) { 
  (185, ):{member access tmp2~~>prev = x};
} else { 
  (185, ):
};
member access x~~>next = tmp2}
}
void delete1(node2 x, int a)[]
static EBase: [][](emp ; (emp ; (x::dll{}<p,n>@M[HeapNode1])))*((n > a) & (a > 0))( FLOW __norm) {EAssume: 12,:(emp ; (emp ; (x::dll{}<p,n-1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(191, ):if (a == 1) { 
  (191, ):{local: node2 l
node2 l = member access x~~>next~~>next;
(196, ):if (l != null) { 
  (196, ):{member access l~~>prev = x};
} else { 
  (196, ):
};
member access x~~>next = l};
} else { 
  (191, ):{(192, ):delete1(member access x~~>next, a - 1)}
}}
}
void delete(node2 x, int a)[]
static EBase: [][](emp ; (emp ; (x::dll{}<p,n>@M[HeapNode1])))*((n > a) & (a > 0))( FLOW __norm) {EAssume: 4,:(emp ; (emp ; (x::dll{}<p,n-1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 tmp,node2 tmp_null
node2 tmp;
node2 tmp_null = null;
(203, ):if (a == 1) { 
  (203, ):{(207, ):if (member access x~~>next~~>next != null) { 
  (207, ):{member access x~~>next~~>next~~>prev = x;
tmp = member access x~~>next~~>next;
member access x~~>next = tmp};
} else { 
  (207, ):member access x~~>next = tmp_null
}};
} else { 
  (203, ):{(204, ):delete(member access x~~>next, a - 1)}
}}
}
void insert(node2 x, int a)[]
static EBase: [][](emp ; (emp ; (x::dll{}<p,n>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (x::dll{}<p,m>@M[HeapNode1])))*(m > n)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: boolean l
boolean l = member access x~~>next == null;
(221, ):if (l) { 
  (221, ):member access x~~>next = new node2(a, x, null);
} else { 
  (221, ):(222, ):insert(member access x~~>next, a)
}}
}
@@prog4


Checking procedure append$node2~node2... 
Procedure append$node2~node2 SUCCESS.

Checking procedure append1$node2~node2... 
Procedure append1$node2~node2 SUCCESS.

Checking procedure append2$node2~node2... 
Procedure append2$node2~node2 SUCCESS.

Checking procedure delete$node2~int... 
Procedure delete$node2~int SUCCESS.

Checking procedure delete1$node2~int... 
Procedure delete1$node2~int SUCCESS.

Checking procedure f1$node2... 
Procedure f1$node2 SUCCESS.

Checking procedure f2$node2... 
Procedure f2$node2 SUCCESS.

Checking procedure insert$node2~int... 
Procedure insert$node2~int SUCCESS.

Checking procedure test_del$node2... 
Procedure test_del$node2 SUCCESS.

Checking procedure test_del2$node2~node2... 
Procedure test_del2$node2~node2 SUCCESS.

Checking procedure test_fold$... 
Procedure test_fold$ SUCCESS.
Stop Omega... 603 invocations 
0 false contexts at: ()

!!! log(small):(4.49972,3547)
Total verification time: 3.121804 second(s)
	Time spent in main process: 2.913272 second(s)
	Time spent in child processes: 0.208532 second(s)


======================================

!!!Full processing file "./hip/heaps.ss"
Parsing file "./hip/heaps.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_18


}

class int_ptr extends Object {
int valVAL_19


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_20


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_14;
int nleftVAL_13;
int nrightVAL_12;
node leftREC_11;
node rightREC_21


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
pq{}[]<n,mx> == 

(None,[]): EBase: [][](emp)*((self = null) & ((n = 0) & (mx = 0)))( FLOW __flow) 
||
(None,[]): EBase: [][](EX m3 . (emp ; (emp ; (((self::node{}<d,m1,m2,l,r>@M[HeapNode1]) * (l::pq{}<m1,mx1>@M[HeapNode1])) * (r::pq{}<m2,mx2>@M[HeapNode1]))))*((n = (1+m1)+m2) & ((d >= 0) & ((d >= mx1) & ((d >= mx2) & ((mx >= d) & ((m3 = m1-m2) & ((m3 >= 0) & (m3 <= 1))))))))( FLOW __flow))  inv (n >= 0) & (mx >= 0) inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 144,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 143,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 142,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 141,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 140,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 139,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 138,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 137,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 136,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 135,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 134,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 133,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 132,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 131,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 130,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 129,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 128,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 127,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 126,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 125,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 124,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 123,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 122,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 121,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 120,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 119,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 118,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 117,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 116,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 115,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 114,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 113,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 112,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 111,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 110,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 109,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 108,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 107,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 106,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 105,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 104,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 103,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 102,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 101,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 100,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 99,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 98,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 97,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 96,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 95,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 94,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 93,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 92,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 91,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 90,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 89,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 88,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 87,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 86,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 85,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 84,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 83,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 82,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 81,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 80,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 79,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 78,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 77,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 76,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 75,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 74,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 73,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 72,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 71,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 70,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 69,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 66,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int deletemax(node@R t)[]
static EBase: [][](emp ; (emp ; (t::pq{}<n,mx>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 58,:(emp ; (emp ; (t'::pq{}<n-1,mx2>@M[HeapNode1])))*((mx2 <= res) & (res <= mx))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int v,int tmp
int v, tmp;
(145, ):if ((member access t~~>nleft == 0) && (member access t~~>nright == 0)) { 
  (145, ):{tmp = member access t~~>val;
t = null;
(155, ):return tmp};
} else { 
  (145, ):{(146, ):bind t to (tval, tnleft, tnright, tleft, tright) in
{v = (148, ):deleteone(tnleft, tnright, tleft, tright);
tmp = tval;
(150, ):ripple(tval, v, tnleft, tnright, tleft, tright)};
(151, ):return tmp}
}}
}
void ripple(int@R d, int v, int m1, int m2, node l, node r)[]
static EBase: [][](emp ; (emp ; ((l::pq{}<m1,mx1>@M[HeapNode1]) * (r::pq{}<m2,mx2>@M[HeapNode1]))))*(((0 <= m1-m2) & ((m1-m2) <= 1)) & (((d >= mx1) & (d >= mx2)) & ((0 <= v) & (v <= d))))( FLOW __norm) {EAssume: 42,:(emp ; (emp ; ((l::pq{}<m1,mx3>@M[HeapNode1]) * (r::pq{}<m2,mx4>@M[HeapNode1]))))*((mx3 <= mx1) & ((mx4 <= mx2) & ((max1 = max(mx1,v)) & ((max2 = max(mx2,max1)) & ((d' <= max2) & (((d' >= mx3) & (d' >= mx4)) & (d' >= 0)))))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(161, ):if (m1 == 0) { 
  (161, ):{(200, ):if (m2 == 0) { 
  (200, ):{d = v};
} else { 
  (200, ):
}};
} else { 
  (161, ):{(162, ):if (m2 == 0) { 
  (162, ):{(191, ):if (v >= member access l~~>val) { 
  (191, ):d = v;
} else { 
  (191, ):{d = member access l~~>val;
member access l~~>val = v}
}};
} else { 
  (162, ):{(163, ):if (member access l~~>val >= member access r~~>val) { 
  (163, ):{(176, ):if (v >= member access l~~>val) { 
  (176, ):d = v;
} else { 
  (176, ):{d = member access l~~>val;
(179, ):ripple(member access l~~>val, v, member access l~~>nleft, member access l~~>nright, member access l~~>left, member access l~~>right)}
}};
} else { 
  (163, ):{(164, ):if (v >= member access r~~>val) { 
  (164, ):d = v;
} else { 
  (164, ):{dprint;
d = member access r~~>val;
(167, ):ripple(member access r~~>val, v, member access r~~>nleft, member access r~~>nright, member access r~~>left, member access r~~>right)}
}}
}}
}}
}}
}
int deleteone(int@R m1, int@R m2, node@R l, node@R r)[]
static EBase: [][](emp ; (emp ; ((l::pq{}<m1,mx1>@M[HeapNode1]) * (r::pq{}<m2,mx2>@M[HeapNode1]))))*(((m1+m2) > 0) & ((0 <= m1-m2) & ((m1-m2) <= 1)))( FLOW __norm) {EAssume: 36,:(emp ; (emp ; ((l'::pq{}<m1',mx3>@M[HeapNode1]) * (r'::pq{}<m2',mx4>@M[HeapNode1]))))*((((m1'+m2')+1) = (m1+m2)) & (((0 <= m1'-m2') & ((m1'-m2') <= 1)) & ((mx3 <= mx1) & ((mx4 <= mx2) & ((maxi = max(mx1,mx2)) & ((0 <= res) & (res <= maxi)))))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(204, ):if (m1 > m2) { 
  (204, ):{m1 = m1 - 1;
(211, ):return (212, ):deleteoneel(l)};
} else { 
  (204, ):{m2 = m2 - 1;
(207, ):return (208, ):deleteoneel(r)}
}}
}
int deleteoneel(node@R t)[]
static EBase: [][](emp ; (emp ; (t::pq{}<n,mx>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 29,:(emp ; (emp ; (t'::pq{}<n-1,mx2>@M[HeapNode1])))*(((0 <= res) & (res <= mx)) & (mx2 <= mx))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int v
int v;
(214, ):if ((member access t~~>nleft == 0) && (member access t~~>nright == 0)) { 
  (214, ):{v = member access t~~>val;
t = null;
(222, ):return v};
} else { 
  (214, ):{local: int tmp
int tmp;
(215, ):bind t to (tval, tnleft, tnright, tleft, tright) in
{tmp = (217, ):deleteone(tnleft, tnright, tleft, tright)};
(218, ):return tmp}
}}
}
node insert(node t, int v)[]
static EBase: [][](emp ; (emp ; (t::pq{}<n,mx>@M[HeapNode1])))*(v >= 0)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (res::pq{}<n1,ma>@M[HeapNode1])))*((n1 = n+1) & (((v >= mx) & (ma = v)) | (ma = mx)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp,node tmp_null,int tmpv
node tmp, tmp_null = null;
int tmpv;
(228, ):if (t == null) { 
  (228, ):(288, ):return new node(v, 0, 0, tmp_null, tmp_null);
} else { 
  (228, ):(229, ):if (v > member access t~~>val) { 
  (229, ):{(255, ):if (member access t~~>nleft <= member access t~~>nright) { 
  (255, ):{tmp = member access t~~>left;
tmpv = member access t~~>val;
member access t~~>left = (273, ):insert(tmp, tmpv);
tmpv = member access t~~>nleft;
member access t~~>nleft = tmpv + 1};
} else { 
  (255, ):{tmp = member access t~~>right;
tmpv = member access t~~>val;
member access t~~>right = (261, ):insert(tmp, tmpv);
tmpv = member access t~~>nright;
member access t~~>nright = tmpv + 1}
};
member access t~~>val = v;
(285, ):return t};
} else { 
  (229, ):{(230, ):if (member access t~~>nleft <= member access t~~>nright) { 
  (230, ):{tmp = member access t~~>left;
member access t~~>left = (244, ):insert(tmp, v);
tmpv = member access t~~>nleft;
member access t~~>nleft = tmpv + 1};
} else { 
  (230, ):{tmp = member access t~~>right;
member access t~~>right = (234, ):insert(tmp, v);
tmpv = member access t~~>nright;
member access t~~>nright = tmpv + 1}
};
(254, ):return t}
}
}}
}
@@prog4


Checking procedure deleteoneel$node... 
Procedure deleteoneel$node SUCCESS.

Checking procedure deleteone$int~int~node~node... 
Procedure deleteone$int~int~node~node SUCCESS.

!!! SHAPE inferred spec: EBase exists (Expl)[](Impl)[n; mx](ex)[]t::pq{}<n,mx>@ rem br[{411}]&(
       ([1<=n & 0<=n & 0!=n][0<=mx][null!=t]))&{FLOW,(4,5)=__norm#E}[]
         EBase emp&MayLoop[]&{FLOW,(4,5)=__norm#E}[]
                 EAssume ref [t]
                   (exists flted_76_82,
                   mx2: t'::pq{}<flted_76_82,mx2>@ rem br[{410,411}]&(
                   ([1+flted_76_82=n & 0<=flted_76_82]
                    [0<=res & 0<=mx2 & mx2<=mx & res<=mx]))&
                   {FLOW,(4,5)=__norm#E})[]
                   
!!! SHAPE inferred spec: EBase exists (Expl)[](Impl)[mx1; mx2](ex)[](exists m1_73,
       m2_74: l::pq{}<m1_73,mx1>@ rem br[{411}] * 
       r::pq{}<m2_74,mx2>@ rem br[{410,411}]&(
       ([m1=m1_73 & m2=m2_74 & 1<=(m1+m2) & 0<=m2_74 & 0<=m1_73 & m2<=m1 & 
          0!=m1_73 & (-1+m1)<=m2]
        [0<=mx1][null!=l][0<=mx2]))&
       {FLOW,(4,5)=__norm#E})[]
         EBase emp&MayLoop[]&{FLOW,(4,5)=__norm#E}[]
                 EAssume ref [m1;m2;l;r]
                   (exists m1_75,m2_76,mx3,mx4,
                   maxi: l'::pq{}<m1_75,mx3>@ rem br[{410,411}] * 
                   r'::pq{}<m2_76,mx4>@ rem br[{410,411}]&(
                   ([maxi=max(mx1,mx2) & mx3<=mx1 & 0<=mx4 & 0<=mx3 & 
                      mx4<=mx2 & res<=maxi & 0<=res]
                    [m1'=m1_75 & m2'=m2_76 & m1'+m2'=-1+m1+m2 & 0<=m2_76 & 
                      0<=m1_75 & m2'<=m1' & (-1+m1')<=m2']
                    ))&
                   {FLOW,(4,5)=__norm#E})[]
                   
Checking procedure ripple$int~int~int~int~node~node... 
dprint: ./hip/heaps.ss:170: ctx:  List of Failesc Context: [FEC(0, 0, 1  [(,1 ); (,2 ); (,1 ); (,2 ); (,1 ); (,2 ); (,1 ); (,2 )])]

Successful States:
[
 Label: [(,1 ); (,2 ); (,1 ); (,2 ); (,1 ); (,2 ); (,1 ); (,2 )]
 State:l'::node<d_2482,m1_2484,m2_2487,l_2483,r_2486>@ rem br[{1}] * l_2483::pq{}<m1_2479,mx1_2485>@ rem br[{410,411}] * r_2486::pq{}<m2_2480,mx2_2488>@ rem br[{410,411}] * r'::node<d_2529,m1_2531,m2_2534,l_2530,r_2533>@ rem br[{1}] * l_2530::pq{}<m1_2526,mx1_2532>@ rem br[{410,411}] * r_2533::pq{}<m2_2527,mx2_2535>@ rem br[{410,411}]&(([
                                                                    !(v_bool_141_1680')]
                                                                    [!(v_bool_132_1681')]
                                                                    [l=l' & 
                                                                    null!=l]
                                                                    [r=r' & 
                                                                    null!=r]
                                                                    [m1=m1' & 
                                                                    m1=m1_2365 & 
                                                                    m1_2479=m1_2484 & 
                                                                    m1_2526=m1_2531 & 
                                                                    m2=m2' & 
                                                                    m2=m2_2366 & 
                                                                    m2_2480=m2_2487 & 
                                                                    m2_2527=m2_2534 & 
                                                                    m2_2366=1+
                                                                    m1_2531+
                                                                    m2_2534 & 
                                                                    0<=m1_2526 & 
                                                                    0<=m3_2528 & 
                                                                    m1_2365=1+
                                                                    m1_2484+
                                                                    m2_2487 & 
                                                                    0!=m1_2365 & 
                                                                    0<=m2_2366 & 
                                                                    m2_2487+
                                                                    m3_2481=m1_2484 & 
                                                                    0<=m2_2480 & 
                                                                    (-1+
                                                                    m1)<=m2 & 
                                                                    m2<=m1 & 
                                                                    0<=m3_2481 & 
                                                                    0<=m1_2479 & 
                                                                    0<=m1_2365 & 
                                                                    0!=m2_2366 & 
                                                                    m3_2481<=1 & 
                                                                    m2_2534+
                                                                    m3_2528=m1_2531 & 
                                                                    m3_2528<=1 & 
                                                                    0<=m2_2527]
                                                                    [d=d' & 
                                                                    v=v' & 
                                                                    0<=mx1_2532 & 
                                                                    mx1<=d & 
                                                                    d_2482<=mx1 & 
                                                                    (1+
                                                                    v')<=d_2529 & 
                                                                    0<=d_2529 & 
                                                                    (1+
                                                                    d_2482)<=d_2529 & 
                                                                    mx2_2535<=d_2529 & 
                                                                    0<=d_2482 & 
                                                                    0<=mx1 & 
                                                                    mx2<=d & 
                                                                    0<=v & 
                                                                    mx1_2485<=d_2482 & 
                                                                    0<=mx2 & 
                                                                    0<=mx2_2488 & 
                                                                    v<=d & 
                                                                    0<=mx2_2535 & 
                                                                    mx1_2532<=d_2529 & 
                                                                    mx2_2488<=d_2482 & 
                                                                    0<=mx1_2485 & 
                                                                    d_2529<=mx2]
                                                                    [!(v_bool_154_1679')]
                                                                    [!(v_bool_166_1678')]
                                                                    ))&{FLOW,(4,5)=__norm#E}[]
       es_ho_vars_map: []l'::node<d_2482,m1_2484,m2_2487,l_2483,r_2486>@ rem br[{1}] * l_2483::pq<m1_2479,mx1_2485>@ rem br[{410,411}] * r_2486::pq<m2_2480,mx2_2488>@ rem br[{410,411}] * r'::node<d_2529,m1_2531,m2_2534,l_2530,r_2533>@ rem br[{1}] * l_2530::pq<m1_2526,mx1_2532>@ rem br[{410,411}] * r_2533::pq<m2_2527,mx2_2535>@ rem br[{410,411}]&(([
                                                                    !(v_bool_141_1680')]
                                                                    [!(v_bool_132_1681')]
                                                                    [l=l' & 
                                                                    null!=l]
                                                                    [r=r' & 
                                                                    null!=r]
                                                                    [m1=m1' & 
                                                                    m1=m1_2365 & 
                                                                    m1_2479=m1_2484 & 
                                                                    m1_2526=m1_2531 & 
                                                                    m2=m2' & 
                                                                    m2=m2_2366 & 
                                                                    m2_2480=m2_2487 & 
                                                                    m2_2527=m2_2534 & 
                                                                    m2_2366=1+
                                                                    m1_2531+
                                                                    m2_2534 & 
                                                                    0<=m1_2526 & 
                                                                    0<=m3_2528 & 
                                                                    m1_2365=1+
                                                                    m1_2484+
                                                                    m2_2487 & 
                                                                    0!=m1_2365 & 
                                                                    0<=m2_2366 & 
                                                                    m2_2487+
                                                                    m3_2481=m1_2484 & 
                                                                    0<=m2_2480 & 
                                                                    (-1+
                                                                    m1)<=m2 & 
                                                                    m2<=m1 & 
                                                                    0<=m3_2481 & 
                                                                    0<=m1_2479 & 
                                                                    0<=m1_2365 & 
                                                                    0!=m2_2366 & 
                                                                    m3_2481<=1 & 
                                                                    m2_2534+
                                                                    m3_2528=m1_2531 & 
                                                                    m3_2528<=1 & 
                                                                    0<=m2_2527]
                                                                    [d=d' & 
                                                                    v=v' & 
                                                                    0<=mx1_2532 & 
                                                                    mx1<=d & 
                                                                    d_2482<=mx1 & 
                                                                    (1+
                                                                    v')<=d_2529 & 
                                                                    0<=d_2529 & 
                                                                    (1+
                                                                    d_2482)<=d_2529 & 
                                                                    mx2_2535<=d_2529 & 
                                                                    0<=d_2482 & 
                                                                    0<=mx1 & 
                                                                    mx2<=d & 
                                                                    0<=v & 
                                                                    mx1_2485<=d_2482 & 
                                                                    0<=mx2 & 
                                                                    0<=mx2_2488 & 
                                                                    v<=d & 
                                                                    0<=mx2_2535 & 
                                                                    mx1_2532<=d_2529 & 
                                                                    mx2_2488<=d_2482 & 
                                                                    0<=mx1_2485 & 
                                                                    d_2529<=mx2]
                                                                    [!(v_bool_154_1679')]
                                                                    [!(v_bool_166_1678')]
                                                                    ))

 ]

Procedure ripple$int~int~int~int~node~node SUCCESS.

Checking procedure deletemax$node... 
Procedure deletemax$node SUCCESS.

Checking procedure insert$node~int... 
Procedure insert$node~int SUCCESS.
Stop Omega... 1711 invocations 
1 false contexts at: ( (134,2) )

!!! log(small):(14.324004,7443)
Total verification time: 10.864454 second(s)
	Time spent in main process: 9.514606 second(s)
	Time spent in child processes: 1.349848 second(s)


======================================

!!!Full processing file "./hip/insertion.ss"
Parsing file "./hip/insertion.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_15


}

class int_ptr extends Object {
int valVAL_16


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_17


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_18


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
sll{}[]<n,sm,lg> == 

(None,[]): EBase: [][](emp ; (emp ; (self::node{}<sm,null>@M[HeapNode1])))*((sm = lg) & (n = 1))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<sm,q>@M[HeapNode1]) * (q::sll{}<n-1,qs,lg>@M[HeapNode1]))))*((q != null) & (sm <= qs))( FLOW __flow)  inv (n >= 1) & (sm <= lg) inv_lock: None view_data_name:  view_imm_map: []
bnd{}[]<n,sm,bg> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<d,p>@M[HeapNode1]) * (p::bnd{}<n-1,sm,bg>@M[HeapNode1]))))*((sm <= d) & (d < bg))( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 84,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 83,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 73,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 72,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 70,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 69,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 68,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 67,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 66,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 65,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 64,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 63,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 62,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 61,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 60,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 59,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 57,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 56,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 55,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 54,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 52,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 50,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 49,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 48,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 46,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 45,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 39,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 38,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 37,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 36,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 35,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 34,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 33,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 32,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 31,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 30,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 29,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 28,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 27,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 26,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 25,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 24,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 23,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 22,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 21,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 20,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 19,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 18,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 17,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 16,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 15,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 14,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 13,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 12,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 11,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 10,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void insertion_sort(node x, node@R y)[]
static EBase: [][](emp ; (emp ; ((x::bnd{}<n1,sm1,bg1>@M[HeapNode1]) * (y::sll{}<n2,sm2,bg2>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 7,:(emp ; (emp ; ((y'::sll{}<n1+n2,sm,bg>@M[HeapNode1]) * (x::bnd{}<n1,sm1,bg1>@M[HeapNode1]))))*((sm <= sm2) & (bg >= bg2))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(89, ):if (x != null) { 
  (89, ):{y = (91, ):insert(y, member access x~~>val);
(93, ):insertion_sort(member access x~~>next, y)};
} else { 
  (89, ):
}}
}
node insert(node x, int v)[]
static EBase: [][](emp ; (emp ; (x::sll{}<n,xs,xl>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (res::sll{}<n+1,sres,lres>@M[HeapNode1])))*((sres = min(v,xs)) & (lres = max(v,xl)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp_null,node xn
node tmp_null = null;
node xn;
(96, ):if (v <= member access x~~>val) { 
  (96, ):{(109, ):return new node(v, x)};
} else { 
  (96, ):{(97, ):if (member access x~~>next != null) { 
  (97, ):{xn = (102, ):insert(member access x~~>next, v);
member access x~~>next = xn;
(106, ):return x};
} else { 
  (97, ):{member access x~~>next = new node(v, tmp_null);
(100, ):return x}
}}
}}
}
@@prog4


Checking procedure insert$node~int... 
Procedure insert$node~int SUCCESS.

Checking procedure insertion_sort$node~node... 
Procedure insertion_sort$node~node SUCCESS.
Stop Omega... 384 invocations 
0 false contexts at: ()

!!! log(small):(1.31502,1256)
Total verification time: 1.210188 second(s)
	Time spent in main process: 1.084752 second(s)
	Time spent in child processes: 0.125436 second(s)


======================================

!!!Full processing file "./hip/ll.ss"
Parsing file "./hip/ll.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_16


}

class int_ptr extends Object {
int valVAL_17


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_18


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_19


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
ll{}[]<n> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<Anon_12,q>@M[HeapNode1]) * (q::ll{}<n-1>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 211,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 210,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 209,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 208,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 207,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 206,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 205,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 204,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 203,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 202,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 201,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 200,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 199,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 198,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 197,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 196,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 195,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 194,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 193,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 192,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 191,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 190,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 189,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 188,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 187,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 186,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 185,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 184,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 183,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 182,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 181,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 180,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 179,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 178,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 177,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 176,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 175,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 174,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 173,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 172,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 171,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 170,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 169,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 168,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 167,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 166,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 165,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 164,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 163,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 162,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 161,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 160,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 159,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 158,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 157,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 156,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 155,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 154,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 153,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 152,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 151,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 150,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 149,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 148,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 147,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 146,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 145,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 144,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 143,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 142,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 141,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 140,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 139,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 138,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 137,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 136,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 135,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 134,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 133,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void reverse17(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 127,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(212, ):if (xs != null) { 
  (212, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(219, ):reverse(xs, ys)};
} else { 
  (212, ):
}}
}
void reverse16(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 121,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(221, ):if (xs != null) { 
  (221, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(228, ):reverse(xs, ys)};
} else { 
  (221, ):
}}
}
void reverse15(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 115,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(230, ):if (xs != null) { 
  (230, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(237, ):reverse(xs, ys)};
} else { 
  (230, ):
}}
}
void reverse14(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 109,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(239, ):if (xs != null) { 
  (239, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(246, ):reverse(xs, ys)};
} else { 
  (239, ):
}}
}
void reverse13(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 103,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(248, ):if (xs != null) { 
  (248, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(255, ):reverse(xs, ys)};
} else { 
  (248, ):
}}
}
void reverse12(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 97,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(257, ):if (xs != null) { 
  (257, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(264, ):reverse(xs, ys)};
} else { 
  (257, ):
}}
}
void reverse11(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 91,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(266, ):if (xs != null) { 
  (266, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(273, ):reverse(xs, ys)};
} else { 
  (266, ):
}}
}
void reverse10(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 85,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(275, ):if (xs != null) { 
  (275, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(282, ):reverse(xs, ys)};
} else { 
  (275, ):
}}
}
void reverse9(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 79,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(284, ):if (xs != null) { 
  (284, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(291, ):reverse(xs, ys)};
} else { 
  (284, ):
}}
}
void reverse8(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 73,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(293, ):if (xs != null) { 
  (293, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(300, ):reverse(xs, ys)};
} else { 
  (293, ):
}}
}
void reverse7(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 67,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(302, ):if (xs != null) { 
  (302, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(309, ):reverse(xs, ys)};
} else { 
  (302, ):
}}
}
void reverse6(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 61,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(311, ):if (xs != null) { 
  (311, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(318, ):reverse(xs, ys)};
} else { 
  (311, ):
}}
}
void reverse5(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 55,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(320, ):if (xs != null) { 
  (320, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(327, ):reverse(xs, ys)};
} else { 
  (320, ):
}}
}
void reverse4(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 49,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(329, ):if (xs != null) { 
  (329, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(336, ):reverse(xs, ys)};
} else { 
  (329, ):
}}
}
void reverse3(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 43,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(338, ):if (xs != null) { 
  (338, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(345, ):reverse(xs, ys)};
} else { 
  (338, ):
}}
}
void reverse2(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 37,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(347, ):if (xs != null) { 
  (347, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(354, ):reverse(xs, ys)};
} else { 
  (347, ):
}}
}
void reverse(node@R xs, node@R ys)[]
static EBase: [][](emp ; (emp ; ((xs::ll{}<n>@M[HeapNode1]) * (ys::ll{}<m>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 31,:(emp ; (emp ; (ys'::ll{}<n+m>@M[HeapNode1])))*(xs' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(356, ):if (xs != null) { 
  (356, ):{local: node tmp
node tmp;
tmp = member access xs~~>next;
member access xs~~>next = ys;
ys = xs;
xs = tmp;
(363, ):reverse(xs, ys)};
} else { 
  (356, ):
}}
}
node create_list(int a)[]
static EBase: [][](emp)*(a >= 0)( FLOW __norm) {EAssume: 26,:(emp ; (emp ; (res::ll{}<a>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
(365, ):if (a == 0) { 
  (365, ):{(371, ):return null};
} else { 
  (365, ):{a = a - 1;
tmp = (369, ):create_list(a);
(370, ):return new node(0, tmp)}
}}
}
void delete(node x, int a)[]
static EBase: [][](emp ; (emp ; (x::ll{}<n>@M[HeapNode1])))*((n > a) & (a > 0))( FLOW __norm) {EAssume: 22,:(emp ; (emp ; (x::ll{}<n-1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(373, ):if (a == 1) { 
  (373, ):{member access x~~>next = member access x~~>next~~>next};
} else { 
  (373, ):{(374, ):delete(member access x~~>next, a - 1)}
}}
}
void insert(node x, int a)[]
static EBase: [][](emp ; (emp ; (x::ll{}<n>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 19,:(emp ; (emp ; (x::ll{}<n+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp = null;
(381, ):if (member access x~~>next == null) { 
  (381, ):member access x~~>next = new node(a, tmp);
} else { 
  (381, ):(382, ):insert(member access x~~>next, a)
}}
}
node get_next_next(node x)[]
static EBase: [][](emp ; (emp ; (x::ll{}<n>@M[HeapNode1])))*(n > 1)( FLOW __norm) {EAssume: 18,:(emp ; (emp ; (res::ll{}<n-2>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(388, ):return member access x~~>next~~>next}
}
void set_null(node x)[]
static EBase: [][](emp ; (emp ; (x::ll{}<i>@M[HeapNode1])))*(i > 0)( FLOW __norm) {EAssume: 16,:(emp ; (emp ; (x::ll{}<1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{member access x~~>next = null}
}
void set_null2(node x)[]
static EBase: [][](emp ; (emp ; (x::ll{}<i>@M[HeapNode1])))*(i > 0)( FLOW __norm) {EAssume: 12,:(emp ; (emp ; (x::ll{}<1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(392, ):if (4 > 3) { 
  (392, ):member access x~~>next = null;
} else { 
  (392, ):member access x~~>next = null
}}
}
void set_next(node x, node y)[]
static EBase: [][](emp ; (emp ; ((x::ll{}<i>@M[HeapNode1]) * (y::ll{}<j>@M[HeapNode1]))))*(i > 0)( FLOW __norm) {EAssume: 10,:(emp ; (emp ; (x::ll{}<j+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{member access x~~>next = y}
}
node get_next(node x)[]
static EBase: [][](emp ; (emp ; (x::ll{}<n>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 8,:(emp ; (emp ; ((x::ll{}<1>@M[HeapNode1]) * (res::ll{}<n-1>@M[HeapNode1]))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp = member access x~~>next;
member access x~~>next = null;
(403, ):return tmp}
}
node ret_first(node x)[]
static EBase: [][](emp ; (emp ; ((x::ll{}<n>@M[HeapNode1]) * (y::ll{}<m>@M[HeapNode1]))))*(n < m)( FLOW __norm) {EAssume: 7,:(emp ; (emp ; (x::ll{}<n>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(404, ):return x}
}
void append(node x, node y)[]
static EBase: [][](emp ; (emp ; ((x::ll{}<n1>@M[HeapNode1]) * (y::ll{}<n2>@M[HeapNode1]))))*(x != null)( FLOW __norm) {EAssume: 4,:(emp ; (emp ; (x::ll{}<n1+n2>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(405, ):if (member access x~~>next == null) { 
  (405, ):member access x~~>next = y;
} else { 
  (405, ):(406, ):append(member access x~~>next, y)
}}
}
void append2(node x, node y)[]
static EBase: [][](emp ; (emp ; ((x::ll{}<n1>@M[HeapNode1]) * (y::ll{}<n2>@M[HeapNode1]))))*(n1 > 0)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (x::ll{}<n1+n2>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(412, ):if (member access x~~>next == null) { 
  (412, ):member access x~~>next = y;
} else { 
  (412, ):(413, ):append2(member access x~~>next, y)
}}
}
@@prog4


Checking procedure append$node~node... 
Procedure append$node~node SUCCESS.

Checking procedure append2$node~node... 
Procedure append2$node~node SUCCESS.

Checking procedure create_list$int... 
Procedure create_list$int SUCCESS.

Checking procedure delete$node~int... 
Procedure delete$node~int SUCCESS.

Checking procedure get_next$node... 
Procedure get_next$node SUCCESS.

Checking procedure get_next_next$node... 
Procedure get_next_next$node SUCCESS.

Checking procedure insert$node~int... 
Procedure insert$node~int SUCCESS.

Checking procedure ret_first$node... 
Procedure ret_first$node SUCCESS.

Checking procedure reverse$node~node... 
Procedure reverse$node~node SUCCESS.

Checking procedure reverse10$node~node... 
Procedure reverse10$node~node SUCCESS.

Checking procedure reverse11$node~node... 
Procedure reverse11$node~node SUCCESS.

Checking procedure reverse12$node~node... 
Procedure reverse12$node~node SUCCESS.

Checking procedure reverse13$node~node... 
Procedure reverse13$node~node SUCCESS.

Checking procedure reverse14$node~node... 
Procedure reverse14$node~node SUCCESS.

Checking procedure reverse15$node~node... 
Procedure reverse15$node~node SUCCESS.

Checking procedure reverse16$node~node... 
Procedure reverse16$node~node SUCCESS.

Checking procedure reverse17$node~node... 
Procedure reverse17$node~node SUCCESS.

Checking procedure reverse2$node~node... 
Procedure reverse2$node~node SUCCESS.

Checking procedure reverse3$node~node... 
Procedure reverse3$node~node SUCCESS.

Checking procedure reverse4$node~node... 
Procedure reverse4$node~node SUCCESS.

Checking procedure reverse5$node~node... 
Procedure reverse5$node~node SUCCESS.

Checking procedure reverse6$node~node... 
Procedure reverse6$node~node SUCCESS.

Checking procedure reverse7$node~node... 
Procedure reverse7$node~node SUCCESS.

Checking procedure reverse8$node~node... 
Procedure reverse8$node~node SUCCESS.

Checking procedure reverse9$node~node... 
Procedure reverse9$node~node SUCCESS.

Checking procedure set_next$node~node... 
Procedure set_next$node~node SUCCESS.

Checking procedure set_null$node... 
Procedure set_null$node SUCCESS.

Checking procedure set_null2$node... 
Procedure set_null2$node SUCCESS.
Stop Omega... 368 invocations 
2 false contexts at: ( (99,11)  (99,2) )

!!! log(small):(2.630145,5167)
Total verification time: 2.789461 second(s)
	Time spent in main process: 2.695187 second(s)
	Time spent in child processes: 0.094274 second(s)


======================================

!!!Full processing file "./hip/merge.ss"
Parsing file "./hip/merge.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_18


}

class int_ptr extends Object {
int valVAL_19


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_20


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_21


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
sll{}[]<n,sm,lg> == 

(None,[]): EBase: [][](emp ; (emp ; (self::node{}<sm,null>@M[HeapNode1])))*((sm = lg) & (n = 1))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<sm,q>@M[HeapNode1]) * (q::sll{}<n-1,qs,lg>@M[HeapNode1]))))*(sm <= qs)( FLOW __flow)  inv (n >= 1) & ((sm <= lg) & (self != null)) inv_lock: None view_data_name:  view_imm_map: []
bnd{}[]<n,sm,bg> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<d,p>@M[HeapNode1]) * (p::bnd{}<n-1,sm,bg>@M[HeapNode1]))))*((sm <= d) & (d <= bg))( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 108,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 107,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 106,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 105,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 104,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 103,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 102,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 101,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 100,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 99,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 98,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 97,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 96,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 95,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 94,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 93,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 92,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 91,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 90,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 89,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 88,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 87,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 85,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 84,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 83,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 82,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 81,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 80,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 79,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 78,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 77,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 76,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 75,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 74,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 73,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 72,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 71,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 70,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 69,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 66,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 65,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 63,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 62,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 61,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 60,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 59,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 58,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 57,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 56,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 55,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 54,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 53,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 52,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 51,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 50,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 49,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 48,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 47,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 46,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 45,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 44,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 43,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 42,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 41,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 40,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 39,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 38,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 37,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 36,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 35,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 34,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 33,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 32,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 31,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 30,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

node insert(node x, int v)[]
static EBase: [][](emp ; (emp ; (x::sll{}<n,xs,xl>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 25,:(emp ; (emp ; (res::sll{}<n+1,sres,lres>@M[HeapNode1])))*((sres = min(v,xs)) & (lres = max(v,xl)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
(109, ):if (v <= member access x~~>val) { 
  (109, ):(121, ):return new node(v, x);
} else { 
  (109, ):{(110, ):if (member access x~~>next != null) { 
  (110, ):{member access x~~>next = (115, ):insert(member access x~~>next, v);
(118, ):return x};
} else { 
  (110, ):{member access x~~>next = new node(v, null);
(113, ):return x}
}}
}}
}
node merge(node x1, node x2)[]
static EBase: [][](emp ; (emp ; ((x1::sll{}<n1,s1,b1>@M[HeapNode1]) * (x2::sll{}<n2,s2,b2>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 19,:(emp ; (emp ; (res::sll{}<n1+n2,s3,b3>@M[HeapNode1])))*((s3 = min(s1,s2)) & (b3 = max(b1,b2)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(124, ):if (x2 == null) { 
  (124, ):(139, ):return x1;
} else { 
  (124, ):{(125, ):if (x1 == null) { 
  (125, ):(137, ):return x2;
} else { 
  (125, ):{x1 = (127, ):insert(x1, member access x2~~>val);
(129, ):if (member access x2~~>next != null) { 
  (129, ):{local: node tmp
node tmp = (131, ):merge(x1, member access x2~~>next);
 :assert_inexact EBase: [][](emp ; (emp ; (tmp'::sll{}<n1+n2,Anon_13,max(b1,b2)>@M[HeapNode1])))*(true)( FLOW __norm) 
 assume: 
;
(134, ):return tmp};
} else { 
  (129, ):(130, ):return x1
}}
}}
}}
}
node merge_sort(node xs)[]
static EBase: [][](emp ; (emp ; (xs::bnd{}<n,sm,bg>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 12,:(emp ; (emp ; (res::sll{}<n,smres,bgres>@M[HeapNode1])))*((smres >= sm) & (bgres <= bg))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int c,int middle,node s1,node s2,node s3
int c, middle;
node s1, s2, s3;
(141, ):if (member access xs~~>next != null) { 
  (141, ):{c = (144, ):count(xs);
middle = (146, ):mydiv2(c);
s1 = (148, ):split_func(xs, middle);
s2 = (150, ):merge_sort(s1);
s3 = (152, ):merge_sort(xs);
(153, ):return (154, ):merge(s2, s3)};
} else { 
  (141, ):{(142, ):return xs}
}}
}
int mydiv2(int c)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 11,:(emp)*((res+res) = c)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

node split_func(node@R x, int a)[]
static EBase: [][](emp ; (emp ; (x::bnd{}<n,sm,bg>@M[HeapNode1])))*((a > 0) & (n > a))( FLOW __norm) {EAssume: 4,:(emp ; (emp ; ((x'::bnd{}<n1,sm,bg>@M[HeapNode1]) * (res::bnd{}<n2,sm,bg>@M[HeapNode1]))))*((n = n1+n2) & ((n1 > 0) & ((n2 > 0) & (n1 = a))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
(157, ):if (a == 1) { 
  (157, ):{tmp = member access x~~>next;
member access x~~>next = null;
(168, ):return tmp};
} else { 
  (157, ):{local: node tmp_17
a = a - 1;
node tmp_17;
(160, ):bind x to (Anon_12, xnext) in
{tmp_17 = (162, ):split_func(xnext, a)};
(163, ):return tmp_17}
}}
}
int count(node x)[]
static EBase: [][](emp ; (emp ; (x::bnd{}<n,sm,bg>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (x::bnd{}<n,sm,bg>@M[HeapNode1])))*(res = n)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int tmp
int tmp;
(170, ):if (x == null) { 
  (170, ):(175, ):return 0;
} else { 
  (170, ):(171, ):return 1 + (173, ):count(member access x~~>next)
}}
}
@@prog4


Checking procedure count$node... 
Procedure count$node SUCCESS.

Checking procedure insert$node~int... 
Procedure insert$node~int SUCCESS.

Checking procedure merge$node~node... 
assert:./hip/merge.ss:105: 4:  : ok


Procedure merge$node~node SUCCESS.

Checking procedure split_func$node~int... 
Procedure split_func$node~int SUCCESS.

Checking procedure merge_sort$node... 
Procedure merge_sort$node SUCCESS.
Stop Omega... 569 invocations 
2 false contexts at: ( (97,3)  (93,2) )

!!! log(small):(2.099478,2041)
Total verification time: 2.206147 second(s)
	Time spent in main process: 1.912162 second(s)
	Time spent in child processes: 0.293985 second(s)


======================================

!!!Full processing file "./hip/perfect.ss"
Parsing file "./hip/perfect.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_19


}

class int_ptr extends Object {
int valVAL_20


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_21


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node2 extends Object {
int valVAL_13;
int flagVAL_12;
node2 leftREC_11;
node2 rightREC_22


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
perfect{}[]<n> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; (((self::node2{}<Anon_14,Anon_15,l,r>@M[HeapNode1]) * (l::perfect{}<n-1>@M[HeapNode1])) * (r::perfect{}<n-1>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 95,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 94,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 93,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 92,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 91,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 90,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 89,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 88,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 80,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 79,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 77,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 76,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 75,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 74,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 72,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 71,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 70,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 69,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 68,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 67,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 66,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 65,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 64,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 63,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 62,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 61,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 60,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 59,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 58,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 55,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 54,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 53,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 52,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 51,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 49,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 48,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 46,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 45,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 44,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 43,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 42,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 41,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 40,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 39,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 38,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 37,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 36,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 35,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 34,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 33,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 32,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 31,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 30,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 29,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 28,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 27,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 26,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 25,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 24,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 23,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 22,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 21,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 20,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 19,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 18,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 17,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void insert(node2@R t, int a)[]
static EBase: [][](emp ; (emp ; (t::perfect{}<n>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 15,:(emp ; (emp ; (t'::perfect{}<n1>@M[HeapNode1])))*((n1 = n) | (n1 = n+1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: boolean si
boolean si = (96, ):simple_insert(t, a);
(97, ):if (si) { 
  (97, ):(102, ):return ;
} else { 
  (97, ):{local: int n,node2 new_tree
int n = (98, ):height(t);
node2 new_tree = (99, ):create(n);
t = new node2(a, 1, t, new_tree);
(101, ):return }
}}
}
int height(node2 t)[]
static EBase: [][](emp ; (emp ; (t::perfect{}<n>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 12,:(emp ; (emp ; (t::perfect{}<n>@M[HeapNode1])))*(res = n)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(103, ):if (t != null) { 
  (103, ):(105, ):return ((107, ):maxim((108, ):height(member access t~~>left), (110, ):height(member access t~~>right))) + 1;
} else { 
  (103, ):(104, ):return 0
}}
}
int maxim(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 10,:(emp)*(((a < b) | (res = a)) & ((a >= b) | (res = b)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(113, ):if (a >= b) { 
  (113, ):(115, ):return a;
} else { 
  (113, ):(114, ):return b
}}
}
node2 create(int n)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 6,:(emp ; (emp ; (res::perfect{}<n>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(117, ):if (n == 0) { 
  (117, ):(123, ):return null;
} else { 
  (117, ):{(118, ):return new node2(0, 0, (119, ):create(n - 1), (121, ):create(n - 1))}
}}
}
boolean simple_insert(node2 t, int a)[]
static EBase: [][](emp ; (emp ; (t::perfect{}<n>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (t::perfect{}<n>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(125, ):if (t == null) { 
  (125, ):{(141, ):return false};
} else { 
  (125, ):{(126, ):if (member access t~~>flag == 0) { 
  (126, ):{member access t~~>val = a;
member access t~~>flag = 1;
(138, ):return true};
} else { 
  (126, ):{(127, ):if ((132, ):simple_insert(member access t~~>left, a)) { 
  (127, ):(131, ):return true;
} else { 
  (127, ):(128, ):return (129, ):simple_insert(member access t~~>right, a)
}}
}}
}}
}
@@prog4


Checking procedure create$int... 
Procedure create$int SUCCESS.

Checking procedure maxim$int~int... 
Procedure maxim$int~int SUCCESS.

Checking procedure height$node2... 
Procedure height$node2 SUCCESS.

Checking procedure simple_insert$node2~int... 
Procedure simple_insert$node2~int SUCCESS.

Checking procedure insert$node2~int... 
Procedure insert$node2~int SUCCESS.
Stop Omega... 339 invocations 
0 false contexts at: ()

!!! log(small):(0.681179,1375)
Total verification time: 1.010901 second(s)
	Time spent in main process: 0.916627 second(s)
	Time spent in child processes: 0.094274 second(s)


======================================

!!!Full processing file "./hip/qsort.ss"
Parsing file "./hip/qsort.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_15


}

class int_ptr extends Object {
int valVAL_16


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_17


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_18


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
sll{}[]<n,sm,lg> == 

(None,[]): EBase: [][](emp ; (emp ; (self::node{}<qmin,null>@M[HeapNode1])))*((qmin = sm) & ((qmin = lg) & (n = 1)))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<sm,q>@M[HeapNode1]) * (q::sll{}<n-1,qs,lg>@M[HeapNode1]))))*(sm <= qs)( FLOW __flow)  inv (n >= 1) & ((sm <= lg) & (self != null)) inv_lock: None view_data_name:  view_imm_map: []
bnd{}[]<n,sm,bg> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<d,p>@M[HeapNode1]) * (p::bnd{}<n-1,sm,bg>@M[HeapNode1]))))*((sm <= d) & (d < bg))( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 102,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 101,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 100,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 99,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 98,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 97,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 96,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 95,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 94,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 93,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 92,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 91,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 87,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 86,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 84,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 83,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 82,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 81,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 79,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 78,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 77,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 76,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 75,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 74,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 73,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 72,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 71,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 70,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 69,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 68,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 67,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 66,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 65,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 64,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 63,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 62,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 61,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 60,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 58,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 57,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 56,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 55,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 54,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 53,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 52,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 51,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 50,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 49,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 48,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 47,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 46,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 45,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 44,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 43,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 42,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 41,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 40,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 39,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 38,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 37,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 36,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 35,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 34,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 33,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 32,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 31,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 30,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 29,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 28,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 27,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 26,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 25,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 24,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void qsort(node@R xs)[]
static 

(None,[]): EBase: [][](emp)*(xs = null)( FLOW __norm) {EAssume: 13,:(emp)*(xs' = null)( FLOW __norm)}
||
(None,[]): EBase: [][](emp ; (emp ; (xs::bnd{}<n,sm,bg>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 14,:(emp ; (emp ; (xs'::sll{}<n,smres,bgres>@M[HeapNode1])))*((smres >= sm) & (bgres < bg))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp,int v,boolean b
node tmp;
int v;
boolean b;
(103, ):if (xs != null) { 
  (103, ):{v = member access xs~~>val;
(106, ):bind xs to (xsval, xsnext) in
{tmp = (108, ):partition(xsnext, v)};
b = member access xs~~>next == null;
(112, ):if (tmp != null) { 
  (112, ):{(113, ):qsort(tmp)};
} else { 
  (112, ):
};
tmp = new node(v, tmp);
(116, ):if (b) { 
  (116, ):xs = tmp;
} else { 
  (116, ):{(117, ):bind xs to (xsval, xsnext) in
{(118, ):qsort(xsnext)};
xs = (120, ):append_bll(member access xs~~>next, tmp)}
}};
} else { 
  (103, ):
}}
}
node append_bll(node x, node y)[]
static 

(None,[]): EBase: [][](emp ; (emp ; (y::sll{}<m,s2,b2>@M[HeapNode1])))*(x = null)( FLOW __norm) {EAssume: 8,:(emp ; (emp ; (res::sll{}<m,s2,b2>@M[HeapNode1])))*(true)( FLOW __norm)}
||
(None,[]): EBase: [][](emp ; (emp ; ((x::sll{}<nn,s0,b0>@M[HeapNode1]) * (y::sll{}<m,s2,b2>@M[HeapNode1]))))*(b0 <= s2)( FLOW __norm) {EAssume: 9,:(emp ; (emp ; (res::sll{}<nn+m,s0,b2>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node xn
node xn;
(124, ):if (x == null) { 
  (124, ):(131, ):return y;
} else { 
  (124, ):{xn = (126, ):append_bll(member access x~~>next, y);
member access x~~>next = xn;
(130, ):return x}
}}
}
node partition(node@R xs, int c)[]
static EBase: [][](emp ; (emp ; (xs::bnd{}<n,sm,bg>@M[HeapNode1])))*((sm <= c) & (c <= bg))( FLOW __norm) {EAssume: 1,:(emp ; (emp ; ((xs'::bnd{}<a,sm,c>@M[HeapNode1]) * (res::bnd{}<b,c,bg>@M[HeapNode1]))))*(n = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp1,int v
node tmp1;
int v;
(133, ):if (xs == null) { 
  (133, ):(149, ):return null;
} else { 
  (133, ):{(134, ):if (member access xs~~>val >= c) { 
  (134, ):{v = member access xs~~>val;
(141, ):bind xs to (xsval, xsnext) in
{tmp1 = (143, ):partition(xsnext, c)};
xs = member access xs~~>next;
(146, ):return new node(v, tmp1)};
} else { 
  (134, ):{(135, ):bind xs to (xsval, xsnext) in
{tmp1 = (137, ):partition(xsnext, c)};
(138, ):return tmp1}
}}
}}
}
@@prog4


WARNING: ./hip/qsort.ss_66:10_66:18:the result type __norm#E is not covered by the throw list[]

Checking procedure append_bll$node~node... 
Procedure append_bll$node~node SUCCESS.

Checking procedure partition$node~int... 
Procedure partition$node~int SUCCESS.

Checking procedure qsort$node... 
Procedure qsort$node SUCCESS.

Termination checking result: SUCCESS

Stop Omega... 651 invocations 
29 false contexts at: ( (74,1)  (94,8)  (94,19)  (94,3)  (91,4)  (89,2)  (87,8)  (87,3)  (85,8)  (85,2)  (81,2)  (83,3)  (82,6)  (81,6)  (80,13)  (80,13)  (80,8)  (78,9)  (78,3)  (76,12)  (76,8)  (75,1)  (55,21)  (59,9)  (58,9)  (57,14)  (57,25)  (57,9)  (56,13) )

!!! log(small):(2.678854,2288)
Total verification time: 2.528599 second(s)
	Time spent in main process: 2.28164 second(s)
	Time spent in child processes: 0.246959 second(s)


======================================

!!!Full processing file "./hip/selection.ss"
Parsing file "./hip/selection.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_16


}

class int_ptr extends Object {
int valVAL_17


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_18


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_19


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
sll{}[]<n,sm,lg> == 

(None,[]): EBase: [][](emp ; (emp ; (self::node{}<sm,null>@M[HeapNode1])))*((sm = lg) & (n = 1))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<sm,q>@M[HeapNode1]) * (q::sll{}<n-1,qs,lg>@M[HeapNode1]))))*((q != null) & (sm <= qs))( FLOW __flow)  inv (n >= 1) & ((sm <= lg) & (self != null)) inv_lock: None view_data_name:  view_imm_map: []
bnd1{}[]<n,sm,bg,mi> == 

(None,[]): EBase: [][](emp ; (emp ; (self::node{}<mi,null>@M[HeapNode1])))*(((sm <= mi) & (mi < bg)) & (n = 1))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<d,p>@M[HeapNode1]) * (p::bnd1{}<n-1,sm,bg,tmi>@M[HeapNode1]))))*(((sm <= d) & (d < bg)) & ((mi = min(d,tmi)) & ((sm <= mi) & (mi < bg))))( FLOW __flow)  inv (n >= 1) & (((sm <= mi) & (mi < bg)) & (self != null)) inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 86,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 85,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 84,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 75,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 74,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 72,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 71,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 70,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 69,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 67,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 66,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 65,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 64,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 63,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 62,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 61,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 60,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 59,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 57,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 56,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 54,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 52,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 51,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 49,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 48,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 46,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 45,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 41,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 40,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 39,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 38,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 37,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 36,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 35,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 34,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 33,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 32,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 31,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 30,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 29,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 28,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 27,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 26,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 25,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 24,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 23,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 22,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 21,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 20,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 19,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 18,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 17,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 16,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 15,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 14,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 13,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 12,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

node selection_sort(node@R x)[]
static EBase: [][](emp ; (emp ; (x::bnd1{}<n,sm,lg,mi>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 8,:(emp ; (emp ; (res::sll{}<n,mi,l>@M[HeapNode1])))*((l < lg) & (x' = null))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int minimum,node tmp,node tmp_null
int minimum;
node tmp, tmp_null = null;
minimum = (92, ):find_min(x);
(93, ):delete_min(x, minimum);
(94, ):if (x == null) { 
  (94, ):(98, ):return new node(minimum, tmp_null);
} else { 
  (94, ):{tmp = (96, ):selection_sort(x);
(97, ):return new node(minimum, tmp)}
}}
}
void delete_min(node@R x, int a)[]
static EBase: [][](emp ; (emp ; (x::bnd1{}<n,s,l,mi>@M[HeapNode1])))*((n >= 1) & (a = mi))( FLOW __norm) {EAssume: 5,:(emp)*((x' = null) & ((n = 1) & ((s <= mi) & (mi < l))))( FLOW __norm)
or(emp ; (emp ; (x'::bnd1{}<n-1,s,l,mi1>@M[HeapNode1])))*((mi1 >= mi) & ((x' != null) & (n > 1)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(100, ):if (member access x~~>val == a) { 
  (100, ):x = member access x~~>next;
} else { 
  (100, ):{(101, ):bind x to (Anon_12, xnext) in
{(102, ):delete_min(xnext, a)}}
}}
}
int find_min(node x)[]
static EBase: [][](emp ; (emp ; (x::bnd1{}<n,s,l,mi>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (x::bnd1{}<n,s,l,mi>@M[HeapNode1])))*(res = mi)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int tmp
int tmp;
(107, ):if (member access x~~>next == null) { 
  (107, ):(117, ):return member access x~~>val;
} else { 
  (107, ):{tmp = (109, ):find_min(member access x~~>next);
(111, ):if (tmp > member access x~~>val) { 
  (111, ):(113, ):return member access x~~>val;
} else { 
  (111, ):(112, ):return tmp
}}
}}
}
@@prog4


WARNING: ./hip/selection.ss_37:9_37:40:the result type __norm#E is not covered by the throw list[]

Checking procedure delete_min$node~int... 
Procedure delete_min$node~int SUCCESS.

Checking procedure find_min$node... 
Procedure find_min$node SUCCESS.

Checking procedure selection_sort$node... 
Procedure selection_sort$node SUCCESS.
Stop Omega... 434 invocations 
0 false contexts at: ()

!!! log(small):(1.309261,1346)
Total verification time: 1.428349 second(s)
	Time spent in main process: 1.291017 second(s)
	Time spent in child processes: 0.137332 second(s)


======================================

!!!Full processing file "./hip/sll.ss"
Parsing file "./hip/sll.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_19


}

class int_ptr extends Object {
int valVAL_20


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_21


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_22


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
sll{}[]<n,sm,lg> == 

(None,[]): EBase: [][](emp)*((self = null) & ((n = 0) & (sm <= lg)))( FLOW __flow) 
||
(None,[]): EBase: [][](EX qs ql . (emp ; (emp ; ((self::node{}<qmin,q>@M[HeapNode1]) * (q::sll{}<n-1,qs,ql>@M[HeapNode1]))))*((qmin <= qs) & ((ql <= lg) & (sm <= qmin)))( FLOW __flow))  inv (n >= 0) & (sm <= lg) inv_lock: None view_data_name:  view_imm_map: []
ll{}[]<n> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<Anon_12,q>@M[HeapNode1]) * (q::ll{}<n-1>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 102,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 101,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 100,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 99,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 98,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 97,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 96,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 95,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 94,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 93,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 92,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 91,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 87,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 86,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 84,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 83,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 82,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 81,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 79,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 78,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 77,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 76,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 75,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 74,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 73,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 72,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 71,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 70,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 69,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 68,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 67,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 66,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 65,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 64,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 63,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 62,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 61,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 60,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 58,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 57,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 56,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 55,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 54,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 53,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 52,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 51,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 50,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 49,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 48,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 47,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 46,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 45,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 44,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 43,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 42,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 41,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 40,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 39,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 38,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 37,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 36,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 35,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 34,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 33,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 32,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 31,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 30,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 29,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 28,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 27,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 26,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 25,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 24,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void id(int x)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 22,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int n
int n = 1;
n++;
(105, ):id(n)}
}
void insertion_sort(node x, node@R y)[]
static EBase: [][](emp ; (emp ; ((x::ll{}<n>@M[HeapNode1]) * (y::sll{}<m1,ys1,yl1>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 19,:(emp ; (emp ; ((y'::sll{}<n+m1,Anon_14,Anon_15>@M[HeapNode1]) * (x::ll{}<n>@M[HeapNode1]))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(106, ):if (x != null) { 
  (106, ):{y = (108, ):insert(y, member access x~~>val);
(110, ):insertion_sort(member access x~~>next, y)};
} else { 
  (106, ):
}}
}
node get_tail(node x)[]
static EBase: [][](emp ; (emp ; (x::sll{}<n,xs,xl>@M[HeapNode1])))*(x != null)( FLOW __norm) {EAssume: 18,:(emp ; (emp ; (res::sll{}<n-1,sres,lres>@M[HeapNode1])))*((sres >= xs) & (lres <= xl))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(113, ):return member access x~~>next}
}
node delete(node x, int v)[]
static EBase: [][](emp ; (emp ; (x::sll{}<n,xs,xl>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 12,:(emp ; (emp ; (res::sll{}<nres,sres,lres>@M[HeapNode1])))*((sres >= xs) & ((lres <= xl) & (((n-1) <= nres) & (nres <= n))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
(115, ):if (x != null) { 
  (115, ):(117, ):if (v < member access x~~>val) { 
  (117, ):(129, ):return x;
} else { 
  (117, ):(118, ):if (v == member access x~~>val) { 
  (118, ):(125, ):return member access x~~>next;
} else { 
  (118, ):{tmp = member access x~~>next;
member access x~~>next = (122, ):delete(tmp, v);
(124, ):return x}
}
};
} else { 
  (115, ):(116, ):return null
}}
}
node insert2(node x, node vn)[]
static EBase: [][](emp ; (emp ; ((x::sll{}<n,sm,lg>@M[HeapNode1]) * (vn::node{}<v,Anon_13>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 6,:(emp ; (emp ; (res::sll{}<n+1,mi,ma>@M[HeapNode1])))*((mi = min(v,sm)) & (ma = max(v,lg)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(133, ):if (x == null) { 
  (133, ):{member access vn~~>next = null;
(148, ):return vn};
} else { 
  (133, ):(134, ):if (member access vn~~>val <= member access x~~>val) { 
  (134, ):{member access vn~~>next = x;
(142, ):return vn};
} else { 
  (134, ):{member access x~~>next = (136, ):insert2(member access x~~>next, vn);
(139, ):return x}
}
}}
}
node insert(node x, int v)[]
static EBase: [][](emp ; (emp ; (x::sll{}<n,sm,lg>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (res::sll{}<n+1,mi,ma>@M[HeapNode1])))*((mi = min(v,sm)) & (ma = max(v,lg)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
(150, ):if (x == null) { 
  (150, ):(161, ):return new node(v, null);
} else { 
  (150, ):{(151, ):if (v <= member access x~~>val) { 
  (151, ):(158, ):return new node(v, x);
} else { 
  (151, ):{tmp = member access x~~>next;
member access x~~>next = (155, ):insert(tmp, v);
(157, ):return x}
}}
}}
}
@@prog4


Checking procedure delete$node~int... 
Procedure delete$node~int SUCCESS.

Checking procedure get_tail$node... 
Procedure get_tail$node SUCCESS.

Checking procedure id$int... 
Procedure id$int SUCCESS.

Checking procedure insert$node~int... 
Procedure insert$node~int SUCCESS.

Checking procedure insert2$node~node... 
Procedure insert2$node~node SUCCESS.

Checking procedure insertion_sort$node~node... 
Procedure insertion_sort$node~node SUCCESS.
Stop Omega... 539 invocations 
0 false contexts at: ()

!!! log(small):(1.652645,1943)
Total verification time: 1.648641 second(s)
	Time spent in main process: 1.500819 second(s)
	Time spent in child processes: 0.147822 second(s)


======================================

!!!Full processing file "./hip/trees.ss"
Parsing file "./hip/trees.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_25


}

class int_ptr extends Object {
int valVAL_26


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_27


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node2 extends Object {
int valVAL_13;
node2 leftREC_12;
node2 rightREC_28


}

class node extends Object {
int valVAL_11;
node nextREC_29


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
bst{}[]<sm,lg> == 

(None,[]): EBase: [][](emp)*((self = null) & (sm <= lg))( FLOW __flow) 
||
(None,[]): EBase: [][](EX pl qs . (emp ; (emp ; (((self::node2{}<v,p,q>@M[HeapNode1]) * (p::bst{}<sm,pl>@M[HeapNode1])) * (q::bst{}<qs,lg>@M[HeapNode1]))))*((pl <= v) & (qs >= v))( FLOW __flow))  inv sm <= lg inv_lock: None view_data_name:  view_imm_map: []
dll{}[]<p,n> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node2{}<Anon_16,p,q>@M[HeapNode1]) * (q::dll{}<self,n1>@M[HeapNode1]))))*(n = n1+1)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []
tree{}[]<m,n> == 

(None,[]): EBase: [][](emp)*((self = null) & ((m = 0) & (n = 0)))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; (((self::node2{}<Anon_15,p,q>@M[HeapNode1]) * (p::tree{}<m1,n1>@M[HeapNode1])) * (q::tree{}<m2,n2>@M[HeapNode1]))))*((m = (1+m1)+m2) & (n = 1+max(n1,n2)))( FLOW __flow)  inv (m >= 0) & (n >= 0) inv_lock: None view_data_name:  view_imm_map: []
tree1{}[]<m> == 

(None,[]): EBase: [][](emp)*((self = null) & (m = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; (((self::node2{}<Anon_14,p,q>@M[HeapNode1]) * (p::tree1{}<m1>@M[HeapNode1])) * (q::tree1{}<m2>@M[HeapNode1]))))*(m = (1+m1)+m2)( FLOW __flow)  inv m >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 118,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 117,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 116,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 115,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 114,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 113,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 112,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 111,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 110,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 109,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 108,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 107,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 106,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 105,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 104,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 103,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 102,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 101,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 100,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 99,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 98,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 97,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 96,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 95,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 94,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 93,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 92,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 91,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 90,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 89,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 88,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 87,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 86,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 85,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 84,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 83,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 82,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 81,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 80,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 79,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 69,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 68,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 67,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 66,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 65,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 64,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 63,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 62,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 61,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 60,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 59,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 58,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 57,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 56,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 55,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 54,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 53,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 52,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 51,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 50,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 49,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 48,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 47,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 46,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 45,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 44,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 43,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete(node2@R x, int a)[]
static EBase: [][](emp ; (emp ; (x::bst{}<sm,lg>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 31,:(emp ; (emp ; (x'::bst{}<s,l>@M[HeapNode1])))*((sm <= s) & (l <= lg))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int tmp
int tmp;
(119, ):if (x != null) { 
  (119, ):{(120, ):bind x to (xval, xleft, xright) in
{(121, ):if (xval == a) { 
  (121, ):{(126, ):if (xright == null) { 
  (126, ):{ :assert_inexact EBase: [][](emp)*(true)( FLOW __norm) 
 assume: 
;
x = xleft};
} else { 
  (126, ):{tmp = (128, ):remove_min(xright);
xval = tmp}
}};
} else { 
  (121, ):{(122, ):if (xval < a) { 
  (122, ):(124, ):delete(xright, a);
} else { 
  (122, ):(123, ):delete(xleft, a)
}}
}}};
} else { 
  (119, ):
}}
}
int remove_min(node2@R x)[]
static EBase: [][](emp ; (emp ; (x::bst{}<s,b>@M[HeapNode1])))*(x != null)( FLOW __norm) {EAssume: 26,:(emp ; (emp ; (x'::bst{}<s1,b>@M[HeapNode1])))*((s <= res) & (res <= s1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int tmp,int a
int tmp, a;
(135, ):if (member access x~~>left == null) { 
  (135, ):{tmp = member access x~~>val;
x = member access x~~>right;
(144, ):return tmp};
} else { 
  (135, ):{local: int tmp_24
int tmp_24;
(136, ):bind x to (Anon_19, xleft, Anon_20) in
{tmp_24 = (138, ):remove_min(xleft)};
(139, ):return tmp_24}
}}
}
node2 insert(node2 x, int a)[]
static EBase: [][](emp ; (emp ; (x::bst{}<sm,lg>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 20,:(emp ; (emp ; (res::bst{}<mi,ma>@M[HeapNode1])))*((res != null) & ((mi = min(sm,a)) & (ma = max(lg,a))))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 tmp,node2 tmp_null
node2 tmp;
node2 tmp_null = null;
(147, ):if (x == null) { 
  (147, ):(161, ):return new node2(a, null, null);
} else { 
  (147, ):{(148, ):if (a <= member access x~~>val) { 
  (148, ):{tmp = member access x~~>left;
member access x~~>left = (156, ):insert(tmp, a)};
} else { 
  (148, ):{member access x~~>right = (150, ):insert(member access x~~>right, a)}
};
(160, ):return x}
}}
}
void flatten(node2 x)[]
static EBase: [][](emp ; (emp ; (x::tree{}<m,n>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 13,:(EX q . (emp ; (emp ; (x::dll{}<q,m>@M[HeapNode1])))*(q = null)( FLOW __norm))}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 tmp
node2 tmp;
(163, ):if (x != null) { 
  (163, ):{(164, ):flatten(member access x~~>left);
(166, ):flatten(member access x~~>right);
tmp = (169, ):append(member access x~~>left, member access x~~>right);
member access x~~>left = null;
member access x~~>right = tmp;
(176, ):if (tmp != null) { 
  (176, ):member access tmp~~>left = x;
} else { 
  (176, ):
}};
} else { 
  (163, ):
}}
}
int count(node2 z)[]
static EBase: [][](emp ; (emp ; (z::tree1{}<m>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 7,:(emp ; (emp ; (z::tree1{}<m>@M[HeapNode1])))*((res = m) & (res >= 0))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int cleft,int cright
int cleft, cright;
(181, ):if (z == null) { 
  (181, ):(191, ):return 0;
} else { 
  (181, ):{cleft = (183, ):count(member access z~~>left);
cright = (186, ):count(member access z~~>right);
(188, ):return (1 + cleft) + cright}
}}
}
node2 append(node2 x, node2 y)[]
static EBase: [][](emp ; (emp ; ((x::dll{}<Anon_17,m>@M[HeapNode1]) * (y::dll{}<Anon_18,n>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (res::dll{}<r,m+n>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 z
node2 z;
(193, ):if (x == null) { 
  (193, ):(204, ):return y;
} else { 
  (193, ):{z = (195, ):append(member access x~~>right, y);
member access x~~>right = z;
(199, ):if (z != null) { 
  (199, ):member access z~~>left = x;
} else { 
  (199, ):
};
(203, ):return x}
}}
}
@@prog4


Checking procedure append$node2~node2... 
Procedure append$node2~node2 SUCCESS.

Checking procedure count$node2... 
Procedure count$node2 SUCCESS.

Checking procedure remove_min$node2... 
Procedure remove_min$node2 SUCCESS.

Checking procedure delete$node2~int... 
assert:./hip/trees.ss:276: 20:  : ok


Procedure delete$node2~int SUCCESS.

Checking procedure flatten$node2... 
Procedure flatten$node2 SUCCESS.

Checking procedure insert$node2~int... 
Procedure insert$node2~int SUCCESS.
Stop Omega... 624 invocations 
0 false contexts at: ()

!!! log(small):(2.549758,3224)
Total verification time: 2.387672 second(s)
	Time spent in main process: 2.201944 second(s)
	Time spent in child processes: 0.185728 second(s)


======================================

!!!Full processing file "./hip/rb.ss"
Parsing file "./hip/rb.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_26


}

class int_ptr extends Object {
int valVAL_27


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_28


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_13;
int colorVAL_12;
node leftREC_11;
node rightREC_29


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
rb{}[]<n,cl,bh> == 

(None,[]): 

(None,[]): EBase: [][](emp)*((self = null) & ((n = 0) & ((bh = 1) & (cl = 0))))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; (((self::node{}<v,1,l,r>@M[HeapNode1]) * (l::rb{}<nl,0,bhl>@M[HeapNode1])) * (r::rb{}<nr,0,bhr>@M[HeapNode1]))))*((cl = 1) & ((n = (1+nl)+nr) & ((bhl = bh) & (bhr = bh))))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; (((self::node{}<v,0,l,r>@M[HeapNode1]) * (l::rb{}<nl,Anon_14,bhl>@M[HeapNode1])) * (r::rb{}<nr,Anon_15,bhr>@M[HeapNode1]))))*((cl = 0) & ((n = (1+nl)+nr) & ((bhl = bhr) & (bh = 1+bhl))))( FLOW __flow)  inv (n >= 0) & ((bh >= 1) & ((0 <= cl) & (cl <= 1))) inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 194,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 193,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 192,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 191,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 190,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 189,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 188,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 187,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 186,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 185,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 184,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 183,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 182,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 181,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 180,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 179,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 178,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 177,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 176,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 175,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 174,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 173,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 172,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 171,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 170,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 169,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 168,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 167,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 166,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 165,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 164,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 163,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 162,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 161,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 160,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 159,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 158,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 157,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 156,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 155,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 154,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 153,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 152,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 151,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 150,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 149,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 148,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 147,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 146,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 145,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 144,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 143,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 142,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 141,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 140,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 139,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 138,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 137,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 136,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 135,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 134,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 133,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 132,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 131,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 130,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 129,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 128,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 127,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 126,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 125,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 124,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 123,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 122,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 121,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 120,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 119,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 118,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 117,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 116,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

node insert(node x, int v)[]
static EBase: [][](emp ; (emp ; (x::rb{}<n,Anon_21,bh>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 95,:(emp ; (emp ; (res::rb{}<n+1,Anon_22,bh1>@M[HeapNode1])))*((res != null) & ((bh <= bh1) & (bh1 <= bh)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp,node tmp_null
node tmp, tmp_null = null;
(195, ):if (x == null) { 
  (195, ):(303, ):return new node(v, 1, tmp_null, tmp_null);
} else { 
  (195, ):{(196, ):if (v <= member access x~~>val) { 
  (196, ):{tmp = member access x~~>left;
member access x~~>left = (252, ):insert(tmp, v);
(254, ):if (member access x~~>color == 0) { 
  (254, ):{(257, ):if ((297, ):is_red(member access x~~>left)) { 
  (257, ):{(260, ):if ((295, ):is_red(member access x~~>left~~>left)) { 
  (260, ):{(281, ):if ((293, ):is_red(member access x~~>right)) { 
  (281, ):{member access x~~>left~~>color = 0;
member access x~~>right~~>color = 0;
(292, ):return x};
} else { 
  (281, ):{x = (283, ):rotate_case_3(member access x~~>left~~>left, member access x~~>left~~>right, member access x~~>right);
(287, ):return x}
}};
} else { 
  (260, ):{(261, ):if ((279, ):is_red(member access x~~>left~~>right)) { 
  (261, ):{(264, ):if ((277, ):is_red(member access x~~>right)) { 
  (264, ):{member access x~~>left~~>color = 0;
member access x~~>right~~>color = 0;
(276, ):return x};
} else { 
  (264, ):{x = (266, ):case_2(member access x~~>left~~>left, member access x~~>left~~>right~~>left, member access x~~>left~~>right~~>right, member access x~~>right);
(271, ):return x}
}};
} else { 
  (261, ):(262, ):return (263, ):node_error()
}}
}};
} else { 
  (257, ):(258, ):return (259, ):node_error()
}};
} else { 
  (254, ):(255, ):return (256, ):node_error()
}};
} else { 
  (196, ):{tmp = member access x~~>right;
member access x~~>right = (200, ):insert(tmp, v);
(202, ):if (member access x~~>color == 0) { 
  (202, ):{(205, ):if ((245, ):is_red(member access x~~>right)) { 
  (205, ):{(208, ):if ((243, ):is_red(member access x~~>right~~>left)) { 
  (208, ):(228, ):if ((241, ):is_red(member access x~~>left)) { 
  (228, ):{member access x~~>left~~>color = 0;
member access x~~>right~~>color = 0;
(240, ):return x};
} else { 
  (228, ):{x = (230, ):case_2r(member access x~~>left, member access x~~>right~~>left~~>left, member access x~~>right~~>left~~>right, member access x~~>right~~>right);
(235, ):return x}
};
} else { 
  (208, ):{(209, ):if ((226, ):is_red(member access x~~>right~~>right)) { 
  (209, ):(212, ):if ((224, ):is_red(member access x~~>left)) { 
  (212, ):{member access x~~>left~~>color = 0;
member access x~~>right~~>color = 0;
(223, ):return x};
} else { 
  (212, ):{x = (214, ):rotate_case_3r(member access x~~>left, member access x~~>right~~>left, member access x~~>right~~>right);
(218, ):return x}
};
} else { 
  (209, ):(210, ):return (211, ):node_error()
}}
}};
} else { 
  (205, ):(206, ):return (207, ):node_error()
}};
} else { 
  (202, ):(203, ):return (204, ):node_error()
}}
}}
}}
}
node node_error()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 94,:(hfalse)*(false)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void del(node@R x, int a)[]
static EBase: [][](emp ; (emp ; (x::rb{}<n,cl,bh>@M[HeapNode1])))*((0 <= cl) & (cl <= 1))( FLOW __norm) {EAssume: 60,:(emp ; (emp ; (x'::rb{}<n-1,cl2,bh>@M[HeapNode1])))*((cl = 1) & ((0 <= cl2) & (cl2 <= 1)))( FLOW __norm)
or(emp ; (emp ; (x'::rb{}<n-1,0,bh2>@M[HeapNode1])))*((((bh-1) <= bh2) & (bh2 <= h)) & (cl = 0))( FLOW __norm)
or(emp ; (emp ; (x'::rb{}<n,cl,bh>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int v
int v;
 :assert_inexact EBase: [][](hfalse)*(false)( FLOW __norm) 
 assume: 
;
(306, ):if (x != null) { 
  (306, ):{ :assert_inexact EBase: [][](hfalse)*(false)( FLOW __norm) 
 assume: 
;
(308, ):if (member access x~~>val == a) { 
  (308, ):{(420, ):if (member access x~~>right == null) { 
  (420, ):{(476, ):if ((479, ):is_red(member access x~~>left)) { 
  (476, ):member access x~~>left~~>color = 0;
} else { 
  (476, ):
};
x = member access x~~>left};
} else { 
  (420, ):{v = (422, ):remove_min(member access x~~>right);
(424, ):if (((474, ):bh(member access x~~>right)) < ((472, ):bh(member access x~~>left))) { 
  (424, ):{(425, ):if ((469, ):is_black(member access x~~>right)) { 
  (425, ):{(426, ):if ((467, ):is_red(member access x~~>left)) { 
  (426, ):{(459, ):if (member access x~~>left~~>right != null) { 
  (459, ):x = (461, ):del_2r(member access x~~>left~~>left, member access x~~>left~~>right, member access x~~>right);
} else { 
  (459, ):
}};
} else { 
  (426, ):{(427, ):if ((457, ):is_black(member access x~~>left~~>left)) { 
  (427, ):(434, ):if ((455, ):is_black(member access x~~>left~~>right)) { 
  (434, ):(442, ):if (member access x~~>color == 0) { 
  (442, ):x = (449, ):del_3r(member access x~~>left~~>left, member access x~~>left~~>right, member access x~~>right);
} else { 
  (442, ):x = (444, ):del_4r(member access x~~>left~~>left, member access x~~>left~~>right, member access x~~>right)
};
} else { 
  (434, ):x = (436, ):del_5r(member access x~~>left~~>left, member access x~~>left~~>right~~>left, member access x~~>left~~>right~~>right, member access x~~>right, member access x~~>color)
};
} else { 
  (427, ):x = (429, ):del_6r(member access x~~>left~~>left, member access x~~>left~~>right, member access x~~>right, member access x~~>color)
}}
}};
} else { 
  (425, ):
}};
} else { 
  (424, ):
}}
}};
} else { 
  (308, ):{(309, ):if (member access x~~>val < a) { 
  (309, ):{(364, ):del(member access x~~>right, a);
(366, ):if (((416, ):bh(member access x~~>right)) < ((414, ):bh(member access x~~>left))) { 
  (366, ):{(367, ):if ((411, ):is_black(member access x~~>right)) { 
  (367, ):(368, ):if ((409, ):is_red(member access x~~>left)) { 
  (368, ):{(401, ):if (member access x~~>left~~>right != null) { 
  (401, ):x = (403, ):del_2r(member access x~~>left~~>left, member access x~~>left~~>right, member access x~~>right);
} else { 
  (401, ):
}};
} else { 
  (368, ):{(369, ):if ((399, ):is_black(member access x~~>left~~>left)) { 
  (369, ):(376, ):if ((397, ):is_black(member access x~~>left~~>right)) { 
  (376, ):(384, ):if (member access x~~>color == 0) { 
  (384, ):x = (391, ):del_3r(member access x~~>left~~>left, member access x~~>left~~>right, member access x~~>right);
} else { 
  (384, ):x = (386, ):del_4r(member access x~~>left~~>left, member access x~~>left~~>right, member access x~~>right)
};
} else { 
  (376, ):x = (378, ):del_5r(member access x~~>left~~>left, member access x~~>left~~>right~~>left, member access x~~>left~~>right~~>right, member access x~~>right, member access x~~>color)
};
} else { 
  (369, ):x = (371, ):del_6r(member access x~~>left~~>left, member access x~~>left~~>right, member access x~~>right, member access x~~>color)
}}
};
} else { 
  (367, ):
}};
} else { 
  (366, ):
}};
} else { 
  (309, ):{(310, ):del(member access x~~>left, a);
(312, ):if (((362, ):bh(member access x~~>left)) < ((360, ):bh(member access x~~>right))) { 
  (312, ):{(313, ):if ((357, ):is_black(member access x~~>left)) { 
  (313, ):(314, ):if ((355, ):is_red(member access x~~>right)) { 
  (314, ):{(347, ):if (member access x~~>right~~>left != null) { 
  (347, ):x = (349, ):del_2(member access x~~>left, member access x~~>right~~>left, member access x~~>right~~>right);
} else { 
  (347, ):
}};
} else { 
  (314, ):{(315, ):if ((345, ):is_black(member access x~~>right~~>right)) { 
  (315, ):(322, ):if ((343, ):is_black(member access x~~>right~~>left)) { 
  (322, ):{(330, ):if (member access x~~>color == 0) { 
  (330, ):x = (337, ):del_3(member access x~~>left, member access x~~>right~~>left, member access x~~>right~~>right);
} else { 
  (330, ):x = (332, ):del_4(member access x~~>left, member access x~~>right~~>left, member access x~~>right~~>right)
}};
} else { 
  (322, ):x = (324, ):del_5(member access x~~>left, member access x~~>right~~>left~~>left, member access x~~>right~~>left~~>right, member access x~~>right~~>right, member access x~~>color)
};
} else { 
  (315, ):x = (317, ):del_6(member access x~~>left, member access x~~>right~~>left, member access x~~>right~~>right, member access x~~>color)
}}
};
} else { 
  (313, ):
}};
} else { 
  (312, ):
}}
}}
}};
} else { 
  (306, ):
}}
}
int remove_min(node@R x)[]
static EBase: [][](emp ; (emp ; (x::rb{}<n,cl,bh>@M[HeapNode1])))*((x != null) & ((0 <= cl) & (cl <= 1)))( FLOW __norm) {EAssume: 47,:(emp ; (emp ; (x'::rb{}<n-1,cl2,bh>@M[HeapNode1])))*((cl = 1) & ((0 <= cl2) & (cl2 <= 1)))( FLOW __norm)
or(emp ; (emp ; (x'::rb{}<n-1,0,bh2>@M[HeapNode1])))*((((bh-1) <= bh2) & (bh2 <= bh)) & (cl = 0))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int v1
int v1;
(488, ):if (member access x~~>left == null) { 
  (488, ):{local: int tmp
int tmp = member access x~~>val;
(553, ):if ((556, ):is_red(member access x~~>right)) { 
  (553, ):member access x~~>right~~>color = 0;
} else { 
  (553, ):
};
x = member access x~~>right;
(560, ):return tmp};
} else { 
  (488, ):{v1 = (490, ):remove_min(member access x~~>left);
(492, ):if (((550, ):bh(member access x~~>left)) < ((548, ):bh(member access x~~>right))) { 
  (492, ):{(494, ):if ((545, ):is_black(member access x~~>left)) { 
  (494, ):{(496, ):if ((543, ):is_red(member access x~~>right)) { 
  (496, ):{(533, ):if (member access x~~>right~~>left != null) { 
  (533, ):{x = (536, ):del_2(member access x~~>left, member access x~~>right~~>left, member access x~~>right~~>right);
(540, ):return v1};
} else { 
  (533, ):(534, ):return v1
}};
} else { 
  (496, ):{(497, ):if ((531, ):is_black(member access x~~>right~~>right)) { 
  (497, ):{(505, ):if ((529, ):is_black(member access x~~>right~~>left)) { 
  (505, ):(514, ):if (member access x~~>color == 0) { 
  (514, ):{x = (522, ):del_3(member access x~~>left, member access x~~>right~~>left, member access x~~>right~~>right);
(526, ):return v1};
} else { 
  (514, ):{x = (516, ):del_4(member access x~~>left, member access x~~>right~~>left, member access x~~>right~~>right);
(520, ):return v1}
};
} else { 
  (505, ):{x = (507, ):del_5(member access x~~>left, member access x~~>right~~>left~~>left, member access x~~>right~~>left~~>right, member access x~~>right~~>right, member access x~~>color);
(513, ):return v1}
}};
} else { 
  (497, ):{x = (499, ):del_6(member access x~~>left, member access x~~>right~~>left, member access x~~>right~~>right, member access x~~>color);
(504, ):return v1}
}}
}};
} else { 
  (494, ):(495, ):return v1
}};
} else { 
  (492, ):(493, ):return v1
}}
}}
}
int bh(node x)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 46,:(hfalse)*(false)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

node del_2r(node a, node b, node c)[]
static EBase: [][](emp ; (emp ; (((a::rb{}<na,0,h+1>@M[HeapNode1]) * (b::rb{}<nb,0,h+1>@M[HeapNode1])) * (c::rb{}<nc,0,h>@M[HeapNode1]))))*(b != null)( FLOW __norm) {EAssume: 38,:(emp ; (emp ; (res::rb{}<((na+nb)+nc)+2,0,h+2>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp,node f
node tmp, f;
(563, ):if ((580, ):is_black(member access b~~>left)) { 
  (563, ):{(568, ):if ((578, ):is_black(member access b~~>right)) { 
  (568, ):tmp = (575, ):del_4r(member access b~~>left, member access b~~>right, c);
} else { 
  (568, ):tmp = (570, ):del_5r(member access b~~>left, member access b~~>right~~>left, member access b~~>right~~>right, c, 1)
}};
} else { 
  (563, ):tmp = (565, ):del_6r(member access b~~>left, member access b~~>right, c, 1)
};
 :assert_inexact EBase: [][](emp ; (emp ; (tmp'::rb{}<(nb+nc)+1,Anon_20,ha>@M[HeapNode1])))*(h = ha)( FLOW __norm) 
 assume: 
;
 :assert_inexact EBase: [][](emp ; (emp ; (a'::rb{}<n_1,0,hb>@M[HeapNode1])))*((hb = h) & (n_1 = nb))( FLOW __norm) 
 assume: 
;
 :assert_inexact EBase: [][](emp ; (emp ; (a'::rb{}<n_2,0,hc>@M[HeapNode1])))*((hc = h+1) & (n_2 = na))( FLOW __norm) 
 assume: 
;
f = new node(0, 0, a, tmp);
(586, ):return f}
}
node del_2(node a, node b, node c)[]
static EBase: [][](emp ; (emp ; (((a::rb{}<na,0,h>@M[HeapNode1]) * (b::rb{}<nb,0,h+1>@M[HeapNode1])) * (c::rb{}<nc,0,h+1>@M[HeapNode1]))))*((b != null) & (c != null))( FLOW __norm) {EAssume: 34,:(emp ; (emp ; (res::rb{}<((na+nb)+nc)+2,0,h+2>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
(587, ):if ((604, ):is_black(member access b~~>right)) { 
  (587, ):{(592, ):if ((602, ):is_black(member access b~~>left)) { 
  (592, ):tmp = (599, ):del_4(a, member access b~~>left, member access b~~>right);
} else { 
  (592, ):tmp = (594, ):del_5(a, member access b~~>left~~>left, member access b~~>left~~>right, member access b~~>right, 1)
}};
} else { 
  (587, ):tmp = (589, ):del_6(a, member access b~~>left, member access b~~>right, 1)
};
(606, ):return new node(0, 0, tmp, c)}
}
node del_3r(node a, node b, node c)[]
static EBase: [][](emp ; (emp ; (((a::rb{}<na,0,ha>@M[HeapNode1]) * (b::rb{}<nb,0,ha>@M[HeapNode1])) * (c::rb{}<nc,0,ha>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 32,:(emp ; (emp ; (res::rb{}<((na+nb)+nc)+2,0,ha+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
tmp = new node(0, 1, a, b);
(608, ):return new node(0, 0, tmp, c)}
}
node del_3(node a, node b, node c)[]
static EBase: [][](emp ; (emp ; (((a::rb{}<na,0,ha>@M[HeapNode1]) * (b::rb{}<nb,0,ha>@M[HeapNode1])) * (c::rb{}<nc,0,ha>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 30,:(emp ; (emp ; (res::rb{}<((na+nb)+nc)+2,0,ha+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
tmp = new node(0, 1, b, c);
(610, ):return new node(0, 0, a, tmp)}
}
node del_4r(node a, node b, node c)[]
static EBase: [][](emp ; (emp ; (((a::rb{}<na,0,ha>@M[HeapNode1]) * (b::rb{}<nb,0,ha>@M[HeapNode1])) * (c::rb{}<nc,0,ha>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 28,:(emp ; (emp ; (res::rb{}<((na+nb)+nc)+2,0,ha+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
tmp = new node(0, 1, a, b);
(612, ):return new node(0, 0, tmp, c)}
}
node del_4(node a, node b, node c)[]
static EBase: [][](emp ; (emp ; (((a::rb{}<na,0,ha>@M[HeapNode1]) * (b::rb{}<nb,0,ha>@M[HeapNode1])) * (c::rb{}<nc,0,ha>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 25,:(emp ; (emp ; (res::rb{}<((na+nb)+nc)+2,0,ha+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp1,node tmp2
node tmp1, tmp2;
tmp1 = new node(0, 1, b, c);
tmp2 = new node(0, 0, a, tmp1);
(615, ):return tmp2}
}
node del_5r(node a, node b, node c, node d, int color)[]
static EBase: [][](emp ; (emp ; ((((a::rb{}<na,0,h>@M[HeapNode1]) * (b::rb{}<nb,0,h>@M[HeapNode1])) * (c::rb{}<nc,0,h>@M[HeapNode1])) * (d::rb{}<nd,0,h>@M[HeapNode1]))))*(color = 0)( FLOW __norm)
or(emp ; (emp ; ((((a::rb{}<na,0,h>@M[HeapNode1]) * (b::rb{}<nb,0,h>@M[HeapNode1])) * (c::rb{}<nc,0,h>@M[HeapNode1])) * (d::rb{}<nd,0,h>@M[HeapNode1]))))*(color = 1)( FLOW __norm) {EAssume: 23,:(emp ; (emp ; (res::rb{}<(((na+nb)+nc)+nd)+3,0,h+2>@M[HeapNode1])))*(color = 0)( FLOW __norm)
or(emp ; (emp ; (res::rb{}<(((na+nb)+nc)+nd)+3,1,h+1>@M[HeapNode1])))*(color = 1)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
tmp = new node(0, 1, a, b);
(617, ):return (618, ):del_6r(tmp, c, d, color)}
}
node del_5(node a, node b, node c, node d, int color)[]
static EBase: [][](emp ; (emp ; ((((a::rb{}<na,0,h>@M[HeapNode1]) * (b::rb{}<nb,0,h>@M[HeapNode1])) * (c::rb{}<nc,0,h>@M[HeapNode1])) * (d::rb{}<nd,0,h>@M[HeapNode1]))))*(color = 0)( FLOW __norm)
or(emp ; (emp ; ((((a::rb{}<na,0,h>@M[HeapNode1]) * (b::rb{}<nb,0,h>@M[HeapNode1])) * (c::rb{}<nc,0,h>@M[HeapNode1])) * (d::rb{}<nd,0,h>@M[HeapNode1]))))*(color = 1)( FLOW __norm) {EAssume: 21,:(emp ; (emp ; (res::rb{}<(((na+nb)+nc)+nd)+3,0,h+2>@M[HeapNode1])))*(color = 0)( FLOW __norm)
or(emp ; (emp ; (res::rb{}<(((na+nb)+nc)+nd)+3,1,h+1>@M[HeapNode1])))*(color = 1)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
tmp = new node(0, 1, c, d);
(620, ):return (621, ):del_6(a, b, tmp, color)}
}
node del_6r(node a, node b, node c, int color)[]
static EBase: [][](emp ; (emp ; (((a::rb{}<na,1,ha>@M[HeapNode1]) * (b::rb{}<nb,Anon_18,ha>@M[HeapNode1])) * (c::rb{}<nc,0,ha>@M[HeapNode1]))))*(color = 0)( FLOW __norm)
or(emp ; (emp ; (((a::rb{}<na,1,ha>@M[HeapNode1]) * (b::rb{}<nb,Anon_19,ha>@M[HeapNode1])) * (c::rb{}<nc,0,ha>@M[HeapNode1]))))*(color = 1)( FLOW __norm) {EAssume: 18,:(emp ; (emp ; (res::rb{}<((na+nb)+nc)+2,0,ha+2>@M[HeapNode1])))*(color = 0)( FLOW __norm)
or(emp ; (emp ; (res::rb{}<((na+nb)+nc)+2,1,ha+1>@M[HeapNode1])))*(color = 1)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
member access a~~>color = 0;
tmp = new node(0, 0, b, c);
(625, ):return new node(0, color, a, tmp)}
}
node del_6(node a, node b, node c, int color)[]
static EBase: [][](emp ; (emp ; (((a::rb{}<na,0,h>@M[HeapNode1]) * (b::rb{}<nb,Anon_16,h>@M[HeapNode1])) * (c::rb{}<nc,1,h>@M[HeapNode1]))))*(color = 0)( FLOW __norm)
or(emp ; (emp ; (((a::rb{}<na,0,h>@M[HeapNode1]) * (b::rb{}<nb,Anon_17,h>@M[HeapNode1])) * (c::rb{}<nc,1,h>@M[HeapNode1]))))*(color = 1)( FLOW __norm) {EAssume: 15,:(emp ; (emp ; (res::rb{}<((na+nb)+nc)+2,0,h+2>@M[HeapNode1])))*(color = 0)( FLOW __norm)
or(emp ; (emp ; (res::rb{}<((na+nb)+nc)+2,1,h+1>@M[HeapNode1])))*(color = 1)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
member access c~~>color = 0;
tmp = new node(0, 0, a, b);
(629, ):return new node(0, color, tmp, c)}
}
boolean is_black(node x)[]
static EBase: [][](emp ; (emp ; (x::rb{}<n,cl,bh>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 12,:(emp ; (emp ; (x::rb{}<n,cl,bh>@M[HeapNode1])))*((cl = 1) & (!(res)))( FLOW __norm)
or(emp ; (emp ; (x::rb{}<n,cl,bh>@M[HeapNode1])))*((cl = 0) & (res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(630, ):if (x == null) { 
  (630, ):(636, ):return true;
} else { 
  (630, ):(631, ):if (member access x~~>color == 0) { 
  (631, ):(633, ):return true;
} else { 
  (631, ):(632, ):return false
}
}}
}
boolean is_red(node x)[]
static EBase: [][](emp ; (emp ; (x::rb{}<n,cl,bh>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 9,:(emp ; (emp ; (x::rb{}<n,cl,bh>@M[HeapNode1])))*((cl = 1) & (res))( FLOW __norm)
or(emp ; (emp ; (x::rb{}<n,cl,bh>@M[HeapNode1])))*((cl = 0) & (!(res)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(638, ):if (x == null) { 
  (638, ):(644, ):return false;
} else { 
  (638, ):(639, ):if (member access x~~>color == 0) { 
  (639, ):(641, ):return false;
} else { 
  (639, ):(640, ):return true
}
}}
}
node case_2r(node a, node b, node c, node d)[]
static EBase: [][](emp ; (emp ; ((((a::rb{}<na,0,bha>@M[HeapNode1]) * (b::rb{}<nb,0,bha>@M[HeapNode1])) * (c::rb{}<nc,0,bha>@M[HeapNode1])) * (d::rb{}<nd,0,bha>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 7,:(emp ; (emp ; (res::rb{}<(((na+nb)+nc)+nd)+3,0,bha+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
tmp = new node(0, 1, c, d);
(647, ):return (648, ):rotate_case_3r(a, b, tmp)}
}
node rotate_case_3r(node a, node b, node c)[]
static EBase: [][](emp ; (emp ; (((a::rb{}<na,0,bha>@M[HeapNode1]) * (b::rb{}<nb,0,bha>@M[HeapNode1])) * (c::rb{}<nc,1,bha>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 5,:(emp ; (emp ; (res::rb{}<((na+nb)+nc)+2,0,bha+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
tmp = new node(0, 1, a, b);
(650, ):return new node(0, 0, tmp, c)}
}
node case_2(node a, node b, node c, node d)[]
static EBase: [][](emp ; (emp ; ((((a::rb{}<na,0,bha>@M[HeapNode1]) * (b::rb{}<nb,0,bha>@M[HeapNode1])) * (c::rb{}<nc,0,bha>@M[HeapNode1])) * (d::rb{}<nd,0,bha>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 3,:(emp ; (emp ; (res::rb{}<(((na+nb)+nc)+nd)+3,0,bha+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
tmp = new node(0, 1, a, b);
(652, ):return (653, ):rotate_case_3(tmp, c, d)}
}
node rotate_case_3(node a, node b, node c)[]
static EBase: [][](emp ; (emp ; (((a::rb{}<na,1,bha>@M[HeapNode1]) * (b::rb{}<nb,0,bha>@M[HeapNode1])) * (c::rb{}<nc,0,bha>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (res::rb{}<((na+nb)+nc)+2,0,bha+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp;
tmp = new node(0, 1, b, c);
(655, ):return new node(0, 0, a, tmp)}
}
@@prog4


Checking procedure rotate_case_3$node~node~node... 
Procedure rotate_case_3$node~node~node SUCCESS.

Checking procedure case_2$node~node~node~node... 
Procedure case_2$node~node~node~node SUCCESS.

Checking procedure rotate_case_3r$node~node~node... 
Procedure rotate_case_3r$node~node~node SUCCESS.

Checking procedure case_2r$node~node~node~node... 
Procedure case_2r$node~node~node~node SUCCESS.

Checking procedure del_4$node~node~node... 
Procedure del_4$node~node~node SUCCESS.

Checking procedure del_6$node~node~node~int... 
Procedure del_6$node~node~node~int SUCCESS.

Checking procedure del_5$node~node~node~node~int... 
Procedure del_5$node~node~node~node~int SUCCESS.

Checking procedure is_black$node... 
Procedure is_black$node SUCCESS.

Checking procedure del_2$node~node~node... 
Procedure del_2$node~node~node SUCCESS.

Checking procedure del_4r$node~node~node... 
Procedure del_4r$node~node~node SUCCESS.

Checking procedure del_6r$node~node~node~int... 
Procedure del_6r$node~node~node~int SUCCESS.

Checking procedure del_5r$node~node~node~node~int... 
Procedure del_5r$node~node~node~node~int SUCCESS.

Checking procedure del_2r$node~node~node... 
assert/assume:./hip/rb.ss:277: 1:  : failed


assert/assume:./hip/rb.ss:278: 1:  : failed


assert:./hip/rb.ss:279: 1:  : ok


Procedure del_2r$node~node~node SUCCESS.

Checking procedure del_3$node~node~node... 
Procedure del_3$node~node~node SUCCESS.

Checking procedure del_3r$node~node~node... 
Procedure del_3r$node~node~node SUCCESS.

Checking procedure is_red$node... 
Procedure is_red$node SUCCESS.

Checking procedure remove_min$node... 
Procedure remove_min$node SUCCESS.

Checking procedure del$node~int... 
assert/assume:./hip/rb.ss:395: 4:  : failed


assert/assume:./hip/rb.ss:396: 9:  : failed


Procedure del$node~int SUCCESS.

Checking procedure insert$node~int... 
Procedure insert$node~int SUCCESS.
Stop Omega... 2513 invocations 
294 false contexts at: ( (633,4)  (630,5)  (626,7)  (623,8)  (622,12)  (622,49)  (622,35)  (622,27)  (622,8)  (621,7)  (618,8)  (617,24)  (617,8)  (616,23)  (616,8)  (615,7)  (614,18)  (614,11)  (614,7)  (609,7)  (608,11)  (608,66)  (608,46)  (608,27)  (608,19)  (608,7)  (607,6)  (604,7)  (603,23)  (603,7)  (602,22)  (602,7)  (601,6)  (600,17)  (600,10)  (600,6)  (587,4)  (584,5)  (580,7)  (576,8)  (575,12)  (575,71)  (575,51)  (575,32)  (575,19)  (575,8)  (574,7)  (571,8)  (570,24)  (570,8)  (569,23)  (569,8)  (568,7)  (567,18)  (567,11)  (566,6)  (560,7)  (559,11)  (559,52)  (559,38)  (559,25)  (559,7)  (558,6)  (555,7)  (554,23)  (554,7)  (553,22)  (553,7)  (552,6)  (551,17)  (551,10)  (550,5)  (472,4)  (474,5)  (494,12)  (494,55)  (494,40)  (494,26)  (494,18)  (494,8)  (491,13)  (491,81)  (491,66)  (491,46)  (491,27)  (491,19)  (491,9)  (488,14)  (488,42)  (488,28)  (488,20)  (488,10)  (486,14)  (486,42)  (486,28)  (486,20)  (486,10)  (485,24)  (485,13)  (485,13)  (484,8)  (483,21)  (483,12)  (483,8)  (482,20)  (482,11)  (481,6)  (477,7)  (478,12)  (478,40)  (478,26)  (478,18)  (478,8)  (477,11)  (477,11)  (476,6)  (475,17)  (475,10)  (475,6)  (474,18)  (474,9)  (473,4)  (472,8)  (472,24)  (472,21)  (443,4)  (445,5)  (463,12)  (463,55)  (463,46)  (463,32)  (463,19)  (463,8)  (461,13)  (461,81)  (461,72)  (461,52)  (461,33)  (461,20)  (461,9)  (459,14)  (459,48)  (459,34)  (459,21)  (459,10)  (457,14)  (457,48)  (457,34)  (457,21)  (457,10)  (456,24)  (456,13)  (456,13)  (456,9)  (455,21)  (455,12)  (455,8)  (454,20)  (454,11)  (453,6)  (448,7)  (449,12)  (449,46)  (449,32)  (449,19)  (449,8)  (448,11)  (448,11)  (447,6)  (446,17)  (446,10)  (446,6)  (445,18)  (445,9)  (444,4)  (443,8)  (443,25)  (443,22)  (409,4)  (411,5)  (429,12)  (429,55)  (429,46)  (429,32)  (429,19)  (429,8)  (427,13)  (427,81)  (427,72)  (427,52)  (427,33)  (427,20)  (427,9)  (425,14)  (425,48)  (425,34)  (425,21)  (425,10)  (423,14)  (423,48)  (423,34)  (423,21)  (423,10)  (422,24)  (422,13)  (422,13)  (422,9)  (421,21)  (421,12)  (421,8)  (420,20)  (420,11)  (419,6)  (415,7)  (416,12)  (416,46)  (416,32)  (416,19)  (416,8)  (415,11)  (415,11)  (414,6)  (413,17)  (413,10)  (412,5)  (411,18)  (411,9)  (410,4)  (409,8)  (409,25)  (409,22)  (372,3)  (369,4)  (363,6)  (362,10)  (362,53)  (362,38)  (362,24)  (362,16)  (362,6)  (361,5)  (357,7)  (356,11)  (356,79)  (356,64)  (356,44)  (356,25)  (356,17)  (356,7)  (355,6)  (352,8)  (351,12)  (351,40)  (351,26)  (351,18)  (351,8)  (350,7)  (347,8)  (346,12)  (346,40)  (346,26)  (346,18)  (346,8)  (345,7)  (344,22)  (344,11)  (344,11)  (344,7)  (343,19)  (343,10)  (342,5)  (341,18)  (341,9)  (340,4)  (337,6)  (334,48)  (333,10)  (333,38)  (333,24)  (333,16)  (333,6)  (332,40)  (331,9)  (331,9)  (330,4)  (329,15)  (329,8)  (328,3)  (327,16)  (327,7)  (326,2)  (325,6)  (325,22)  (325,19) )

!!! log(small):(48.693252,42591)
!!! log(big)(>0.5s)(11):(7.893117,[(sleek-hec,0.648537);(sleek-hec,0.651899);(sleek-hec,0.689891);(sleek-hec,1.10898);(sleek-hec,0.651686);(sleek-hec,0.65509);(sleek-hec,0.69331);(sleek-hec,1.078743);(sleek-hec,0.550099);(sleek-hec,0.576587);(sleek-hec,0.588295)])
Total verification time: 32.049136 second(s)
	Time spent in main process: 31.084201 second(s)
	Time spent in child processes: 0.964935 second(s)


======================================

!!!Full processing file "./hip/global1.ss"
Parsing file "./hip/global1.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_16


}

class int_ptr extends Object {
int valVAL_17


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_18


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

global int n
global int k

WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 80,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 79,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 69,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 68,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 66,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 65,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 64,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 63,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 62,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 60,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 59,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 57,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 56,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 55,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 54,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 53,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 52,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 51,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 50,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 48,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 47,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 45,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 35,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 34,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 33,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 29,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 28,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 27,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 26,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 25,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 24,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 22,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 21,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 20,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 16,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 15,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 14,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 13,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 9,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 8,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 7,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 6,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void increase(int@R n_15, int@R k_14)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 1,:(emp)*((k_14' = k_14+1) & (n_15' = n_15+1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{k_14 = k_14 + 1;
n_15 = n_15 + 1}
}
@@prog4


WARNING: ./hip/global1.ss_7:9_7:24:the result type __norm#E is not covered by the throw list[]

Checking procedure increase$int~int... 
Procedure increase$int~int SUCCESS.
Stop Omega... 44 invocations 
0 false contexts at: ()

!!! log(small):(0.02098,203)
Total verification time: 0.339383 second(s)
	Time spent in main process: 0.319647 second(s)
	Time spent in child processes: 0.019736 second(s)


======================================

!!!Full processing file "./hip/global2.ss"
Parsing file "./hip/global2.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_16


}

class int_ptr extends Object {
int valVAL_17


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_18


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

global int n
global int k

WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 78,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 65,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 64,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 63,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 62,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 61,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 60,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 59,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 57,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 56,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 55,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 54,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 53,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 52,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 51,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 50,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 49,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 48,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 47,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 46,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 45,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 43,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 33,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 32,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 30,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 29,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 27,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 26,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 25,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 24,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 23,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 22,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 21,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 20,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 19,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 17,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 16,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 14,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 13,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 11,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 10,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 8,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 6,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void increase(int@R n_15, int@R k_14)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 1,:(emp)*(k_14' = k_14+n_15)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{k_14 = k_14 + n_15}
}
@@prog4


WARNING: ./hip/global2.ss_7:9_7:15:the result type __norm#E is not covered by the throw list[]

Checking procedure increase$int~int... 
Procedure increase$int~int SUCCESS.
Stop Omega... 43 invocations 
0 false contexts at: ()

!!! log(small):(0.018961,190)
Total verification time: 0.377726 second(s)
	Time spent in main process: 0.358528 second(s)
	Time spent in child processes: 0.019198 second(s)


======================================

!!!Full processing file "./hip/global3.ss"
Parsing file "./hip/global3.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_18


}

class int_ptr extends Object {
int valVAL_19


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_20


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

global int n
global int k

WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 83,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 82,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 72,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 71,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 69,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 68,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 67,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 66,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 65,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 64,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 63,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 62,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 59,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 58,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 53,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 52,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 51,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 50,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 46,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 45,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 38,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 37,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 36,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 35,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 34,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 33,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 32,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 31,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 30,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 29,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 28,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 27,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 26,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 25,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 24,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 23,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 22,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 21,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 20,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 19,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 18,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 17,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 16,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 15,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 14,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 13,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 12,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 11,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 10,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 9,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void increase_n(int k_14, int@R n_15)[]
static EBase: [][](emp)*(k_14 > 0)( FLOW __norm) {EAssume: 6,:(emp)*(n_15' = k_14+n_15)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{n_15 = n_15 + k_14}
}
void increase(int@R n_17, int@R k_16)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 1,:(emp)*((k_16' = k_16+1) & (n_17' = n_17+1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{k_16 = k_16 + 1;
n_17 = n_17 + 1}
}
@@prog4


WARNING: ./hip/global3.ss_16:9_16:15:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/global3.ss_7:9_7:24:the result type __norm#E is not covered by the throw list[]

Checking procedure increase$int~int... 
Procedure increase$int~int SUCCESS.

Checking procedure increase_n$int~int... 
Procedure increase_n$int~int SUCCESS.
Stop Omega... 47 invocations 
0 false contexts at: ()

!!! log(small):(0.023328,213)
Total verification time: 0.348348 second(s)
	Time spent in main process: 0.328312 second(s)
	Time spent in child processes: 0.020036 second(s)


======================================

!!!Full processing file "./hip/global4.ss"
Parsing file "./hip/global4.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_17


}

class int_ptr extends Object {
int valVAL_18


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_19


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

global int t
global int n

WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 81,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 80,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 79,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 70,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 69,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 67,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 66,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 65,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 64,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 63,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 62,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 59,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 58,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 51,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 50,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 49,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 48,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 45,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 36,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 35,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 34,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 33,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 32,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 30,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 29,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 28,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 27,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 26,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 25,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 24,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 23,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 22,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 21,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 20,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 19,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 17,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 16,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 15,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 14,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 13,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 11,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 9,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 8,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 7,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void main(int@R t_15, int@R n_14)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*((t_15' = 2) & (n_14' = 3))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{n_14 = 1;
t_15 = 2;
(88, ):increase_n(t_15, n_14)}
}
void increase_n(int k, int@R n_16)[]
static EBase: [][](emp)*(k > 0)( FLOW __norm) {EAssume: 1,:(emp)*(n_16' = k+n_16)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{n_16 = n_16 + k}
}
@@prog4


WARNING: ./hip/global4.ss_15:9_15:20:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/global4.ss_7:9_7:15:the result type __norm#E is not covered by the throw list[]

Checking procedure increase_n$int~int... 
Procedure increase_n$int~int SUCCESS.

Checking procedure main$int~int... 
Procedure main$int~int SUCCESS.
Stop Omega... 51 invocations 
0 false contexts at: ()

!!! log(small):(0.023109,210)
Total verification time: 0.344184 second(s)
	Time spent in main process: 0.323196 second(s)
	Time spent in child processes: 0.020988 second(s)


======================================

!!!Full processing file "./hip/global5.ss"
Parsing file "./hip/global5.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_17


}

class int_ptr extends Object {
int valVAL_18


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_19


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

global int n, k

WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 79,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 78,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 68,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 66,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 65,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 64,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 63,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 62,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 61,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 60,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 59,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 58,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 49,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 48,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 34,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 33,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 32,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 31,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 29,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 28,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 27,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 26,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 25,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 24,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 23,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 22,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 20,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 19,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 18,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 16,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 15,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 14,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 13,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 12,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 10,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 9,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 8,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 7,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 6,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void decrease(int@R k_14)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(k_14' = k_14-1)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{k_14--}
}
void increase(int@R k_local_1, int@R n_16, int@R k_15)[]
static EBase: [][](emp)*(k_local_1 > 0)( FLOW __norm) {EAssume: 1,:(emp)*(k_local_1' = n_16)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{k_local_1 = n_16;
(87, ):decrease(k_15)}
}
@@prog4


WARNING: ./hip/global5.ss_14:11_14:19:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/global5.ss_6:11_6:17:the result type __norm#E is not covered by the throw list[]

Checking procedure decrease$int... 
Procedure decrease$int SUCCESS.

Checking procedure increase$int~int~int... 
Procedure increase$int~int~int SUCCESS.
Stop Omega... 49 invocations 
0 false contexts at: ()

!!! log(small):(0.022243,206)
Total verification time: 0.344821 second(s)
	Time spent in main process: 0.324059 second(s)
	Time spent in child processes: 0.020762 second(s)


======================================

!!!Full processing file "./hip/global-ll.ss"
Parsing file "./hip/global-ll.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_22


}

class int_ptr extends Object {
int valVAL_23


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_24


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_25


}

global node p
global int n

WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
ll{}[]<n> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<Anon_12,q>@M[HeapNode1]) * (q::ll{}<n1>@M[HeapNode1]))))*(n = n1+1)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 94,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 93,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 92,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 91,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 90,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 89,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 88,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 87,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 79,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 78,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 76,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 75,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 74,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 73,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 71,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 70,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 69,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 68,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 67,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 66,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 65,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 64,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 63,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 62,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 61,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 60,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 59,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 58,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 57,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 56,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 55,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 54,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 53,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 52,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 51,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 49,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 48,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 46,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 45,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 44,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 43,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 42,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 41,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 40,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 39,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 38,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 37,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 36,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 35,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 34,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 33,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 30,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 27,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 26,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 25,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 24,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 23,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 22,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 21,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 20,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 19,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 18,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 17,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 16,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void main(node@R p_17, int@R n_16)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 13,:(emp ; (emp ; (p_17'::ll{}<n_16'>@M[HeapNode1])))*(n_16' = 3)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{p_17 = new node(5, null);
n_16 = 1;
(97, ):insert(4, p_17, n_16);
(98, ):insert(3, p_17, n_16);
(99, ):insert(2, p_17, n_16);
(100, ):insert(1, p_17, n_16);
(101, ):delete_last(p_17, n_16);
(102, ):delete_last(p_17, n_16)}
}
void delete_last(node@R p_19, int@R n_18)[]
static EBase: [][](emp ; (emp ; (p_19::ll{}<n_18>@M[HeapNode1])))*(n_18 > 1)( FLOW __norm) {EAssume: 10,:(emp ; (emp ; (p_19'::ll{}<n_18'>@M[HeapNode1])))*((n_18 = n_18'+1) & (p_19 = p_19'))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(103, ):delete_last_rec(p_19);
n_18 = n_18 - 1}
}
void insert(int a, node@R p_21, int@R n_20)[]
static EBase: [][](emp ; (emp ; (p_21::ll{}<n_20>@M[HeapNode1])))*(n_20 > 0)( FLOW __norm) {EAssume: 7,:(emp ; (emp ; (p_21'::ll{}<n_20'>@M[HeapNode1])))*((n_20' = n_20+1) & (p_21 = p_21'))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(106, ):insert_rec(p_21, a);
n_20 = n_20 + 1}
}
void delete_last_rec(node x)[]
static EBase: [][](emp ; (emp ; (x::ll{}<n1>@M[HeapNode1])))*(n1 > 1)( FLOW __norm) {EAssume: 4,:(emp ; (emp ; (x::ll{}<n1-1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(109, ):if (member access x~~>next~~>next == null) { 
  (109, ):member access x~~>next = member access x~~>next~~>next;
} else { 
  (109, ):{(110, ):delete_last_rec(member access x~~>next)}
}}
}
void insert_rec(node x, int a)[]
static EBase: [][](emp ; (emp ; (x::ll{}<n1>@M[HeapNode1])))*(n1 > 0)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (x::ll{}<n1+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp
node tmp = null;
(117, ):if (member access x~~>next == null) { 
  (117, ):member access x~~>next = new node(a, tmp);
} else { 
  (117, ):(118, ):insert_rec(member access x~~>next, a)
}}
}
@@prog4


Checking procedure delete_last_rec$node... 
Procedure delete_last_rec$node SUCCESS.

Checking procedure delete_last$node~int... 
Procedure delete_last$node~int SUCCESS.

Checking procedure insert_rec$node~int... 
Procedure insert_rec$node~int SUCCESS.

Checking procedure insert$int~node~int... 
Procedure insert$int~node~int SUCCESS.

Checking procedure main$node~int... 
Procedure main$node~int SUCCESS.
Stop Omega... 323 invocations 
0 false contexts at: ()

!!! log(small):(0.736948,1113)
Total verification time: 0.998081 second(s)
	Time spent in main process: 0.874287 second(s)
	Time spent in child processes: 0.123794 second(s)


======================================

!!!Full processing file "./hip/global-mutual-rec.ss"
Parsing file "./hip/global-mutual-rec.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_20


}

class int_ptr extends Object {
int valVAL_21


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_22


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

global int n, k

WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 92,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 91,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 88,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 87,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 86,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 85,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 74,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 73,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 72,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 71,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 69,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 68,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 67,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 66,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 65,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 64,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 63,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 62,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 61,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 60,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 59,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 58,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 57,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 56,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 54,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 53,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 52,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 51,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 49,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 48,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 46,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 45,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 43,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 42,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 41,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 40,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 39,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 38,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 36,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 35,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 34,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 33,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 31,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 30,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 29,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 28,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 27,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 26,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 25,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 24,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 23,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 22,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 21,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 20,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 19,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 18,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 17,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 16,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 15,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 14,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void main(int@R n_15, int@R k_14)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 11,:(emp)*((n_15' = 5) & (k_14' = 5))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int t
n_15 = 10;
int t = 5;
k_14 = 10;
(95, ):decrease1(10, n_15, k_14)}
}
void decrease2(int t, int@R n_17, int@R k_16)[]
static 

(None,[]): EBase: [][ a](emp)*((t = a+a) & (a >= 0))( FLOW __norm) {EAssume: 6,:(emp)*((k_16' = k_16-a) & ((n_17' = n_17-a) & (t = a+a)))( FLOW __norm)}
||
(None,[]): EBase: [][ a](emp)*((t = (a+a)+1) & (a >= 0))( FLOW __norm) {EAssume: 7,:(emp)*((k_16' = (k_16-a)-1) & ((n_17' = n_17-a) & (t = (a+a)+1)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(96, ):if (t > 0) { 
  (96, ):{k_16--;
(99, ):decrease1(t - 1, n_17, k_16)};
} else { 
  (96, ):
}}
}
void decrease1(int t, int@R n_19, int@R k_18)[]
static 

(None,[]): EBase: [][ a](emp)*((t = a+a) & (a >= 0))( FLOW __norm) {EAssume: 1,:(emp)*((n_19' = n_19-a) & ((k_18' = k_18-a) & (t = a+a)))( FLOW __norm)}
||
(None,[]): EBase: [][ a](emp)*((t = (a+a)+1) & (a >= 0))( FLOW __norm) {EAssume: 2,:(emp)*((n_19' = (n_19-a)-1) & ((k_18' = k_18-a) & (t = (a+a)+1)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(102, ):if (t > 0) { 
  (102, ):{n_19--;
(105, ):decrease2(t - 1, n_19, k_18)};
} else { 
  (102, ):
}}
}
@@prog4


WARNING: ./hip/global-mutual-rec.ss_38:11_38:26:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/global-mutual-rec.ss_26:11_26:38:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/global-mutual-rec.ss_28:11_28:42:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/global-mutual-rec.ss_5:11_5:38:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/global-mutual-rec.ss_7:11_7:42:the result type __norm#E is not covered by the throw list[]

Checking procedure decrease2$int~int~int... 
Procedure decrease2$int~int~int SUCCESS.

Checking procedure decrease1$int~int~int... 
Procedure decrease1$int~int~int SUCCESS.

!!! SHAPE inferred spec: EList :EBase exists (Expl)[a](Impl)[](ex)[]emp&(([t=a+a & 0<=a]))&
              {FLOW,(4,5)=__norm#E}[]
                EBase emp&MayLoop[]&{FLOW,(4,5)=__norm#E}[]
                        EAssume ref [n_17;k_16]
                          emp&(([a+k_16'=k_16 & t=a+a & a+n_17'=n_17]))&
                          {FLOW,(4,5)=__norm#E}[]
                          || :EBase exists (Expl)[a](Impl)[](ex)[]emp&(
                                    ([t=1+a+a & 0<=a]))&
                                    {FLOW,(4,5)=__norm#E}[]
                                      EBase emp&MayLoop[]&
                                            {FLOW,(4,5)=__norm#E}[]
                                              EAssume ref [n_17;k_16]
                                                emp&(
                                                ([1+a+k_16'=k_16 & t=1+a+a & 
                                                   a+n_17'=n_17]
                                                 ))&
                                                {FLOW,(4,5)=__norm#E}[]
                                                
!!! SHAPE inferred spec: EList :EBase exists (Expl)[a](Impl)[](ex)[]emp&(([t=a+a & 0<=a]))&
              {FLOW,(4,5)=__norm#E}[]
                EBase emp&MayLoop[]&{FLOW,(4,5)=__norm#E}[]
                        EAssume ref [n_19;k_18]
                          emp&(([a+n_19'=n_19 & t=a+a & a+k_18'=k_18]))&
                          {FLOW,(4,5)=__norm#E}[]
                          || :EBase exists (Expl)[a](Impl)[](ex)[]emp&(
                                    ([t=1+a+a & 0<=a]))&
                                    {FLOW,(4,5)=__norm#E}[]
                                      EBase emp&MayLoop[]&
                                            {FLOW,(4,5)=__norm#E}[]
                                              EAssume ref [n_19;k_18]
                                                emp&(
                                                ([1+a+n_19'=n_19 & t=1+a+a & 
                                                   a+k_18'=k_18]
                                                 ))&
                                                {FLOW,(4,5)=__norm#E}[]
                                                
Checking procedure main$int~int... 
Procedure main$int~int SUCCESS.
Stop Omega... 124 invocations 
2 false contexts at: ( (9,3)  (30,3) )

!!! log(small):(0.116726,549)
Total verification time: 0.560445 second(s)
	Time spent in main process: 0.527004 second(s)
	Time spent in child processes: 0.033441 second(s)


======================================

!!!Full processing file "./hip/classic/classic1.ss"
Parsing file "./hip/classic/classic1.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_19


}

class int_ptr extends Object {
int valVAL_20


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_21


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_22


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 65,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 63,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 62,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 43,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 42,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 33,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 27,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 26,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 25,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 24,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 22,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 20,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 16,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 14,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 13,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 8,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 6,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int foo2(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_14,Anon_15>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 2,:(emp ; (emp ; htrue))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(82, ):return member access x~~>val}
}
int foo1(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_12,Anon_13>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(84, ):return member access x~~>val}
}
@@prog4


WARNING: ./hip/classic/classic1.ss_15:10_15:15:the result type __norm#E is not covered by the throw list[]

Checking procedure foo1$node... 
Procedure foo1$node SUCCESS.

Checking procedure foo2$node... 
Procedure foo2$node SUCCESS.
Stop Omega... 44 invocations 
0 false contexts at: ()

!!! log(small):(0.022569,204)
Total verification time: 0.341272 second(s)
	Time spent in main process: 0.32184 second(s)
	Time spent in child processes: 0.019432 second(s)


======================================

!!!Full processing file "./hip/classic/classic1.ss"
Parsing file "./hip/classic/classic1.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_19


}

class int_ptr extends Object {
int valVAL_20


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_21


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_22


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 65,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 63,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 62,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 43,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 42,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 33,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 27,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 26,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 25,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 24,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 22,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 20,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 16,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 14,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 13,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 8,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 6,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int foo2(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_14,Anon_15>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 2,:(emp ; (emp ; htrue))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(82, ):return member access x~~>val}
}
int foo1(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_12,Anon_13>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(84, ):return member access x~~>val}
}
@@prog4


WARNING: ./hip/classic/classic1.ss_15:10_15:15:the result type __norm#E is not covered by the throw list[]

Checking procedure foo1$node... 
( []) ::0: 0: Postcondition cannot be derived from context


(Cause of PostCond Failure)::0: 0:  List of Partial Context: [PC(1, 0)]
Failed States:
[
 Label: []
 State:
        fe_kind: MUST
        fe_name: 
        fe_locs: {
                  fc_message: classical separation logic
                  fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]
 ]
Successful States:
[]

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/classic/classic1.ss",Line:10,Col:9

ERROR: at _0:0_0:0 
Message: Post condition cannot be derived by the system.
 
Procedure foo1$node FAIL.(2)

Exception Failure("Post condition cannot be derived by the system.") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure foo1$node

Checking procedure foo2$node... 
Procedure foo2$node SUCCESS.
Stop Omega... 44 invocations 
0 false contexts at: ()

!!! log(small):(0.022248,202)
Total verification time: 0.342031 second(s)
	Time spent in main process: 0.322373 second(s)
	Time spent in child processes: 0.019658 second(s)


======================================

!!!Full processing file "./hip/classic/classic1a.ss"
Parsing file "./hip/classic/classic1a.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_19


}

class int_ptr extends Object {
int valVAL_20


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_21


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_22


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 65,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 63,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 62,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 43,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 42,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 33,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 27,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 26,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 25,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 24,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 22,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 20,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 16,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 14,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 13,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 8,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 6,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int foo1(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_14,Anon_15>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 2,:(emp ; (emp ; htrue))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(82, ):return member access x~~>val}
}
int foo2(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_12,Anon_13>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(84, ):return member access x~~>val}
}
@@prog4


WARNING: ./hip/classic/classic1a.ss_15:10_15:15:the result type __norm#E is not covered by the throw list[]

Checking procedure foo1$node... 
Procedure foo1$node SUCCESS.

Checking procedure foo2$node... 
Procedure foo2$node SUCCESS.
Stop Omega... 44 invocations 
0 false contexts at: ()

!!! log(small):(0.022855,204)
Total verification time: 0.357917 second(s)
	Time spent in main process: 0.321216 second(s)
	Time spent in child processes: 0.036701 second(s)


======================================

!!!Full processing file "./hip/classic/classic1a.ss"
Parsing file "./hip/classic/classic1a.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_19


}

class int_ptr extends Object {
int valVAL_20


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_21


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_22


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 65,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 63,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 62,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 43,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 42,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 33,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 27,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 26,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 25,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 24,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 22,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 20,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 16,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 14,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 13,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 8,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 6,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int foo1(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_14,Anon_15>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 2,:(emp ; (emp ; htrue))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(82, ):return member access x~~>val}
}
int foo2(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_12,Anon_13>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(84, ):return member access x~~>val}
}
@@prog4


WARNING: ./hip/classic/classic1a.ss_15:10_15:15:the result type __norm#E is not covered by the throw list[]

Checking procedure foo1$node... 
Procedure foo1$node SUCCESS.

Checking procedure foo2$node... 
( []) ::0: 0: Postcondition cannot be derived from context


(Cause of PostCond Failure)::0: 0:  List of Partial Context: [PC(1, 0)]
Failed States:
[
 Label: []
 State:
        fe_kind: MUST
        fe_name: 
        fe_locs: {
                  fc_message: classical separation logic
                  fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]
 ]
Successful States:
[]

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/classic/classic1a.ss",Line:10,Col:9

ERROR: at _0:0_0:0 
Message: Post condition cannot be derived by the system.
 
Procedure foo2$node FAIL.(2)

Exception Failure("Post condition cannot be derived by the system.") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure foo2$node
Stop Omega... 44 invocations 
0 false contexts at: ()

!!! log(small):(0.022595,202)
Total verification time: 0.339826 second(s)
	Time spent in main process: 0.320262 second(s)
	Time spent in child processes: 0.019564 second(s)


======================================

!!!Full processing file "./hip/classic/classic2.ss"
Parsing file "./hip/classic/classic2.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_19


}

class int_ptr extends Object {
int valVAL_20


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_21


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_22


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 65,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 63,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 62,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 43,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 42,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 33,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 27,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 26,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 25,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 24,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 22,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 20,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 16,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 14,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 13,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 8,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 6,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int foo2(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_14,Anon_15>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume_exact: 2,:(emp ; (emp ; htrue))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(82, ):return member access x~~>val}
}
int foo1(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_12,Anon_13>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume_exact: 1,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(84, ):return member access x~~>val}
}
@@prog4


WARNING: ./hip/classic/classic2.ss_15:16_15:21:the result type __norm#E is not covered by the throw list[]

Checking procedure foo1$node... 
( []) ::0: 0: Postcondition cannot be derived from context


(Cause of PostCond Failure)::0: 0:  List of Partial Context: [PC(1, 0)]
Failed States:
[
 Label: []
 State:
        fe_kind: MUST
        fe_name: 
        fe_locs: {
                  fc_message: classical separation logic
                  fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]
 ]
Successful States:
[]

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/classic/classic2.ss",Line:10,Col:9

ERROR: at _0:0_0:0 
Message: Post condition cannot be derived by the system.
 
Procedure foo1$node FAIL.(2)

Exception Failure("Post condition cannot be derived by the system.") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure foo1$node

Checking procedure foo2$node... 
Procedure foo2$node SUCCESS.
Stop Omega... 44 invocations 
0 false contexts at: ()

!!! log(small):(0.021945,202)
Total verification time: 0.338859 second(s)
	Time spent in main process: 0.319629 second(s)
	Time spent in child processes: 0.01923 second(s)


======================================

!!!Full processing file "./hip/classic/classic2a.ss"
Parsing file "./hip/classic/classic2a.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_19


}

class int_ptr extends Object {
int valVAL_20


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_21


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_22


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 65,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 63,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 62,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 43,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 42,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 33,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 27,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 26,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 25,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 24,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 22,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 20,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 16,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 14,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 13,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 8,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 6,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int foo1(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_14,Anon_15>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume_exact: 2,:(emp ; (emp ; htrue))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(82, ):return member access x~~>val}
}
int foo2(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_12,Anon_13>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume_exact: 1,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(84, ):return member access x~~>val}
}
@@prog4


WARNING: ./hip/classic/classic2a.ss_15:16_15:21:the result type __norm#E is not covered by the throw list[]

Checking procedure foo1$node... 
Procedure foo1$node SUCCESS.

Checking procedure foo2$node... 
( []) ::0: 0: Postcondition cannot be derived from context


(Cause of PostCond Failure)::0: 0:  List of Partial Context: [PC(1, 0)]
Failed States:
[
 Label: []
 State:
        fe_kind: MUST
        fe_name: 
        fe_locs: {
                  fc_message: classical separation logic
                  fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]
 ]
Successful States:
[]

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/classic/classic2a.ss",Line:10,Col:9

ERROR: at _0:0_0:0 
Message: Post condition cannot be derived by the system.
 
Procedure foo2$node FAIL.(2)

Exception Failure("Post condition cannot be derived by the system.") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure foo2$node
Stop Omega... 44 invocations 
0 false contexts at: ()

!!! log(small):(0.022206,202)
Total verification time: 0.338927 second(s)
	Time spent in main process: 0.319159 second(s)
	Time spent in child processes: 0.019768 second(s)


======================================

!!!Full processing file "./hip/classic/classic3.ss"
Parsing file "./hip/classic/classic3.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_19


}

class int_ptr extends Object {
int valVAL_20


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_21


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_22


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 65,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 63,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 62,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 43,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 42,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 33,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 27,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 26,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 25,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 24,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 22,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 20,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 16,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 14,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 13,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 8,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 6,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int foo2(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_14,Anon_15>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume_inexact: 2,:(emp ; (emp ; htrue))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(82, ):return member access x~~>val}
}
int foo1(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_12,Anon_13>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume_inexact: 1,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(84, ):return member access x~~>val}
}
@@prog4


WARNING: ./hip/classic/classic3.ss_15:18_15:23:the result type __norm#E is not covered by the throw list[]

Checking procedure foo1$node... 
Procedure foo1$node SUCCESS.

Checking procedure foo2$node... 
Procedure foo2$node SUCCESS.
Stop Omega... 44 invocations 
0 false contexts at: ()

!!! log(small):(0.023722,204)
Total verification time: 0.341135 second(s)
	Time spent in main process: 0.321569 second(s)
	Time spent in child processes: 0.019566 second(s)


======================================

!!!Full processing file "./hip/classic/classic3a.ss"
Parsing file "./hip/classic/classic3a.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_19


}

class int_ptr extends Object {
int valVAL_20


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_21


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_22


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 65,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 63,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 62,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 43,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 42,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 33,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 27,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 26,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 25,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 24,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 22,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 20,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 16,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 14,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 13,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 8,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 6,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int foo1(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_14,Anon_15>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume_inexact: 2,:(emp ; (emp ; htrue))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(82, ):return member access x~~>val}
}
int foo2(node x)[]
static EBase: [][](emp ; (emp ; (x::node{}<Anon_12,Anon_13>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume_inexact: 1,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(84, ):return member access x~~>val}
}
@@prog4


WARNING: ./hip/classic/classic3a.ss_15:18_15:23:the result type __norm#E is not covered by the throw list[]

Checking procedure foo1$node... 
Procedure foo1$node SUCCESS.

Checking procedure foo2$node... 
Procedure foo2$node SUCCESS.
Stop Omega... 44 invocations 
0 false contexts at: ()

!!! log(small):(0.023876,204)
Total verification time: 0.366373 second(s)
	Time spent in main process: 0.346666 second(s)
	Time spent in child processes: 0.019707 second(s)


======================================

!!!Full processing file "./hip/../../modular_examples/dll-modular.ss"
Parsing file "./hip/../../modular_examples/dll-modular.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_31


}

class int_ptr extends Object {
int valVAL_32


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_33


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node2 extends Object {
int valVAL_12;
node2 prevREC_11;
node2 nextREC_34


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
dll{}[]<p,n> == 

(None,[]): EBase: [][](emp)*(

"": self = null
 && 
"n": n = 0)( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node2{}<Anon_13,p,q>@M[HeapNode1]) * (q::dll{}<self,n1>@M[HeapNode1]))))*(

"n": n1 = n-1)( FLOW __flow)  inv 

"n": n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 131,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 130,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 129,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 128,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 127,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 126,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 125,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 124,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 123,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 122,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 121,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 120,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 119,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 118,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 117,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 116,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 115,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 114,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 113,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 112,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 111,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 110,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 109,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 108,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 107,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 106,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 105,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 104,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 103,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 102,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 101,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 100,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 99,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 98,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 97,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 96,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 95,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 94,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 93,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 92,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 91,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 82,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 81,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 80,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 79,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 78,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 77,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 76,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 75,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 73,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 72,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 71,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 70,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 69,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 68,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 67,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 66,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 65,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 64,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 63,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 62,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 61,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 60,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 59,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 58,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 57,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 56,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 55,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 54,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 53,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void f2(node2 x)[]
static EBase: [][](emp ; (emp ; (x::dll{}<q,m>@M[HeapNode1])))*(

"n": m > 0)( FLOW __norm) {EAssume: 52,:(emp ; (emp ; (x::dll{}<q,m>@M[HeapNode1])))*(

"n": m > 0)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(132, ):f1(x)}
}
void f1(node2 x)[]
static EBase: [][](emp ; (emp ; (x::dll{}<q,m>@M[HeapNode1])))*(

"n": m > 0)( FLOW __norm) {EAssume: 49,:(emp ; (emp ; (x::dll{}<q,n>@M[HeapNode1])))*(

"n": n = m)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int t
int t = 0;
t = t + 1}
}
void append2(node2 x, node2 y)[]
static EBase: [][](emp ; (emp ; ((x::dll{}<q,m>@M[HeapNode1]) * (y::dll{}<p,n>@M[HeapNode1]))))*(

"n": m > 0)( FLOW __norm) {EAssume: 44,:(emp ; (emp ; (x::dll{}<q,n1>@M[HeapNode1])))*(

"n": n1 = n+m)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 tmp
node2 tmp;
(135, ):if (member access x~~>next == null) { 
  (135, ):{member access x~~>next = y;
(140, ):if (y != null) { 
  (140, ):{member access y~~>prev = x};
} else { 
  (140, ):
}};
} else { 
  (135, ):{(136, ):append2(member access x~~>next, y)}
}}
}
node2 append1(node2 x, node2 y)[]
static EBase: [][](emp ; (emp ; ((x::dll{}<q,m>@M[HeapNode1]) * (y::dll{}<p,n>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 39,:(emp ; (emp ; (res::dll{}<Anon_27,n1>@M[HeapNode1])))*(

"n": n1 = n+m)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(146, ):if (x == null) { 
  (146, ):(156, ):return y;
} else { 
  (146, ):{local: node2 tmp
node2 tmp = (147, ):append1(member access x~~>next, y);
(149, ):if (tmp != null) { 
  (149, ):member access tmp~~>prev = x;
} else { 
  (149, ):
};
member access x~~>next = tmp;
(155, ):return x}
}}
}
node2 append(node2 x, node2 y)[]
static EBase: [][](emp ; (emp ; ((x::dll{}<q,m>@M[HeapNode1]) * (y::dll{}<p,n>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 31,:(emp ; (emp ; (res::dll{}<Anon_26,n1>@M[HeapNode1])))*(

"n": n1 = n+m)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 tmp
node2 tmp;
(158, ):if (x == null) { 
  (158, ):(172, ):return y;
} else { 
  (158, ):{tmp = member access x~~>next;
tmp = (162, ):append(tmp, y);
(163, ):if (tmp != null) { 
  (163, ):{member access x~~>next = tmp;
member access tmp~~>prev = x};
} else { 
  (163, ):{member access x~~>next = null}
};
(171, ):return x}
}}
}
node2 test_fold()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 28,:(emp ; (emp ; (res::dll{}<Anon_25,n>@M[HeapNode1])))*(

"n": n = 3)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 tmp_null,node2 tmp1,node2 tmp2,node2 tmp3
node2 tmp_null = null;
node2 tmp1 = new node2(10, tmp_null, tmp_null);
node2 tmp2 = new node2(20, tmp_null, tmp1);
member access tmp1~~>prev = tmp2;
node2 tmp3 = new node2(30, tmp_null, tmp2);
member access tmp2~~>prev = tmp3;
(178, ):return tmp3}
}
void test_del2(node2 x, node2 tmp2)[]
static EBase: [][](emp ; (emp ; ((x::node2{}<Anon_16,Anon_17,Anon_18>@M[HeapNode1]) * (tmp2::dll{}<x,Anon_19>@M[HeapNode1]))))*(tmp2 != null)( FLOW __norm)
or(emp ; (emp ; (x::node2{}<Anon_20,Anon_21,Anon_22>@M[HeapNode1])))*(tmp2 = null)( FLOW __norm) {EAssume: 24,:(emp ; (emp ; (x::dll{}<Anon_23,Anon_24>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(179, ):if (tmp2 != null) { 
  (179, ):{member access tmp2~~>prev = x};
} else { 
  (179, ):
};
member access x~~>next = tmp2}
}
void test_del(node2 x)[]
static EBase: [][](emp ; (emp ; (x::dll{}<p,n>@M[HeapNode1])))*(

"n": n > 1)( FLOW __norm) {EAssume: 20,:(emp ; (emp ; (x::dll{}<Anon_14,Anon_15>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 tmp1,node2 tmp2
node2 tmp1 = member access x~~>next;
node2 tmp2 = member access tmp1~~>next;
(187, ):if (tmp2 != null) { 
  (187, ):{member access tmp2~~>prev = x};
} else { 
  (187, ):
};
member access x~~>next = tmp2}
}
void delete1(node2 x, int a)[]
static EBase: [][](emp ; (emp ; (x::dll{}<p,n>@M[HeapNode1])))*(

"n","": (n > a) & (a > 0))( FLOW __norm) {EAssume: 13,:(emp ; (emp ; (x::dll{}<p,n1>@M[HeapNode1])))*(

"n": n1 = n-1)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 tmp
node2 tmp;
(193, ):if (a == 1) { 
  (193, ):{(197, ):if (member access x~~>next~~>next != null) { 
  (197, ):{member access x~~>next~~>next~~>prev = x};
} else { 
  (197, ):
};
tmp = member access x~~>next~~>next;
member access x~~>next = tmp};
} else { 
  (193, ):(194, ):delete1(member access x~~>next, a - 1)
}}
}
void delete(node2 x, int a)[]
static EBase: [][](emp ; (emp ; (x::dll{}<p,n>@M[HeapNode1])))*(

"n","": (n > a) & (a > 0))( FLOW __norm) {EAssume: 5,:(emp ; (emp ; (x::dll{}<p,n1>@M[HeapNode1])))*(

"n": n1 = n-1)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node2 tmp,node2 tmp_null
node2 tmp;
node2 tmp_null = null;
(207, ):if (a == 1) { 
  (207, ):{(211, ):if (member access x~~>next~~>next != null) { 
  (211, ):{member access x~~>next~~>next~~>prev = x;
tmp = member access x~~>next~~>next;
member access x~~>next = tmp};
} else { 
  (211, ):member access x~~>next = tmp_null
}};
} else { 
  (207, ):{(208, ):delete(member access x~~>next, a - 1)}
}}
}
void insert(node2 x, int a)[]
static EBase: [][](emp ; (emp ; (x::dll{}<p,n>@M[HeapNode1])))*(x != null)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (x::dll{}<p,n1>@M[HeapNode1])))*(

"n": n1 = n+1)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(223, ):if (member access x~~>next == null) { 
  (223, ):{member access x~~>next = new node2(a, x, null)};
} else { 
  (223, ):{ :assert  assume: (hfalse)*(false)( FLOW __norm)
;
(225, ):insert(member access x~~>next, a)}
}}
}
@@prog4


Checking procedure append$node2~node2... 
Procedure append$node2~node2 SUCCESS.

Checking procedure append1$node2~node2... 
Procedure append1$node2~node2 SUCCESS.

Checking procedure append2$node2~node2... 
Procedure append2$node2~node2 SUCCESS.

Checking procedure delete$node2~int... 
Procedure delete$node2~int SUCCESS.

Checking procedure delete1$node2~int... 
Procedure delete1$node2~int SUCCESS.

Checking procedure f1$node2... 
Procedure f1$node2 SUCCESS.

Checking procedure f2$node2... 
Procedure f2$node2 SUCCESS.

Checking procedure insert$node2~int... 
Procedure insert$node2~int SUCCESS.

Checking procedure test_del$node2... 
Procedure test_del$node2 SUCCESS.

Checking procedure test_del2$node2~node2... 
Procedure test_del2$node2~node2 SUCCESS.

Checking procedure test_fold$... 
Procedure test_fold$ SUCCESS.

Termination checking result: SUCCESS

Stop Omega... 808 invocations 
2 false contexts at: ( (32,3)  (32,10) )

!!! log(small):(6.347673,9674)
Total verification time: 3.437477 second(s)
	Time spent in main process: 3.149582 second(s)
	Time spent in child processes: 0.287895 second(s)


======================================

!!!Full processing file "./hip/../../modular_examples/selection-modular.ss"
Parsing file "./hip/../../modular_examples/selection-modular.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_16


}

class int_ptr extends Object {
int valVAL_17


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_18


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_19


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
sll{}[]<n,sm,lg> == 

(None,[]): EBase: [][](emp ; (emp ; (self::node{}<sm,null>@M[HeapNode1])))*(

"n": n = 1
 && 
"v": sm = lg)( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<sm,q>@M[HeapNode1]) * (q::sll{}<n1,qs,lg>@M[HeapNode1]))))*(

"": q != null
 && 
"n": n1 = n-1
 && 
"v": sm <= qs)( FLOW __flow)  inv 

"n": n >= 1
 && 
"v": sm <= lg inv_lock: None view_data_name:  view_imm_map: []
bnd1{}[]<n,sm,bg,mi> == 

(None,[]): EBase: [][](emp ; (emp ; (self::node{}<mi,null>@M[HeapNode1])))*(

"n": n = 1
 && 
"v": (sm <= mi) & (mi < bg))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<d,p>@M[HeapNode1]) * (p::bnd1{}<n1,sm,bg,tmi>@M[HeapNode1]))))*(

"n": n1 = n-1
 && 
"v": ((sm <= d) & (d < bg)) & (mi = min(d,tmi)))( FLOW __flow)  inv 

"n": n >= 0
 && 
"v": (sm <= mi) & (mi < bg) inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 86,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 85,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 84,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 75,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 74,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 72,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 71,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 70,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 69,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 67,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 66,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 65,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 64,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 63,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 62,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 61,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 60,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 59,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 57,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 56,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 54,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 52,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 51,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 49,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 48,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 46,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 45,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 41,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 40,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 39,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 38,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 37,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 36,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 35,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 34,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 33,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 32,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 31,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 30,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 29,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 28,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 27,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 26,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 25,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 24,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 23,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 22,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 21,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 20,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 19,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 18,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 17,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 16,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 15,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 14,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 13,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 12,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

node selection_sort(node@R x)[]
static EBase: [][](emp ; (emp ; (x::bnd1{}<n,sm,lg,mi>@M[HeapNode1])))*(

"n": n > 0)( FLOW __norm) {EAssume: 8,:(emp ; (emp ; (res::sll{}<n,mi,l>@M[HeapNode1])))*(

"v": l < lg)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int minimum,node tmp,node tmp_null
int minimum;
node tmp, tmp_null = null;
minimum = (92, ):find_min(x);
(93, ):delete_min(x, minimum);
(94, ):if (x == null) { 
  (94, ):(98, ):return new node(minimum, tmp_null);
} else { 
  (94, ):{tmp = (96, ):selection_sort(x);
(97, ):return new node(minimum, tmp)}
}}
}
void delete_min(node@R x, int a)[]
static EBase: [][](emp ; (emp ; (x::bnd1{}<n,s,l,mi>@M[HeapNode1])))*(

"n": n >= 1
 && 
"v": a = mi)( FLOW __norm) {EAssume: 5,:(emp)*(

"": x' = null
 && 
"n": n = 1
 && 
"v": (s <= mi) & (mi < l))( FLOW __norm)
or(emp ; (emp ; (x'::bnd1{}<n1,s,l,mi1>@M[HeapNode1])))*(

"": x' != null
 && 
"n": (n > 1) & (n1 = n-1)
 && 
"v": mi1 >= mi)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(100, ):if (member access x~~>val == a) { 
  (100, ):x = member access x~~>next;
} else { 
  (100, ):{(101, ):bind x to (Anon_12, xnext) in
{(102, ):delete_min(xnext, a)}}
}}
}
int find_min(node x)[]
static EBase: [][](emp ; (emp ; (x::bnd1{}<n,s,l,mi>@M[HeapNode1])))*(

"n": n > 0)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (x::bnd1{}<n,s,l,mi>@M[HeapNode1])))*(

"v": res = mi)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int tmp
int tmp;
(107, ):if (member access x~~>next == null) { 
  (107, ):(117, ):return member access x~~>val;
} else { 
  (107, ):{tmp = (109, ):find_min(member access x~~>next);
(111, ):if (tmp > member access x~~>val) { 
  (111, ):(113, ):return member access x~~>val;
} else { 
  (111, ):(112, ):return tmp
}}
}}
}
@@prog4


WARNING: ./hip/../../modular_examples/selection-modular.ss_39:9_39:49:the result type __norm#E is not covered by the throw list[]
AndList:? 
 AndList( "n":n=1 ; "v":lg=sm) 

Last Proving Location: 1 File "./hip/../../modular_examples/selection-modular.ss",Line:14,Col:1

ERROR: at _0:0_0:0 
Message: omega.ml: encountered AndList, should have been already handled
 Omega Error Exp:Failure("omega.ml: encountered AndList, should have been already handled")
 Formula: 
 AndList( "n":n=1 ; "v":lg=sm) 
AndList:? 
 AndList( "n":2<=n ; "v":sm<=lg) 

Last Proving Location: 1 File "./hip/../../modular_examples/selection-modular.ss",Line:14,Col:1

ERROR: at _0:0_0:0 
Message: omega.ml: encountered AndList, should have been already handled
 Omega Error Exp:Failure("omega.ml: encountered AndList, should have been already handled")
 Formula: 
 AndList( "n":2<=n ; "v":sm<=lg) 
AndList:? 
 AndList( "n":n=1 ; "v":sm<=mi & mi<bg) 

Last Proving Location: 1 File "./hip/../../modular_examples/selection-modular.ss",Line:9,Col:1

ERROR: at _0:0_0:0 
Message: omega.ml: encountered AndList, should have been already handled
 Omega Error Exp:Failure("omega.ml: encountered AndList, should have been already handled")
 Formula: 
 AndList( "n":n=1 ; "v":sm<=mi & mi<bg) 
AndList:? 
 AndList( "n":1<=n ; "v":sm<=mi & mi<bg) 

Last Proving Location: 1 File "./hip/../../modular_examples/selection-modular.ss",Line:9,Col:1

ERROR: at _0:0_0:0 
Message: omega.ml: encountered AndList, should have been already handled
 Omega Error Exp:Failure("omega.ml: encountered AndList, should have been already handled")
 Formula: 
 AndList( "n":1<=n ; "v":sm<=mi & mi<bg) 

Checking procedure delete_min$node~int... 
Procedure delete_min$node~int SUCCESS.

Checking procedure find_min$node... 
Procedure find_min$node SUCCESS.

Checking procedure selection_sort$node... 
Procedure selection_sort$node SUCCESS.
Stop Omega... 428 invocations 
0 false contexts at: ()

!!! log(small):(1.767863,1077)
Total verification time: 1.496981 second(s)
	Time spent in main process: 1.294727 second(s)
	Time spent in child processes: 0.202254 second(s)


======================================

!!!Full processing file "./hip/../../modular_examples/qsort-modular.ss"
Parsing file "./hip/../../modular_examples/qsort-modular.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_15


}

class int_ptr extends Object {
int valVAL_16


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_17


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class node extends Object {
int valVAL_11;
node nextREC_18


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
sll{}[]<n,sm,lg> == 

(None,[]): EBase: [][](emp ; (emp ; (self::node{}<qmin,null>@M[HeapNode1])))*(

"n": n = 1
 && 
"v": (qmin = sm) & (qmin = lg))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<sm,q>@M[HeapNode1]) * (q::sll{}<n1,qs,lg>@M[HeapNode1]))))*(

"n": n = n1+1
 && 
"v": (q != null) & (sm <= qs))( FLOW __flow)  inv 

"n": n >= 1
 && 
"v": sm <= lg inv_lock: None view_data_name:  view_imm_map: []
bnd{}[]<n,sm,bg> == 

(None,[]): EBase: [][](emp)*(

"": self = null
 && 
"n": n = 0)( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<d,p>@M[HeapNode1]) * (p::bnd{}<n1,sm,bg>@M[HeapNode1]))))*(

"n": n = n1+1
 && 
"v": (sm <= d) & (d < bg))( FLOW __flow)  inv 

"n": n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 102,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 101,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 100,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 99,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 98,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 97,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 96,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 95,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 94,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 93,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 92,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 91,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 87,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 86,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 84,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 83,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 82,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 81,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 79,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 78,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 77,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 76,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 75,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 74,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 73,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 72,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 71,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 70,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 69,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 68,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 67,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 66,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 65,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 64,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 63,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 62,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 61,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 60,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 58,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 57,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 56,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 55,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 54,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 53,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 52,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 51,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 50,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 49,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 48,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 47,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 46,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 45,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 44,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 43,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 42,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 41,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 40,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 39,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 38,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 37,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 36,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 35,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 34,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 33,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 32,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 31,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 30,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 29,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 28,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 27,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 26,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 25,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 24,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void qsort(node@R xs)[]
static 

(None,[]): EBase: [][](emp)*(xs = null)( FLOW __norm) {EAssume: 13,:(emp)*(xs' = null)( FLOW __norm)}
||
(None,[]): EBase: [][](emp ; (emp ; (xs::bnd{}<n,sm,bg>@M[HeapNode1])))*(

"n": n > 0)( FLOW __norm) {EAssume: 14,:(emp ; (emp ; (xs'::sll{}<n,smres,bgres>@M[HeapNode1])))*(

"v": (smres >= sm) & (bgres < bg))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp,int v,boolean b
node tmp;
int v;
boolean b;
(103, ):if (xs != null) { 
  (103, ):{v = member access xs~~>val;
(106, ):bind xs to (xsval, xsnext) in
{tmp = (108, ):partition(xsnext, v)};
b = member access xs~~>next == null;
(112, ):if (tmp != null) { 
  (112, ):(113, ):qsort(tmp);
} else { 
  (112, ):
};
tmp = new node(v, tmp);
(116, ):if (b) { 
  (116, ):xs = tmp;
} else { 
  (116, ):{(117, ):bind xs to (xsval, xsnext) in
{(118, ):qsort(xsnext)};
xs = (120, ):append_bll(member access xs~~>next, tmp)}
}};
} else { 
  (103, ):
}}
}
node append_bll(node x, node y)[]
static 

(None,[]): EBase: [][](emp ; (emp ; (y::sll{}<m,s2,b2>@M[HeapNode1])))*(x = null)( FLOW __norm) {EAssume: 8,:(emp ; (emp ; (res::sll{}<m,s2,b2>@M[HeapNode1])))*(true)( FLOW __norm)}
||
(None,[]): EBase: [][](emp ; (emp ; ((x::sll{}<nn,s0,b0>@M[HeapNode1]) * (y::sll{}<m,s2,b2>@M[HeapNode1]))))*(

"v": b0 <= s2)( FLOW __norm) {EAssume: 9,:(emp ; (emp ; (res::sll{}<nr,s0,b2>@M[HeapNode1])))*(

"n": nr = nn+m)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node xn
node xn;
(124, ):if (x == null) { 
  (124, ):(131, ):return y;
} else { 
  (124, ):{xn = (126, ):append_bll(member access x~~>next, y);
member access x~~>next = xn;
(130, ):return x}
}}
}
node partition(node@R xs, int c)[]
static EBase: [][](emp ; (emp ; (xs::bnd{}<n,sm,bg>@M[HeapNode1])))*(

"v": (sm <= c) & (c <= bg))( FLOW __norm) {EAssume: 1,:(emp ; (emp ; ((xs'::bnd{}<a,sm,c>@M[HeapNode1]) * (res::bnd{}<b,c,bg>@M[HeapNode1]))))*(

"n": n = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node tmp1,int v
node tmp1;
int v;
(133, ):if (xs == null) { 
  (133, ):(149, ):return null;
} else { 
  (133, ):{(134, ):if (member access xs~~>val >= c) { 
  (134, ):{v = member access xs~~>val;
(141, ):bind xs to (xsval, xsnext) in
{tmp1 = (143, ):partition(xsnext, c)};
xs = member access xs~~>next;
(146, ):return new node(v, tmp1)};
} else { 
  (134, ):{(135, ):bind xs to (xsval, xsnext) in
{tmp1 = (137, ):partition(xsnext, c)};
(138, ):return tmp1}
}}
}}
}
@@prog4


WARNING: ./hip/../../modular_examples/qsort-modular.ss_99:10_99:18:the result type __norm#E is not covered by the throw list[]
AndList:? 
 AndList( "n":n=1 ; "v":lg=sm) 

Last Proving Location: 1 File "./hip/../../modular_examples/qsort-modular.ss",Line:14,Col:1

ERROR: at _0:0_0:0 
Message: omega.ml: encountered AndList, should have been already handled
 Omega Error Exp:Failure("omega.ml: encountered AndList, should have been already handled")
 Formula: 
 AndList( "n":n=1 ; "v":lg=sm) 
AndList:? 
 AndList( "n":2<=n ; "v":sm<=lg) 

Last Proving Location: 1 File "./hip/../../modular_examples/qsort-modular.ss",Line:14,Col:1

ERROR: at _0:0_0:0 
Message: omega.ml: encountered AndList, should have been already handled
 Omega Error Exp:Failure("omega.ml: encountered AndList, should have been already handled")
 Formula: 
 AndList( "n":2<=n ; "v":sm<=lg) 

Checking procedure append_bll$node~node... 
Procedure append_bll$node~node SUCCESS.

Checking procedure partition$node~int... 
Procedure partition$node~int SUCCESS.

Checking procedure qsort$node... 
Procedure qsort$node SUCCESS.

Termination checking result: SUCCESS

Stop Omega... 810 invocations 
28 false contexts at: ( (111,1)  (130,8)  (130,19)  (130,3)  (127,4)  (125,2)  (123,8)  (123,3)  (121,8)  (121,2)  (118,2)  (119,3)  (118,6)  (117,13)  (117,13)  (117,8)  (115,9)  (115,3)  (113,12)  (113,8)  (112,1)  (78,21)  (82,9)  (81,9)  (80,14)  (80,25)  (80,9)  (79,13) )

!!! log(small):(7.438377,3455)
Total verification time: 4.951966 second(s)
	Time spent in main process: 3.329644 second(s)
	Time spent in child processes: 1.622322 second(s)


======================================

!!!Full processing file "./hip/vperm/vperm_check.ss"
Parsing file "./hip/vperm/vperm_check.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_14


}

class int_ptr extends Object {
int valVAL_15


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_16


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class cell extends Object {
int valVAL_17


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 95,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 94,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 93,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 92,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 91,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 90,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 89,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 88,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 80,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 79,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 77,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 76,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 75,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 74,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 72,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 71,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 70,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 69,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 68,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 67,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 66,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 65,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 64,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 63,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 62,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 61,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 60,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 59,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 58,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 55,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 54,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 53,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 52,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 51,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 49,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 48,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 46,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 45,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 44,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 43,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 42,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 41,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 40,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 39,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 38,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 37,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 36,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 35,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 34,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 33,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 32,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 31,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 30,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 29,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 28,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 27,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 26,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 25,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 24,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 23,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 22,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 21,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 20,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 19,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 18,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 17,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int test4(int@R x, int@R y)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 15,:(emp)*((@full[[y]]) & (res = z))( FLOW __norm)
AND <thread = None>&(thread = z) --> (emp)*(@full[[x]])}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int id
int id;
id = (97, ):fork(inc, x);
(98, ):inc(y);
(99, ):return x}
}
int test3(int@R x, int@R y)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 12,:(emp)*((@full[[y]]) & (res = z))( FLOW __norm)
AND <thread = None>&(thread = z) --> (emp)*(@full[[x]])}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int id
int id;
id = (101, ):fork(inc, x);
y = x;
(103, ):inc(y);
(104, ):return id}
}
int test2(cell@R x, cell@R y)[]
static EBase: [][](emp ; (emp ; ((x::cell{}<i>@M[HeapNode1]) * (y::cell{}<j>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 8,:(emp ; (emp ; (y::cell{}<j+1>@M[HeapNode1])))*((@full[[y]]) & (res = z))( FLOW __norm)
AND <thread = None>&(thread = z) --> (emp ; (emp ; (x::cell{}<i+1>@M[HeapNode1])))*(@full[[x]])}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int id
int id;
id = (106, ):fork(incCell, x);
member access y~~>val++;
member access x~~>val++;
(113, ):return id}
}
int test1(int@R x, int@R y)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*((@full[[y]]) & (res = z))( FLOW __norm)
AND <thread = None>&(thread = z) --> (emp)*(@full[[x]])}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int id
int id;
id = (115, ):fork(inc, x);
x = 0;
(117, ):inc(y);
(118, ):return id}
}
void incCell(cell@R x)[]
static EBase: [][](emp ; (emp ; (x::cell{}<i>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 3,:(emp ; (emp ; (x::cell{}<i+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{member access x~~>val++}
}
void inc(int@R i)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 1,:(emp)*(i' = i+1)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{i++}
}
@@prog4


WARNING: ./hip/vperm/vperm_check.ss_13:10_13:16:the result type __norm#E is not covered by the throw list[]

Checking procedure inc$int... 
Procedure inc$int SUCCESS.

Checking procedure incCell$cell... 
Procedure incCell$cell SUCCESS.

Checking procedure test1$int~int... 
VarPerm Failure:./hip/vperm/vperm_check.ss:33: 2: check_full_varperm: var [x'] MUST have full permission


() :./hip/vperm/vperm_check.ss:34: 2: Proving precondition in method failed


(Cause of PreCond Failure):./hip/vperm/vperm_check.ss:34: 2:  List of Failesc Context: []

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/vperm/vperm_check.ss",Line:34,Col:2

ERROR: at ./hip/vperm/vperm_check.ss_34:2_34:8 
Message: Proving precondition in method failed.
 
Procedure test1$int~int FAIL.(2)

Exception Failure("Proving precondition in method failed.") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure test1$int~int

Checking procedure test2$cell~cell... 
VarPerm Failure:./hip/vperm/vperm_check.ss:47: 2: check_full_varperm: var [x'] MUST have full permission


() :./hip/vperm/vperm_check.ss:47: 2: Proving precondition in method failed


(Cause of PreCond Failure):./hip/vperm/vperm_check.ss:47: 2:  List of Failesc Context: []

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/vperm/vperm_check.ss",Line:47,Col:2

ERROR: at ./hip/vperm/vperm_check.ss_47:2_47:9 
Message: Proving precondition in method failed.
 
Procedure test2$cell~cell FAIL.(2)

Exception Failure("Proving precondition in method failed.") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure test2$cell~cell

Checking procedure test3$int~int... 
VarPerm Failure:./hip/vperm/vperm_check.ss:59: 6: check_full_varperm: var [x'] MUST have full permission


() :./hip/vperm/vperm_check.ss:60: 2: Proving precondition in method failed


(Cause of PreCond Failure):./hip/vperm/vperm_check.ss:60: 2:  List of Failesc Context: []

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/vperm/vperm_check.ss",Line:60,Col:2

ERROR: at ./hip/vperm/vperm_check.ss_60:2_60:8 
Message: Proving precondition in method failed.
 
Procedure test3$int~int FAIL.(2)

Exception Failure("Proving precondition in method failed.") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure test3$int~int

Checking procedure test4$int~int... 
VarPerm Failure:./hip/vperm/vperm_check.ss:73: 2: check_full_varperm: var [x'] MUST have full permission


Procedure test4$int~int result FAIL.(1)
Stop Omega... 68 invocations 
0 false contexts at: ()

!!! log(small):(0.092619,549)
Total verification time: 0.556957 second(s)
	Time spent in main process: 0.535906 second(s)
	Time spent in child processes: 0.021051 second(s)


======================================

!!!Full processing file "./hip/vperm/task_decompose.ss"
Parsing file "./hip/vperm/task_decompose.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_14


}

class int_ptr extends Object {
int valVAL_15


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_16


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 85,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 84,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 74,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 73,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 71,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 70,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 69,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 68,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 66,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 65,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 64,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 63,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 62,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 59,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 58,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 55,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 54,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 53,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 52,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 49,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 48,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 46,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 45,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 40,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 39,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 38,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 37,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 36,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 35,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 34,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 33,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 32,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 31,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 30,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 28,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 27,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 26,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 25,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 24,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 23,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 22,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 21,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 20,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 19,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 18,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 17,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 16,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 15,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 14,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 13,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 12,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 11,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int main()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 6,:(emp)*(res = 2)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int id,int x,int y
int id;
int x, y;
x = 0;
y = 0;
id = (93, ):creator(x, y);
(94, ):joiner(id, x);
(95, ):return x + y}
}
void joiner(int id, int@R x)[]
static EBase: [][ i](emp)*(true)( FLOW __norm)
AND <thread = None>&(thread = id) --> (emp)*(x' = i+1) {EAssume: 5,:(emp)*(x' = i+1)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(97, ):join(id)}
}
int creator(int@R x, int@R y)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*((y' = y+1) & (res = z))( FLOW __norm)
AND <thread = None>&(thread = z) --> (emp)*(x' = x+1)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int id
int id;
id = (99, ):fork(inc, x);
(100, ):inc(y);
(101, ):return id}
}
void inc(int@R i)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 1,:(emp)*(i' = i+1)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{i++}
}
@@prog4


WARNING: ./hip/vperm/task_decompose.ss_29:11_29:17:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/vperm/task_decompose.ss_10:10_10:16:the result type __norm#E is not covered by the throw list[]

Checking procedure inc$int... 
Procedure inc$int SUCCESS.

Checking procedure creator$int~int... 
Procedure creator$int~int SUCCESS.

Checking procedure joiner$int~int... 
Procedure joiner$int~int SUCCESS.

Checking procedure main$... 
Procedure main$ SUCCESS.
Stop Omega... 67 invocations 
0 false contexts at: ()

!!! log(small):(0.045867,321)
Total verification time: 0.433773 second(s)
	Time spent in main process: 0.409995 second(s)
	Time spent in child processes: 0.023778 second(s)


======================================

!!!Full processing file "./hip/parahip/cell.ss"
Parsing file "./hip/parahip/cell.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_14


}

class int_ptr extends Object {
int valVAL_15


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_16


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class cell extends Object {
int valVAL_17


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
LOCKB{}[]<x,y> == EBase: [][](emp ; (emp ; (self::lock{}()<>@M[HeapNode1])))*(true)( FLOW __flow)  inv self != null inv_lock: Some((EX v1 v2 . (emp ; (emp ; ((x::cell{}()<v1>@M[HeapNode1]) * (y::cell{}()<v2>@M[HeapNode1]))))*((v1+v2) >= 2)( FLOW __norm))) view_data_name:  view_imm_map: []
LOCKA{}[]<x> == EBase: [][](emp ; (emp ; (self::lock{}()<>@M[HeapNode1])))*(true)( FLOW __flow)  inv self != null inv_lock: Some((EX v . (emp ; (emp ; (x::cell{}()<v>@M[HeapNode1])))*(v >= 0)( FLOW __norm))) view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 83,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 82,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 72,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 71,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 69,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 68,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 67,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 66,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 65,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 64,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 63,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 62,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 59,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 58,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 53,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 52,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 51,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 50,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 46,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 45,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 38,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 37,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 36,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 35,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 34,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 33,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 32,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 31,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 30,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 29,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 28,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 27,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 26,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 25,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 24,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 23,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 22,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 21,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 20,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 19,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 18,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 17,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 16,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 15,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 14,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 13,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 12,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 11,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 10,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 9,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void test1()[]
static EBase: [][](emp)*(LS = Bag())( FLOW __norm) {EAssume: 4,:(emp)*(LS' = Bag())( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: cell x,cell y,lock l
cell x;
cell y;
lock l;
l = new lock();
x = new cell(1);
y = new cell(1);
(91, ):init[LOCKB](l, x, y);
member access x~~>val--;
(95, ):release(l);
(96, ):acquire(l);
(97, ):finalize(l)}
}
void test()[]
static EBase: [][](emp)*(LS = Bag())( FLOW __norm) {EAssume: 1,:(emp)*(LS' = Bag())( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: cell x,lock l
cell x;
lock l;
l = new lock();
x = new cell(0);
(100, ):init[LOCKA](l, x);
(101, ):release(l);
(102, ):acquire(l);
(103, ):finalize(l)}
}
@@prog4

Starting z3... 

WARNING: ./hip/parahip/cell.ss_67:10_67:16:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/parahip/cell.ss_45:10_45:16:the result type __norm#E is not covered by the throw list[]

Checking procedure test$... Starting Reduce... 
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure test$ SUCCESS.

Checking procedure test1$... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

procedure call:./hip/parahip/cell.ss:79: 2: 
Verification Context:(Line:0,Col:0)
Proving precondition in method release$lock for spec:
 EBase (exists v1_1513,v2_1514: x_42'::cell()<v1_1513>@ rem br[{1}] * 
       y_43'::cell()<v2_1514>@ rem br[{1}] * (htrue)&(
       ([l_44' <in> LS' ][2<=(v2_1514+v1_1513)][x_42'!=null][y_43'!=null]))&
       {FLOW,(4,5)=__norm#E})[]
         EAssume ref [LS;LSMU]
           htrue&(([LS'=LS-{l_44'} & LSMU'=LSMU-{level(l_44')}]))&
           {FLOW,(4,5)=__norm#E}[]
            has failed 


Procedure test1$ result FAIL.(1)
Stop Omega... 4 invocations 
0 false contexts at: ()

!!! log(small):(0.429149,535)
!!! 
 log(bigger)(>4s)(14):(210.,[(SAT:220<3:REDLOG (REDUCE LOGIC),15.);(imply:245<11:REDLOG (REDUCE LOGIC),15.);(imply:246<11:REDLOG (REDUCE LOGIC),15.);(SAT:253<12:REDLOG (REDUCE LOGIC),15.);(imply:262<13:REDLOG (REDUCE LOGIC),15.);(imply:273<14:REDLOG (REDUCE LOGIC),15.);(imply:392<32:REDLOG (REDUCE LOGIC),15.);(imply:393<32:REDLOG (REDUCE LOGIC),15.);(SAT:401<33:REDLOG (REDUCE LOGIC),15.);(imply:444<39:REDLOG (REDUCE LOGIC),15.);(SAT:452<40:REDLOG (REDUCE LOGIC),15.);(imply:469<43:REDLOG (REDUCE LOGIC),15.);(imply:473<43:REDLOG (REDUCE LOGIC),15.);(SAT:480<43:REDLOG (REDUCE LOGIC),15.)])
Total verification time: 0.83936 second(s)
	Time spent in main process: 0.769678 second(s)
	Time spent in child processes: 0.069682 second(s)


======================================

!!!Full processing file "./hip/parahip/cell-extreme-cases.ss"
Parsing file "./hip/parahip/cell-extreme-cases.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_14


}

class int_ptr extends Object {
int valVAL_15


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_16


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class cell extends Object {
int valVAL_17


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
LOCKA{}[]<x> == EBase: [][](emp ; (emp ; (self::lock{}()<>@M[HeapNode1])))*(true)( FLOW __flow)  inv self != null inv_lock: Some((EX v . (emp ; (emp ; (x::cell{}()<v>@M[HeapNode1])))*(v >= 0)( FLOW __norm))) view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 91,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 87,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 86,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 85,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 84,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 75,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 73,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 72,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 71,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 70,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 68,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 67,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 66,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 65,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 64,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 63,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 62,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 59,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 58,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 57,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 56,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 55,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 54,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 51,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 49,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 48,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 46,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 45,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 42,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 41,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 40,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 39,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 38,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 37,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 35,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 34,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 33,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 32,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 31,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 30,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 27,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 26,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 25,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 24,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 23,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 22,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 21,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 20,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 19,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 18,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 17,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 16,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 15,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 14,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 13,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void test4()[]
static EBase: [][](emp)*(LS = Bag())( FLOW __norm) {EAssume: 10,:(emp)*(LS' = Bag())( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: cell x,lock l
cell x;
lock l;
l = new lock();
x = new cell(0);
(94, ):init[LOCKA](l, x);
(95, ):release(l);
(96, ):release(l)}
}
void test3()[]
static EBase: [][](emp)*(LS = Bag())( FLOW __norm) {EAssume: 7,:(emp)*(LS' = Bag())( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: cell x,lock l
cell x;
lock l;
l = new lock();
x = new cell(0);
(99, ):init[LOCKA](l, x);
(100, ):release(l);
(101, ):acquire(l);
(102, ):acquire(l)}
}
void test2()[]
static EBase: [][](emp)*(LS = Bag())( FLOW __norm) {EAssume: 4,:(emp)*(LS' = Bag())( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: cell x,lock l
cell x;
lock l;
l = new lock();
x = new cell(0);
(105, ):release(l)}
}
void test()[]
static EBase: [][](emp)*(LS = Bag())( FLOW __norm) {EAssume: 1,:(emp)*(LS' = Bag())( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: cell x,lock l
cell x;
lock l;
l = new lock();
x = new cell(0);
(108, ):finalize(l)}
}
@@prog4

Starting z3... 

WARNING: ./hip/parahip/cell-extreme-cases.ss_93:10_93:16:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/parahip/cell-extreme-cases.ss_66:10_66:16:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/parahip/cell-extreme-cases.ss_46:10_46:16:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/parahip/cell-extreme-cases.ss_28:10_28:16:the result type __norm#E is not covered by the throw list[]

Checking procedure test$... Starting Reduce... 
Nested Timer(stop)

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/parahip/cell-extreme-cases.ss",Line:36,Col:2

ERROR: at ./hip/parahip/cell-extreme-cases.ss_36:2_36:13 
Message: Scall : lock has not been initialized
 
Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/parahip/cell-extreme-cases.ss",Line:36,Col:2

ERROR: at ./hip/parahip/cell-extreme-cases.ss_36:2_36:13 
Message: Scall : could not find heap node for lock l_46'
 
Procedure test$ FAIL.(2)

Exception Failure("Scall : could not find heap node for lock l_46'") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure test$

Checking procedure test2$... 
Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/parahip/cell-extreme-cases.ss",Line:54,Col:2

ERROR: at ./hip/parahip/cell-extreme-cases.ss_54:2_54:12 
Message: Scall : lock has not been initialized
 
Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/parahip/cell-extreme-cases.ss",Line:54,Col:2

ERROR: at ./hip/parahip/cell-extreme-cases.ss_54:2_54:12 
Message: Scall : could not find heap node for lock l_44'
 
Procedure test2$ FAIL.(2)

Exception Failure("Scall : could not find heap node for lock l_44'") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure test2$

Checking procedure test3$... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

procedure call:./hip/parahip/cell-extreme-cases.ss:79: 2: 
Verification Context:(Line:0,Col:0)
Proving precondition in method acquire$lock for spec:
 EBase exists (Expl)[](Impl)[f_1487](ex)[]l_42'::LOCKA{}( f_1487)<x_41>@ rem br[{232}]&
       (
       ([f_1487>FLOAT 0. & f_1487<=FLOAT 1.]
        [l_42' <notin> LS'  & l_42'!=null & waitlevel'<(level(l_42'))]))&
       {FLOW,(1,28)=__flow#E}[]
         EAssume ref [LS;LSMU]
           (exists v_1488: x_41'::cell()<v_1488>@ rem br[{1}] * 
           l_42'::LOCKA{}( f_1487)<x_41>@ rem br[{232}]&(
           ([LS'=union(LS,{l_42'}) & l_42'!=null & LSMU'=union(LSMU,
              {level(l_42')})]
            [0<=v_1488][x_41'!=null]))&
           {FLOW,(4,5)=__norm#E})[]
            has failed 


Procedure test3$ result FAIL.(1)

Checking procedure test4$... 
Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/parahip/cell-extreme-cases.ss",Line:108,Col:2

ERROR: at ./hip/parahip/cell-extreme-cases.ss_108:2_108:12 
Message: Expect a node
 
!!! WARNING logtime exception:0.007312
Procedure test4$ FAIL.(2)

Exception Failure("Expect a node") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure test4$
Stop Omega... 2 invocations 
0 false contexts at: ()

!!! log(small):(0.164299,345)
!!! 
 log(bigger)(>4s)(8):(120.,[(SAT:205<1:REDLOG (REDUCE LOGIC),15.);(imply:266<15:REDLOG (REDUCE LOGIC),15.);(imply:267<15:REDLOG (REDUCE LOGIC),15.);(SAT:274<16:REDLOG (REDUCE LOGIC),15.);(imply:283<17:REDLOG (REDUCE LOGIC),15.);(imply:285<17:REDLOG (REDUCE LOGIC),15.);(imply:286<17:REDLOG (REDUCE LOGIC),15.);(imply:287<18:REDLOG (REDUCE LOGIC),15.)])
Total verification time: 0.555311 second(s)
	Time spent in main process: 0.534776 second(s)
	Time spent in child processes: 0.020535 second(s)


======================================

!!!Full processing file "./hip/parahip/ordered-locking.ss"
Parsing file "./hip/parahip/ordered-locking.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_14


}

class int_ptr extends Object {
int valVAL_15


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_16


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
LOCK{}[]<> == EBase: [][](emp ; (emp ; (self::lock{}()<>@M[HeapNode1])))*(true)( FLOW __flow)  inv self != null inv_lock: Some((emp)*(true)( FLOW __norm)) view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)

lemmas(to be proved and saved)[
=>coerc splitLock
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; (self::LOCK{}(f)<>@M[HeapNode1])))*((f = f1+f2) & ((f1 > 0.) & (f2 > 0.)))( FLOW __norm)
	 body:(emp ; (emp ; ((self::LOCK{}(f1)<>@M[HeapNode1]) * (self::LOCK{}(f2)<>@M[HeapNode1]))))*(((0.) < f) & (f <= 1.))( FLOW __norm)
]

boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 65,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 63,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 62,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 43,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 42,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 33,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 27,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 26,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 25,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 24,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 22,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 20,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 16,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 14,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 13,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 8,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 6,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void main()[]
static EBase: [][](emp)*(LS = Bag())( FLOW __norm) {EAssume: 2,:(emp)*(LS = Bag())( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: lock l1,lock l2,int id
lock l1 = new lock(1);
(82, ):init[LOCK](l1);
(83, ):release(l1);
lock l2 = new lock(2);
(84, ):init[LOCK](l2);
(85, ):release(l2);
int id = (86, ):fork(func, l1, l2);
(87, ):acquire(l1);
(88, ):acquire(l2);
(89, ):release(l1);
(90, ):release(l2);
(91, ):join(id)}
}
void func(lock l1, lock l2)[]
static EBase: [][](emp ; (emp ; ((l1::LOCK{}(0.6)<>@M[HeapNode1]) * (l2::LOCK{}(0.6)<>@M[HeapNode1]))))*(((waitlevel < level(l1)) & ((BagNotIn(l1,LS)) & (BagNotIn(l2,LS)))) & ((l1 != l2) & ((level(l1)) < (level(l2)))))( FLOW __norm) {EAssume: 1,:(emp ; (emp ; ((l1::LOCK{}(0.6)<>@M[HeapNode1]) * (l2::LOCK{}(0.6)<>@M[HeapNode1]))))*(LS' = LS)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(92, ):acquire(l1);
(93, ):acquire(l2);
(94, ):release(l1);
(95, ):release(l2)}
}
@@prog4

Starting z3... 

WARNING: ./hip/parahip/ordered-locking.ss_26:10_26:15:the result type __norm#E is not covered by the throw list[]

Checking procedure func$lock~lock... Starting Reduce... 
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure func$lock~lock SUCCESS.

Checking procedure main$... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure main$ SUCCESS.
Stop Omega... 2 invocations 
0 false contexts at: ()

!!! log(small):(3.223875,1352)
!!! 
 log(bigger)(>4s)(73):(1095.,[(imply:196<2:REDLOG (REDUCE LOGIC),15.);(imply:197<2:REDLOG (REDUCE LOGIC),15.);(imply:201<2:REDLOG (REDUCE LOGIC),15.);(imply:202<2:REDLOG (REDUCE LOGIC),15.);(imply:204<3:REDLOG (REDUCE LOGIC),15.);(imply:209<3:REDLOG (REDUCE LOGIC),15.);(imply:210<3:REDLOG (REDUCE LOGIC),15.);(SAT:214<3:REDLOG (REDUCE LOGIC),15.);(SAT:215<3:REDLOG (REDUCE LOGIC),15.);(SAT:217<3:REDLOG (REDUCE LOGIC),15.);(imply:218<3:REDLOG (REDUCE LOGIC),15.);(SAT:224<3:REDLOG (REDUCE LOGIC),15.);(imply:227<4:REDLOG (REDUCE LOGIC),15.);(imply:229<4:REDLOG (REDUCE LOGIC),15.);(SAT:247<5:REDLOG (REDUCE LOGIC),15.);(imply:258<6:REDLOG (REDUCE LOGIC),15.);(imply:272<7:REDLOG (REDUCE LOGIC),15.);(imply:297<8:REDLOG (REDUCE LOGIC),15.);(imply:312<10:REDLOG (REDUCE LOGIC),15.);(imply:318<11:REDLOG (REDUCE LOGIC),15.);(imply:323<11:REDLOG (REDUCE LOGIC),15.);(imply:334<12:REDLOG (REDUCE LOGIC),15.);(imply:336<13:REDLOG (REDUCE LOGIC),15.);(imply:345<14:REDLOG (REDUCE LOGIC),15.);(imply:363<16:REDLOG (REDUCE LOGIC),15.);(imply:372<17:REDLOG (REDUCE LOGIC),15.);(imply:441<29:REDLOG (REDUCE LOGIC),15.);(imply:442<30:REDLOG (REDUCE LOGIC),15.);(imply:447<30:REDLOG (REDUCE LOGIC),15.);(imply:450<31:REDLOG (REDUCE LOGIC),15.);(imply:459<32:REDLOG (REDUCE LOGIC),15.);(imply:477<33:REDLOG (REDUCE LOGIC),15.);(imply:478<33:REDLOG (REDUCE LOGIC),15.);(imply:486<33:REDLOG (REDUCE LOGIC),15.);(SAT:491<33:REDLOG (REDUCE LOGIC),15.);(SAT:492<33:REDLOG (REDUCE LOGIC),15.);(imply:632<41:REDLOG (REDUCE LOGIC),15.);(imply:633<41:REDLOG (REDUCE LOGIC),15.);(SAT:634<41:REDLOG (REDUCE LOGIC),15.);(SAT:635<41:REDLOG (REDUCE LOGIC),15.);(imply:638<42:REDLOG (REDUCE LOGIC),15.);(imply:639<42:REDLOG (REDUCE LOGIC),15.);(imply:640<42:REDLOG (REDUCE LOGIC),15.);(imply:641<42:REDLOG (REDUCE LOGIC),15.);(imply:737<46:REDLOG (REDUCE LOGIC),15.);(imply:738<46:REDLOG (REDUCE LOGIC),15.);(imply:739<47:REDLOG (REDUCE LOGIC),15.);(imply:740<47:REDLOG (REDUCE LOGIC),15.);(imply:745<47:REDLOG (REDUCE LOGIC),15.);(imply:746<47:REDLOG (REDUCE LOGIC),15.);(imply:749<47:REDLOG (REDUCE LOGIC),15.);(SAT:753<47:REDLOG (REDUCE LOGIC),15.);(SAT:834<53:REDLOG (REDUCE LOGIC),15.);(SAT:836<53:REDLOG (REDUCE LOGIC),15.);(imply:868<54:REDLOG (REDUCE LOGIC),15.);(imply:870<54:REDLOG (REDUCE LOGIC),15.);(imply:873<54:REDLOG (REDUCE LOGIC),15.);(imply:874<54:REDLOG (REDUCE LOGIC),15.);(imply:875<55:REDLOG (REDUCE LOGIC),15.);(imply:876<55:REDLOG (REDUCE LOGIC),15.);(imply:881<55:REDLOG (REDUCE LOGIC),15.);(imply:882<55:REDLOG (REDUCE LOGIC),15.);(imply:885<55:REDLOG (REDUCE LOGIC),15.);(SAT:889<55:REDLOG (REDUCE LOGIC),15.);(SAT:972<61:REDLOG (REDUCE LOGIC),15.);(imply:1004<62:REDLOG (REDUCE LOGIC),15.);(imply:1006<62:REDLOG (REDUCE LOGIC),15.);(imply:1013<62:REDLOG (REDUCE LOGIC),15.);(SAT:1017<62:REDLOG (REDUCE LOGIC),15.);(imply:1145<70:REDLOG (REDUCE LOGIC),15.);(imply:1244<74:REDLOG (REDUCE LOGIC),15.);(imply:1247<74:REDLOG (REDUCE LOGIC),15.);(imply:1262<74:REDLOG (REDUCE LOGIC),15.)])
Total verification time: 2.588619 second(s)
	Time spent in main process: 2.568509 second(s)
	Time spent in child processes: 0.02011 second(s)


======================================

!!!Full processing file "./hip/parahip/unordered-locking.ss"
Parsing file "./hip/parahip/unordered-locking.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_14


}

class int_ptr extends Object {
int valVAL_15


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_16


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
LOCK{}[]<> == EBase: [][](emp ; (emp ; (self::lock{}()<>@M[HeapNode1])))*(true)( FLOW __flow)  inv self != null inv_lock: Some((emp)*(true)( FLOW __norm)) view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)

lemmas(to be proved and saved)[
=>coerc splitLock
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; (self::LOCK{}(f)<>@M[HeapNode1])))*((f = f1+f2) & ((f1 > 0.) & (f2 > 0.)))( FLOW __norm)
	 body:(emp ; (emp ; ((self::LOCK{}(f1)<>@M[HeapNode1]) * (self::LOCK{}(f2)<>@M[HeapNode1]))))*(((0.) < f) & (f <= 1.))( FLOW __norm)
]

boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 66,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 65,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 63,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 62,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 59,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 48,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 43,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 42,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 33,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 27,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 26,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 25,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 24,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 22,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 20,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 16,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 15,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 14,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 13,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 9,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 8,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 7,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 6,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 3,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void main()[]
static EBase: [][](emp)*(LS = Bag())( FLOW __norm) {EAssume: 2,:(emp)*(LS = Bag())( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: lock l1,lock l2,int id
lock l1 = new lock(1);
(82, ):init[LOCK](l1);
(83, ):release(l1);
lock l2 = new lock(2);
(84, ):init[LOCK](l2);
(85, ):release(l2);
int id = (86, ):fork(func, l1, l2);
(87, ):acquire(l1);
(88, ):acquire(l2);
(89, ):release(l1);
(90, ):release(l2);
(91, ):join(id)}
}
void func(lock l1, lock l2)[]
static EBase: [][](emp ; (emp ; ((l1::LOCK{}(0.6)<>@M[HeapNode1]) * (l2::LOCK{}(0.6)<>@M[HeapNode1]))))*(((waitlevel < level(l1)) & ((BagNotIn(l1,LS)) & (BagNotIn(l2,LS)))) & ((l1 != l2) & ((level(l1)) < (level(l2)))))( FLOW __norm) {EAssume: 1,:(emp ; (emp ; ((l1::LOCK{}(0.6)<>@M[HeapNode1]) * (l2::LOCK{}(0.6)<>@M[HeapNode1]))))*(LS' = LS)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(92, ):acquire(l2);
(93, ):acquire(l1);
(94, ):release(l1);
(95, ):release(l2)}
}
@@prog4

Starting z3... 

WARNING: ./hip/parahip/unordered-locking.ss_25:10_25:15:the result type __norm#E is not covered by the throw list[]

Checking procedure func$lock~lock... Starting Reduce... 
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

procedure call:./hip/parahip/unordered-locking.ss:18: 2: 
Verification Context:(Line:0,Col:0)
Proving precondition in method acquire$lock for spec:
 EBase exists (Expl)[](Impl)[f_1474](ex)[]l1'::LOCK{}( f_1474)<>@ rem br[{211}]&
       (
       ([f_1474>FLOAT 0. & f_1474<=FLOAT 1.]
        [l1' <notin> LS'  & l1'!=null & waitlevel'<(level(l1'))]))&
       {FLOW,(1,28)=__flow#E}[]
         EAssume ref [LS;LSMU]
           l1'::LOCK{}( f_1474)<>@ rem br[{211}]&(
           ([LS'=union(LS,{l1'}) & l1'!=null & LSMU'=union(LSMU,{level(l1')})]
            ))&
           {FLOW,(4,5)=__norm#E}[]
            has failed 


Procedure func$lock~lock result FAIL.(1)

Checking procedure main$... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure main$ SUCCESS.
Stop Omega... 2 invocations 
0 false contexts at: ()

!!! log(small):(2.571668,1209)
!!! 
 log(bigger)(>4s)(63):(945.,[(imply:196<2:REDLOG (REDUCE LOGIC),15.);(imply:197<2:REDLOG (REDUCE LOGIC),15.);(imply:201<2:REDLOG (REDUCE LOGIC),15.);(imply:202<2:REDLOG (REDUCE LOGIC),15.);(imply:204<3:REDLOG (REDUCE LOGIC),15.);(imply:209<3:REDLOG (REDUCE LOGIC),15.);(imply:210<3:REDLOG (REDUCE LOGIC),15.);(SAT:214<3:REDLOG (REDUCE LOGIC),15.);(SAT:215<3:REDLOG (REDUCE LOGIC),15.);(SAT:217<3:REDLOG (REDUCE LOGIC),15.);(imply:218<3:REDLOG (REDUCE LOGIC),15.);(SAT:225<3:REDLOG (REDUCE LOGIC),15.);(imply:227<4:REDLOG (REDUCE LOGIC),15.);(imply:229<4:REDLOG (REDUCE LOGIC),15.);(imply:300<17:REDLOG (REDUCE LOGIC),15.);(imply:301<18:REDLOG (REDUCE LOGIC),15.);(imply:306<18:REDLOG (REDUCE LOGIC),15.);(imply:309<19:REDLOG (REDUCE LOGIC),15.);(imply:310<20:REDLOG (REDUCE LOGIC),15.);(imply:318<20:REDLOG (REDUCE LOGIC),15.);(imply:321<21:REDLOG (REDUCE LOGIC),15.);(imply:336<21:REDLOG (REDUCE LOGIC),15.);(imply:337<21:REDLOG (REDUCE LOGIC),15.);(imply:345<21:REDLOG (REDUCE LOGIC),15.);(SAT:350<21:REDLOG (REDUCE LOGIC),15.);(SAT:351<21:REDLOG (REDUCE LOGIC),15.);(imply:491<29:REDLOG (REDUCE LOGIC),15.);(imply:492<29:REDLOG (REDUCE LOGIC),15.);(SAT:493<29:REDLOG (REDUCE LOGIC),15.);(SAT:494<29:REDLOG (REDUCE LOGIC),15.);(imply:497<30:REDLOG (REDUCE LOGIC),15.);(imply:498<30:REDLOG (REDUCE LOGIC),15.);(imply:499<30:REDLOG (REDUCE LOGIC),15.);(imply:500<30:REDLOG (REDUCE LOGIC),15.);(imply:596<34:REDLOG (REDUCE LOGIC),15.);(imply:597<34:REDLOG (REDUCE LOGIC),15.);(imply:598<35:REDLOG (REDUCE LOGIC),15.);(imply:599<35:REDLOG (REDUCE LOGIC),15.);(imply:604<35:REDLOG (REDUCE LOGIC),15.);(imply:605<35:REDLOG (REDUCE LOGIC),15.);(imply:608<35:REDLOG (REDUCE LOGIC),15.);(SAT:612<35:REDLOG (REDUCE LOGIC),15.);(SAT:693<41:REDLOG (REDUCE LOGIC),15.);(SAT:695<41:REDLOG (REDUCE LOGIC),15.);(imply:727<42:REDLOG (REDUCE LOGIC),15.);(imply:729<42:REDLOG (REDUCE LOGIC),15.);(imply:732<42:REDLOG (REDUCE LOGIC),15.);(imply:733<42:REDLOG (REDUCE LOGIC),15.);(imply:734<43:REDLOG (REDUCE LOGIC),15.);(imply:735<43:REDLOG (REDUCE LOGIC),15.);(imply:740<43:REDLOG (REDUCE LOGIC),15.);(imply:741<43:REDLOG (REDUCE LOGIC),15.);(imply:744<43:REDLOG (REDUCE LOGIC),15.);(SAT:748<43:REDLOG (REDUCE LOGIC),15.);(SAT:831<49:REDLOG (REDUCE LOGIC),15.);(imply:863<50:REDLOG (REDUCE LOGIC),15.);(imply:865<50:REDLOG (REDUCE LOGIC),15.);(imply:872<50:REDLOG (REDUCE LOGIC),15.);(SAT:876<50:REDLOG (REDUCE LOGIC),15.);(imply:1004<58:REDLOG (REDUCE LOGIC),15.);(imply:1103<62:REDLOG (REDUCE LOGIC),15.);(imply:1106<62:REDLOG (REDUCE LOGIC),15.);(imply:1121<62:REDLOG (REDUCE LOGIC),15.)])
Total verification time: 2.351281 second(s)
	Time spent in main process: 2.330466 second(s)
	Time spent in child processes: 0.020815 second(s)


======================================

!!!Full processing file "./hip/veribsync/hip-bperm1.ss"
Parsing file "./hip/veribsync/hip-bperm1.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Reduce... 
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_15


}

class int_ptr extends Object {
int valVAL_16


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_17


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class cell extends Object {
int valVAL_18


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)


boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 93,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 92,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 91,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 89,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 88,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 87,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 86,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 78,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 77,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 75,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 74,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 73,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 72,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 70,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 69,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 68,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 67,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 66,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 65,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 64,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 63,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 62,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 59,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 58,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 57,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 56,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 53,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 52,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 51,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 49,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 48,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 46,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 45,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 44,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 43,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 42,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 41,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 40,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 39,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 37,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 36,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 35,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 34,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 33,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 32,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 31,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 30,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 29,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 28,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 27,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 26,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 25,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 24,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 23,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 22,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 21,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 20,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 19,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 18,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 17,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 16,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 15,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void testNewCell2()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 13,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: cell c
cell c = (94, ):newCell(2, 0);
member access c~~>val = 5;
(97, ):destroyCell(c)}
}
void testNewCell()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 11,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: cell c
cell c = new cell(2, 0);
member access c~~>val = 5;
(100, ):destroyCell(c)}
}
void destroyCellFail(cell c)[]
static EBase: [][](emp ; (emp ; (c::cell{}((1,2,0))<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 10,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(101, ):destroyCell(c)}
}
void updateCellFail(cell c, int newv)[]
static EBase: [][](emp ; (emp ; (c::cell{}((1,2,0))<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 8,:(emp ; (emp ; (c::cell{}((1,2,0))<newv>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int x
int x;
member access c~~>val = newv}
}
int updateCell(cell c, int newv)[]
static EBase: [][](emp ; (emp ; (c::cell{}((2,2,0))<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 5,:(emp ; (emp ; (c::cell{}((2,2,0))<newv>@M[HeapNode1])))*(res = v)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int x
int x;
x = member access c~~>val;
member access c~~>val = newv;
(108, ):return x}
}
int readCell(cell c)[]
static EBase: [][](emp ; (emp ; (c::cell{}((1,2,0))<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 3,:(emp ; (emp ; (c::cell{}((1,2,0))<v>@M[HeapNode1])))*(res = v)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int x
int x;
x = member access c~~>val;
(111, ):return x}
}
void destroyCell(cell@R ce)[]
static EBase: [][](emp ; (emp ; (ce::cell{}((c,t,a))<Anon_11>@M[HeapNode1])))*(c = t+a)( FLOW __norm) {EAssume: 2,:(emp)*(ce' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

cell newCell(int bound, int value)[]
static EBase: [][](emp)*(bound > 0)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (res::cell{}((bound,bound,0))<value>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

@@prog4

Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

WARNING: ./hip/veribsync/hip-bperm1.ss_19:10_19:18:the result type __norm#E is not covered by the throw list[]
Starting Omega...oc

Checking procedure destroyCellFail$cell... 
() :./hip/veribsync/hip-bperm1.ss:63: 2: Proving precondition in method failed


(Cause of PreCond Failure):./hip/veribsync/hip-bperm1.ss:63: 2:  List of Failesc Context: []

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/veribsync/hip-bperm1.ss",Line:63,Col:2

ERROR: at ./hip/veribsync/hip-bperm1.ss_63:2_63:16 
Message: Proving precondition in method failed.
 
Procedure destroyCellFail$cell FAIL.(2)

Exception Failure("Proving precondition in method failed.") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure destroyCellFail$cell

Checking procedure readCell$cell... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure readCell$cell SUCCESS.

Checking procedure testNewCell$... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure testNewCell$ SUCCESS.

Checking procedure testNewCell2$... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure testNewCell2$ SUCCESS.

Checking procedure updateCell$cell~int... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure updateCell$cell~int SUCCESS.

Checking procedure updateCellFail$cell~int... Proving binding in method updateCellFail$cell~int for spec  EAssume 
   (exists newv_1689,bperm_49_1690,bperm_49_1691,
   bperm_49_1692: c::cell( (bperm_49_1692,bperm_49_1691,bperm_49_1690))<newv_1689>@ rem br[{1}]&
   (
   ([newv=newv_1689][0=bperm_49_1690][2=bperm_49_1691][1=bperm_49_1692]
    [c!=null]))&
   {FLOW,(4,5)=__norm#E})[]
   , Line 0

( []) bind: node  c'::cell( (cbperm_1850,tbperm_1851,abperm_1852))<val_53_1497'> cannot be derived from context
./hip/veribsync/hip-bperm1.ss_53:2_53:7

(Cause of Bind Failure) List of Failesc Context: [FEC(1, 0, 0 )]
Failed States:
[
 Label: []
 State:
        fe_kind: MAY
        fe_name: logical bug
        fe_locs: {
                  fc_message: failed in entailing pure formula(s) in conseq
                  fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[ SEARCH ==>  Match(c,c') ==> ]]
 ]./hip/veribsync/hip-bperm1.ss_53:2_53:7

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/veribsync/hip-bperm1.ss",Line:53,Col:2

Procedure updateCellFail$cell~int FAIL.(2)

Exception Failure("Proving precond failed") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure updateCellFail$cell~int
Halting Reduce... 
Stopping Reduce... 
Stop Omega... 23 invocations 
0 false contexts at: ()

!!! log(small):(0.191446,595)
!!! 
 log(bigger)(>4s)(80):(1200.,[(SAT:1<0:REDLOG (REDUCE LOGIC),15.);(SAT:2<0:REDLOG (REDUCE LOGIC),15.);(SAT:5<0:REDLOG (REDUCE LOGIC),15.);(SAT:6<0:REDLOG (REDUCE LOGIC),15.);(SAT:121<0:REDLOG (REDUCE LOGIC),15.);(SAT:122<0:REDLOG (REDUCE LOGIC),15.);(SAT:126<0:REDLOG (REDUCE LOGIC),15.);(SAT:130<0:REDLOG (REDUCE LOGIC),15.);(SAT:131<0:REDLOG (REDUCE LOGIC),15.);(SAT:132<0:REDLOG (REDUCE LOGIC),15.);(SAT:133<0:REDLOG (REDUCE LOGIC),15.);(SAT:134<0:REDLOG (REDUCE LOGIC),15.);(SAT:145<0:REDLOG (REDUCE LOGIC),15.);(SAT:146<0:REDLOG (REDUCE LOGIC),15.);(SAT:147<0:REDLOG (REDUCE LOGIC),15.);(SAT:148<0:REDLOG (REDUCE LOGIC),15.);(SAT:149<0:REDLOG (REDUCE LOGIC),15.);(SAT:150<0:REDLOG (REDUCE LOGIC),15.);(SAT:152<0:REDLOG (REDUCE LOGIC),15.);(SAT:153<0:REDLOG (REDUCE LOGIC),15.);(SAT:154<0:REDLOG (REDUCE LOGIC),15.);(SAT:158<0:REDLOG (REDUCE LOGIC),15.);(SAT:159<0:REDLOG (REDUCE LOGIC),15.);(SAT:160<0:REDLOG (REDUCE LOGIC),15.);(SAT:161<0:REDLOG (REDUCE LOGIC),15.);(SAT:162<0:REDLOG (REDUCE LOGIC),15.);(SAT:165<0:REDLOG (REDUCE LOGIC),15.);(SAT:166<0:REDLOG (REDUCE LOGIC),15.);(SAT:167<0:REDLOG (REDUCE LOGIC),15.);(SAT:168<0:REDLOG (REDUCE LOGIC),15.);(SAT:169<0:REDLOG (REDUCE LOGIC),15.);(SAT:171<0:REDLOG (REDUCE LOGIC),15.);(SAT:176<0:REDLOG (REDUCE LOGIC),15.);(SAT:177<0:REDLOG (REDUCE LOGIC),15.);(SAT:178<0:REDLOG (REDUCE LOGIC),15.);(SAT:179<0:REDLOG (REDUCE LOGIC),15.);(SAT:182<0:REDLOG (REDUCE LOGIC),15.);(SAT:183<0:REDLOG (REDUCE LOGIC),15.);(SAT:187<0:REDLOG (REDUCE LOGIC),15.);(SAT:192<1:REDLOG (REDUCE LOGIC),15.);(SAT:193<1:REDLOG (REDUCE LOGIC),15.);(SAT:194<1:REDLOG (REDUCE LOGIC),15.);(SAT:195<1:REDLOG (REDUCE LOGIC),15.);(SAT:196<1:REDLOG (REDUCE LOGIC),15.);(SAT:197<1:REDLOG (REDUCE LOGIC),15.);(SAT:199<2:REDLOG (REDUCE LOGIC),15.);(SAT:201<2:REDLOG (REDUCE LOGIC),15.);(SAT:220<5:REDLOG (REDUCE LOGIC),15.);(SAT:221<5:REDLOG (REDUCE LOGIC),15.);(SAT:246<9:REDLOG (REDUCE LOGIC),15.);(SAT:254<9:REDLOG (REDUCE LOGIC),15.);(SAT:263<11:REDLOG (REDUCE LOGIC),15.);(SAT:269<12:REDLOG (REDUCE LOGIC),15.);(SAT:271<12:REDLOG (REDUCE LOGIC),15.);(SAT:278<13:REDLOG (REDUCE LOGIC),15.);(SAT:280<13:REDLOG (REDUCE LOGIC),15.);(SAT:288<13:REDLOG (REDUCE LOGIC),15.);(SAT:300<16:REDLOG (REDUCE LOGIC),15.);(SAT:301<16:REDLOG (REDUCE LOGIC),15.);(SAT:302<16:REDLOG (REDUCE LOGIC),15.);(SAT:337<20:REDLOG (REDUCE LOGIC),15.);(SAT:341<20:REDLOG (REDUCE LOGIC),15.);(SAT:349<21:REDLOG (REDUCE LOGIC),15.);(SAT:358<22:REDLOG (REDUCE LOGIC),15.);(SAT:363<22:REDLOG (REDUCE LOGIC),15.);(SAT:390<27:REDLOG (REDUCE LOGIC),15.);(SAT:393<28:REDLOG (REDUCE LOGIC),15.);(SAT:416<31:REDLOG (REDUCE LOGIC),15.);(SAT:419<31:REDLOG (REDUCE LOGIC),15.);(SAT:451<35:REDLOG (REDUCE LOGIC),15.);(SAT:463<36:REDLOG (REDUCE LOGIC),15.);(SAT:473<37:REDLOG (REDUCE LOGIC),15.);(SAT:479<37:REDLOG (REDUCE LOGIC),15.);(SAT:487<38:REDLOG (REDUCE LOGIC),15.);(SAT:512<41:REDLOG (REDUCE LOGIC),15.);(SAT:545<45:REDLOG (REDUCE LOGIC),15.);(SAT:575<48:REDLOG (REDUCE LOGIC),15.);(SAT:582<48:REDLOG (REDUCE LOGIC),15.);(SAT:584<48:REDLOG (REDUCE LOGIC),15.);(SAT:603<50:REDLOG (REDUCE LOGIC),15.)])
Total verification time: 0.924397 second(s)
	Time spent in main process: 0.623514 second(s)
	Time spent in child processes: 0.300883 second(s)


======================================

!!!Full processing file "./hip/veribsync/barrier-static-consistency.ss"
Parsing file "./hip/veribsync/barrier-static-consistency.ss" by default parser...

!!! processing primitives "["prelude.ss"]

!!! processing includes "[barrier_static_header.ss]Starting Reduce... 
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_15


}

class int_ptr extends Object {
int valVAL_16


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_17


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class Object extends  {



}

class String extends Object {



}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)

lemmas(to be proved and saved)[
=>coerc S-COMBINE
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::barrier{}((c1,t,0))<p>@M[HeapNode1]) * (self::barrier{}((c2,t,0))<p>@M[HeapNode1]))))*(true)( FLOW __norm)
	 body:(emp ; (emp ; (self::barrier{}((c1+c2,t,0))<p>@M[HeapNode1])))*(true)( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc S-SPLIT
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; (self::barrier{}((c,t,0))<p>@M[HeapNode1])))*(((0 < c) & (c <= t)) & ((c = c1+c2) & (((0 < c1) & (c1 < t)) & ((0 < c2) & (c2 < t)))))( FLOW __norm)
	 body:(emp ; (emp ; ((self::barrier{}((c1,t,0))<p>@M[HeapNode1]) * (self::barrier{}((c2,t,0))<p>@M[HeapNode1]))))*(true)( FLOW __norm)
]

boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 80,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 79,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 69,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 68,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 66,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 65,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 64,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 63,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 62,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 60,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 59,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 57,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 56,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 55,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 54,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 53,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 52,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 51,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 50,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 48,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 47,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 45,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 35,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 34,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 33,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 29,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 28,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 27,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 26,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 25,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 24,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 22,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 21,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 20,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 16,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 15,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 14,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 13,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 9,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 8,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 7,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 6,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void waitBarrier(barrier b)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((c,t,0))<p>@M[HeapNode1])))*(c = 1)( FLOW __norm) {EAssume: 87,:(emp ; (emp ; (b::barrier{}((c,t,0))<p+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

barrier newBarrier(int bound)[]
static EBase: [][](emp)*(bound > 0)( FLOW __norm) {EAssume: 86,:(emp ; (emp ; (res::barrier{}((bound,bound,0))<0>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void destroyBarrier(barrier@R b)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((c,t,0))<Anon_14>@M[HeapNode1])))*(c = t)( FLOW __norm) {EAssume: 85,:(emp)*(b' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void main()[]
static EBase: [][](emp ; (emp ; emp))*(true)( FLOW __norm) {EAssume: 5,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: barrier b1,barrier b2,int id1,int id2
barrier b1 = (88, ):newBarrier(2);
barrier b2 = (89, ):newBarrier(2);
int id1 = (90, ):fork(participant_fail, b1, b1);
int id2 = (91, ):fork(participant_fail, b2, b2);
(92, ):join(id1);
(93, ):join(id2);
(94, ):destroyBarrier(b1);
(95, ):destroyBarrier(b2)}
}
void main_fail()[]
static EBase: [][](emp ; (emp ; emp))*(true)( FLOW __norm) {EAssume: 4,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: barrier b1,int id1
barrier b1 = (96, ):newBarrier(2);
int id1 = (97, ):fork(participant1, b1);
(98, ):join(id1);
(99, ):destroyBarrier(b1)}
}
void participant1(barrier b1)[]
static EBase: [][](emp ; (emp ; (b1::barrier{}((1,2,0))<p>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 3,:(emp ; (emp ; (b1::barrier{}((1,2,0))<p+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(100, ):waitBarrier(b1)}
}
void participant(barrier b1, barrier b2)[]
static EBase: [][](emp ; (emp ; ((b1::barrier{}((1,2,0))<0>@M[HeapNode1]) * (b2::barrier{}((1,2,0))<0>@M[HeapNode1]))))*(b1 != b2)( FLOW __norm) {EAssume: 2,:(emp ; (emp ; ((b1::barrier{}((1,2,0))<1>@M[HeapNode1]) * (b2::barrier{}((1,2,0))<1>@M[HeapNode1]))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(101, ):waitBarrier(b1);
(102, ):waitBarrier(b2)}
}
void participant_fail(barrier b1, barrier b2)[]
static EBase: [][](emp ; (emp ; ((b1::barrier{}((1,2,0))<0>@M[HeapNode1]) * (b2::barrier{}((1,2,0))<0>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; ((b1::barrier{}((1,2,0))<1>@M[HeapNode1]) * (b2::barrier{}((1,2,0))<1>@M[HeapNode1]))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(103, ):waitBarrier(b1);
(104, ):waitBarrier(b2)}
}
@@prog4

Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

WARNING: ./hip/veribsync/barrier_static_header.ss_15:10_15:17:the result type __norm#E is not covered by the throw list[]
Starting Omega...oc

Checking procedure main$... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure main$ SUCCESS.

Checking procedure main_fail$... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

procedure call:./hip/veribsync/barrier-static-consistency.ss:43: 2: join(id1_74') has failed.
 List of Failesc Context: [FEC(1, 0, 0 )]
Failed States:
[
 Label: []
 State:
        fe_kind: MAY
        fe_name: Possibly inconsistent state
        fe_locs: {
                  fc_message: Possibly inconsistent state detected
                  fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]
 ] 


() :./hip/veribsync/barrier-static-consistency.ss:45: 2: Proving precondition in method failed


(Cause of PreCond Failure):./hip/veribsync/barrier-static-consistency.ss:45: 2:  List of Failesc Context: []

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/veribsync/barrier-static-consistency.ss",Line:45,Col:2

ERROR: at ./hip/veribsync/barrier-static-consistency.ss_45:2_45:20 
Message: Proving precondition in method failed.
 
Procedure main_fail$ FAIL.(2)

Exception Failure("Proving precondition in method failed.") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure main_fail$

Checking procedure participant$barrier~barrier... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure participant$barrier~barrier SUCCESS.

Checking procedure participant1$barrier... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure participant1$barrier SUCCESS.

Checking procedure participant_fail$barrier~barrier... 
( []) :./hip/veribsync/barrier-static-consistency.ss:15: 2: Proving precondition in method failed


(Cause of PreCond Failure):./hip/veribsync/barrier-static-consistency.ss:15: 2:  List of Failesc Context: [FEC(1, 0, 0 )]
Failed States:
[
 Label: []
 State:
        fe_kind: MAY
        fe_name: Possibly inconsistent state
        fe_locs: {
                  fc_message: Possibly inconsistent state detected
                  fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]
 ]

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/veribsync/barrier-static-consistency.ss",Line:15,Col:2

ERROR: at ./hip/veribsync/barrier-static-consistency.ss_15:2_15:17 
Message: Proving precondition in method failed.
 
Procedure participant_fail$barrier~barrier FAIL.(2)

Exception Failure("Proving precondition in method failed.") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure participant_fail$barrier~barrier
Halting Reduce... 
Stopping Reduce... 
Stop Omega... 92 invocations 
0 false contexts at: ()

!!! log(small):(1.546909,1520)
!!! 
 log(bigger)(>4s)(97):(1455.,[(SAT:1<0:REDLOG (REDUCE LOGIC),15.);(SAT:2<0:REDLOG (REDUCE LOGIC),15.);(SAT:5<0:REDLOG (REDUCE LOGIC),15.);(SAT:6<0:REDLOG (REDUCE LOGIC),15.);(SAT:113<0:REDLOG (REDUCE LOGIC),15.);(SAT:114<0:REDLOG (REDUCE LOGIC),15.);(SAT:118<0:REDLOG (REDUCE LOGIC),15.);(SAT:122<0:REDLOG (REDUCE LOGIC),15.);(SAT:123<0:REDLOG (REDUCE LOGIC),15.);(SAT:124<0:REDLOG (REDUCE LOGIC),15.);(SAT:125<0:REDLOG (REDUCE LOGIC),15.);(SAT:126<0:REDLOG (REDUCE LOGIC),15.);(SAT:137<0:REDLOG (REDUCE LOGIC),15.);(SAT:138<0:REDLOG (REDUCE LOGIC),15.);(SAT:139<0:REDLOG (REDUCE LOGIC),15.);(SAT:140<0:REDLOG (REDUCE LOGIC),15.);(SAT:141<0:REDLOG (REDUCE LOGIC),15.);(SAT:142<0:REDLOG (REDUCE LOGIC),15.);(SAT:144<0:REDLOG (REDUCE LOGIC),15.);(SAT:145<0:REDLOG (REDUCE LOGIC),15.);(SAT:146<0:REDLOG (REDUCE LOGIC),15.);(SAT:150<0:REDLOG (REDUCE LOGIC),15.);(SAT:151<0:REDLOG (REDUCE LOGIC),15.);(SAT:152<0:REDLOG (REDUCE LOGIC),15.);(SAT:153<0:REDLOG (REDUCE LOGIC),15.);(SAT:154<0:REDLOG (REDUCE LOGIC),15.);(SAT:157<0:REDLOG (REDUCE LOGIC),15.);(SAT:158<0:REDLOG (REDUCE LOGIC),15.);(SAT:159<0:REDLOG (REDUCE LOGIC),15.);(SAT:160<0:REDLOG (REDUCE LOGIC),15.);(SAT:161<0:REDLOG (REDUCE LOGIC),15.);(SAT:163<0:REDLOG (REDUCE LOGIC),15.);(SAT:168<0:REDLOG (REDUCE LOGIC),15.);(SAT:169<0:REDLOG (REDUCE LOGIC),15.);(SAT:170<0:REDLOG (REDUCE LOGIC),15.);(SAT:171<0:REDLOG (REDUCE LOGIC),15.);(SAT:174<0:REDLOG (REDUCE LOGIC),15.);(SAT:175<0:REDLOG (REDUCE LOGIC),15.);(SAT:179<0:REDLOG (REDUCE LOGIC),15.);(SAT:181<0:REDLOG (REDUCE LOGIC),15.);(SAT:182<0:REDLOG (REDUCE LOGIC),15.);(SAT:192<2:REDLOG (REDUCE LOGIC),15.);(SAT:203<4:REDLOG (REDUCE LOGIC),15.);(SAT:204<4:REDLOG (REDUCE LOGIC),15.);(SAT:225<6:REDLOG (REDUCE LOGIC),15.);(SAT:226<6:REDLOG (REDUCE LOGIC),15.);(SAT:229<6:REDLOG (REDUCE LOGIC),15.);(SAT:230<6:REDLOG (REDUCE LOGIC),15.);(SAT:234<7:REDLOG (REDUCE LOGIC),15.);(SAT:235<7:REDLOG (REDUCE LOGIC),15.);(SAT:298<14:REDLOG (REDUCE LOGIC),15.);(SAT:299<14:REDLOG (REDUCE LOGIC),15.);(SAT:301<14:REDLOG (REDUCE LOGIC),15.);(SAT:304<14:REDLOG (REDUCE LOGIC),15.);(SAT:346<18:REDLOG (REDUCE LOGIC),15.);(SAT:356<18:REDLOG (REDUCE LOGIC),15.);(SAT:363<19:REDLOG (REDUCE LOGIC),15.);(SAT:408<25:REDLOG (REDUCE LOGIC),15.);(SAT:411<25:REDLOG (REDUCE LOGIC),15.);(SAT:447<27:REDLOG (REDUCE LOGIC),15.);(SAT:454<27:REDLOG (REDUCE LOGIC),15.);(SAT:508<34:REDLOG (REDUCE LOGIC),15.);(SAT:585<36:REDLOG (REDUCE LOGIC),15.);(SAT:586<36:REDLOG (REDUCE LOGIC),15.);(SAT:593<38:REDLOG (REDUCE LOGIC),15.);(SAT:633<40:REDLOG (REDUCE LOGIC),15.);(SAT:664<40:REDLOG (REDUCE LOGIC),15.);(SAT:695<40:REDLOG (REDUCE LOGIC),15.);(SAT:847<48:REDLOG (REDUCE LOGIC),15.);(SAT:848<48:REDLOG (REDUCE LOGIC),15.);(SAT:924<52:REDLOG (REDUCE LOGIC),15.);(SAT:952<52:REDLOG (REDUCE LOGIC),15.);(SAT:954<52:REDLOG (REDUCE LOGIC),15.);(SAT:957<52:REDLOG (REDUCE LOGIC),15.);(SAT:1002<53:REDLOG (REDUCE LOGIC),15.);(SAT:1015<54:REDLOG (REDUCE LOGIC),15.);(SAT:1016<54:REDLOG (REDUCE LOGIC),15.);(SAT:1042<54:REDLOG (REDUCE LOGIC),15.);(SAT:1127<65:REDLOG (REDUCE LOGIC),15.);(SAT:1136<65:REDLOG (REDUCE LOGIC),15.);(SAT:1144<66:REDLOG (REDUCE LOGIC),15.);(SAT:1161<67:REDLOG (REDUCE LOGIC),15.);(SAT:1169<67:REDLOG (REDUCE LOGIC),15.);(SAT:1171<67:REDLOG (REDUCE LOGIC),15.);(SAT:1186<74:REDLOG (REDUCE LOGIC),15.);(SAT:1224<77:REDLOG (REDUCE LOGIC),15.);(SAT:1234<78:REDLOG (REDUCE LOGIC),15.);(SAT:1272<82:REDLOG (REDUCE LOGIC),15.);(SAT:1323<86:REDLOG (REDUCE LOGIC),15.);(SAT:1362<88:REDLOG (REDUCE LOGIC),15.);(SAT:1384<91:REDLOG (REDUCE LOGIC),15.);(SAT:1404<93:REDLOG (REDUCE LOGIC),15.);(SAT:1409<93:REDLOG (REDUCE LOGIC),15.);(SAT:1427<95:REDLOG (REDUCE LOGIC),15.);(SAT:1441<96:REDLOG (REDUCE LOGIC),15.);(SAT:1445<96:REDLOG (REDUCE LOGIC),15.);(SAT:1459<98:REDLOG (REDUCE LOGIC),15.)])
Total verification time: 2.365844 second(s)
	Time spent in main process: 1.982435 second(s)
	Time spent in child processes: 0.383409 second(s)


======================================

!!!Full processing file "./hip/veribsync/barrier-dynamic-exp3.ss"
Parsing file "./hip/veribsync/barrier-dynamic-exp3.ss" by default parser...

!!! processing primitives "["prelude.ss"]

!!! processing includes "[barrier_dynamic_header.ss]Starting Reduce... 
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_15


}

class int_ptr extends Object {
int valVAL_16


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_17


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class Object extends  {



}

class String extends Object {



}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)

lemmas(to be proved and saved)[
=>coerc D-COMBINE-3
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::barrier{}((0,t,a1))<p1>@M[HeapNode1]) * (self::barrier{}((0,t,a2))<p2>@M[HeapNode1]))))*(true)( FLOW __norm)
	 body:(emp ; (emp ; (self::barrier{}((0,t,a1+a2))<p>@M[HeapNode1])))*(p = max(p1,p2))( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc D-COMBINE-2
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::barrier{}((c1,t,a1))<p1>@M[HeapNode1]) * (self::barrier{}((c2,t,a2))<p2>@M[HeapNode1]))))*((c1 != 0) & ((c2 = 0) & (p2 <= p1)))( FLOW __norm)
	 body:(emp ; (emp ; (self::barrier{}((c1,t,a1+a2))<p1>@M[HeapNode1])))*(true)( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc D-COMBINE-1
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::barrier{}((c1,t,a1))<p>@M[HeapNode1]) * (self::barrier{}((c2,t,a2))<p>@M[HeapNode1]))))*((c1 != 0) & (c2 != 0))( FLOW __norm)
	 body:(emp ; (emp ; (self::barrier{}((c1+c2,t,a1+a2))<p>@M[HeapNode1])))*(true)( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc D-FULL
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; (self::barrier{}((c,t,a))<p>@M[HeapNode1])))*((c = t+a) & ((a != 0) & (c > 0)))( FLOW __norm)
	 body:(emp ; (emp ; (self::barrier{}((c,t+a,0))<p>@M[HeapNode1])))*(true)( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc D-SPLIT
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; (self::barrier{}((c,t,a))<p>@M[HeapNode1])))*(((0 < c) & (c <= t+a)) & ((c = c1+c2) & ((a = a1+a2) & (((0 < c1) & (c1 < t+a1)) & (((0 < c2) & (c2 < t+a2)) & ((((a1) * (c)) = ((c1) * (a))) & (((a2) * (c)) = ((c2) * (a)))))))))( FLOW __norm)
	 body:(emp ; (emp ; ((self::barrier{}((c1,t,a1))<p>@M[HeapNode1]) * (self::barrier{}((c2,t,a2))<p>@M[HeapNode1]))))*(true)( FLOW __norm)
]

boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 79,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 78,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 68,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 67,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 66,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 65,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 64,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 63,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 62,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 61,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 60,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 59,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 58,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 57,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 56,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 55,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 54,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 51,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 50,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 49,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 48,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 47,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 45,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 44,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 34,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 33,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 32,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 31,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 29,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 28,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 27,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 26,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 25,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 24,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 23,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 22,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 21,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 20,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 19,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 18,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 16,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 15,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 14,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 13,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 12,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 10,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 9,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 8,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 7,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 6,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void removeParticipant(barrier b, int m)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((c,t,a))<p>@M[HeapNode1])))*((c >= m) & (m > 0))( FLOW __norm) {EAssume: 88,:(emp ; (emp ; (b::barrier{}((c-m,t,a-m))<p>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void addParticipant(barrier b, int m)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((c,t,a))<p>@M[HeapNode1])))*((c > 0) & (m > 0))( FLOW __norm) {EAssume: 87,:(emp ; (emp ; (b::barrier{}((c+m,t,a+m))<p>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void waitBarrier(barrier b)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((c,t,a))<p>@M[HeapNode1])))*(c = 1)( FLOW __norm) {EAssume: 86,:(emp ; (emp ; (b::barrier{}((c,t,a))<p+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

barrier newBarrier(int bound)[]
static EBase: [][](emp)*(bound > 0)( FLOW __norm) {EAssume: 85,:(emp ; (emp ; (res::barrier{}((bound,bound,0))<0>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void destroyBarrier(barrier@R b)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((c,t,a))<Anon_14>@M[HeapNode1])))*(c = t+a)( FLOW __norm) {EAssume: 84,:(emp)*(b' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void main()[]
static EBase: [][](emp ; (emp ; emp))*(true)( FLOW __norm) {EAssume: 4,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: barrier b,int id1,int id2,int id3
barrier b = (89, ):newBarrier(2);
(90, ):addParticipant(b, 1);
int id1 = (91, ):fork(thread1, b);
int id2 = (92, ):fork(thread2, b);
int id3 = (93, ):fork(thread3, b);
(94, ):join(id1);
(95, ):join(id2);
(96, ):join(id3);
(97, ):destroyBarrier(b)}
}
void thread3(barrier b)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((1,3,0))<0>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 3,:(emp ; (emp ; (b::barrier{}((0,3,0-1))<1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(98, ):waitBarrier(b);
(99, ):removeParticipant(b, 1)}
}
void thread2(barrier b)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((1,3,0))<0>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 2,:(emp ; (emp ; (b::barrier{}((0,3,0-1))<3>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(100, ):waitBarrier(b);
(101, ):waitBarrier(b);
(102, ):waitBarrier(b);
(103, ):removeParticipant(b, 1)}
}
void thread1(barrier b)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((1,3,0))<0>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (b::barrier{}((1,3,0))<2>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(104, ):waitBarrier(b);
(105, ):waitBarrier(b)}
}
@@prog4

Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

WARNING: ./hip/veribsync/barrier_dynamic_header.ss_41:10_41:17:the result type __norm#E is not covered by the throw list[]
Starting Omega...oc

Checking procedure main$... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

procedure call:./hip/veribsync/barrier-dynamic-exp3.ss:65: 2: join(id2_89') has failed.
 List of Failesc Context: [FEC(1, 0, 0 ) FEC(1, 0, 0 )]
Failed States:
[
 Label: []
 State:
        fe_kind: MAY
        fe_name: Possibly inconsistent state
        fe_locs: {
                  fc_message: Possibly inconsistent state detected
                  fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]
 ],
Failed States:
[
 Label: []
 State:
        fe_kind: MAY
        fe_name: Possibly inconsistent state
        fe_locs: {
                  fc_message: Possibly inconsistent state detected
                  fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]
 ] 


procedure call:./hip/veribsync/barrier-dynamic-exp3.ss:68: 2: 
empty/false context: Proving precondition in method join$int has failed 


() :./hip/veribsync/barrier-dynamic-exp3.ss:70: 2: Proving precondition in method failed


(Cause of PreCond Failure):./hip/veribsync/barrier-dynamic-exp3.ss:70: 2:  List of Failesc Context: []

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/veribsync/barrier-dynamic-exp3.ss",Line:70,Col:2

ERROR: at ./hip/veribsync/barrier-dynamic-exp3.ss_70:2_70:19 
Message: Proving precondition in method failed.
 
Procedure main$ FAIL.(2)

Exception Failure("Proving precondition in method failed.") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure main$

Checking procedure thread1$barrier... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure thread1$barrier SUCCESS.

Checking procedure thread2$barrier... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure thread2$barrier SUCCESS.

Checking procedure thread3$barrier... 
Procedure thread3$barrier SUCCESS.
Halting Reduce... 
Stopping Reduce... 
Stop Omega... 86 invocations 
0 false contexts at: ()

!!! log(small):(2.600526,2174)
!!! 
 log(bigger)(>4s)(128):(1920.,[(SAT:1<0:REDLOG (REDUCE LOGIC),15.);(SAT:2<0:REDLOG (REDUCE LOGIC),15.);(SAT:5<0:REDLOG (REDUCE LOGIC),15.);(SAT:6<0:REDLOG (REDUCE LOGIC),15.);(SAT:113<0:REDLOG (REDUCE LOGIC),15.);(SAT:114<0:REDLOG (REDUCE LOGIC),15.);(SAT:118<0:REDLOG (REDUCE LOGIC),15.);(SAT:122<0:REDLOG (REDUCE LOGIC),15.);(SAT:123<0:REDLOG (REDUCE LOGIC),15.);(SAT:124<0:REDLOG (REDUCE LOGIC),15.);(SAT:125<0:REDLOG (REDUCE LOGIC),15.);(SAT:126<0:REDLOG (REDUCE LOGIC),15.);(SAT:137<0:REDLOG (REDUCE LOGIC),15.);(SAT:138<0:REDLOG (REDUCE LOGIC),15.);(SAT:139<0:REDLOG (REDUCE LOGIC),15.);(SAT:140<0:REDLOG (REDUCE LOGIC),15.);(SAT:141<0:REDLOG (REDUCE LOGIC),15.);(SAT:142<0:REDLOG (REDUCE LOGIC),15.);(SAT:144<0:REDLOG (REDUCE LOGIC),15.);(SAT:145<0:REDLOG (REDUCE LOGIC),15.);(SAT:146<0:REDLOG (REDUCE LOGIC),15.);(SAT:150<0:REDLOG (REDUCE LOGIC),15.);(SAT:151<0:REDLOG (REDUCE LOGIC),15.);(SAT:152<0:REDLOG (REDUCE LOGIC),15.);(SAT:153<0:REDLOG (REDUCE LOGIC),15.);(SAT:154<0:REDLOG (REDUCE LOGIC),15.);(SAT:157<0:REDLOG (REDUCE LOGIC),15.);(SAT:158<0:REDLOG (REDUCE LOGIC),15.);(SAT:159<0:REDLOG (REDUCE LOGIC),15.);(SAT:160<0:REDLOG (REDUCE LOGIC),15.);(SAT:161<0:REDLOG (REDUCE LOGIC),15.);(SAT:163<0:REDLOG (REDUCE LOGIC),15.);(SAT:168<0:REDLOG (REDUCE LOGIC),15.);(SAT:169<0:REDLOG (REDUCE LOGIC),15.);(SAT:170<0:REDLOG (REDUCE LOGIC),15.);(SAT:171<0:REDLOG (REDUCE LOGIC),15.);(SAT:174<0:REDLOG (REDUCE LOGIC),15.);(SAT:175<0:REDLOG (REDUCE LOGIC),15.);(SAT:179<0:REDLOG (REDUCE LOGIC),15.);(SAT:181<0:REDLOG (REDUCE LOGIC),15.);(SAT:182<0:REDLOG (REDUCE LOGIC),15.);(SAT:192<2:REDLOG (REDUCE LOGIC),15.);(SAT:203<4:REDLOG (REDUCE LOGIC),15.);(SAT:204<4:REDLOG (REDUCE LOGIC),15.);(SAT:213<5:REDLOG (REDUCE LOGIC),15.);(SAT:214<5:REDLOG (REDUCE LOGIC),15.);(SAT:222<6:REDLOG (REDUCE LOGIC),15.);(SAT:279<12:REDLOG (REDUCE LOGIC),15.);(SAT:280<12:REDLOG (REDUCE LOGIC),15.);(SAT:283<12:REDLOG (REDUCE LOGIC),15.);(SAT:284<12:REDLOG (REDUCE LOGIC),15.);(SAT:288<13:REDLOG (REDUCE LOGIC),15.);(SAT:289<13:REDLOG (REDUCE LOGIC),15.);(SAT:296<15:REDLOG (REDUCE LOGIC),15.);(SAT:303<15:REDLOG (REDUCE LOGIC),15.);(SAT:344<19:REDLOG (REDUCE LOGIC),15.);(SAT:400<25:REDLOG (REDUCE LOGIC),15.);(SAT:401<25:REDLOG (REDUCE LOGIC),15.);(SAT:402<25:REDLOG (REDUCE LOGIC),15.);(SAT:419<26:REDLOG (REDUCE LOGIC),15.);(imply:424<28:REDLOG (REDUCE LOGIC),15.);(SAT:439<29:REDLOG (REDUCE LOGIC),15.);(imply:444<31:REDLOG (REDUCE LOGIC),15.);(SAT:456<32:REDLOG (REDUCE LOGIC),15.);(SAT:512<35:REDLOG (REDUCE LOGIC),15.);(SAT:522<36:REDLOG (REDUCE LOGIC),15.);(imply:558<38:REDLOG (REDUCE LOGIC),15.);(SAT:560<38:REDLOG (REDUCE LOGIC),15.);(SAT:571<39:REDLOG (REDUCE LOGIC),15.);(imply:577<40:REDLOG (REDUCE LOGIC),15.);(SAT:579<40:REDLOG (REDUCE LOGIC),15.);(SAT:608<43:REDLOG (REDUCE LOGIC),15.);(SAT:618<43:REDLOG (REDUCE LOGIC),15.);(SAT:620<44:REDLOG (REDUCE LOGIC),15.);(imply:656<46:REDLOG (REDUCE LOGIC),15.);(imply:658<47:REDLOG (REDUCE LOGIC),15.);(imply:662<48:REDLOG (REDUCE LOGIC),15.);(imply:663<48:REDLOG (REDUCE LOGIC),15.);(imply:664<48:REDLOG (REDUCE LOGIC),15.);(imply:665<48:REDLOG (REDUCE LOGIC),15.);(SAT:670<48:REDLOG (REDUCE LOGIC),15.);(SAT:682<48:REDLOG (REDUCE LOGIC),15.);(imply:683<48:REDLOG (REDUCE LOGIC),15.);(SAT:685<48:REDLOG (REDUCE LOGIC),15.);(SAT:697<49:REDLOG (REDUCE LOGIC),15.);(imply:770<54:REDLOG (REDUCE LOGIC),15.);(imply:789<56:REDLOG (REDUCE LOGIC),15.);(SAT:791<56:REDLOG (REDUCE LOGIC),15.);(SAT:820<59:REDLOG (REDUCE LOGIC),15.);(SAT:834<60:REDLOG (REDUCE LOGIC),15.);(imply:876<62:REDLOG (REDUCE LOGIC),15.);(imply:878<63:REDLOG (REDUCE LOGIC),15.);(imply:879<63:REDLOG (REDUCE LOGIC),15.);(imply:880<63:REDLOG (REDUCE LOGIC),15.);(SAT:895<63:REDLOG (REDUCE LOGIC),15.);(SAT:896<63:REDLOG (REDUCE LOGIC),15.);(imply:897<63:REDLOG (REDUCE LOGIC),15.);(SAT:910<64:REDLOG (REDUCE LOGIC),15.);(SAT:953<68:REDLOG (REDUCE LOGIC),15.);(SAT:968<68:REDLOG (REDUCE LOGIC),15.);(SAT:981<68:REDLOG (REDUCE LOGIC),15.);(SAT:1001<70:REDLOG (REDUCE LOGIC),15.);(SAT:1010<71:REDLOG (REDUCE LOGIC),15.);(SAT:1087<76:REDLOG (REDUCE LOGIC),15.);(SAT:1091<76:REDLOG (REDUCE LOGIC),15.);(SAT:1104<76:REDLOG (REDUCE LOGIC),15.);(SAT:1107<76:REDLOG (REDUCE LOGIC),15.);(SAT:1201<105:REDLOG (REDUCE LOGIC),15.);(SAT:1203<105:REDLOG (REDUCE LOGIC),15.);(SAT:1204<105:REDLOG (REDUCE LOGIC),15.);(SAT:1210<106:REDLOG (REDUCE LOGIC),15.);(SAT:1227<107:REDLOG (REDUCE LOGIC),15.);(SAT:1236<108:REDLOG (REDUCE LOGIC),15.);(SAT:1285<114:REDLOG (REDUCE LOGIC),15.);(SAT:1312<116:REDLOG (REDUCE LOGIC),15.);(SAT:1321<117:REDLOG (REDUCE LOGIC),15.);(SAT:1361<121:REDLOG (REDUCE LOGIC),15.);(SAT:1362<121:REDLOG (REDUCE LOGIC),15.);(SAT:1393<123:REDLOG (REDUCE LOGIC),15.);(SAT:1604<145:REDLOG (REDUCE LOGIC),15.);(SAT:1613<146:REDLOG (REDUCE LOGIC),15.);(SAT:1680<153:REDLOG (REDUCE LOGIC),15.);(SAT:1695<153:REDLOG (REDUCE LOGIC),15.);(SAT:1774<158:REDLOG (REDUCE LOGIC),15.);(SAT:1819<163:REDLOG (REDUCE LOGIC),15.);(SAT:1820<163:REDLOG (REDUCE LOGIC),15.);(SAT:1822<163:REDLOG (REDUCE LOGIC),15.);(SAT:1862<165:REDLOG (REDUCE LOGIC),15.)])
Total verification time: 4.112035 second(s)
	Time spent in main process: 3.464257 second(s)
	Time spent in child processes: 0.647778 second(s)


======================================

!!!Full processing file "./hip/veribsync/barrier-dynamic-exp4.ss"
Parsing file "./hip/veribsync/barrier-dynamic-exp4.ss" by default parser...

!!! processing primitives "["prelude.ss"]

!!! processing includes "[barrier_dynamic_header.ss]Starting Reduce... 
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_15


}

class int_ptr extends Object {
int valVAL_16


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_17


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class Object extends  {



}

class String extends Object {



}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)

lemmas(to be proved and saved)[
=>coerc D-COMBINE-3
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::barrier{}((0,t,a1))<p1>@M[HeapNode1]) * (self::barrier{}((0,t,a2))<p2>@M[HeapNode1]))))*(true)( FLOW __norm)
	 body:(emp ; (emp ; (self::barrier{}((0,t,a1+a2))<p>@M[HeapNode1])))*(p = max(p1,p2))( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc D-COMBINE-2
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::barrier{}((c1,t,a1))<p1>@M[HeapNode1]) * (self::barrier{}((c2,t,a2))<p2>@M[HeapNode1]))))*((c1 != 0) & ((c2 = 0) & (p2 <= p1)))( FLOW __norm)
	 body:(emp ; (emp ; (self::barrier{}((c1,t,a1+a2))<p1>@M[HeapNode1])))*(true)( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc D-COMBINE-1
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::barrier{}((c1,t,a1))<p>@M[HeapNode1]) * (self::barrier{}((c2,t,a2))<p>@M[HeapNode1]))))*((c1 != 0) & (c2 != 0))( FLOW __norm)
	 body:(emp ; (emp ; (self::barrier{}((c1+c2,t,a1+a2))<p>@M[HeapNode1])))*(true)( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc D-FULL
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; (self::barrier{}((c,t,a))<p>@M[HeapNode1])))*((c = t+a) & ((a != 0) & (c > 0)))( FLOW __norm)
	 body:(emp ; (emp ; (self::barrier{}((c,t+a,0))<p>@M[HeapNode1])))*(true)( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc D-SPLIT
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; (self::barrier{}((c,t,a))<p>@M[HeapNode1])))*(((0 < c) & (c <= t+a)) & ((c = c1+c2) & ((a = a1+a2) & (((0 < c1) & (c1 < t+a1)) & (((0 < c2) & (c2 < t+a2)) & ((((a1) * (c)) = ((c1) * (a))) & (((a2) * (c)) = ((c2) * (a)))))))))( FLOW __norm)
	 body:(emp ; (emp ; ((self::barrier{}((c1,t,a1))<p>@M[HeapNode1]) * (self::barrier{}((c2,t,a2))<p>@M[HeapNode1]))))*(true)( FLOW __norm)
]

boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 80,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 79,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 77,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 75,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 73,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 69,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 68,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 66,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 65,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 64,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 63,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 62,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 60,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 59,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 58,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 57,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 56,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 55,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 54,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 53,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 52,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 51,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 50,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 49,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 48,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 47,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 46,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 45,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 42,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 41,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 40,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 39,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 38,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 37,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 35,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 34,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 33,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 32,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 31,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 30,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 29,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 28,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 27,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 26,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 25,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 24,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 23,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 22,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 21,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 20,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 19,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 18,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 17,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 16,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 15,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 14,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 13,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 12,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 11,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 10,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 9,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 8,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 7,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 6,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void removeParticipant(barrier b, int m)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((c,t,a))<p>@M[HeapNode1])))*((c >= m) & (m > 0))( FLOW __norm) {EAssume: 89,:(emp ; (emp ; (b::barrier{}((c-m,t,a-m))<p>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void addParticipant(barrier b, int m)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((c,t,a))<p>@M[HeapNode1])))*((c > 0) & (m > 0))( FLOW __norm) {EAssume: 88,:(emp ; (emp ; (b::barrier{}((c+m,t,a+m))<p>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void waitBarrier(barrier b)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((c,t,a))<p>@M[HeapNode1])))*(c = 1)( FLOW __norm) {EAssume: 87,:(emp ; (emp ; (b::barrier{}((c,t,a))<p+1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

barrier newBarrier(int bound)[]
static EBase: [][](emp)*(bound > 0)( FLOW __norm) {EAssume: 86,:(emp ; (emp ; (res::barrier{}((bound,bound,0))<0>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void destroyBarrier(barrier@R b)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((c,t,a))<Anon_14>@M[HeapNode1])))*(c = t+a)( FLOW __norm) {EAssume: 85,:(emp)*(b' = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void main()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: barrier b,int id1,int id2
barrier b = (90, ):newBarrier(2);
int id1 = (91, ):fork(thread1, b);
int id2 = (92, ):fork(thread2, b);
(93, ):join(id1);
(94, ):join(id2);
(95, ):destroyBarrier(b)}
}
void childthread2(barrier b)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((1,2,(1) / (2)))<1>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 4,:(emp ; (emp ; (b::barrier{}((0,2,(0-1) / (2)))<1>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(96, ):removeParticipant(b, 1)}
}
void childthread1(barrier b)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((1,2,(1) / (2)))<1>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 3,:(emp ; (emp ; (b::barrier{}((0,2,(0-1) / (2)))<2>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(97, ):waitBarrier(b);
(98, ):removeParticipant(b, 1)}
}
void thread2(barrier b)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((1,2,0))<0>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 2,:(emp ; (emp ; (b::barrier{}((0,2,0-1))<2>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int id1,int id2
(99, ):waitBarrier(b);
(100, ):addParticipant(b, 1);
int id1 = (101, ):fork(childthread1, b);
int id2 = (102, ):fork(childthread2, b);
(103, ):join(id1);
(104, ):join(id2)}
}
void thread1(barrier b)[]
static EBase: [][](emp ; (emp ; (b::barrier{}((1,2,0))<0>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 1,:(emp ; (emp ; (b::barrier{}((1,2,0))<3>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(105, ):waitBarrier(b);
(106, ):waitBarrier(b);
(107, ):waitBarrier(b)}
}
@@prog4

Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

WARNING: ./hip/veribsync/barrier_dynamic_header.ss_41:10_41:17:the result type __norm#E is not covered by the throw list[]
Starting Omega...oc

Checking procedure childthread1$barrier... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure childthread1$barrier SUCCESS.

Checking procedure childthread2$barrier... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure childthread2$barrier SUCCESS.

Checking procedure main$... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure main$ SUCCESS.

Checking procedure thread1$barrier... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure thread1$barrier SUCCESS.

Checking procedure thread2$barrier... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure thread2$barrier SUCCESS.
Halting Reduce... 
Stopping Reduce... 
Stop Omega... 107 invocations 
0 false contexts at: ()

!!! log(small):(1.836322,1926)
!!! 
 log(bigger)(>4s)(169):(2535.,[(SAT:1<0:REDLOG (REDUCE LOGIC),15.);(SAT:2<0:REDLOG (REDUCE LOGIC),15.);(SAT:5<0:REDLOG (REDUCE LOGIC),15.);(SAT:6<0:REDLOG (REDUCE LOGIC),15.);(SAT:113<0:REDLOG (REDUCE LOGIC),15.);(SAT:114<0:REDLOG (REDUCE LOGIC),15.);(SAT:118<0:REDLOG (REDUCE LOGIC),15.);(SAT:122<0:REDLOG (REDUCE LOGIC),15.);(SAT:123<0:REDLOG (REDUCE LOGIC),15.);(SAT:124<0:REDLOG (REDUCE LOGIC),15.);(SAT:125<0:REDLOG (REDUCE LOGIC),15.);(SAT:126<0:REDLOG (REDUCE LOGIC),15.);(SAT:137<0:REDLOG (REDUCE LOGIC),15.);(SAT:138<0:REDLOG (REDUCE LOGIC),15.);(SAT:139<0:REDLOG (REDUCE LOGIC),15.);(SAT:140<0:REDLOG (REDUCE LOGIC),15.);(SAT:141<0:REDLOG (REDUCE LOGIC),15.);(SAT:142<0:REDLOG (REDUCE LOGIC),15.);(SAT:144<0:REDLOG (REDUCE LOGIC),15.);(SAT:145<0:REDLOG (REDUCE LOGIC),15.);(SAT:146<0:REDLOG (REDUCE LOGIC),15.);(SAT:150<0:REDLOG (REDUCE LOGIC),15.);(SAT:151<0:REDLOG (REDUCE LOGIC),15.);(SAT:152<0:REDLOG (REDUCE LOGIC),15.);(SAT:153<0:REDLOG (REDUCE LOGIC),15.);(SAT:154<0:REDLOG (REDUCE LOGIC),15.);(SAT:157<0:REDLOG (REDUCE LOGIC),15.);(SAT:158<0:REDLOG (REDUCE LOGIC),15.);(SAT:159<0:REDLOG (REDUCE LOGIC),15.);(SAT:160<0:REDLOG (REDUCE LOGIC),15.);(SAT:161<0:REDLOG (REDUCE LOGIC),15.);(SAT:163<0:REDLOG (REDUCE LOGIC),15.);(SAT:168<0:REDLOG (REDUCE LOGIC),15.);(SAT:169<0:REDLOG (REDUCE LOGIC),15.);(SAT:170<0:REDLOG (REDUCE LOGIC),15.);(SAT:171<0:REDLOG (REDUCE LOGIC),15.);(SAT:174<0:REDLOG (REDUCE LOGIC),15.);(SAT:175<0:REDLOG (REDUCE LOGIC),15.);(SAT:179<0:REDLOG (REDUCE LOGIC),15.);(SAT:184<1:REDLOG (REDUCE LOGIC),15.);(SAT:185<1:REDLOG (REDUCE LOGIC),15.);(SAT:186<1:REDLOG (REDUCE LOGIC),15.);(SAT:187<1:REDLOG (REDUCE LOGIC),15.);(SAT:188<1:REDLOG (REDUCE LOGIC),15.);(SAT:193<2:REDLOG (REDUCE LOGIC),15.);(SAT:195<2:REDLOG (REDUCE LOGIC),15.);(SAT:208<3:REDLOG (REDUCE LOGIC),15.);(SAT:209<3:REDLOG (REDUCE LOGIC),15.);(SAT:218<4:REDLOG (REDUCE LOGIC),15.);(SAT:219<4:REDLOG (REDUCE LOGIC),15.);(SAT:227<5:REDLOG (REDUCE LOGIC),15.);(SAT:286<11:REDLOG (REDUCE LOGIC),15.);(SAT:288<11:REDLOG (REDUCE LOGIC),15.);(SAT:292<11:REDLOG (REDUCE LOGIC),15.);(SAT:297<12:REDLOG (REDUCE LOGIC),15.);(SAT:299<12:REDLOG (REDUCE LOGIC),15.);(SAT:311<14:REDLOG (REDUCE LOGIC),15.);(SAT:316<14:REDLOG (REDUCE LOGIC),15.);(SAT:323<15:REDLOG (REDUCE LOGIC),15.);(SAT:338<16:REDLOG (REDUCE LOGIC),15.);(SAT:382<21:REDLOG (REDUCE LOGIC),15.);(SAT:383<21:REDLOG (REDUCE LOGIC),15.);(SAT:384<21:REDLOG (REDUCE LOGIC),15.);(imply:396<22:REDLOG (REDUCE LOGIC),15.);(imply:399<23:REDLOG (REDUCE LOGIC),15.);(SAT:411<23:REDLOG (REDUCE LOGIC),15.);(SAT:412<23:REDLOG (REDUCE LOGIC),15.);(SAT:432<25:REDLOG (REDUCE LOGIC),15.);(SAT:442<26:REDLOG (REDUCE LOGIC),15.);(SAT:446<26:REDLOG (REDUCE LOGIC),15.);(SAT:448<26:REDLOG (REDUCE LOGIC),15.);(SAT:451<27:REDLOG (REDUCE LOGIC),15.);(SAT:486<31:REDLOG (REDUCE LOGIC),15.);(SAT:536<36:REDLOG (REDUCE LOGIC),15.);(imply:540<37:REDLOG (REDUCE LOGIC),15.);(imply:543<38:REDLOG (REDUCE LOGIC),15.);(SAT:546<38:REDLOG (REDUCE LOGIC),15.);(SAT:565<41:REDLOG (REDUCE LOGIC),15.);(SAT:577<43:REDLOG (REDUCE LOGIC),15.);(SAT:586<44:REDLOG (REDUCE LOGIC),15.);(SAT:595<45:REDLOG (REDUCE LOGIC),15.);(SAT:652<51:REDLOG (REDUCE LOGIC),15.);(SAT:656<51:REDLOG (REDUCE LOGIC),15.);(SAT:657<51:REDLOG (REDUCE LOGIC),15.);(SAT:661<52:REDLOG (REDUCE LOGIC),15.);(SAT:662<52:REDLOG (REDUCE LOGIC),15.);(imply:669<54:REDLOG (REDUCE LOGIC),15.);(SAT:681<55:REDLOG (REDUCE LOGIC),15.);(SAT:691<55:REDLOG (REDUCE LOGIC),15.);(SAT:697<56:REDLOG (REDUCE LOGIC),15.);(imply:709<57:REDLOG (REDUCE LOGIC),15.);(imply:728<59:REDLOG (REDUCE LOGIC),15.);(SAT:730<59:REDLOG (REDUCE LOGIC),15.);(SAT:731<59:REDLOG (REDUCE LOGIC),15.);(SAT:737<59:REDLOG (REDUCE LOGIC),15.);(SAT:739<60:REDLOG (REDUCE LOGIC),15.);(imply:748<61:REDLOG (REDUCE LOGIC),15.);(imply:750<62:REDLOG (REDUCE LOGIC),15.);(imply:751<62:REDLOG (REDUCE LOGIC),15.);(imply:752<62:REDLOG (REDUCE LOGIC),15.);(SAT:761<62:REDLOG (REDUCE LOGIC),15.);(imply:763<62:REDLOG (REDUCE LOGIC),15.);(SAT:770<63:REDLOG (REDUCE LOGIC),15.);(SAT:775<64:REDLOG (REDUCE LOGIC),15.);(SAT:791<64:REDLOG (REDUCE LOGIC),15.);(SAT:792<64:REDLOG (REDUCE LOGIC),15.);(SAT:802<65:REDLOG (REDUCE LOGIC),15.);(SAT:811<66:REDLOG (REDUCE LOGIC),15.);(SAT:830<68:REDLOG (REDUCE LOGIC),15.);(SAT:834<68:REDLOG (REDUCE LOGIC),15.);(SAT:844<68:REDLOG (REDUCE LOGIC),15.);(SAT:853<72:REDLOG (REDUCE LOGIC),15.);(SAT:900<77:REDLOG (REDUCE LOGIC),15.);(SAT:916<77:REDLOG (REDUCE LOGIC),15.);(SAT:917<77:REDLOG (REDUCE LOGIC),15.);(SAT:940<77:REDLOG (REDUCE LOGIC),15.);(SAT:944<79:REDLOG (REDUCE LOGIC),15.);(SAT:1020<82:REDLOG (REDUCE LOGIC),15.);(SAT:1021<82:REDLOG (REDUCE LOGIC),15.);(SAT:1036<83:REDLOG (REDUCE LOGIC),15.);(SAT:1037<83:REDLOG (REDUCE LOGIC),15.);(SAT:1070<87:REDLOG (REDUCE LOGIC),15.);(SAT:1079<88:REDLOG (REDUCE LOGIC),15.);(SAT:1155<96:REDLOG (REDUCE LOGIC),15.);(SAT:1164<97:REDLOG (REDUCE LOGIC),15.);(SAT:1248<105:REDLOG (REDUCE LOGIC),15.);(SAT:1257<106:REDLOG (REDUCE LOGIC),15.);(SAT:1312<110:REDLOG (REDUCE LOGIC),15.);(SAT:1322<112:REDLOG (REDUCE LOGIC),15.);(SAT:1445<124:REDLOG (REDUCE LOGIC),15.);(SAT:1507<129:REDLOG (REDUCE LOGIC),15.);(SAT:1516<130:REDLOG (REDUCE LOGIC),15.);(SAT:1525<131:REDLOG (REDUCE LOGIC),15.);(SAT:1563<135:REDLOG (REDUCE LOGIC),15.);(SAT:1572<136:REDLOG (REDUCE LOGIC),15.);(SAT:1581<137:REDLOG (REDUCE LOGIC),15.);(SAT:1596<138:REDLOG (REDUCE LOGIC),15.);(imply:1607<139:REDLOG (REDUCE LOGIC),15.);(imply:1609<140:REDLOG (REDUCE LOGIC),15.);(imply:1612<141:REDLOG (REDUCE LOGIC),15.);(imply:1613<141:REDLOG (REDUCE LOGIC),15.);(imply:1615<141:REDLOG (REDUCE LOGIC),15.);(SAT:1636<141:REDLOG (REDUCE LOGIC),15.);(SAT:1647<142:REDLOG (REDUCE LOGIC),15.);(imply:1664<143:REDLOG (REDUCE LOGIC),15.);(imply:1683<145:REDLOG (REDUCE LOGIC),15.);(SAT:1685<145:REDLOG (REDUCE LOGIC),15.);(SAT:1686<145:REDLOG (REDUCE LOGIC),15.);(SAT:1699<146:REDLOG (REDUCE LOGIC),15.);(imply:1711<147:REDLOG (REDUCE LOGIC),15.);(imply:1713<147:REDLOG (REDUCE LOGIC),15.);(imply:1715<148:REDLOG (REDUCE LOGIC),15.);(imply:1716<148:REDLOG (REDUCE LOGIC),15.);(imply:1717<148:REDLOG (REDUCE LOGIC),15.);(SAT:1731<148:REDLOG (REDUCE LOGIC),15.);(imply:1733<148:REDLOG (REDUCE LOGIC),15.);(SAT:1745<149:REDLOG (REDUCE LOGIC),15.);(SAT:1750<150:REDLOG (REDUCE LOGIC),15.);(SAT:1776<150:REDLOG (REDUCE LOGIC),15.);(SAT:1786<151:REDLOG (REDUCE LOGIC),15.);(SAT:1818<154:REDLOG (REDUCE LOGIC),15.);(SAT:1822<154:REDLOG (REDUCE LOGIC),15.);(SAT:1834<154:REDLOG (REDUCE LOGIC),15.);(SAT:1853<160:REDLOG (REDUCE LOGIC),15.);(SAT:1858<160:REDLOG (REDUCE LOGIC),15.);(SAT:1872<160:REDLOG (REDUCE LOGIC),15.);(SAT:1920<165:REDLOG (REDUCE LOGIC),15.);(SAT:1926<165:REDLOG (REDUCE LOGIC),15.);(SAT:1927<165:REDLOG (REDUCE LOGIC),15.)])
Total verification time: 3.350895 second(s)
	Time spent in main process: 2.781706 second(s)
	Time spent in child processes: 0.569189 second(s)


======================================

!!!Full processing file "./hip/conchip/mapreduce.ss"
Parsing file "./hip/conchip/mapreduce.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_29


}

class int_ptr extends Object {
int valVAL_30


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_31


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class count extends Object {
int valVAL_32


}

class list extends Object {
node hREC_33


}

class node extends Object {
int valVAL_11;
node nextREC_34


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
DEAD{}[]<> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
RTHRD2{(+)Q}[]<t,l,c> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
RTHRD{(-)P,(+)Q}[]<t,l,c> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
MTHRD2{(+)Q@Split}[]<l,ol,el> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
MTHRD{(-)P,(+)Q}[]<l,ol,el> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
ll{}[]<n> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; ((self::node{}<Anon_12,q>@M[HeapNode1]) * (q::ll{}<n-1>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)

lemmas(to be proved and saved)[
=>coerc normalize
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::MTHRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}<x,y,z>@M[HeapNode1]) * (self::DEAD{}<>@M[HeapNode1]))))*(true)( FLOW __norm)
	 body:(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)
]

boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 112,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 111,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 110,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 109,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 108,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 107,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 106,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 105,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 104,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 103,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 102,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 101,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 100,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 99,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 98,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 97,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 96,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 95,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 94,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 93,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 92,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 91,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 89,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 88,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 87,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 86,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 85,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 84,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 83,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 82,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 81,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 80,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 79,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 78,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 77,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 76,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 75,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 74,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 73,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 72,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 71,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 70,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 68,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 67,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 66,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 65,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 64,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 63,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 62,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 61,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 60,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 59,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 58,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 57,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 56,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 55,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 54,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 53,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 52,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 51,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 50,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 49,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 48,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 47,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 46,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 45,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 44,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 43,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 42,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 41,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 40,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 39,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 38,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 37,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 36,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 35,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 34,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void main()[]
static EBase: [][](emp ; (emp ; emp))*(true)( FLOW __norm) {EAssume: 32,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int n,node ll,list l,list el,list ol,count c1,count c2,thrd m,thrd r1,thrd r2,int n1,int n2,int n3
int n = 10000;
node ll = (113, ):createll(n);
list l = new list(ll);
list el = new list(null);
list ol = new list(null);
count c1 = new count(0);
count c2 = new count(0);
thrd m = (114, ):create_mapper();
thrd r1 = (115, ):create_reducer1();
thrd r2 = (116, ):create_reducer2();
(117, ):fork_mapper(m, l, ol, el);
(118, ):fork_reducer(r1, m, ol, c1);
(119, ):fork_reducer(r2, m, el, c2);
(120, ):join_reducer(r1);
(121, ):join_reducer(r2);
int n1 = (122, ):countList(l);
int n2 = (123, ):countList(ol);
int n3 = (124, ):countList(el);
 :assert_inexact EBase: [][](emp)*((n1' = n2'+n3') & (n1' = n'))( FLOW __norm) 
 assume: 
;
(126, ):destroyList(l);
(127, ):destroyList(ol);
(128, ):destroyList(el);
(129, ):destroyCount(c1);
(130, ):destroyCount(c2)}
}
void reducer2(thrd m, list el, count c)[]
static EBase: [][](emp ; (emp ; ((m::MTHRD2{(emp ; (emp ; ((el::list{}<hel>@M[HeapNode1]) * (hel::ll{}<n>@M[HeapNode1]))))*(n >= 0)( FLOW __norm)}<Anon_23,Anon_24,el>@M[HeapNode1]) * (c::count{}<Anon_25>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 30,:(emp ; (emp ; ((((el::list{}<hel>@M[HeapNode1]) * (hel::ll{}<n>@M[HeapNode1])) * (m::DEAD{}<>@M[HeapNode1])) * (c::count{}<n>@M[HeapNode1]))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int t
(131, ):join_mapper(m);
int t = (132, ):countList(el);
member access c~~>val = t}
}
void reducer1(thrd m, list ol, count c)[]
static EBase: [][](emp ; (emp ; ((m::MTHRD2{(emp ; (emp ; ((ol::list{}<hol>@M[HeapNode1]) * (hol::ll{}<n>@M[HeapNode1]))))*(n >= 0)( FLOW __norm)}<Anon_20,ol,Anon_21>@M[HeapNode1]) * (c::count{}<Anon_22>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 28,:(emp ; (emp ; ((((ol::list{}<hol>@M[HeapNode1]) * (hol::ll{}<n>@M[HeapNode1])) * (m::DEAD{}<>@M[HeapNode1])) * (c::count{}<n>@M[HeapNode1]))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int t
(135, ):join_mapper(m);
int t = (136, ):countList(ol);
member access c~~>val = t}
}
void mapper_helper(node l, node@R ol, node@R el)[]
static EBase: [][](emp ; (emp ; (l::ll{}<n>@M[HeapNode1])))*((ol = null) & ((el = null) & (n >= 0)))( FLOW __norm) {EAssume: 20,:(emp ; (emp ; (((l::ll{}<n>@M[HeapNode1]) * (ol'::ll{}<n1>@M[HeapNode1])) * (el'::ll{}<n2>@M[HeapNode1]))))*(n = n1+n2)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(139, ):if (l == null) { 
  (139, ):{ol = null;
el = null};
} else { 
  (139, ):{(140, ):mapper_helper(member access l~~>next, ol, el);
(142, ):if ((member access l~~>val % 2) != 0) { 
  (142, ):{ol = new node(member access l~~>val, ol)};
} else { 
  (142, ):{el = new node(member access l~~>val, el)}
}}
}}
}
void mapper(list l, list ol, list el)[]
static EBase: [][](emp ; (emp ; ((((l::list{}<hl>@M[HeapNode1]) * (hl::ll{}<n>@M[HeapNode1])) * (ol::list{}<null>@M[HeapNode1])) * (el::list{}<null>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 17,:(emp ; (emp ; ((((((l::list{}<hl>@M[HeapNode1]) * (hl::ll{}<n>@M[HeapNode1])) * (ol::list{}<hol>@M[HeapNode1])) * (el::list{}<hel>@M[HeapNode1])) * (hol::ll{}<n1>@M[HeapNode1])) * (hel::ll{}<n2>@M[HeapNode1]))))*(n = n1+n2)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: node hol,node hel
node hol = null;
node hel = null;
(153, ):mapper_helper(member access l~~>h, hol, hel);
member access ol~~>h = hol;
member access el~~>h = hel}
}
int countList(list l)[]
static EBase: [][](emp ; (emp ; ((l::list{}<nl>@M[HeapNode1]) * (nl::ll{}<n>@M[HeapNode1]))))*(n >= 0)( FLOW __norm) {EAssume: 16,:(emp ; (emp ; ((l::list{}<nl>@M[HeapNode1]) * (nl::ll{}<n>@M[HeapNode1]))))*(res = n)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(159, ):return (160, ):count_helper(member access l~~>h)}
}
int count_helper(node nl)[]
static EBase: [][](emp ; (emp ; (nl::ll{}<n>@M[HeapNode1])))*(n >= 0)( FLOW __norm) {EAssume: 13,:(emp ; (emp ; (nl::ll{}<n>@M[HeapNode1])))*(res = n)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(162, ):if (nl == null) { 
  (162, ):{(167, ):return 0};
} else { 
  (162, ):{local: node next,int n
node next = member access nl~~>next;
int n = (164, ):count_helper(next);
(165, ):return 1 + n}
}}
}
node createll(int n)[]
static EBase: [][](emp)*(n >= 0)( FLOW __norm) {EAssume: 12,:(emp ; (emp ; (res::ll{}<n>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void destroyList(list l)[]
static EBase: [][](emp ; (emp ; ((l::list{}<hl>@M[HeapNode1]) * (hl::ll{}<n>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 11,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(169, ):destroyll(member access l~~>h);
(171, ):destroyL(l)}
}
void destroyll(node l)[]
static EBase: [][](emp ; (emp ; (l::ll{}<n>@M[HeapNode1])))*(n >= 0)( FLOW __norm) {EAssume: 10,:(emp ; (emp ; emp))*(l = null)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void destroyL(list l)[]
static EBase: [][](emp ; (emp ; (l::list{}<null>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 9,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void destroyCount(count c)[]
static EBase: [][](emp ; (emp ; (c::count{}<Anon_19>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 8,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join_reducer(thrd t)[]
static EBase: [][](EX m l c . (emp ; (emp ; (t::RTHRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}<m,l,c>@M[HeapNode1])))*(true)( FLOW __norm)) {EAssume: 7,:(emp ; (emp ; ((t::DEAD{}<>@M[HeapNode1]) * (HVar Q))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void fork_reducer(thrd t, thrd m, list l, count c)[]
static EBase: [][](emp ; (emp ; ((t::RTHRD{(emp ; (emp ; (HVar P)))*(true)( FLOW __norm),(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}<m,l,c>@M[HeapNode1]) * (HVar P))))*(true)( FLOW __norm) {EAssume: 6,:(emp ; (emp ; (t::RTHRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}<m,l,c>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

thrd create_reducer2()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 5,:(EX m el c . (emp ; (emp ; (res::RTHRD{(emp ; (emp ; ((m::MTHRD2{(emp ; (emp ; ((el::list{}<hel>@M[HeapNode1]) * (hel::ll{}<n2>@M[HeapNode1]))))*(n2 >= 0)( FLOW __norm)}<Anon_16,Anon_17,el>@M[HeapNode1]) * (c::count{}<Anon_18>@M[HeapNode1]))))*(true)( FLOW __norm),(emp ; (emp ; ((((el::list{}<hel>@M[HeapNode1]) * (hel::ll{}<n2>@M[HeapNode1])) * (m::DEAD{}<>@M[HeapNode1])) * (c::count{}<n2>@M[HeapNode1]))))*(true)( FLOW __norm)}<m,el,c>@M[HeapNode1])))*(true)( FLOW __norm))}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

thrd create_reducer1()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(EX m ol c . (emp ; (emp ; (res::RTHRD{(emp ; (emp ; ((m::MTHRD2{(emp ; (emp ; ((ol::list{}<hol>@M[HeapNode1]) * (hol::ll{}<n1>@M[HeapNode1]))))*(n1 >= 0)( FLOW __norm)}<Anon_13,ol,Anon_14>@M[HeapNode1]) * (c::count{}<Anon_15>@M[HeapNode1]))))*(true)( FLOW __norm),(emp ; (emp ; ((((ol::list{}<hol>@M[HeapNode1]) * (hol::ll{}<n1>@M[HeapNode1])) * (m::DEAD{}<>@M[HeapNode1])) * (c::count{}<n1>@M[HeapNode1]))))*(true)( FLOW __norm)}<m,ol,c>@M[HeapNode1])))*(true)( FLOW __norm))}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join_mapper(thrd t)[]
static EBase: [][](EX l ol el . (emp ; (emp ; (t::MTHRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}<l,ol,el>@M[HeapNode1])))*(true)( FLOW __norm)) {EAssume: 3,:(emp ; (emp ; ((t::DEAD{}<>@M[HeapNode1]) * (HVar Q))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void fork_mapper(thrd t, list l, list ol, list el)[]
static EBase: [][](emp ; (emp ; ((t::MTHRD{(emp ; (emp ; (HVar P)))*(true)( FLOW __norm),(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}<l,ol,el>@M[HeapNode1]) * (HVar P))))*(true)( FLOW __norm) {EAssume: 2,:(emp ; (emp ; (t::MTHRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}<l,ol,el>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

thrd create_mapper()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 1,:(EX l ol el . (emp ; (emp ; (res::MTHRD{(emp ; (emp ; ((((l::list{}<hl>@M[HeapNode1]) * (hl::ll{}<n>@M[HeapNode1])) * (ol::list{}<null>@M[HeapNode1])) * (el::list{}<null>@M[HeapNode1]))))*(n >= 0)( FLOW __norm),(emp ; (emp ; ((((((l::list{}<hl>@M[HeapNode1]) * (hl::ll{}<n>@M[HeapNode1])) * (ol::list{}<hol>@M[HeapNode1])) * (hol::ll{}<n1>@M[HeapNode1])) * (el::list{}<hel>@M[HeapNode1])) * (hel::ll{}<n2>@M[HeapNode1]))))*(n = n1+n2)( FLOW __norm)}<l,ol,el>@M[HeapNode1])))*(true)( FLOW __norm))}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

@@prog4

Starting z3... 

WARNING: ./hip/conchip/mapreduce.ss_80:10_80:22:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/conchip/mapreduce.ss_67:11_67:25:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/conchip/mapreduce.ss_63:11_63:31:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/conchip/mapreduce.ss_50:11_50:25:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/conchip/mapreduce.ss_46:11_46:33:the result type __norm#E is not covered by the throw list[]

Checking procedure count_helper$node... 
Procedure count_helper$node SUCCESS.

Checking procedure countList$list... 
Procedure countList$list SUCCESS.

Checking procedure destroyList$list... 
Procedure destroyList$list SUCCESS.

Checking procedure main$... 
assert:./hip/conchip/mapreduce.ss:190: 2:  : ok


Procedure main$ SUCCESS.

Checking procedure mapper_helper$node~node~node... 
Procedure mapper_helper$node~node~node SUCCESS.

Checking procedure mapper$list~list~list... 
Procedure mapper$list~list~list SUCCESS.

Checking procedure reducer1$thrd~list~count... 
Procedure reducer1$thrd~list~count SUCCESS.

Checking procedure reducer2$thrd~list~count... 
Procedure reducer2$thrd~list~count SUCCESS.
Stop Omega... 7 invocations 
0 false contexts at: ()

!!! log(small):(7.851011,14277)
Total verification time: 4.59106 second(s)
	Time spent in main process: 4.56788 second(s)
	Time spent in child processes: 0.02318 second(s)


======================================

!!!Full processing file "./hip/conchip/multi-join2.ss"
Parsing file "./hip/conchip/multi-join2.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_15


}

class int_ptr extends Object {
int valVAL_16


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_17


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class cell extends Object {
int valVAL_18


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
dead{}[]<> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
THRD4{(+)Q@Split}[]<t1,x,y> == EBase: [][](emp)*(true)( FLOW __flow)  inv (x != null) & (y != null) inv_lock: None view_data_name:  view_imm_map: []
THRD3{(-)P,(+)Q}[]<t1,x,y> == EBase: [][](emp)*(true)( FLOW __flow)  inv (x != null) & (y != null) inv_lock: None view_data_name:  view_imm_map: []
THRD2{(+)Q@Split}[]<x,y> == EBase: [][](emp)*(true)( FLOW __flow)  inv (x != null) & (y != null) inv_lock: None view_data_name:  view_imm_map: []
THRD{(-)P,(+)Q}[]<x,y> == EBase: [][](emp)*(true)( FLOW __flow)  inv (x != null) & (y != null) inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)

lemmas(to be proved and saved)[
=>coerc combineCell
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::cell{}(f1)<v>@M[HeapNode1]) * (self::cell{}(f2)<v>@M[HeapNode1]))))*(true)( FLOW __norm)
	 body:(emp ; (emp ; (self::cell{}(f1+f2)<v>@M[HeapNode1])))*(true)( FLOW __norm)
]

split lemmas[
=>coerc splitCell
	 kind: LEM_SPLIT
	 origin: user-given
	 head: (emp ; (emp ; (self::cell{}(f)<v>@M[HeapNode1])))*((f = f1+f2) & ((f1 > 0.) & (f2 > 0.)))( FLOW __norm)
	 body:(emp ; (emp ; ((self::cell{}(f1)<v>@M[HeapNode1]) * (self::cell{}(f2)<v>@M[HeapNode1]))))*(((0.) < f) & (f <= 1.))( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc normalize
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::THRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}()<x,y>@M[HeapNode1]) * (self::dead{}()<>@M[HeapNode1]))))*(true)( FLOW __norm)
	 body:(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)
]

boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 98,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 97,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 96,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 95,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 94,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 93,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 92,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 91,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 83,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 82,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 80,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 79,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 78,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 77,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 75,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 74,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 73,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 72,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 71,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 70,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 69,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 68,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 67,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 66,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 65,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 64,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 63,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 62,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 61,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 60,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 59,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 58,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 57,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 56,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 55,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 54,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 53,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 52,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 51,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 49,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 48,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 47,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 46,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 45,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 44,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 43,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 42,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 41,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 40,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 39,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 38,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 37,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 36,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 35,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 34,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 33,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 32,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 31,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 30,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 29,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 28,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 27,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 26,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 25,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 24,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 23,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 22,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 21,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 20,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void main()[]
static EBase: [][](emp ; (emp ; emp))*(true)( FLOW __norm) {EAssume: 16,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: cell x,cell y,thrd t1,thrd t2,int a
cell x = new cell(0);
cell y = new cell(0);
thrd t1 = (99, ):create_thrd1();
thrd t2 = (100, ):create_thrd2();
(101, ):fork_thrd1(t1, x, y);
(102, ):fork_thrd2(t2, t1, x, y);
(103, ):join_thrd1(t1);
int a = member access x~~>val + member access y~~>val;
 :assert_inexact EBase: [][](emp)*(a' = 3)( FLOW __norm) 
 assume: 
;
(108, ):join_thrd2(t2);
 :assert_inexact EBase: [][](emp ; (emp ; ((x'::cell{}()<1>@M[HeapNode1]) * (y'::cell{}()<2>@M[HeapNode1]))))*(true)( FLOW __norm) 
 assume: 
;
(110, ):destroyCell(x);
(111, ):destroyCell(y)}
}
void thread2(thrd t1, cell x, cell y)[]
static EBase: [][](emp ; (emp ; (t1::THRD2{(emp ; (emp ; ((x::cell{}(0.6)<1>@M[HeapNode1]) * (y::cell{}(0.6)<2>@M[HeapNode1]))))*(true)( FLOW __norm)}()<x,y>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 13,:(emp ; (emp ; ((x::cell{}(0.6)<1>@M[HeapNode1]) * (y::cell{}(0.6)<2>@M[HeapNode1]))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int a
(112, ):join_thrd1(t1);
int a = member access x~~>val + member access y~~>val;
 :assert_inexact EBase: [][](emp)*(a' = 3)( FLOW __norm) 
 assume: 
}
}
void thread1(cell x, cell y)[]
static EBase: [][](emp ; (emp ; ((x::cell{}()<0>@M[HeapNode1]) * (y::cell{}()<0>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 8,:(emp ; (emp ; ((x::cell{}()<1>@M[HeapNode1]) * (y::cell{}()<2>@M[HeapNode1]))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{member access x~~>val = member access x~~>val + 1;
member access y~~>val = member access y~~>val + 2}
}
void destroyCell(cell a)[]
static EBase: [][](emp ; (emp ; (a::cell{}()<Anon_11>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 7,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join_thrd2(thrd t)[]
static EBase: [][](EX t1 x y . (emp ; (emp ; (t::THRD4{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}()<t1,x,y>@M[HeapNode1])))*(true)( FLOW __norm)) {EAssume: 6,:(emp ; (emp ; ((t::dead{}()<>@M[HeapNode1]) * (HVar Q))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void fork_thrd2(thrd t, thrd t1, cell x, cell y)[]
static EBase: [][](emp ; (emp ; ((t::THRD3{(emp ; (emp ; (HVar P)))*(true)( FLOW __norm),(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}()<t1,x,y>@M[HeapNode1]) * (HVar P))))*(true)( FLOW __norm) {EAssume: 5,:(emp ; (emp ; (t::THRD4{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}()<t1,x,y>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

thrd create_thrd2()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 4,:(EX t1 x y . (emp ; (emp ; (res::THRD3{(emp ; (emp ; (t1::THRD2{(emp ; (emp ; ((x::cell{}(0.6)<1>@M[HeapNode1]) * (y::cell{}(0.6)<2>@M[HeapNode1]))))*(true)( FLOW __norm)}()<x,y>@M[HeapNode1])))*(true)( FLOW __norm),(emp ; (emp ; ((x::cell{}(0.6)<1>@M[HeapNode1]) * (y::cell{}(0.6)<2>@M[HeapNode1]))))*(true)( FLOW __norm)}()<t1,x,y>@M[HeapNode1])))*(true)( FLOW __norm))}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join_thrd1(thrd t)[]
static EBase: [][](EX x y . (emp ; (emp ; (t::THRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}()<x,y>@M[HeapNode1])))*(true)( FLOW __norm)) {EAssume: 3,:(emp ; (emp ; ((t::dead{}()<>@M[HeapNode1]) * (HVar Q))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void fork_thrd1(thrd t, cell x, cell y)[]
static EBase: [][](emp ; (emp ; ((t::THRD{(emp ; (emp ; (HVar P)))*(true)( FLOW __norm),(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}()<x,y>@M[HeapNode1]) * (HVar P))))*(true)( FLOW __norm) {EAssume: 2,:(emp ; (emp ; (t::THRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}()<x,y>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

thrd create_thrd1()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 1,:(EX x y . (emp ; (emp ; (res::THRD{(emp ; (emp ; ((x::cell{}()<0>@M[HeapNode1]) * (y::cell{}()<0>@M[HeapNode1]))))*(true)( FLOW __norm),(emp ; (emp ; ((x::cell{}()<1>@M[HeapNode1]) * (y::cell{}()<2>@M[HeapNode1]))))*(true)( FLOW __norm)}()<x,y>@M[HeapNode1])))*(true)( FLOW __norm))}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

@@prog4

Starting z3... 

WARNING: ./hip/conchip/multi-join2.ss_54:11_54:25:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/conchip/multi-join2.ss_50:11_50:31:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/conchip/multi-join2.ss_40:11_40:25:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/conchip/multi-join2.ss_36:11_36:28:the result type __norm#E is not covered by the throw list[]

Checking procedure main$... Starting Reduce... 
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

assert:./hip/conchip/multi-join2.ss:105: 2:  : ok

Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

assert:./hip/conchip/multi-join2.ss:109: 2:  : ok

Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure main$ SUCCESS.

Checking procedure thread1$cell~cell... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure thread1$cell~cell SUCCESS.

Checking procedure thread2$thrd~cell~cell... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

assert:./hip/conchip/multi-join2.ss:87: 2:  : ok

Nested Timer(stop)
Nested Timer(stop)

Procedure thread2$thrd~cell~cell SUCCESS.
Stop Omega... 6 invocations 
0 false contexts at: ()

!!! log(small):(2.180603,1130)
!!! 
 log(bigger)(>4s)(120):(1800.,[(SAT:197<0:REDLOG (REDUCE LOGIC),15.);(imply:205<2:REDLOG (REDUCE LOGIC),15.);(imply:208<2:REDLOG (REDUCE LOGIC),15.);(imply:209<2:REDLOG (REDUCE LOGIC),15.);(SAT:211<2:REDLOG (REDUCE LOGIC),15.);(imply:276<16:REDLOG (REDUCE LOGIC),15.);(imply:277<17:REDLOG (REDUCE LOGIC),15.);(imply:282<17:REDLOG (REDUCE LOGIC),15.);(imply:285<18:REDLOG (REDUCE LOGIC),15.);(imply:286<19:REDLOG (REDUCE LOGIC),15.);(imply:287<19:REDLOG (REDUCE LOGIC),15.);(imply:294<19:REDLOG (REDUCE LOGIC),15.);(imply:296<19:REDLOG (REDUCE LOGIC),15.);(imply:297<20:REDLOG (REDUCE LOGIC),15.);(imply:298<20:REDLOG (REDUCE LOGIC),15.);(imply:308<20:REDLOG (REDUCE LOGIC),15.);(imply:311<20:REDLOG (REDUCE LOGIC),15.);(SAT:313<20:REDLOG (REDUCE LOGIC),15.);(SAT:317<20:REDLOG (REDUCE LOGIC),15.);(imply:356<31:REDLOG (REDUCE LOGIC),15.);(imply:357<31:REDLOG (REDUCE LOGIC),15.);(imply:358<31:REDLOG (REDUCE LOGIC),15.);(imply:361<31:REDLOG (REDUCE LOGIC),15.);(imply:362<31:REDLOG (REDUCE LOGIC),15.);(imply:363<32:REDLOG (REDUCE LOGIC),15.);(imply:366<32:REDLOG (REDUCE LOGIC),15.);(imply:367<32:REDLOG (REDUCE LOGIC),15.);(SAT:370<32:REDLOG (REDUCE LOGIC),15.);(SAT:377<32:REDLOG (REDUCE LOGIC),15.);(imply:380<35:REDLOG (REDUCE LOGIC),15.);(imply:381<35:REDLOG (REDUCE LOGIC),15.);(imply:382<35:REDLOG (REDUCE LOGIC),15.);(imply:385<35:REDLOG (REDUCE LOGIC),15.);(imply:386<35:REDLOG (REDUCE LOGIC),15.);(imply:387<36:REDLOG (REDUCE LOGIC),15.);(imply:390<36:REDLOG (REDUCE LOGIC),15.);(imply:391<36:REDLOG (REDUCE LOGIC),15.);(SAT:401<36:REDLOG (REDUCE LOGIC),15.);(imply:404<37:REDLOG (REDUCE LOGIC),15.);(imply:405<37:REDLOG (REDUCE LOGIC),15.);(imply:406<37:REDLOG (REDUCE LOGIC),15.);(SAT:421<37:REDLOG (REDUCE LOGIC),15.);(imply:424<38:REDLOG (REDUCE LOGIC),15.);(imply:426<38:REDLOG (REDUCE LOGIC),15.);(SAT:441<38:REDLOG (REDUCE LOGIC),15.);(SAT:448<40:REDLOG (REDUCE LOGIC),15.);(imply:500<44:REDLOG (REDUCE LOGIC),15.);(imply:521<45:REDLOG (REDUCE LOGIC),15.);(imply:522<46:REDLOG (REDUCE LOGIC),15.);(imply:523<46:REDLOG (REDUCE LOGIC),15.);(imply:529<46:REDLOG (REDUCE LOGIC),15.);(imply:530<46:REDLOG (REDUCE LOGIC),15.);(SAT:532<46:REDLOG (REDUCE LOGIC),15.);(imply:541<47:REDLOG (REDUCE LOGIC),15.);(imply:542<48:REDLOG (REDUCE LOGIC),15.);(imply:543<48:REDLOG (REDUCE LOGIC),15.);(SAT:558<48:REDLOG (REDUCE LOGIC),15.);(imply:564<49:REDLOG (REDUCE LOGIC),15.);(imply:574<50:REDLOG (REDUCE LOGIC),15.);(imply:584<50:REDLOG (REDUCE LOGIC),15.);(imply:585<50:REDLOG (REDUCE LOGIC),15.);(SAT:593<50:REDLOG (REDUCE LOGIC),15.);(imply:600<51:REDLOG (REDUCE LOGIC),15.);(imply:601<51:REDLOG (REDUCE LOGIC),15.);(imply:602<51:REDLOG (REDUCE LOGIC),15.);(imply:605<52:REDLOG (REDUCE LOGIC),15.);(imply:607<53:REDLOG (REDUCE LOGIC),15.);(imply:608<53:REDLOG (REDUCE LOGIC),15.);(imply:615<53:REDLOG (REDUCE LOGIC),15.);(imply:616<53:REDLOG (REDUCE LOGIC),15.);(SAT:624<53:REDLOG (REDUCE LOGIC),15.);(SAT:651<55:REDLOG (REDUCE LOGIC),15.);(imply:658<56:REDLOG (REDUCE LOGIC),15.);(imply:659<56:REDLOG (REDUCE LOGIC),15.);(SAT:672<56:REDLOG (REDUCE LOGIC),15.);(imply:688<58:REDLOG (REDUCE LOGIC),15.);(imply:690<59:REDLOG (REDUCE LOGIC),15.);(imply:693<59:REDLOG (REDUCE LOGIC),15.);(SAT:700<59:REDLOG (REDUCE LOGIC),15.);(imply:708<60:REDLOG (REDUCE LOGIC),15.);(SAT:717<60:REDLOG (REDUCE LOGIC),15.);(SAT:733<61:REDLOG (REDUCE LOGIC),15.);(imply:755<64:REDLOG (REDUCE LOGIC),15.);(imply:756<64:REDLOG (REDUCE LOGIC),15.);(SAT:760<65:REDLOG (REDUCE LOGIC),15.);(imply:805<72:REDLOG (REDUCE LOGIC),15.);(SAT:809<73:REDLOG (REDUCE LOGIC),15.);(imply:811<74:REDLOG (REDUCE LOGIC),15.);(imply:831<76:REDLOG (REDUCE LOGIC),15.);(imply:832<76:REDLOG (REDUCE LOGIC),15.);(imply:833<77:REDLOG (REDUCE LOGIC),15.);(imply:836<77:REDLOG (REDUCE LOGIC),15.);(imply:837<77:REDLOG (REDUCE LOGIC),15.);(SAT:841<77:REDLOG (REDUCE LOGIC),15.);(imply:899<84:REDLOG (REDUCE LOGIC),15.);(imply:900<85:REDLOG (REDUCE LOGIC),15.);(imply:903<85:REDLOG (REDUCE LOGIC),15.);(SAT:906<85:REDLOG (REDUCE LOGIC),15.);(imply:909<86:REDLOG (REDUCE LOGIC),15.);(imply:910<86:REDLOG (REDUCE LOGIC),15.);(imply:911<86:REDLOG (REDUCE LOGIC),15.);(imply:924<88:REDLOG (REDUCE LOGIC),15.);(imply:925<88:REDLOG (REDUCE LOGIC),15.);(SAT:928<88:REDLOG (REDUCE LOGIC),15.);(imply:940<92:REDLOG (REDUCE LOGIC),15.);(imply:980<96:REDLOG (REDUCE LOGIC),15.);(imply:985<96:REDLOG (REDUCE LOGIC),15.);(imply:986<96:REDLOG (REDUCE LOGIC),15.);(imply:990<97:REDLOG (REDUCE LOGIC),15.);(imply:991<97:REDLOG (REDUCE LOGIC),15.);(SAT:994<97:REDLOG (REDUCE LOGIC),15.);(SAT:996<97:REDLOG (REDUCE LOGIC),15.);(imply:1009<99:REDLOG (REDUCE LOGIC),15.);(imply:1019<100:REDLOG (REDUCE LOGIC),15.);(SAT:1035<101:REDLOG (REDUCE LOGIC),15.);(imply:1038<102:REDLOG (REDUCE LOGIC),15.);(imply:1068<104:REDLOG (REDUCE LOGIC),15.);(imply:1095<106:REDLOG (REDUCE LOGIC),15.);(imply:1122<107:REDLOG (REDUCE LOGIC),15.);(imply:1133<109:REDLOG (REDUCE LOGIC),15.)])
Total verification time: 2.09521 second(s)
	Time spent in main process: 2.076957 second(s)
	Time spent in child processes: 0.018253 second(s)


======================================

!!!Full processing file "./hip/conchip/latch-exp2.ss"
Parsing file "./hip/conchip/latch-exp2.ss" by default parser...
WARNING : parsing problem cyclic is neither a ranking function nor a relation nor a heap predicate

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_17


}

class int_ptr extends Object {
int valVAL_18


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_19


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class cell extends Object {
int vVAL_20


}

class CDL extends Object {



}

global WAIT g

WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
CNT{}[]<n> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
LatchOut{(+)P}[]<> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
LatchIn{(-)P}[]<> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
DEAD{}[]<> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
THRD2{(+)Q@Split}[]<c1,c2,g> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
THRD{(-)P,(+)Q}[]<c1,c2,g> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)

lemmas(to be proved and saved)[
=>coerc thrd_normalize
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::THRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}<c1,c2,g>@M[HeapNode1]) * (self::DEAD{}<>@M[HeapNode1]))))*(true)( FLOW __norm)
	 body:(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc deadlock
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; (self::WAIT{}<S>@M[HeapNode1])))*(cyclic(S))( FLOW __norm)
	 body:(emp ; (emp ; emp))*(true)( FLOW __Fail)
]

propagation lemmas[
=>coerc wait-for
	 kind: LEM_PROP
	 origin: user-given
	 head: (emp ; (emp ; (((c1::CNT{}<a>@M[HeapNode1]) * (c2::CNT{}<b>@M[HeapNode1])) * (x::WAIT{}<S>@M[HeapNode1]))))*((a > 0) & ((b < 0) & ((BagNotIn(v,S)) & (v = (c2,c1)))))( FLOW __norm)
	 body:(emp ; (emp ; (((c1::CNT{}<a>@M[HeapNode1]) * (c2::CNT{}<b>@M[HeapNode1])) * (x::WAIT{}<S1>@M[HeapNode1]))))*((S1 = BagUnion(S, Bag((c2,c1)))) & ((a > 0) & (b < 0)))( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc wait-combine
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::WAIT{}<S1>@M[HeapNode1]) * (self::WAIT{}<S2>@M[HeapNode1]))))*(true)( FLOW __norm)
	 body:(emp ; (emp ; (self::WAIT{}<S>@M[HeapNode1])))*(S = BagUnion(S1, S2))( FLOW __norm)
]

split lemmas[
=>coerc wait-split
	 kind: LEM_SPLIT
	 origin: user-given
	 head: (emp ; (emp ; (self::WAIT{}<S>@M[HeapNode1])))*(true)( FLOW __norm)
	 body:(emp ; (emp ; ((self::WAIT{}<S>@M[HeapNode1]) * (self::WAIT{}<S>@M[HeapNode1]))))*(true)( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc error2
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::LatchIn{(emp ; (emp ; (HVar P)))*(true)( FLOW __norm)}<>@M[HeapNode1]) * (self::CNT{}<n>@M[HeapNode1]))))*(n < 0)( FLOW __norm)
	 body:(emp ; (emp ; emp))*(true)( FLOW __Fail)
]

lemmas(to be proved and saved)[
=>coerc error1
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::CNT{}<a>@M[HeapNode1]) * (self::CNT{}<b>@M[HeapNode1]))))*((a > 0) & (b < 0))( FLOW __norm)
	 body:(emp ; (emp ; emp))*(true)( FLOW __Fail)
]

lemmas(to be proved and saved)[
=>coerc normalize
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::LatchOut{(emp ; (emp ; (HVar P)))*(true)( FLOW __norm)}<>@M[HeapNode1]) * (self::CNT{}<n>@M[HeapNode1]))))*(n < 0)( FLOW __norm)
	 body:(emp ; (emp ; (HVar P)))*(true)( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc combine2
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::CNT{}<a>@M[HeapNode1]) * (self::CNT{}<b>@M[HeapNode1]))))*((a <= 0) & (b <= 0))( FLOW __norm)
	 body:(emp ; (emp ; (self::CNT{}<a+b>@M[HeapNode1])))*(true)( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc combine1
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::CNT{}<a>@M[HeapNode1]) * (self::CNT{}<b>@M[HeapNode1]))))*((a >= 0) & (b >= 0))( FLOW __norm)
	 body:(emp ; (emp ; (self::CNT{}<a+b>@M[HeapNode1])))*(true)( FLOW __norm)
]

split lemmas[
=>coerc split
	 kind: LEM_SPLIT
	 origin: user-given
	 head: (emp ; (emp ; (self::CNT{}<n>@M[HeapNode1])))*((a >= 0) & ((b >= 0) & (n = a+b)))( FLOW __norm)
	 body:(emp ; (emp ; ((self::CNT{}<a>@M[HeapNode1]) * (self::CNT{}<b>@M[HeapNode1]))))*(true)( FLOW __norm)
]

boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 91,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 87,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 86,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 85,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 84,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 83,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 82,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 80,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 79,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 78,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 77,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 76,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 75,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 74,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 73,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 72,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 71,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 70,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 69,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 68,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 67,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 66,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 65,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 64,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 63,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 62,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 61,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 60,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 59,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 58,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 57,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 56,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 55,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 54,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 53,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 52,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 51,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 49,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 48,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 47,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 46,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 45,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 44,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 43,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 42,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 41,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 40,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 39,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 38,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 37,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 36,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 35,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 34,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 33,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 32,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 31,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 30,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 29,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 28,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 27,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 26,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 25,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 24,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 23,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 22,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 21,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 20,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 19,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 18,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 17,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 16,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 15,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 14,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 13,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void main(WAIT@R g_14)[]
static EBase: [][](emp ; (emp ; (g_14::WAIT{}<S>@M[HeapNode1])))*(S = Bag())( FLOW __norm) {EAssume: 11,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: CDL c1,CDL c2,thrd tid
CDL c1 = (92, ):create_latch(1);
CDL c2 = (93, ):create_latch(1);
 :assert  assume: (emp)*(c1' != c2')( FLOW __norm)
;
thrd tid = (95, ):create_thrd();
(96, ):fork_thrd(tid, c1, c2, g_14);
(97, ):await(c2);
(98, ):countDown(c1);
(99, ):join_thrd(tid)}
}
void thread1(CDL c1, CDL c2, WAIT g_15)[]
static EBase: [][](emp ; (emp ; (((((g_15::WAIT{}<B>@M[HeapNode1]) * (c1::LatchOut{(emp ; (emp ; emp))*(true)( FLOW __norm)}<>@M[HeapNode1])) * (c1::CNT{}<0>@M[HeapNode1])) * (c2::LatchIn{(emp ; (emp ; emp))*(true)( FLOW __norm)}<>@M[HeapNode1])) * (c2::CNT{}<1>@M[HeapNode1]))))*((c1 != c2) & (B = Bag()))( FLOW __norm) {EAssume: 10,:(emp ; (emp ; (((g_15::WAIT{}<B1>@M[HeapNode1]) * (c1::CNT{}<0-1>@M[HeapNode1])) * (c2::CNT{}<0>@M[HeapNode1]))))*(B1 = Bag((c1,c2)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(100, ):await(c1);
(101, ):countDown(c2)}
}
void await(CDL c)[]
static 

(None,[]): EBase: [][](emp ; (emp ; ((c::LatchOut{(emp ; (emp ; (HVar P)))*(true)( FLOW __norm)}<>@M[HeapNode1]) * (c::CNT{}<0>@M[HeapNode1]))))*(true)( FLOW __norm) {EAssume: 8,:(emp ; (emp ; ((c::CNT{}<0-1>@M[HeapNode1]) * (HVar P))))*(true)( FLOW __norm)}
||
(None,[]): EBase: [][](emp ; (emp ; (c::CNT{}<n>@M[HeapNode1])))*(n < 0)( FLOW __norm) {EAssume: 9,:(emp ; (emp ; (c::CNT{}<n>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void countDown(CDL c)[]
static 

(None,[]): EBase: [][](emp ; (emp ; (((c::LatchIn{(emp ; (emp ; (HVar P)))*(true)( FLOW __norm)}<>@M[HeapNode1]) * (HVar P)) * (c::CNT{}<n>@M[HeapNode1]))))*(n > 0)( FLOW __norm) {EAssume: 6,:(emp ; (emp ; (c::CNT{}<n-1>@M[HeapNode1])))*(true)( FLOW __norm)}
||
(None,[]): EBase: [][](emp ; (emp ; (c::CNT{}<n>@M[HeapNode1])))*(n <= 0)( FLOW __norm) {EAssume: 7,:(emp ; (emp ; (c::CNT{}<n>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

CDL create_latch(int n)[]
static EBase: [][](emp)*(n > 0)( FLOW __norm) {EAssume: 5,:(EX x . (emp ; (emp ; (((res::LatchIn{(emp ; (emp ; emp))*(true)( FLOW __norm)}<>@M[HeapNode1]) * (res::LatchOut{(emp ; (emp ; emp))*(true)( FLOW __norm)}<>@M[HeapNode1])) * (res::CNT{}<n>@M[HeapNode1]))))*(true)( FLOW __norm))}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join_thrd(thrd t)[]
static 

(None,[]): EBase: [][](EX c1 c2 g . (emp ; (emp ; (t::THRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}<c1,c2,g>@M[HeapNode1])))*(true)( FLOW __norm)) {EAssume: 3,:(emp ; (emp ; ((t::DEAD{}<>@M[HeapNode1]) * (HVar Q))))*(true)( FLOW __norm)}
||
(None,[]): EBase: [][](emp ; (emp ; (t::DEAD{}<>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 4,:(emp ; (emp ; (t::DEAD{}<>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void fork_thrd(thrd t, CDL c1, CDL c2, WAIT g_16)[]
static EBase: [][](emp ; (emp ; ((t::THRD{(emp ; (emp ; (HVar P)))*(true)( FLOW __norm),(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}<c1,c2,g_16>@M[HeapNode1]) * (HVar P))))*(true)( FLOW __norm) {EAssume: 2,:(emp ; (emp ; (t::THRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}<c1,c2,g_16>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

thrd create_thrd()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 1,:(EX c1 c2 g B . (emp ; (emp ; (res::THRD{(emp ; (emp ; (((((g::WAIT{}<B>@M[HeapNode1]) * (c1::LatchOut{(emp ; (emp ; emp))*(true)( FLOW __norm)}<>@M[HeapNode1])) * (c1::CNT{}<0>@M[HeapNode1])) * (c2::LatchIn{(emp ; (emp ; emp))*(true)( FLOW __norm)}<>@M[HeapNode1])) * (c2::CNT{}<1>@M[HeapNode1]))))*((B = Bag()) & (c1 != c2))( FLOW __norm),(emp ; (emp ; (((g::WAIT{}<B1>@M[HeapNode1]) * (c1::CNT{}<0-1>@M[HeapNode1])) * (c2::CNT{}<0>@M[HeapNode1]))))*(B1 = Bag((c1,c2)))( FLOW __norm)}<c1,c2,g>@M[HeapNode1])))*(true)( FLOW __norm))}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

@@prog4

Starting z3... 

Last Proving Location: 1 File "./hip/conchip/latch-exp2.ss",Line:107,Col:0

ERROR: at _0:0_0:0 
Message: Can not find flow of Object
 Stop Omega... 0 invocations caught
(Program not linked with -g, cannot print stack backtrace)

Exception occurred: Failure("Can not find flow of Object")
Error3(s) detected at main 

======================================

!!!Full processing file "./hip/conchip/deadpool.ss"
Parsing file "./hip/conchip/deadpool.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc
@@prog4
class Object extends  {



}

class String extends Object {



}

class int_ptr_ptr extends Object {
int_ptr valREC_27


}

class int_ptr extends Object {
int valVAL_28


}

class lock extends Object {



}

class barrier extends Object {
int phaseVAL_29


}

class thrd extends Object {



}

class __RET extends __Exc {



}

class __ArrBoundErr extends __Error {



}

class __DivByZeroErr extends __Error {



}

class Object extends  {



}

class String extends Object {



}

class item extends Object {
thrd tREC_13;
item nextREC_30


}

class cell extends Object {
int valVAL_31


}



WAITS{}[]<G,S,d> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
WAIT{}[]<b> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
memLoc{}[]<heap,size> == EBase: [][](emp)*(true)( FLOW __flow)  inv size > 0 inv_lock: None view_data_name:  view_imm_map: []
deadPool{}[]<n> == 

(None,[]): EBase: [][](emp)*((self = null) & (n = 0))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; (((self::item{}()<t,p>@M[HeapNode1]) * (p::deadPool{}()<n-1>@M[HeapNode1])) * (t::dead{}()<>@M[HeapNode1]))))*(true)( FLOW __flow)  inv n >= 0 inv_lock: None view_data_name:  view_imm_map: []
threadPool{}[]<x,n,M> == 

(None,[]): EBase: [][](emp)*((self = null) & ((n = 0) & (M > 0)))( FLOW __flow) 
||
(None,[]): EBase: [][](emp ; (emp ; (((self::item{}()<t,p>@M[HeapNode1]) * (p::threadPool{}()<x,n-1,M>@M[HeapNode1])) * (t::THRD2{(emp ; (emp ; (x::cell{}((1) / (M))<Anon_14>@M[HeapNode1])))*(true)( FLOW __norm)}()<x,M>@M[HeapNode1]))))*(true)( FLOW __flow)  inv (n >= 0) & (M > 0) inv_lock: None view_data_name:  view_imm_map: []
dead{}[]<> == EBase: [][](emp)*(true)( FLOW __flow)  inv true inv_lock: None view_data_name:  view_imm_map: []
THRD2{(+)Q@Split}[]<c,M> == EBase: [][](emp)*(true)( FLOW __flow)  inv (c != null) & (M > 0) inv_lock: None view_data_name:  view_imm_map: []
THRD{(-)P,(+)Q}[]<c,M> == EBase: [][](emp)*(true)( FLOW __flow)  inv (c != null) & (M > 0) inv_lock: None view_data_name:  view_imm_map: []

waitS([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
acyclic([(bag(tup2(Object,Object)),g)])
cyclic([(bag(tup2(Object,Object)),g)])
concrete([(bag(Object),g)])
set_comp([(bag(tup2(Object,Object)),g),(bag(Object),S),(Object,d)])
amodr([(int[],a),(int[],b),(int,i),(int,j)])
update_array_2d([(int[][],a),(int[][],r),(int,val),(int,i),(int,j)])
update_array_1d([(int[],a),(int[],r),(int,val),(int,i)])
update_array_1d_b([(boolean[],a),(boolean[],b),(boolean,val),(int,i)])
domb([(boolean[],a),(int,low),(int,high)])
dom([(int[],a),(int,low),(int,high)])
induce([(int,value)])
axiom ((domb(a,low,high)) & (low <= l)) | (h <= high) |- domb(a,l,h)
axiom (domb(a,low,high)) & ((low <= l) & (h <= high)) |- domb(a,l,h)
axiom (dom(a,low,high)) & ((low <= l) & (h <= high)) |- dom(a,l,h)

lemmas(to be proved and saved)[
=>coerc combineCell
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::cell{}(f1)<v>@M[HeapNode1]) * (self::cell{}(f2)<v>@M[HeapNode1]))))*(true)( FLOW __norm)
	 body:(emp ; (emp ; (self::cell{}(f1+f2)<v>@M[HeapNode1])))*(true)( FLOW __norm)
]

split lemmas[
=>coerc splitCell
	 kind: LEM_SPLIT
	 origin: user-given
	 head: (emp ; (emp ; (self::cell{}(f)<v>@M[HeapNode1])))*((f = f1+f2) & (f1 > 0.))( FLOW __norm)
	 body:(emp ; (emp ; ((self::cell{}(f1)<v>@M[HeapNode1]) * (self::cell{}(f2)<v>@M[HeapNode1]))))*(((0.) < f) & (f <= 1.))( FLOW __norm)
]

lemmas(to be proved and saved)[
=>coerc normalize
	 kind: LEM
	 origin: user-given
	 head: (emp ; (emp ; ((self::THRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}()<c,M>@M[HeapNode1]) * (self::dead{}()<>@M[HeapNode1]))))*(true)( FLOW __norm)
	 body:(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)
]

boolean rand_bool()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 98,:(emp)*(res)( FLOW __norm)
or(emp)*(!(res))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int rand_int()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 97,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] aalloc___(int dim)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 96,:(emp)*(dom(res,0,dim-1))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[][] update___2d(int v, int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 95,:(emp)*(update_array_2d(a,res,v,i,j))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean[] update___1d(boolean v, boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 94,:(emp)*((domb(res,ahalb,ahaub)) & (update_array_1d_b(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int[] update___1d(int v, int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 93,:(emp)*((dom(res,ahalb,ahaub)) & (update_array_1d(a,res,v,i)))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 92,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void delete_ptr(int_ptr@R x)[]
static EBase: [][](emp ; (emp ; (x::int_ptr{}()<v>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 91,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void release()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 90,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void acquire()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 89,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void finalize()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 88,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void init()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 87,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void join()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 86,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int fork()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 85,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___2d(int[][] a, int i, int j)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 84,:(emp)*(res = a[i, j])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean array_get_elm_at___1d(boolean[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((domb(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 83,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int array_get_elm_at___1d(int[] a, int i)[]
static EBase: [][ ahalb ahaub](emp)*((dom(a,ahalb,ahaub)) & ((ahalb <= i) & (i <= ahaub)))( FLOW __norm) {EAssume: 82,:(emp)*(res = a[i])( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int pow___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 81,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean not___(boolean a)[]
static case{ECase:

	 !(a)->EAssume: 80,:(emp)*(res)( FLOW __norm)

	 a->EAssume: 79,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lor___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->case{ECase:

	 !(b)->EAssume: 78,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 77,:(emp)*(res)( FLOW __norm)
}

	 a->EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 76,:(emp)*(res)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean land___(boolean a, boolean b)[]
static case{ECase:

	 !(a)->EAssume: 75,:(emp)*(!(res))( FLOW __norm)

	 a->case{ECase:

	 !(b)->EAssume: 74,:(emp)*(!(res))( FLOW __norm)

	 b->EAssume: 73,:(emp)*(res)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gte___(int a, int b)[]
static case{ECase:

	 a < b->EAssume: 72,:(emp)*(!(res))( FLOW __norm)

	 a >= b->EAssume: 71,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean gt___(int a, int b)[]
static case{ECase:

	 a <= b->EAssume: 70,:(emp)*(!(res))( FLOW __norm)

	 a > b->EAssume: 69,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lte___(int a, int b)[]
static case{ECase:

	 a > b->EAssume: 68,:(emp)*(!(res))( FLOW __norm)

	 a <= b->EAssume: 67,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean lt___(int a, int b)[]
static case{ECase:

	 a >= b->EAssume: 66,:(emp)*(!(res))( FLOW __norm)

	 a < b->EAssume: 65,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(boolean a, boolean b)[]
static case{ECase:

	 a != b->EAssume: 64,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 63,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean neq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 62,:(emp)*(res)( FLOW __norm)

	 a = b->EAssume: 61,:(emp)*(!(res))( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

boolean eq___(int a, int b)[]
static case{ECase:

	 a != b->EAssume: 60,:(emp)*(!(res))( FLOW __norm)

	 a = b->EAssume: 59,:(emp)*(res)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 58,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 57,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float mult___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 56,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 55,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 54,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float minus___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 53,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 52,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(float a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 51,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

float add___(int a, float b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 50,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mod___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 49,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 48,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 1) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 47,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0-1) & ((0 <= res) & (res <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 46,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 45,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q <= 0) & ((0 <= res) & (res <= (0-b)-1))))( FLOW __norm))

	 b >= 1->case{ECase:

	 a >= b->case{ECase:

	 a >= (2) * (b)->EAssume: 44,:(EX q . (emp)*((a = ((b) * (q))+res) & ((q >= 0) & ((0 <= res) & (res <= b-1))))( FLOW __norm))

	 a < (2) * (b)->EAssume: 43,:(emp)*(res = a-b)( FLOW __norm)
}

	 a < b->EAssume: 42,:(emp)*(res = a)( FLOW __norm)
}
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div4(int a, int b)[]
static EBase: [][](emp)*(b != 0)( FLOW __norm) {EAssume: 41,:(emp)*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div3(int a, int b)[]
static case{ECase:

	 b != 0->EAssume: 40,:(emp)*(true)( FLOW __norm)

	 b = 0->EBase: [][](hfalse)*(false)( FLOW __norm) {EAssume: 39,:(hfalse)*(false)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div2(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {case{ECase:

	 b = 0->EAssume: 38,:(emp)*(true)( FLOW __DivByZeroErr)

	 b != 0->EAssume: 37,:(emp)*(true)( FLOW __norm)
}}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int div___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 36,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 35,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res >= 1) & ((0 <= r) & (r <= (0-b)-1))))( FLOW __norm))

	 b >= 1->EAssume: 34,:(EX r . (emp)*((a = ((b) * (res))+r) & ((res <= 0-1) & ((0 <= r) & (r <= b-1))))( FLOW __norm))
}

	 a >= 0->case{ECase:

	 ((0-1) < b) & (b < 1)->EAssume: 33,:(emp)*(true)( FLOW __DivByZeroErr)

	 b <= 0-1->EAssume: 32,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= (0-b)-1)) & (res <= 0)))( FLOW __norm))

	 b > 1->EAssume: 31,:(EX r . (emp)*((a = ((b) * (res))+r) & (((0 <= r) & (r <= b-1)) & ((res >= 0) & (res < a))))( FLOW __norm))

	 b = 1->EAssume: 30,:(emp)*(res = a)( FLOW __norm)
}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mults___(int a, int b)[]
static case{ECase:

	 a < 0->case{ECase:

	 b > 0->EAssume: 29,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < a) & (res < 0-b))))( FLOW __norm)

	 b < 0->EAssume: 28,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > 0-a) & (res > 0-b))))( FLOW __norm)

	 b = 0->EAssume: 27,:(emp)*(res = 0)( FLOW __norm)
}

	 a > 0->case{ECase:

	 b > 0->EAssume: 26,:(emp)*((res = (a) * (b)) & ((res > 0) & ((res > a) & (res > b))))( FLOW __norm)

	 b < 0->EAssume: 25,:(emp)*((res = (a) * (b)) & ((res < 0) & ((res < 0-a) & (res < b))))( FLOW __norm)

	 b = 0->EAssume: 24,:(emp)*(res = 0)( FLOW __norm)
}

	 a = 0->EAssume: 23,:(emp)*(res = 0)( FLOW __norm)
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int mult___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 22,:(emp)*(res = (a) * (b))( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int minus___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 21,:(emp)*(res = a-b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

int add___(int a, int b)[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 20,:(emp)*(res = a+b)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void main()[]
static EBase: [][](emp ; (emp ; emp))*(true)( FLOW __norm) {EAssume: 19,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int n,cell x,item tp
int n = (99, ):input();
cell x = new cell(1);
item tp = (100, ):forkThreads(x, n);
(101, ):joinThreads(tp, x, n);
(102, ):destroyCell(x);
(103, ):destroyDeadPool(tp)}
}
int input()[]
static EBase: [][](emp ; (emp ; emp))*(true)( FLOW __norm) {EAssume: 18,:(emp)*(res > 0)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void destroyDeadPool(item tp)[]
static EBase: [][](emp ; (emp ; (tp::deadPool{}()<n>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 16,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(104, ):if (tp == null) { 
  (104, ):{(108, ):return };
} else { 
  (104, ):{(105, ):destroyDeadPool(member access tp~~>next);
(107, ):destroyItem(tp)}
}}
}
void destroyItem(item x)[]
static EBase: [][](emp ; (emp ; (x::item{}()<Anon_22,Anon_23>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 15,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void destroyCell(cell x)[]
static EBase: [][](emp ; (emp ; (x::cell{}()<Anon_21>@M[HeapNode1])))*(true)( FLOW __norm) {EAssume: 14,:(emp ; (emp ; emp))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void joinThreads(item tp, cell x, int n)[]
static EBase: [][](emp ; (emp ; (tp::threadPool{}()<x,n,n>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 13,:(emp ; (emp ; ((x::cell{}()<Anon_20>@M[HeapNode1]) * (tp::deadPool{}()<n>@M[HeapNode1]))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(110, ):joinHelper(tp, x, n, n)}
}
void joinHelper(item tp, cell x, int n, int M)[]
static EBase: [][](emp ; (emp ; (tp::threadPool{}()<x,n,M>@M[HeapNode1])))*((M >= n) & (n >= 0))( FLOW __norm) {EAssume: 10,:(emp ; (emp ; ((x::cell{}((n) / (M))<Anon_19>@M[HeapNode1]) * (tp::deadPool{}()<n>@M[HeapNode1]))))*(n > 0)( FLOW __norm)
or(emp ; (emp ; (tp::deadPool{}()<n>@M[HeapNode1])))*(n = 0)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(111, ):if (tp == null) { 
  (111, ):{(117, ):return };
} else { 
  (111, ):{local: item node,thrd t
item node = member access tp~~>next;
(113, ):joinHelper(node, x, n - 1, M);
thrd t = member access tp~~>t;
(116, ):join_thrd(t)}
}}
}
item forkThreads(cell x, int n)[]
static EBase: [][](emp ; (emp ; (x::cell{}()<Anon_18>@M[HeapNode1])))*(n > 0)( FLOW __norm) {EAssume: 9,:(emp ; (emp ; (res::threadPool{}()<x,n,n>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(119, ):return (120, ):forkHelper(x, n, n)}
}
item forkHelper(cell x, int n, int M)[]
static case{ECase:

	 n > 0->EBase: [][](emp ; (emp ; (x::cell{}(f)<Anon_17>@M[HeapNode1])))*((f = (n) / (M)) & (M >= n))( FLOW __norm) {EAssume: 6,:(emp ; (emp ; (res::threadPool{}()<x,n,M>@M[HeapNode1])))*(true)( FLOW __norm)}

	 n = 0->EBase: [][](emp ; (emp ; emp))*(true)( FLOW __norm) {EAssume: 5,:(emp ; (emp ; emp))*(res = null)( FLOW __norm)}
}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{(121, ):if (n == 0) { 
  (121, ):{(127, ):return null};
} else { 
  (121, ):{local: thrd t,item p,item node
thrd t = (122, ):create_thrd();
(123, ):fork_thrd(t, x, M);
item p = (124, ):forkHelper(x, n - 1, M);
item node = new item(t, p);
(126, ):return node}
}}
}
void thread(cell x, int M)[]
static EBase: [][](emp ; (emp ; (x::cell{}((1) / (M))<Anon_15>@M[HeapNode1])))*(M > 0)( FLOW __norm) {EAssume: 4,:(emp ; (emp ; (x::cell{}((1) / (M))<Anon_16>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 
{
{local: int tmp
int tmp = member access x~~>val}
}
void join_thrd(thrd t)[]
static EBase: [][](EX x M . (emp ; (emp ; (t::THRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}()<x,M>@M[HeapNode1])))*(true)( FLOW __norm)) {EAssume: 3,:(emp ; (emp ; ((t::dead{}()<>@M[HeapNode1]) * (HVar Q))))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

void fork_thrd(thrd t, cell x, int M)[]
static EBase: [][](emp ; (emp ; ((t::THRD{(emp ; (emp ; (HVar P)))*(true)( FLOW __norm),(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}()<x,M>@M[HeapNode1]) * (HVar P))))*(true)( FLOW __norm) {EAssume: 2,:(emp ; (emp ; (t::THRD2{(emp ; (emp ; (HVar Q)))*(true)( FLOW __norm)}()<x,M>@M[HeapNode1])))*(true)( FLOW __norm)}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

thrd create_thrd()[]
static EBase: [][](emp)*(true)( FLOW __norm) {EAssume: 1,:(EX x M . (emp ; (emp ; (res::THRD{(emp ; (emp ; (x::cell{}((1) / (M))<Anon_11>@M[HeapNode1])))*(M > 0)( FLOW __norm),(emp ; (emp ; (x::cell{}((1) / (M))<Anon_12>@M[HeapNode1])))*(true)( FLOW __norm)}()<x,M>@M[HeapNode1])))*(true)( FLOW __norm))}
dynamic EBase: [][](hfalse)*(false)( FLOW __false) 

@@prog4

Starting z3... 

WARNING: ./hip/conchip/deadpool.ss_75:2_79:3:WARNING : case construct has missing scenario
Found : : (n=0 | 0<n)
Added : : n<=(0-1)


WARNING: ./hip/conchip/deadpool.ss_38:11_38:25:the result type __norm#E is not covered by the throw list[]

WARNING: ./hip/conchip/deadpool.ss_34:11_34:28:the result type __norm#E is not covered by the throw list[]
Starting Reduce... 
Nested Timer(stop)

Checking procedure destroyDeadPool$item... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure destroyDeadPool$item SUCCESS.

Checking procedure forkHelper$cell~int~int... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

() :./hip/conchip/deadpool.ss:86: 4: Proving precondition in method failed


(Cause of PreCond Failure):./hip/conchip/deadpool.ss:86: 4:  List of Failesc Context: []

Context of Verification Failure: 1 File "",Line:0,Col:0
Last Proving Location: 1 File "./hip/conchip/deadpool.ss",Line:86,Col:4

ERROR: at ./hip/conchip/deadpool.ss_86:4_86:20 
Message: Proving precondition in method failed.
 
Procedure forkHelper$cell~int~int FAIL.(2)

Exception Failure("Proving precondition in method failed.") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure forkHelper$cell~int~int

Checking procedure forkThreads$cell~int... Nested Timer(stop)

Procedure forkThreads$cell~int SUCCESS.

Checking procedure joinHelper$item~cell~int~int... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure joinHelper$item~cell~int~int SUCCESS.

Checking procedure joinThreads$item~cell~int... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure joinThreads$item~cell~int SUCCESS.

Checking procedure main$... 
Procedure main$ SUCCESS.

Checking procedure thread$cell~int... Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)

Procedure thread$cell~int SUCCESS.

Termination checking result: SUCCESS

Stop Omega... 60 invocations 
14 false contexts at: ( (83,12)  (83,19)  (83,11)  (89,4)  (88,16)  (88,9)  (87,13)  (87,28)  (87,26)  (87,9)  (86,4)  (85,13)  (85,9)  (84,6) )

!!! log(small):(2.06546,1411)
!!! 
 log(bigger)(>4s)(106):(1590.,[(SAT:394<3:REDLOG (REDUCE LOGIC),15.);(imply:429<8:REDLOG (REDUCE LOGIC),15.);(imply:430<8:REDLOG (REDUCE LOGIC),15.);(SAT:436<9:REDLOG (REDUCE LOGIC),15.);(imply:499<19:REDLOG (REDUCE LOGIC),15.);(SAT:500<19:REDLOG (REDUCE LOGIC),15.);(imply:501<19:REDLOG (REDUCE LOGIC),15.);(SAT:502<19:REDLOG (REDUCE LOGIC),15.);(imply:506<20:REDLOG (REDUCE LOGIC),15.);(imply:513<21:REDLOG (REDUCE LOGIC),15.);(imply:516<21:REDLOG (REDUCE LOGIC),15.);(imply:517<21:REDLOG (REDUCE LOGIC),15.);(SAT:519<21:REDLOG (REDUCE LOGIC),15.);(imply:521<21:REDLOG (REDUCE LOGIC),15.);(SAT:524<21:REDLOG (REDUCE LOGIC),15.);(imply:555<25:REDLOG (REDUCE LOGIC),15.);(imply:560<26:REDLOG (REDUCE LOGIC),15.);(imply:561<27:REDLOG (REDUCE LOGIC),15.);(imply:566<27:REDLOG (REDUCE LOGIC),15.);(imply:568<27:REDLOG (REDUCE LOGIC),15.);(imply:569<28:REDLOG (REDUCE LOGIC),15.);(imply:572<28:REDLOG (REDUCE LOGIC),15.);(imply:575<28:REDLOG (REDUCE LOGIC),15.);(SAT:576<28:REDLOG (REDUCE LOGIC),15.);(SAT:583<28:REDLOG (REDUCE LOGIC),15.);(imply:584<29:REDLOG (REDUCE LOGIC),15.);(imply:587<29:REDLOG (REDUCE LOGIC),15.);(SAT:588<29:REDLOG (REDUCE LOGIC),15.);(imply:596<31:REDLOG (REDUCE LOGIC),15.);(imply:598<32:REDLOG (REDUCE LOGIC),15.);(SAT:608<32:REDLOG (REDUCE LOGIC),15.);(imply:610<33:REDLOG (REDUCE LOGIC),15.);(SAT:620<33:REDLOG (REDUCE LOGIC),15.);(imply:622<35:REDLOG (REDUCE LOGIC),15.);(imply:624<35:REDLOG (REDUCE LOGIC),15.);(SAT:631<35:REDLOG (REDUCE LOGIC),15.);(imply:632<35:REDLOG (REDUCE LOGIC),15.);(SAT:639<35:REDLOG (REDUCE LOGIC),15.);(imply:640<36:REDLOG (REDUCE LOGIC),15.);(imply:642<36:REDLOG (REDUCE LOGIC),15.);(imply:644<37:REDLOG (REDUCE LOGIC),15.);(imply:647<37:REDLOG (REDUCE LOGIC),15.);(SAT:649<37:REDLOG (REDUCE LOGIC),15.);(imply:668<39:REDLOG (REDUCE LOGIC),15.);(SAT:675<39:REDLOG (REDUCE LOGIC),15.);(SAT:699<39:REDLOG (REDUCE LOGIC),15.);(SAT:714<40:REDLOG (REDUCE LOGIC),15.);(SAT:716<43:REDLOG (REDUCE LOGIC),15.);(imply:719<44:REDLOG (REDUCE LOGIC),15.);(imply:721<44:REDLOG (REDUCE LOGIC),15.);(imply:725<45:REDLOG (REDUCE LOGIC),15.);(SAT:737<46:REDLOG (REDUCE LOGIC),15.);(imply:788<52:REDLOG (REDUCE LOGIC),15.);(imply:795<52:REDLOG (REDUCE LOGIC),15.);(SAT:797<52:REDLOG (REDUCE LOGIC),15.);(imply:799<53:REDLOG (REDUCE LOGIC),15.);(imply:918<72:REDLOG (REDUCE LOGIC),15.);(imply:920<75:REDLOG (REDUCE LOGIC),15.);(imply:922<77:REDLOG (REDUCE LOGIC),15.);(imply:924<77:REDLOG (REDUCE LOGIC),15.);(imply:925<77:REDLOG (REDUCE LOGIC),15.);(imply:926<78:REDLOG (REDUCE LOGIC),15.);(SAT:932<78:REDLOG (REDUCE LOGIC),15.);(SAT:935<78:REDLOG (REDUCE LOGIC),15.);(imply:946<81:REDLOG (REDUCE LOGIC),15.);(imply:948<82:REDLOG (REDUCE LOGIC),15.);(SAT:952<82:REDLOG (REDUCE LOGIC),15.);(imply:956<83:REDLOG (REDUCE LOGIC),15.);(SAT:960<83:REDLOG (REDUCE LOGIC),15.);(imply:966<85:REDLOG (REDUCE LOGIC),15.);(SAT:973<85:REDLOG (REDUCE LOGIC),15.);(imply:1033<95:REDLOG (REDUCE LOGIC),15.);(SAT:1034<95:REDLOG (REDUCE LOGIC),15.);(SAT:1036<95:REDLOG (REDUCE LOGIC),15.);(imply:1039<96:REDLOG (REDUCE LOGIC),15.);(imply:1042<96:REDLOG (REDUCE LOGIC),15.);(SAT:1044<97:REDLOG (REDUCE LOGIC),15.);(imply:1049<99:REDLOG (REDUCE LOGIC),15.);(imply:1051<101:REDLOG (REDUCE LOGIC),15.);(SAT:1054<101:REDLOG (REDUCE LOGIC),15.);(imply:1064<102:REDLOG (REDUCE LOGIC),15.);(imply:1068<102:REDLOG (REDUCE LOGIC),15.);(SAT:1130<106:REDLOG (REDUCE LOGIC),15.);(imply:1136<107:REDLOG (REDUCE LOGIC),15.);(imply:1139<107:REDLOG (REDUCE LOGIC),15.);(SAT:1144<108:REDLOG (REDUCE LOGIC),15.);(SAT:1149<111:REDLOG (REDUCE LOGIC),15.);(imply:1151<112:REDLOG (REDUCE LOGIC),15.);(imply:1165<113:REDLOG (REDUCE LOGIC),15.);(imply:1182<114:REDLOG (REDUCE LOGIC),15.);(SAT:1195<115:REDLOG (REDUCE LOGIC),15.);(SAT:1257<122:REDLOG (REDUCE LOGIC),15.);(imply:1260<123:REDLOG (REDUCE LOGIC),15.);(imply:1268<125:REDLOG (REDUCE LOGIC),15.);(SAT:1269<125:REDLOG (REDUCE LOGIC),15.);(imply:1347<143:REDLOG (REDUCE LOGIC),15.);(imply:1349<143:REDLOG (REDUCE LOGIC),15.);(imply:1350<143:REDLOG (REDUCE LOGIC),15.);(imply:1351<144:REDLOG (REDUCE LOGIC),15.);(imply:1354<144:REDLOG (REDUCE LOGIC),15.);(imply:1355<144:REDLOG (REDUCE LOGIC),15.);(SAT:1357<144:REDLOG (REDUCE LOGIC),15.);(imply:1361<145:REDLOG (REDUCE LOGIC),15.);(imply:1363<145:REDLOG (REDUCE LOGIC),15.);(imply:1367<146:REDLOG (REDUCE LOGIC),15.);(SAT:1368<146:REDLOG (REDUCE LOGIC),15.)])
Total verification time: 1.847498 second(s)
	Time spent in main process: 1.770642 second(s)
	Time spent in child processes: 0.076856 second(s)

