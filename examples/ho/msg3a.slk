
data cell {
  int x;
}.

pred_prim MSG{F}<c:cell>
 inv true.


checkentail c::MSG{v::cell<1> & true}<v> * x::cell<1> 
    |- c::MSG{%P}<x> .
print residue.
/*
# msg3a.slk

When we have the state:
 c::MSG{v::cell<1> & true}<v>

We need to view it as:
 (exists v: c::MSG{v::cell<1> & true}<v>)


When we have:
 c::MSG{%P}<x>

We really need to view x as an instantiation rather
than a proving location; so as to allow x to be bound into
%P later.

GOT
===
Fail. 


Since v is bound, can we try to bind v=x, and then generate
the following binding for P.

ho_vars: [P --> (exists flted_14_31,v: v::cell<flted_14_31>&flted_14_31=1
             & v=x)

*/

/*

 let ch=create() with (exists v: ch::MSG{v::cell<1>}<v>)

 send(ch,v) requires ch::MSG{%P}<v> * %P
            ensures 
*/


