Assuming given:
  -> the barrier calls 
  -> method specs (minus barrier states)
  -> shared variables
  -> synchronization on only one barrier
  
 
 -> for each method, construct part of the barrier graph
 
 -> found examples in parsec 2.1 : 
      streamcluster.cpp
      fluidanimate/src/pthreads.cpp
      canneal/src/anneal_thread.cpp
      bodytrack/src/trackingbenchmark/threads/workergroup.cpp
      bodytrack/src/trackingbenchmark/trackingmodelomp.cpp
      bodytrack/src/trackingbenchmark/particlefilter.h
      bodytrack/src/trackingbenchmark/particlefilterpthread.h
 
 -> patterns found  (same code on all threads): 
     1) barrier ; call; barrier ; call ...
     2) loop { code ; barrier; }
          a) both the code and the barrier exited the loop 
          b) the code exited the loop, the barrier did not -> sequences of loops?
     3) branches, with barriers
              a) conditions on the shared vs on the private 
                  no difference ...
              b) can lead to split in barrier diag vs should not lead to split in barrier diag 
                  decision taken on
                    Splits on the next state or not? should it matter ?
                 not really, it depends on the permissions not on the branch conditions those just give
                  the  contradictions if needed
              c) impossible to take a decision based on a variable that could have been changed (from previous states)
     
    4a) compute the discriminant condition ...
     
     4) issues with compaction of the diagram, when two states should be merged?
          
     5) compute the most lax of the constraints?
     
     6) recursive functions - as loops -> terminal state?
     
     
     7) merging informations on different threads?
          a) same program, no need for merging, should agree on everything
          b) different programs:
              -> graph
                  *) always pick the more complex, a loop to a string, a split to a single successor             
              -> specifications
                  *) need to agree on the read groups, write groups
                 **) split and agree on the read fractions
                ***) manage the discriminant conditions
  
Stages: A) construct the graph; B) determine permission requirements  C) determine available pre's D) compute the actual splittings + discriminants

-> initial restrictions:
        -> focus only on the single shared memory cells  (not the entire reachable graph)
        -> the graph can be reconstructed from the control graph? 
            -> inefficient but works (not the most compact barrier definition)
   
  
           
A)construct the graph:
      ->> issues: barrier aliases, multiple barrier defs, multiple barrier instances
      ->> assuming: single barrier def, single barrier instance, initially no aliasing?
            
        ({},c) e (G',c', e') 
        rename c' to c in G' and e'
        Gr = G + G'
  --------------------------------------------
      (G,c, (while cnd e)) -> (Gr,c , while cnd e')
      
      
      ({},c, e1) -> (G',c',e1') 
      ({},c, e2) -> (G',c'', e2')
        rename c'' to c' in G' end e2'
        Gr = G + G'+G''
  --------------------------------------------       ->> does it need to be in the same state at the end? i think it makes sense to be so , same code same expectations
      (G,c) {if _ then e1 else e2} (Gr,c')
      
          G' = G + (c->c')    
  --------------------------------------------
        (G,c, barrier b) (G',c', barrier b //(c->c'))
        
        
  --------------------------------------------
    (G,c,e1=e2) -> (G,c,e1=e2)
    
    
    m(...):= ({},ci)->(G',cf)
    rename c to ci 
    Gr = G+G'  -> if G' is not in G
  --------------------------------------------
      (G,c, m(...)) -> (Gr,cf, m(...))
      
      m(...) {body}
      ({},ci,body)->(G',cf,body')
  --------------------------------------------
    m(...){body'}:=({},ci)->(G',cf)
           
           
B) determine permission requirements     
 post in one go:
    a) start in a state
    b) collect constraints until the next barrier is reached, these will be the post for the transition.
    c) second pass, adding the required resources (assume they are given by the barrier call), once the barrier call is reached, the state 
      is what is available for the reshuffling.
    d) continue with the next code fragment from step a.
pre: 
  collect all the posts and in each thread take what is needed from the collected resources available for reshuffling
    
 
Collection, straight forward, in parrallel with a relaxed forward verification:
    
    -> for each method compute if it did any barrier calls 
    -> construct a subset of the shared variables, with a mark of wheter : full, partial known or partial unknown permission
       S subset {shared_vars}x {F| P | P+concrete share}

    -> at each entailment, if one of the shared is missing then add it and remember it being added
    -> need some backward propagation for the pure constraints? maybe it can be done in a separate step....
       
       add(S,(x,P)) = 
         if (x,F) in S then S
         else if (x,P c) in S then S
         else S \/ {(x,P c)}
        
       add(S,(x,P c1)) = 
          if (x,F) in S then S
          else if (x,P c2) in S then S \/{(x,P c1+c2)}
          else S \/ {(x,P c1)}
        
       add(S,(x,F)) = S\/{(x,F)}
    
            
            S' = add(S,(x,P))
        ------------------- [RHS_fa]
          S |> x.f  S'
          
          S' = add(S,(x,P))
        ------------------- [RHS_a]
          S |> x  S'
          
          
          S |> e1 S2
          S2 |> e2 S'
        ------------------- [RHS_op]
          S|> e1 op e2 S'

       
          S|> e' S''
          S' = add (S'', (x,F))
       --------------------- [Assign]
          S|> x = e' S'
          
          
          S|> e' S''
          S' = add (S'', (x,F))
       --------------------- [Assign]
          S|> x.f = e' S'
          
          S|> e1 S'    S'|> e2 S''
       ----------------------- [Seq]
          S|> e1;e2 S'' 
       
       
          S|> e1 S1    S|> e2 S2
            split analysis, continue in parralele until the next barrier call
       ----------------------- [Seq]
          S|> if c then e1 else e2 
            
       
          Phi = pre(f)
          forall i:
              if Phi |- vi::type_vi <....>  then add (S,{(x,F)})
              else if Phi |- vi::type_vi @c <....> then add (S,{(x,P c)})
              else S
         if f did a barrier call, stop 
       ----------------------- [Call]
          S|>  f(v1....v2) S'
         
         
       
        record the context of the verification for this barrier transition
        record the precondition requirements for the previous barrier transition
       ---------------------------------------------------------------------
                          S|> barrier b  {}
                          
                          
