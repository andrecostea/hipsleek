Assuming given:
  -> the barrier calls 
  -> method specs (minus barrier states)
  -> shared variables
  -> synchronization on only one barrier
  
 
 -> for each method, construct part of the barrier graph
 
 -> found examples in parsec 2.1 : 
      streamcluster.cpp
      fluidanimate/src/pthreads.cpp
      canneal/src/anneal_thread.cpp
      bodytrack/src/trackingbenchmark/threads/workergroup.cpp
      bodytrack/src/trackingbenchmark/trackingmodelomp.cpp
      bodytrack/src/trackingbenchmark/particlefilter.h
      bodytrack/src/trackingbenchmark/particlefilterpthread.h
 
 -> patterns found  (same code on all threads): 
     1) barrier ; call; barrier ; call ...
     2) loop { code ; barrier; }
          a) both the code and the barrier exited the loop 
          b) the code exited the loop, the barrier did not -> sequences of loops?
     3) branches, with barriers
              a) conditions on the shared vs on the private 
                  no difference ...
              b) can lead to split in barrier diag vs should not lead to split in barrier diag 
                  decision taken on
                    Splits on the next state or not? should it matter ?
                 not really, it depends on the permissions not on the branch conditions those just give
                  the  contradictions if needed
              c) impossible to take a decision based on a variable that could have been changed (from previous states)
     
    4a) compute the discriminant condition ...
     
     4) issues with compaction of the diagram, when two states should be merged?
          
     5) compute the most lax of the constraints?
     
     6) recursive functions - as loops -> terminal state?
     
     
     7) merging informations on different threads?
          a) same program, no need for merging, should agree on everything
          b) different programs:
              -> graph
                  *) always pick the more complex, a loop to a string, a split to a single successor             
              -> specifications
                  *) need to agree on the read groups, write groups
                 **) split and agree on the read fractions
                ***) manage the discriminant conditions
                
                
propag backward for the prev transition post

graph+post in one go:
    a) start in a state
    b) collect constraints until the next barrier is reached, these will be the post for the transition.
    c) second pass, adding the required resources (assume they are given by the barrier call), once the barrier call is reached, the state 
      is what is available for the reshuffling.
    d) continue with the next code fragment from step a.
pre: 
  collect all the posts and in each thread take what is needed from the collected resources available for reshuffling
    
 
Collection, straight forward, in parralle with a relaxed forward verification:
    -> at each entailment, if one of the shared is missing then add it and remember it being added
    -> for each method compute if it did any barrier calls 
    -> construct a subset of the shared variables, with a mark of wheter : full, partial known or partial unknown permission, and pure constraints on the
        arguments of the vars
       S subset {shared_vars}x {F| P | P+concrete share} x pure_formula 

       
       
         if (x,P,f1) in S then (S\{(x,P,f1)})\/{(x,P,f/\f1)}
         else if (x,F,f1) in S then (S\{(x,F,f1)})\/{(x,F,f/\f1)}
         else S \/ {(x,P,f)}
      -----------------------------------
                add(S,(x,P,f))
        
        
        if (x,P,f1) in S then (S\{(x,P,f1)})\/{(x,F,f/\f1)}
                      else S \/ {(x,F,)}
      -----------------------------------
                add(S,(x,F,f))
        
    
            
            S' = add(S,(x,P))
        ------------------- [RHS_fa]
          S |> x.f  S'
          
          S' = add(S,(x,P))
        ------------------- [RHS_a]
          S |> x  S'
          
          
          S |> e1 S2
          S2 |> e2 S'
        ------------------- [RHS_op]
          S|> e1 op e2 S'

       
          S|> e' S''
          S' = add (S'', (x,F))
       --------------------- [Assign]
          S|> x = e' S'
          
          
          S|> e' S''
          S' = add (S'', (x,F))
       --------------------- [Assign]
          S|> x.f = e' S'
          
          S|> e1 S'    S'|> e2 S''
       ----------------------- [Seq]
          S|> e1;e2 S'' 
       
       
       
          Phi = pre(f)
          forall i:
              if Phi |- vi::type_vi <....>  then add (S,{(x,F)})
              else add (S,{(x,P)})
              collect from the precondition the pure constraints on the vi arguments
         if f did a barrier call, stop 
       ----------------------- [Call]
          S|>  f(v1....v2) S'
         
       
