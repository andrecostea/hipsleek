open Cpure
open Cformula
open Gen.Basic
open Globals

module CP = Cpure

type term_type =
	| Base
	| Rec

type term_ctx = {
	t_type 	: term_type;
	(* Context associating with base cases or recursive cases *)
	t_ctx 	: list_failesc_context;	
	(* Pure condition of function parameters for base cases or recursive cases *)
	(* Generated by simplifying t_ctx via exist elimination *)
	t_cond_pure 	: CP.formula; 
}

type list_term_ctx = term_ctx list

(* Cprinter Utilities *)
let print_path_trace = ref (fun (c: path_trace) -> "Printer has not been initialized.")

let partition_term_ctx tctx = 
	List.partition (fun ctx -> match ctx.t_type with
	| Base -> true | _ -> false) tctx
	
let collect_path_trace_term_ctx tctx =
	collect_path_trace_list_failesc_context tctx.t_ctx 

(* If a path trace of a base context is a SUPERSET of *)
(* a path trace of a recursive context, then the recursive *)
(* call is met BEFORE the return statement *)
(* so that these labels are not allowed in base context *)
let remove_incorrect_base_term_ctx tctx list_lbl =
	(* let _ = print_string ("rc_lbl: " ^ (pr_list !print_path_trace list_lbl)) in *)
	{ tctx with t_ctx = match tctx.t_type with
	| Base -> List.map (fun (fail_c, esc_c, succ_c) ->
			let succ_c = List.filter (fun (lbl, _) -> 
				not (List.exists (fun l -> Gen.BList.subset_eq (=) l lbl) list_lbl)) succ_c in
			(fail_c, esc_c, succ_c)) tctx.t_ctx
	| Rec -> tctx.t_ctx}
	
let remove_incorrect_base_list_term_ctx tctx =
	let bs, rc = partition_term_ctx tctx in
	let list_rec_lbl = List.concat (List.map collect_path_trace_term_ctx rc) in
	List.map (fun ctx -> remove_incorrect_base_term_ctx ctx list_rec_lbl) tctx
	
let remove_unsat_ctx_list_term_ctx tctx =
	List.map (fun ctx -> 
		{ctx with t_ctx = remove_unsat_succ_ctx_list_failesc_context ctx.t_ctx}) tctx
	
let remove_empty_ctx_list_term_ctx tctx = 
	let tctx = List.map (fun ctx -> 
		{ctx with t_ctx = remove_empty_succ_ctx_list_failesc_context ctx.t_ctx}) tctx in
	List.filter (fun ctx -> not (ctx.t_ctx = [])) tctx