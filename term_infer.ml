open Cpure
open Cformula
open Gen.Basic
open Globals
open Cast

module CP = Cpure
module DD = Debug

type term_type =
	| Base
	| Rec of ident (* Name of recursive callee *)

type term_res =
	| Loop
	| Term
	| Unknown of string

type term_ctx = {
	t_type 				: term_type;
	(* Original Context associating with base cases or recursive cases *)
	t_ctx 				: list_failesc_context;	
	(* Each element of t_pure_ctx is a separate context *)
	t_pure_ctx		: CP.formula list;
	(* Args list and Params list *)
	t_params			: (spec_var list * spec_var list); 
	(* Pure condition of function parameters for base cases or recursive cases *)
	(* Generated by simplifying t_ctx via exist elimination                    *)
	t_cond_pure 	: (CP.formula * term_res) list; 
}

type list_term_ctx = term_ctx list

type term_case_spec = ((CP.formula list) * term_res) list

type term_trans_constraint = {
	trans_src			: term_res;
	trans_src_cond: CP.formula list;
	trans_dst			: term_res;	
	trans_dst_cond: CP.formula list;
	trans_subst		: (spec_var list * spec_var list);
	trans_ctx			: CP.formula;
}

let term_spec_tbl : (ident, term_case_spec) Hashtbl.t = Hashtbl.create 10

let term_ctx_tbl : (ident, list_term_ctx) Hashtbl.t = Hashtbl.create 10

(* Cprinter Utilities *)
let print_path_trace = ref (fun (c: path_trace) -> "Printer has not been initialized.")
let print_pure_formula = ref (fun (c: CP.formula) -> "Printer has not been initialized.")
let print_pure_exp = ref (fun (c: CP.exp) -> "Printer has not been initialized.")
let print_term_case_spec = ref (fun (c: term_case_spec) -> "Printer has not been initialized.")
let print_term_ctx = ref (fun (c: term_ctx) -> "Printer has not been initialized.")
let print_term_trans_constraint = ref (fun (c: term_trans_constraint) -> "Printer has not been initialized.")

(* Debugging Utilities *)
let info_hprint str pr f = DD.info_hprint (add_str str pr) f no_pos
let info_pprint str = DD.info_pprint str no_pos

let partition_term_ctx tctx = 
	List.partition (fun ctx -> match ctx.t_type with
	| Base -> true | _ -> false) tctx
	
let collect_path_trace_term_ctx tctx =
	collect_path_trace_list_failesc_context tctx.t_ctx 

(* If the path trace of a base context is a SUPERSET of *)
(* the path trace of a recursive context, then the      *)
(* recursive call is met BEFORE the return statement    *)
(* so that these labels and their associated contexts   *)
(* should be removed in base context                    *)
let remove_incorrect_base_term_ctx tctx list_lbl =
	(* let _ = print_string ("rc_lbl: " ^ (pr_list !print_path_trace list_lbl)) in *)
	{ tctx with t_ctx = match tctx.t_type with
	| Base -> List.map (fun (fail_c, esc_c, succ_c) ->
			let succ_c = List.filter (fun (lbl, _) -> 
				not (List.exists (fun l -> Gen.BList.subset_eq (=) l lbl) list_lbl)) succ_c in
			(fail_c, esc_c, succ_c)) tctx.t_ctx
	| Rec _ -> tctx.t_ctx}
	
let remove_incorrect_base_list_term_ctx tctx =
	let bs, rc = partition_term_ctx tctx in
	let list_rec_lbl = List.concat (List.map collect_path_trace_term_ctx rc) in
	List.map (fun ctx -> remove_incorrect_base_term_ctx ctx list_rec_lbl) tctx
	
let remove_unsat_ctx_list_term_ctx tctx =
	List.map (fun ctx -> 
		{ctx with t_ctx = remove_unsat_succ_ctx_list_failesc_context ctx.t_ctx}) tctx
	
let remove_empty_ctx_list_term_ctx tctx = 
	let tctx = List.map (fun ctx -> 
		{ctx with t_ctx = remove_empty_succ_ctx_list_failesc_context ctx.t_ctx}) tctx in
	List.filter (fun ctx -> not (ctx.t_ctx = [])) tctx

(* Get the pure condition from context *)
(* and assign Term or Unknown for Base *)
(* and Rec, resp.                      *)
let update_cond_pure_term_ctx	tctx =
	let lf = collect_formula_list_failesc_context tctx.t_ctx in
	let lpf = List.concat (List.map pure_of_formula lf) in
	(* let _ = print_endline (pr_list !print_pure_formula lpf) in *)
	{tctx with 
		t_pure_ctx = lpf;
		t_cond_pure = List.map (fun f ->
			match tctx.t_type with
			| Base -> (f, Term)
			| Rec _ -> (f, Unknown "")) lpf;}
	
let update_cond_pure_list_term_ctx tctx = 
	List.map update_cond_pure_term_ctx tctx
	
let get_method_args proc =
	let farg_types, farg_names = List.split proc.proc_args in	
	List.map2 (fun n t -> CP.SpecVar (t, n, Unprimed)) farg_names farg_types

(* Simplify the termination context to get *)
(* the conditions on method's arguments    *)
let simplify_t_cond_pure args (f, t_res) =
	let qsv = diff_svl (CP.fv f) args in
	(* a!=b has already been transformed to a<b | a>b by Omega *)
	let simpl_f = mkExists_with_simpl Omega.simplify qsv f None no_pos in
	List.map (fun f -> (f, match t_res with
	| Unknown "" -> Unknown (string_of_int (fresh_int ()))
	| _ -> t_res)) (CP.list_of_disjs simpl_f)
		
let simplify_cond_pure_term_ctx args tctx =
	{tctx with t_cond_pure = List.concat (List.map (simplify_t_cond_pure args) tctx.t_cond_pure);}
	
let simplify_cond_pure_list_term_ctx proc tctx =
	let farg_spec_vars = get_method_args proc in
	List.map (simplify_cond_pure_term_ctx farg_spec_vars) tctx
	
(* Construct case spec of termination from termination context *)
let case_spec_of_term_ctx tctx =
	List.map (fun (f, t_res) -> ([f], t_res)) tctx.t_cond_pure

(* TODO: Do we need to check case coverage? *)		
let term_case_spec_of_list_term_ctx tctx =
	List.concat (List.map case_spec_of_term_ctx tctx) 
	
(* Look up termination context and spec *)
let look_up_term_ctx mn =
	Hashtbl.find term_ctx_tbl mn
	
let look_up_term_spec mn =
	Hashtbl.find term_spec_tbl mn
	
let rename_term_spec (fsv, tsv) tspec = 
	List.map (fun (cond, tres) -> 
		(List.map (CP.subst_avoid_capture fsv tsv) cond, tres)) tspec

(* Collect set of termination transition constraints *)
(* based on the termination context of a function   *)
let collect_term_trans_constraints_one_case tp_utils (cond, unk) (mn, ctx) =
	let (is_sat, _, _) = tp_utils in
	let mn_tspec = look_up_term_spec mn in
	let callee_tspec = rename_term_spec ctx.t_params mn_tspec in
	(* let _ = print_endline (!print_term_case_spec callee_tspec) in *)
	List.fold_left (fun a (c_cond, c_tres) ->
		(* if [cond] /\ ctx /\ [c_cond] is SAT then unk >> c_tres (REACHABLE) *)
		let check_reachable single_ctx = 
			let reach_ctx = join_conjunctions (cond @ [single_ctx] @ c_cond) in
			(* let _ = print_endline ("\nTRANS_CTX: " ^ (!print_pure_formula reach_ctx) ^ "\n") in *)
			if (is_sat reach_ctx) then
				[{trans_src = unk; trans_src_cond = cond;
  				trans_dst = c_tres; trans_dst_cond = c_cond;
					trans_subst = ctx.t_params;
  				trans_ctx = single_ctx;}] 
			else []
		in a @ (List.concat (List.map check_reachable ctx.t_pure_ctx))
	) [] callee_tspec

let collect_term_trans_constraints_one_method tp_utils mn = 
	let mn_tctx = look_up_term_ctx mn in
	let mn_tspec = look_up_term_spec mn in
	let unk_cases = List.filter (fun (cond, r) ->
		match r with | Unknown _ -> true | _ -> false) mn_tspec in
	(* (name_of_callee, term_ctx) *)
	let rec_ctx = List.fold_left (fun a ctx -> 
		match ctx.t_type with
		| Base -> a
		| Rec c -> a @ [(c, ctx)]) [] mn_tctx in
	List.concat (List.map (fun c -> 
		List.concat (List.map (collect_term_trans_constraints_one_case tp_utils c) rec_ctx)) unk_cases)
		
(* TODO: collect termination constraints for each scc group *)

let norm_src_cond sc =
	match sc with
	| BForm ((bf, _), _) -> (match bf with
		| Lt (e1, e2, pos)	-> mkSubtract e2 e1 pos                              (* e1<e2  --> e2-e1>0   *)
		| Lte (e1, e2, pos)	-> mkAdd (mkSubtract e2 e1 pos) (mkIConst 1 pos) pos (* e1<=e2 --> e2-e1+1>0 *)
		| Gt (e1, e2, pos)	-> mkSubtract e1 e2 pos                              (* e1>e2  --> e1-e2>0   *)
		| Gte (e1, e2, pos)	-> mkAdd (mkSubtract e1 e2 pos) (mkIConst 1 pos) pos (* e1>=e2 --> e1-e2+1>0 *)
		| Eq (e1, e2, pos)	-> mkAdd (mkSubtract e1 e2 pos) (mkIConst 1 pos) pos (* e1=e2  --> e1-e2+1>0 *)
		| _ -> report_error no_pos "Termination Inference: Unexpected case condition"
		)
	| _ -> report_error no_pos "Termination Inference: Unexpected case condition"

let norm_dst_cond dc =
	match dc with
	| BForm ((bf, _), _) -> (match bf with
		| Lt (e1, e2, pos)	-> mkAdd (mkSubtract e1 e2 pos) (mkIConst 1 pos) pos (* e1<e2  --> e1-e2+1<=0 *)
		| Lte (e1, e2, pos)	-> mkSubtract e1 e2 pos                              (* e1<=e2 --> e1-e2<=0   *)
		| Gt (e1, e2, pos)	-> mkAdd (mkSubtract e2 e1 pos) (mkIConst 1 pos) pos (* e1>e2  --> e2-e1+1<=0 *)
		| Gte (e1, e2, pos)	-> mkSubtract e2 e1 pos                              (* e1>=e2 --> e2-e1<=0   *)
		| Eq (e1, e2, pos)	-> mkSubtract e1 e2 pos                              (* e1=e2  --> e1-e2=0    *)
		| _ -> report_error no_pos "Termination Inference: Unexpected case condition"
		)
	| _ -> report_error no_pos "Termination Inference: Unexpected case condition"

(*| ************************************************************ *)
(*| Solve termination constraints                                *)
(*| Step 1: Build a graph to present termination constraints     *)
(*| Step 2: Do inference bottom-up - Infer termination condition *)
(*| at transition A>>B where A!=B                                *)
(*| ************************************************************ *)

let simplify_inf_cond tp_utils ivars inf_cond ctx =
	let (is_sat, _, simplify) = tp_utils in
	let inf_cond = CP.mkOr (mkNot ctx None no_pos) inf_cond None no_pos in
	let qvars = diff_svl (CP.fv inf_cond) ivars in
	let simpl_cond = simplify (mkForall qvars inf_cond None no_pos) in
	let simpl_cl = CP.list_of_disjs simpl_cond in
	(* To remove the base case in the inferred condition *)
	(* Empty list means FALSE                            *)
	List.filter (fun c -> is_sat (CP.mkAnd c ctx no_pos)) simpl_cl
	(* [simpl_cond] *)

(* Check the condition for a monotone decreasing sequence start *)
(* from the condition Phi(X)>=0 and the update function X'=f(X) *)
let check_monotone_decreasing_sequence tp_utils ivars f_seq f_upd subst =
	let (_, imply, _) = tp_utils in
	let x = fst subst in
	let xp = snd subst in
	let xpp = List.map (fun x -> match x with
	| SpecVar (typ, name, prim) -> SpecVar (typ, fresh_old_name name, prim)) xp in
	let s_0 = f_seq in (* Phi(X) *)
	let s_1 = e_apply_subs (List.combine x xp) s_0 in (* Phi(X') - subst: X -> X' *)
	let s_2 = e_apply_subs (List.combine xp xpp) s_1 in (* Phi(X'') - subst: X' -> X'' *)
	let f_upd_p = CP.subst_avoid_capture x xp (CP.subst_avoid_capture xp xpp f_upd) in
	
	(* If true |- s_0 > s_1 Then return True                      *)
	(* Else If s_0 > s_1 |- s_1 > s_2 Then return (s_0 - s_1 > 0) *)
	(* Else return (s_1 <= 0)                                     *)
	let inf_cond, rank = 
	begin
  	if (imply f_upd (mkPure (mkGt s_0 s_1 no_pos))) 
  	then ([CP.mkTrue no_pos], Some s_0)
  	else 
  		let mkExists vs f = CP.mkExists vs f None no_pos in
  		let mkAnd f1 f2 = mkAnd f1 f2 no_pos in  
  		let merged_ctx = mkAnd (mkAnd 
  			(mkExists (diff_svl (CP.fv f_upd) (x @ xp)) f_upd) 
  			(mkExists (diff_svl (CP.fv f_upd_p) (xp @ xpp)) f_upd_p))
  			(mkPure (mkGt s_0 s_1 no_pos))
  		in
  		if (imply merged_ctx (mkPure (mkGt s_1 s_2 no_pos))) 
  		then (simplify_inf_cond tp_utils ivars (mkPure (mkGt s_0 s_1 no_pos)) f_upd, Some s_0)
  		else (simplify_inf_cond tp_utils ivars (mkPure (mkLte s_1 (mkIConst 0 no_pos) no_pos)) f_upd, None)
	end in
	(* Debug Information *)
	begin
		info_pprint ">>>>>>> check_monotone_decreasing_sequence <<<<<<<";
		info_hprint "s0" !print_pure_exp s_0;
		info_hprint "s1" !print_pure_exp s_1;
		info_hprint "s2" !print_pure_exp s_2;
		info_hprint "ctx s0->s1" !print_pure_formula f_upd;
		info_hprint "ctx s1->s2" !print_pure_formula f_upd_p;
		info_hprint "Infer Cond" (pr_list !print_pure_formula) inf_cond;
		info_hprint "Infer Rank" (pr_option !print_pure_exp) rank;
		info_pprint "\n";
	end; 
	rank
	

(* ivars is the set of variables that the inferred condition is based on them *)
let infer_term_condition tp_utils ivars tc (* trans_constraint *) =
	let sc = List.nth tc.trans_src_cond ((List.length tc.trans_src_cond) - 1) in
	let dc = List.nth tc.trans_dst_cond ((List.length tc.trans_dst_cond) - 1) in
	(* TODO: Support conjunctions in the condition *)
	(* Disjunctions have already been split        *)
	let sce = norm_src_cond sc in (* A in A>0  *)
	let dce = norm_dst_cond dc in (* B in B<=0 *)
	check_monotone_decreasing_sequence tp_utils ivars sce tc.trans_ctx tc.trans_subst
	
let main tp_utils procs =
	List.iter (fun proc ->
		let mn = proc.proc_name in
		let _ = print_endline ("Termination Inference for " ^ mn) in
		let t_ctx = look_up_term_ctx mn in
		let t_case_spec = look_up_term_spec mn in 
		let t_constraints = collect_term_trans_constraints_one_method tp_utils mn in
		let args = get_method_args proc in
		let inf_conds = List.fold_left (fun a c ->
			if (c.trans_src != c.trans_dst) then
				a @ [(infer_term_condition tp_utils args c)]
			else a) [] t_constraints
		in
		info_hprint "Termination Constraints" 
			(pr_list (fun c -> "\n" ^ (!print_term_trans_constraint c))) t_constraints;
		info_pprint "\n";
	) procs



