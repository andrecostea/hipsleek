open Cpure
open Cformula
open Gen.Basic
open Globals
open Cast

module CP = Cpure
module DD = Debug
module RL = Redlog
module MATH = Mathematica

module TNode = struct
	type t = int (* id of term_res *)
	let compare = compare
	let hash = Hashtbl.hash
	let equal = (=)
end

module TG = Graph.Persistent.Digraph.Concrete(TNode)		
module TGC = Graph.Components.Make(TG)	
module TGN = Graph.Oper.Neighbourhood(TG)

type term_type =
	| Base (* Where termination or non-termination can be determined *)
	| Rec of ident (* Name of recursive callee *)

type term_res =
	| MayLoop of int
	| Loop of int
	| Term of term_rank_info
	| Unknown of term_unk_info

and term_rank_info = {
	term_id       : int;
	term_rank     : CP.exp option;
	term_def			: bool;
}

and term_unk_info = {
	unk_id				: int;
	unk_callee		: ident;
	unk_params		: (spec_var list * spec_var list);
	unk_trans_ctx	: CP.formula;
	unk_cond      : CP.formula; (* Condition to reach this unknown *)
}

and term_ctx = {
	t_type        : term_type;
	(* Original Context associating with base cases or recursive cases *)
	t_ctx         : list_failesc_context;	
	(* Each element of t_pure_ctx is a separate context with the assoc path *)
	t_pure_ctx    : (path_trace * CP.formula) list;
	(* Args list and Params list *)
	t_params      : (spec_var list * spec_var list); 
	(* Pure condition of function parameters for base cases or recursive cases *)
	(* Generated by simplifying t_ctx via exist elimination                    *)
	t_cond_pure   : (path_trace * CP.formula * term_res) list; 
}

and list_term_ctx = term_ctx list

(* The structure below supports path-sensitive analysis for termination *)
and term_spec = 
	| TBase of term_spec_base
	| TCase of term_spec_case 
	| TSeq of term_spec_seq

and term_spec_base = {
	term_base_res	: term_res;
	term_base_cond: CP.formula;
}

and term_spec_case = (CP.formula * term_spec) list

(* Seq UNK1; UNK2; ... -> UNK *)
and term_spec_seq = { 
	term_seq_id		: int;
	term_seq_fst  : term_spec; 
	term_seq_snd  : term_spec;	
}

and term_trans_constraint = {
	term_trans_src: term_res;
	term_trans_dst: term_res;	
	term_src_cond : CP.formula;
	term_dst_cond : CP.formula;
}

and term_subst_cmd =
	| TSubst of term_res
	| TSplit of (CP.formula * term_res) list

type reach = 
	| RTerm
	| RLoop
	| RMayLoop

let term_constr_tbl : ((int * int), term_trans_constraint) Hashtbl.t = Hashtbl.create 10

let term_spec_tbl : (ident, term_spec) Hashtbl.t = Hashtbl.create 10

let term_res_tbl : (int, term_res) Hashtbl.t = Hashtbl.create 10

(* let term_ctx_tbl : (ident, list_term_ctx) Hashtbl.t = Hashtbl.create 10 *)

type utils = {
	is_sat        : CP.formula -> bool;
	imply         : CP.formula -> CP.formula -> bool;
	simplify      : CP.formula -> CP.formula;
	fixcalc       : string -> spec_var list -> spec_var list -> CP.formula -> (CP.formula list);
}

(* Cprinter Utilities *)
let print_path_trace = ref (fun (c: path_trace) -> "Printer has not been initialized.")
let print_pure_formula = ref (fun (c: CP.formula) -> "Printer has not been initialized.")
let print_pure_exp = ref (fun (c: CP.exp) -> "Printer has not been initialized.")
let print_term_spec = ref (fun (c: term_spec) -> "Printer has not been initialized.")
let print_term_ctx = ref (fun (c: term_ctx) -> "Printer has not been initialized.")
let print_term_spec = ref (fun (c: term_spec) -> "Printer has not been initialized.")
let print_term_res = ref (fun (c: term_res) -> "Printer has not been initialized.")
let print_term_trans_constraint = ref (fun (c: term_trans_constraint) -> "Printer has not been initialized.")
let print_term_cond_pure = ref (fun (c: path_trace * CP.formula * term_res) -> "Printer has not been initialized.")
let print_term_subst_cmd = ref (fun (c: term_subst_cmd) -> "Printer has not been initialized.")

(* Debugging Utilities *)
let info_hprint str pr f = DD.info_hprint (add_str str pr) f no_pos
let info_pprint str = DD.info_pprint str no_pos

(* Cpure Utilities *)
let mkIConst i = mkIConst i no_pos
let mkVar v = mkVar v no_pos
let mkGt e1 e2 = mkPure (mkGt e1 e2 no_pos)
let mkGte e1 e2 = mkPure (mkGte e1 e2 no_pos)
let mkLte e1 e2 = mkPure (mkLte e1 e2 no_pos)
let mkEq e1 e2 = mkPure (mkEq e1 e2 no_pos)
let mkAdd e1 e2 = mkAdd e1 e2 no_pos
let mkSub e1 e2 = mkSubtract e1 e2 no_pos
let mkMult e1 e2 = mkMult e1 e2 no_pos
let mkNot e = mkNot e None no_pos
let mkOr e1 e2 = CP.mkOr e1 e2 None no_pos
let mkAnd e1 e2 = CP.mkAnd e1 e2 no_pos
let mkExists vs f = CP.mkExists vs f None no_pos
let mkForall vs f = CP.mkForall vs f None no_pos

let mk_fresh_Term () = 
	let id = fresh_int () in
	let r = Term { term_id = id; term_rank = None; term_def = true; } in
	Hashtbl.add term_res_tbl id r; r
	
let mk_fresh_Term_with_rank rank is_def = 
	let id = fresh_int () in
	let r = Term { term_id = id; term_rank = rank; term_def = is_def; } in
	Hashtbl.add term_res_tbl id r; r
	
let mk_fresh_Loop () = 
	let id = fresh_int () in
	let r = Loop id in
	Hashtbl.add term_res_tbl id r; r
	
let mk_fresh_MayLoop () = 
	let id = fresh_int () in
	let r = MayLoop id in
	Hashtbl.add term_res_tbl id r; r
	
let update_unk_id unk =
	let id = fresh_int () in
	let unk = Unknown { unk with unk_id = id; } in
	Hashtbl.add term_res_tbl id unk; unk
	
let update_term_id term =
	let id = fresh_int () in
	let term = Term { term with term_id = id; } in
	Hashtbl.add term_res_tbl id term; term

let partition_term_ctx tctx = 
	List.partition (fun ctx -> match ctx.t_type with
	| Base -> true | _ -> false) tctx
	
let collect_path_trace_term_ctx tctx =
	collect_path_trace_list_failesc_context tctx.t_ctx 
	
let id_of_term_res = function
	| Term term -> term.term_id
	| Loop i -> i
	| MayLoop i -> i
	| Unknown unk -> unk.unk_id

let eq_term_res r1 r2 = 
	(id_of_term_res r1) == (id_of_term_res r2)
	
let compare_trans_constr a b =
	let asrc_id, adst_id = (id_of_term_res a.term_trans_src), (id_of_term_res a.term_trans_dst) in
	let bsrc_id, bdst_id = (id_of_term_res b.term_trans_src), (id_of_term_res b.term_trans_dst) in
	if asrc_id > bsrc_id then 1
	else if asrc_id == bsrc_id then
		if adst_id > bdst_id then 1
		else if adst_id == bdst_id then 0
		else -1
	else -1
	
let eq_trans_constr a b = 
	let asrc_id, adst_id = (id_of_term_res a.term_trans_src), (id_of_term_res a.term_trans_dst) in
	let bsrc_id, bdst_id = (id_of_term_res b.term_trans_src), (id_of_term_res b.term_trans_dst) in
	(asrc_id == bsrc_id) && (adst_id == bdst_id)
	
let eq_trans_constr_list ls1 ls2 =
	try
		List.for_all2 eq_trans_constr ls1 ls2
	with _ -> false

(* If the path trace of a base context is a SUPERSET of *)
(* the path trace of a recursive context, then the      *)
(* recursive call is met BEFORE the return statement    *)
(* so that these labels and their associated contexts   *)
(* should be removed in base context                    *)
let remove_incorrect_base_term_ctx tctx list_lbl =
	{ tctx with t_ctx = match tctx.t_type with
	| Base -> List.map (fun (fail_c, esc_c, succ_c) ->
			let succ_c = List.filter (fun (lbl, _) -> 
				not (List.exists (fun l -> Gen.BList.subset_eq (=) l lbl) list_lbl)) succ_c in
			(fail_c, esc_c, succ_c)) tctx.t_ctx
	| Rec _ -> tctx.t_ctx}
	
let remove_incorrect_base_list_term_ctx tctx =
	let bs, rc = partition_term_ctx tctx in
	(* Path traces of recursive calls *)
	let list_rec_lbl = List.concat (List.map collect_path_trace_term_ctx rc) in
	List.map (fun ctx -> remove_incorrect_base_term_ctx ctx list_rec_lbl) tctx
	
let remove_unsat_ctx_list_term_ctx tctx =
	List.map (fun ctx -> 
		{ctx with t_ctx = remove_unsat_succ_ctx_list_failesc_context ctx.t_ctx}) tctx
	
let remove_empty_ctx_list_term_ctx tctx = 
	let tctx = List.map (fun ctx -> 
		{ctx with t_ctx = remove_empty_succ_ctx_list_failesc_context ctx.t_ctx}) tctx in
	List.filter (fun ctx -> not (ctx.t_ctx = [])) tctx

let remove_duplicate_ctx_list_term_ctx tctx =
	List.fold_left (fun a ctx -> if (List.mem ctx a) then a else a @ [ctx]) [] tctx

let remove_duplicate_path_trace pt = 
	List.fold_left (fun a p ->
		if (List.mem p a) then a else a @ [p]) [] pt

(* Get the pure condition from context *)
(* and assign Term or Unknown for Base *)
(* and Rec, resp.                      *)
let update_cond_pure_term_ctx	tctx =
	let lf = collect_formula_with_path_list_failesc_context tctx.t_ctx in
	let lpf = List.concat (List.map (fun (lbl, f) -> 
		let lbl = remove_duplicate_path_trace lbl in
		List.map (fun pf -> (lbl, pf)) (pure_of_formula f)) lf) in
	{tctx with 
		t_pure_ctx = lpf;
		t_cond_pure = List.map (fun (pt, f) ->
			let term_res = match tctx.t_type with
			| Base -> Term {
					term_id = 0;
					term_rank = None; 
					term_def = true; } (* Definite Termination *)
			| Rec c -> Unknown {
					unk_id = 0;
					unk_callee = c;
					unk_params = tctx.t_params;
					unk_trans_ctx = f; 
					unk_cond = CP.mkTrue no_pos; } in 
			Hashtbl.add term_res_tbl 0 term_res;
			(pt, f, term_res)) lpf;}
	
let update_cond_pure_list_term_ctx tctx = 
	List.map update_cond_pure_term_ctx tctx
	
let get_method_args proc =
	let farg_types, farg_names = List.split proc.proc_args in	
	List.map2 (fun n t -> CP.SpecVar (t, n, Unprimed)) farg_names farg_types

(* Simplify the termination context to get *)
(* the conditions on method's arguments    *)
let simplify_t_cond_pure args (pt, f, t_res) =
	let qsv = diff_svl (CP.fv f) args in
	(* a!=b has already been transformed to a<b | a>b by Omega *)
	let simpl_f = mkExists_with_simpl Omega.simplify qsv f None no_pos in
	List.map (fun f -> (pt, f, match t_res with
	| Unknown unk -> 
			if unk.unk_id != 0 then t_res 
			else update_unk_id unk
	| Term term -> 
			if term.term_id != 0 then t_res 
			else update_term_id term
	| _ -> t_res)) (CP.list_of_disjs simpl_f)
		
let simplify_cond_pure_term_ctx args tctx =
	{tctx with t_cond_pure = List.concat (List.map (simplify_t_cond_pure args) tctx.t_cond_pure);}
	
let simplify_cond_pure_list_term_ctx proc tctx =
	let farg_spec_vars = get_method_args proc in
	List.map (simplify_cond_pure_term_ctx farg_spec_vars) tctx
	
let sort_path_trace_by_order cl =
	let rec comp pt1 pt2 = match pt1, pt2 with
	| [],[] -> 0
	| [],xs -> -1
	| xs,[] -> 1
	| ((a1,_),b1)::zt1, ((a2,_),b2)::zt2 -> 
			if (a1 > a2) then 1
			else if (a1 < a2) then -1
			else begin
				if (b1 > b2) then 1
				else if (b1 < b2) then -1
				else comp zt1 zt2
			end
	in List.sort (fun (pt1, _, _) (pt2, _, _) -> comp pt1 pt2) cl
	
(* BUGS [ps-1d.ss]: exists(x':x'=x & MayLoop) |- exists(x':x'=x & MayLoop) --> false *)	
let rec partition_path_trace utils cl =
	let sml_pt, sml_c, _ = List.hd cl in
	(* A; B is a sequence if pathA subseteq pathB and condB |- condA, *)
	let sml_seq, others = List.partition (fun (pt, c, _) -> 
		(Gen.BList.subset_eq (=) sml_pt pt) && 
		(utils.imply c sml_c)) cl in
	if others = [] then [(sml_c, sml_seq)]
	else
		let par_others = partition_path_trace utils others in
		[(sml_c, sml_seq)] @ par_others
	
let mkTBase cond tres =
	TBase { term_base_res = tres; term_base_cond = cond; }
	
let mkTSeq fst snd =
	TSeq { term_seq_id = fresh_int (); term_seq_fst = fst; term_seq_snd = snd; }
	
let mkTCase cl = TCase cl

let rec construct_term_spec utils cases =
	(* Note 1: If cases is empty then the program does not contain any *)
	(* recursive call, it should terminate                             *)
	(* Note 2: If there is ([], true, UNK) then the program contains   *)
	(* a recursive call without base case, it should not terminates    *)
	if cases = [] then mkTBase (CP.mkTrue no_pos) (mk_fresh_Term ())
	else 
		let par_cases = partition_path_trace utils cases in
		if par_cases = [] then mkTBase (CP.mkTrue no_pos) (mk_fresh_Term ())
		else 
			(* TODO: Cover all cases for completeness *)
			TCase (List.map (fun (cond, seq) -> 
				(cond, construct_term_seq_spec utils seq)) par_cases)

and construct_term_seq_spec utils cases =
	let pfst, cfst, rfst = List.hd cases in
	let cont = List.tl cases in
	let bfst = mkTBase cfst rfst in 
	if (cont = []) then bfst
	else mkTSeq bfst (construct_term_spec utils cont)
	
(* Construct case spec of termination from termination context *)
(* TODO: Do we need to check case coverage? *)		
let term_spec_of_list_term_ctx utils tctx =
	let cases = List.concat (List.map (fun ctx -> ctx.t_cond_pure) tctx) in
	let cases = sort_path_trace_by_order cases in
	(* let _ = print_endline ("\nCollected cases:\n" ^ (pr_list !print_term_cond_pure cases)) in *)
	construct_term_spec utils cases	
	
(* Look up termination context and spec *)
(* let look_up_term_ctx mn = Hashtbl.find term_ctx_tbl mn *)
	
let look_up_term_spec mn = Hashtbl.find term_spec_tbl mn

let rec rename_term_spec (fsv, tsv) (tspec: term_spec) =
	match tspec with
	| TBase b -> TBase { b with term_base_cond = CP.subst_avoid_capture fsv tsv b.term_base_cond; }
	| TSeq s -> TSeq { s with
		term_seq_fst = rename_term_spec (fsv, tsv) s.term_seq_fst;
		term_seq_snd = rename_term_spec (fsv, tsv) s.term_seq_snd; }
	| TCase c -> TCase (List.map (fun (cc, sc) ->
		(CP.subst_avoid_capture fsv tsv cc, rename_term_spec (fsv, tsv) sc)) c) 
		
let rec subst_term_spec utils subst tg tspec =
	if subst = [] then tspec 
	else
		match tspec with
		| TBase b -> subst_term_base_spec utils subst tg b
		| TCase cl -> TCase (List.map (fun (c, spec) -> (c, subst_term_spec utils subst tg spec)) cl)
		| TSeq s -> TSeq { s with
				term_seq_fst = subst_term_spec utils subst tg s.term_seq_fst;
				term_seq_snd = subst_term_spec utils subst tg s.term_seq_snd; }
			
and subst_term_base_spec utils subst tg b =
	let bres = b.term_base_res in
	match bres with
	| Unknown unk ->
		(try
			let unk_id = id_of_term_res bres in
			let _, cmd = List.find (fun (r, cmd) -> (id_of_term_res r) == unk_id) subst in
			match cmd with
			| TSubst res -> TBase { b with term_base_res = res; }
			| TSplit lres -> 
				if lres = [] then TBase b
				else begin
					let then_conds = join_disjunctions (List.map (fun (c, _) -> c) lres) in
					(* Case Coverage *)
					if (utils.imply (CP.mkTrue no_pos) then_conds) then 
						subst_term_base_spec_case_coverage b lres unk tg
					else (* Not Case Coverage *)
						let bcond = b.term_base_cond in
						let else_conds = split_disjunctions (utils.simplify (mkNot then_conds)) in
						let else_conds = List.filter (fun c -> utils.is_sat (mkAnd c bcond)) else_conds in
						if (else_conds = []) then 
							(* Subst like coverage *)
							subst_term_base_spec_case_coverage b lres unk tg
						else
							let else_cases = List.map (fun c ->
								let new_id = fresh_int () in
								let new_unk = Unknown { unk with
									unk_id = new_id; unk_cond = mkAnd unk.unk_cond c; } in
								Hashtbl.add term_res_tbl new_id new_unk;
								(c, mkTBase (mkAnd bcond c) new_unk)) else_conds in
							let then_cases = List.map (fun (c, res) ->
								let new_res = match res with
								| Loop _ | MayLoop _ | Unknown _  -> res
								| Term term -> (match term.term_rank with
									| None -> res
									| Some _ -> 
										let new_id = fresh_int () in
										let new_unk = Unknown { unk with
											unk_id = new_id; unk_cond = mkAnd unk.unk_cond c; } in
										Hashtbl.add term_res_tbl new_id new_unk; new_unk)
								in (c, mkTBase (mkAnd bcond c) new_res)) lres in
							mkTCase (then_cases @ else_cases)
				end
			with _ -> TBase b)
	| _ -> TBase b

and subst_term_base_spec_case_coverage b lres unk tg =
	(* Determine when a TERM substitution should become UNKNOWN *)
	let bcond = b.term_base_cond in
	let unk_id = unk.unk_id in
	let unk_succs = List.map (fun id -> Hashtbl.find term_res_tbl id) (TG.succ tg unk_id) in
	let is_only_term_reachable = not (List.exists (fun succ ->
		match succ with
		| Loop _ | MayLoop _ -> true
		| Unknown _ -> (id_of_term_res succ) != unk_id
		| Term _ -> false) unk_succs) in
	let is_all_term_subst = not (List.exists (fun (_, res) ->
		match res with | Term _ -> false | _ -> true) lres) in
	let is_term = is_only_term_reachable && is_all_term_subst in
	if ((List.length lres) == 1) then
		let is_loop = List.exists (fun succ ->
			match succ with | Loop _ | MayLoop _ -> true | _ -> false) unk_succs in
		let (c, res) = List.hd lres in
		let new_res = subst_term_base_spec_one_case c res unk is_term is_loop in
		TBase { b with term_base_res = new_res; }
	else
		let new_lres = List.map (fun (c, res) ->
		let new_res = subst_term_base_spec_one_case c res unk is_term false in
		(c, mkTBase (mkAnd bcond c) new_res)) lres in
		TCase new_lres

and subst_term_base_spec_one_case cond res unk is_term is_loop =
	match res with
	| Loop _ 
	| MayLoop _ 
	| Unknown _ -> res
	| Term term ->
		match term.term_rank with
		| None -> res (* 1-step termination *)
		| Some rank ->
			if term.term_def then res
			else if is_term then res
			(* Special case when we cannot infer anything new *)
			else if (isConstTrue cond) then
				if is_loop then  
					let new_id = fresh_int () in
					let new_res = MayLoop new_id in
					Hashtbl.add term_res_tbl new_id new_res;
					new_res
				else Unknown unk
			else
				let new_id = fresh_int () in
				let new_res = Unknown { unk with 
					unk_id = new_id; unk_cond = mkAnd unk.unk_cond cond; } in
				Hashtbl.add term_res_tbl new_id new_res;
				new_res

(* Simplify the inferred termination specification with TSeq *)
and simplify_term_spec utils subst tspec =
	match tspec with
	| TBase b -> tspec
	| TCase cl -> mkTCase (List.map (fun (c, spec) -> (c, simplify_term_spec utils subst spec)) cl) 
	| TSeq s -> 
		let simpl_fst = simplify_term_spec utils subst s.term_seq_fst in
		simplify_term_seq_spec utils subst simpl_fst s

and simplify_term_seq_spec utils subst sfst seq =
	match sfst with
	| TBase b -> (match b.term_base_res with 
		| MayLoop _ | Loop _ -> sfst
		| Term _ -> 
			(* simplify_term_spec utils subst seq.term_seq_snd *)
			let simpl_snd = simplify_term_spec utils subst seq.term_seq_snd in
			(match simpl_snd with
			| TCase cl ->
				let then_cond = join_conjunctions (List.map (fun (c, _) -> c) cl) in
				if not (utils.is_sat then_cond) then simpl_snd
				else
					try 
						let res, _ = List.find (fun (_, cmd) -> match cmd with
							| TSubst r -> (id_of_term_res r) == (id_of_term_res b.term_base_res)
							| TSplit cmdl -> List.exists (fun (_, r) -> 
								(id_of_term_res r) == (id_of_term_res b.term_base_res)) cmdl) subst in
						match res with
						| Unknown unk -> 
  						let else_cond = split_disjunctions (utils.simplify (mkNot then_cond)) in
  						let else_cond = List.filter (fun c -> utils.is_sat (mkAnd c b.term_base_cond)) else_cond in
  						let else_cases = List.map (fun c ->
  							let id = fresh_int () in
  							let r = Unknown { unk with unk_id = id; unk_cond = mkAnd unk.unk_cond c } in
  							Hashtbl.add term_res_tbl id r;
  							(c, mkTBase (mkAnd b.term_base_cond c) r)) else_cond in
  							mkTCase (cl @ else_cases)
						| _ -> simpl_snd
					with _ -> simpl_snd
			| _ -> simpl_snd)
		| _ -> TSeq seq)
	| TCase cl -> 
		let simpl_cl = List.map (fun (c, sc) -> 
			(c, simplify_term_spec utils subst (mkTSeq sc seq.term_seq_snd))) cl in
		mkTCase simpl_cl
	| TSeq s -> TSeq { s with term_seq_snd = mkTSeq s.term_seq_snd seq.term_seq_snd }
			
let update_term_spec_one_method utils subst tg mn =
	let old_spec = look_up_term_spec mn in
	let new_spec = simplify_term_spec utils subst (subst_term_spec utils subst tg old_spec) in
	Hashtbl.add term_spec_tbl mn new_spec;
	new_spec

(*****************************************************)
(* Collect set of termination transition constraints *)
(* based on the termination context of a function    *)
(*****************************************************)
let rec collect_term_trans_constrs_callee_term_spec utils cer_seq cee_seq ctx unk tspec =
	match tspec with
	| TBase b -> 
		let reach_ctx = join_conjunctions (ctx @ [unk.unk_trans_ctx] @ [b.term_base_cond]) in
		if (utils.is_sat reach_ctx) then
			let constr = {
				term_trans_src = Unknown unk;
				term_trans_dst = b.term_base_res; 
				term_src_cond = unk.unk_cond;
				term_dst_cond = b.term_base_cond; } in
			Hashtbl.add term_constr_tbl 
				(id_of_term_res constr.term_trans_src, id_of_term_res constr.term_trans_dst) constr;
			[constr]
		else []
	| TCase c -> List.concat (List.map (fun (cc, sc) ->
		collect_term_trans_constrs_callee_term_spec utils cer_seq cee_seq (ctx @ [cc]) unk sc) c)
	| TSeq s -> 
		collect_term_trans_constrs_callee_term_spec utils cer_seq (cee_seq @ [s.term_seq_id]) ctx unk s.term_seq_fst

let rec collect_term_trans_constrs_term_spec utils seq ctx tspec =
	match tspec with
	| TBase b -> (match b.term_base_res with
		| Term _ | Loop _ | MayLoop _ -> []
		| Unknown unk ->
			let callee_tspec = rename_term_spec unk.unk_params (look_up_term_spec unk.unk_callee) in 
			let unk = { unk with unk_cond = b.term_base_cond; } in
			collect_term_trans_constrs_callee_term_spec utils seq [] ctx unk callee_tspec)
	| TCase c -> List.concat (List.map (fun (cc, sc) ->
		collect_term_trans_constrs_term_spec utils seq (ctx @ [cc]) sc) c)
	| TSeq s -> 
		(* We need to solve the FIRST UNKNOWN in the sequence first, *)
		(* by determine whether the BASE CASE is REACHABLE or NOT    *)
		collect_term_trans_constrs_term_spec utils (seq @ [s.term_seq_id]) ctx s.term_seq_fst

let collect_term_trans_constrs_one_proc utils mn =
	let mn_tspec = look_up_term_spec mn in
	let trans_constrs = collect_term_trans_constrs_term_spec utils [] [] mn_tspec in
	List.sort (compare_trans_constr) trans_constrs

(*****************************************************)
let norm_src_cond sc =
	match sc with
	| BForm ((bf, _), _) -> (match bf with
		| Lt (e1, e2, pos)	-> mkSub e2 e1                      (* e1<e2  --> e2-e1>0   *)
		| Lte (e1, e2, pos)	-> mkAdd (mkSub e2 e1) (mkIConst 1) (* e1<=e2 --> e2-e1+1>0 *)
		| Gt (e1, e2, pos)	-> mkSub e1 e2                      (* e1>e2  --> e1-e2>0   *)
		| Gte (e1, e2, pos)	-> mkAdd (mkSub e1 e2) (mkIConst 1) (* e1>=e2 --> e1-e2+1>0 *)
		| Eq (e1, e2, pos)	-> mkAdd (mkSub e1 e2) (mkIConst 1) (* e1=e2  --> e1-e2+1>0 or e2-e1+1>0*)
		| _ -> report_error no_pos "Termination Inference: Unexpected case condition"
		)
	| _ -> report_error no_pos "Termination Inference: Unexpected case condition"

(* Normalize the condition of termination cases *)
(* to find a potential ranking function         *)
let norm_dst_cond dc =
	match dc with
	| BForm ((bf, _), _) -> (match bf with
		| Lt (e1, e2, _)	-> mkAdd (mkSub e1 e2) (mkIConst 1) (* e1<e2  --> e1-e2+1<=0 *)
		| Lte (e1, e2, _)	-> mkSub e1 e2                      (* e1<=e2 --> e1-e2<=0   *)
		| Gt (e1, e2, _)	-> mkAdd (mkSub e2 e1) (mkIConst 1) (* e1>e2  --> e2-e1+1<=0 *)
		| Gte (e1, e2, _)	-> mkSub e2 e1                      (* e1>=e2 --> e2-e1<=0   *)
		| Eq (e1, e2, _)	-> mkSub e1 e2                      (* e1=e2  --> e1-e2=0    *)
		| _ -> report_error no_pos "Termination Inference: Unexpected case condition."
		)
	| _ -> report_error no_pos "Termination Inference: Unexpected case condition with logical connectives."

(*| ************************************************************ *)
(*| Solve termination constraints                                *)
(*| Step 1: Build a graph to present termination constraints     *)
(*| Step 2: Do inference bottom-up - Infer termination condition *)
(*| at transition A>>B where A!=B                                *)
(*| ************************************************************ *)
let filter_known_constrs utils kcond icond =
	let icond_list = split_conjunctions_exists icond in
	join_conjunctions (List.filter (fun c -> not (utils.imply kcond c)) icond_list) 

let simplify_inf_cond utils args inf_cond ctx =
	let inf_cond = mkOr (mkNot ctx) inf_cond in (* ctx |- inf_cond *)
	let qvars = diff_svl (CP.fv inf_cond) args in
	let simpl_cond = utils.simplify (mkForall qvars inf_cond) in
	let simpl_cl = CP.list_of_disjs simpl_cond in
	(* To remove the base case in the inferred condition *)
	(* Empty list means FALSE                            *)
	let sat_cl = List.filter (fun c -> utils.is_sat (mkAnd c ctx)) simpl_cl in
	(* Filter known constraints in the inferred condition *)
	List.map (fun c -> filter_known_constrs utils ctx c) sat_cl
	
(* Fixpoint Calculation for an exact termination *)
(* condition with Equality in Base Case          *)
(* Do NOT support mutually recursive calls       *)
let term_cond_by_fixcalc utils subst base ctx =
	let args, params = subst in
	let cnt = SpecVar (Int, "cnt", Unprimed) in
	let fcnt = "fcnt" in
	let base_cnt = mkAnd base (mkEqVarInt cnt 0 no_pos) in (* base && cnt=0 *)
	let rec_cnt = 
		let cnt1 = SpecVar (Int, "cnt1", Unprimed) in
		let cnt_dec = mkEq (mkVar cnt1) (mkSub (mkVar cnt) (mkIConst 1)) in (* cnt1=cnt-1 *)
		let qvars = (diff_svl (CP.fv ctx) args) @ [cnt1] in
		let rel = mkPure (mkRelForm fcnt (List.map (fun v -> mkVar v) (params @ [cnt1])) no_pos) in
		CP.mkExists qvars (mkAnd ctx (mkAnd cnt_dec rel)) None no_pos
	in
	let fml = mkOr base_cnt rec_cnt in
	let res = utils.fixcalc fcnt (args @ [cnt]) [] fml in
	let qres = List.map (fun f -> mkExists_with_simpl utils.simplify [cnt] f None no_pos) res in
	qres

(* Synthesize a potential ranking function from terminating condition *)	
let find_potential_rank utils subst rec_cond base_cond =
	let cl = split_conjunctions base_cond in
	let rec find ls = 
		if ls = [] then None
		else
			let cond = List.hd ls in
			let prank = e_apply_subs subst (norm_dst_cond cond) in (* cond |- prank <= 0 *)
			let pcond = mkGt prank (mkIConst 0) in
			if (utils.imply rec_cond pcond) then Some (prank, cond) (* rec_cond |- prank > 0 *)
			else if (is_eq_exp cond) then (* e1-e2=0 <=> e1-e2<=0 or e2-e1<=0 *)
				let prank = mkSub (mkIConst 0) prank in
				let pcond = mkGt prank (mkIConst 0) in
				if (utils.imply rec_cond pcond) then Some (prank, cond)
				else find (List.tl ls)
			else find (List.tl ls)  
	in find cl
	
let rec linear_rank_synthesis utils (x1, x2, x3) ctx =
	let _, unk_coe = List.fold_left (fun (i, ls) _ ->
		(i-1, ls @ [SpecVar (Int, "unkcoen" ^ (string_of_int i), Unprimed)])) (List.length x1, []) x1 in
	let free_coe = MATH.norm_spec_var (SpecVar (Int, "unkcoen0", Unprimed)) in
	let unk_rank_1 = List.fold_right (fun op res -> mkAdd res op) 
		(List.map2 (fun coe x -> mkMult (mkVar coe) (mkVar x)) unk_coe x1)
		(mkVar free_coe) 
	in
	let unk_rank_2 = e_apply_subs (List.combine x1 x2) unk_rank_1 in
	let unk_rank_3 = e_apply_subs (List.combine x1 x3) unk_rank_1 in
	
	let bound_constr = mkGte unk_rank_1 (mkIConst 0) in
	let dec_constr = mkAnd (mkGt unk_rank_1 unk_rank_2) (mkGt unk_rank_2 unk_rank_3) in
	(* let dec_constr = mkGt unk_rank_1 unk_rank_2 in *)
	let simpl_ctx = utils.simplify ctx in
	let constr = mkOr (mkNot simpl_ctx) (mkAnd bound_constr dec_constr) in
	let qconstr = mkForall (diff_svl (CP.fv constr) (unk_coe @ [free_coe])) constr in
	
	try
	let sconstr = generate_coefficient_constrs qconstr in
	let math_res = solve_coefficient_constrs (unk_coe @ [free_coe]) sconstr in
	if math_res = [] then None
	else
		let rank = List.fold_right (fun (coe, x) res -> 
			if coe = 0 then res else mkAdd res (mkMult (mkIConst coe) (mkVar x))) 
			(List.map2 (fun unk x -> (List.assoc (name_of_spec_var unk) math_res, x)) unk_coe x1) 
			(mkIConst (List.assoc (name_of_spec_var free_coe) math_res)) in
		Some rank
	with _ -> None
		
and linear_rank_synthesis_scc utils (x1, x2) ctx scc_trans =
	let _, unk_coe = List.fold_left (fun (i, ls) _ ->
  	(i-1, ls @ [SpecVar (Int, "unkcoen" ^ (string_of_int i), Unprimed)])) (List.length x1, []) x1 in
  let free_coe = MATH.norm_spec_var (SpecVar (Int, "unkcoen0", Unprimed)) in
  let unk_rank_1 = List.fold_right (fun op res -> mkAdd res op) 
  	(List.map2 (fun coe x -> mkMult (mkVar coe) (mkVar x)) unk_coe x1)
  	(mkVar free_coe) 
  in
  let unk_rank_2 = e_apply_subs (List.combine x1 x2) unk_rank_1 in
	let pr_n x = None in
		
	let collect_constr trans = 
  	let bound_constr = mkGte unk_rank_1 (mkIConst 0) in
  	let dec_constr = mkGt unk_rank_1 unk_rank_2 in
  	let constr = mkOr (mkNot ctx) (mkAnd bound_constr dec_constr) in
  	let qconstr = mkForall (diff_svl (CP.fv constr) (unk_coe @ [free_coe])) constr in
  	(* Redlog: Quantifier Elimination RLQE *)
  	generate_coefficient_constrs qconstr
	in
	
	try
	let constrs = List.fold_left (fun res trans ->
		mkAnd res (collect_constr trans)) (CP.mkTrue no_pos) scc_trans in		
	(* Mathematica: FindInstance *)
	let math_res = solve_coefficient_constrs (unk_coe @ [free_coe]) constrs in
	if math_res = [] then None
	else
		let rank = List.fold_right (fun (coe, x) res -> 
			if coe = 0 then res else mkAdd res (mkMult (mkIConst coe) (mkVar x))) 
			(List.map2 (fun unk x -> (List.assoc (name_of_spec_var unk) math_res, x)) unk_coe x1) 
			(mkIConst (List.assoc (name_of_spec_var free_coe) math_res)) in
		Some rank
	with _ -> None
		
and generate_coefficient_constrs qconstr =
	(* Redlog: Quantifier Elimination RLQE *)
	let _ = RL.start () in
	let pr_n x = None in
	let rl_f = RL.rl_of_formula pr_n pr_n qconstr in
	let _ = RL.send_cmd "rlset R" in
	let rl_res = RL.send_and_receive ("rlqe " ^ rl_f) in
	let _ = RL.send_cmd "rlset ofsf" in
	let lexbuf = Lexing.from_string rl_res in
	let rl_res = Rlparser.input Rllexer.tokenizer lexbuf in
	let _ = RL.stop () in
	rl_res
	
and solve_coefficient_constrs coes sconstr = 
	(* Mathematica: FindInstance *)
	let _ = MATH.start () in
	let pr_n x = None in
	let rec string_of_math_var_list mvl = match mvl with
	| [] -> ""
	| [v] -> name_of_spec_var v
	| v::rest -> (name_of_spec_var v) ^ ", " ^ (string_of_math_var_list rest) in
	let math_vars = string_of_math_var_list coes in
	let math_input = 
		"FindInstance[" ^ 
		(MATH.mathematica_of_formula pr_n pr_n sconstr) ^ ", " ^
		"{" ^ math_vars ^ "}" ^ ", Integers]\n" in
	let math_res = MATH.send_and_receive math_input in
	let lexbuf = Lexing.from_string math_res in
	let math_res = Mathparser.input Mathlexer.tokenizer lexbuf in
	let _ = MATH.stop() in
	math_res

(* Check and Infer the condition for invariant *)
(* inv: f(X) where f(X) > 0 *)
let rec check_inv utils args (x1, x2) ctx inv =
	let invp = CP.subst_avoid_capture x1 x2 inv in
	let einv = norm_src_cond inv in (* inv => einv > 0 *)
	let einvp = e_apply_subs (List.combine x1 x2) einv in
	
	(* CASE 1: The inv always holds without any condition *)
	if (utils.imply (mkAnd ctx inv) invp) then [CP.mkTrue no_pos]
	(* CASE 2: The inv cannot hold (MUST) *)
	else if not (utils.is_sat (mkAnd (mkAnd ctx inv) invp)) then [CP.mkFalse no_pos]
	(* CASE 3: We can find some other conditions to make inv hold *) 
	else 
		(* Abduction: Find conditions for inv f(X)>0   *)
		(* ctx /\ f(X)>0 /\ A |- f(X')>0               *)
		(* ctx /\ f(X)>0 /\ f(X')<=0 |- not A          *)
		(* CASE 3-1: If ctx /\ f(X')<=0 |- f(X)>0 then *)
		(*   not A = f(X')<=0                          *)
		(* CASE 3-2: Else                              *)
		(*   not A = f(X)>f(X')                        *)
		let inf = 
			if (utils.imply (mkAnd ctx (mkNot invp)) inv) then
				simplify_inf_cond utils args invp ctx
			else
				simplify_inf_cond utils args (mkLte einv einvp) ctx 
		in
		let inf = List.filter (fun f -> utils.is_sat (mkAnd ctx f)) inf in
		if inf = [] then [CP.mkFalse no_pos] 
		else List.concat (List.map (fun f ->
			let inf_f = check_inv utils args (x1, x2) (mkAnd ctx inv) f in
			let inf_f = List.filter (fun inv_f -> not (utils.imply f inv_f)) inf_f in
			if inf_f = [] then [f] else List.map (mkAnd f) inf_f) inf) 

(* Check the condition for a monotone decreasing sequence start     *)
(* from the condition Phi(X)>=0 and the update function X'=f(X)     *)
(* If failed, find the condition for a monotone increasing sequence *)
(*------------------------------------------------------------------*)
(* trans_constr: UNK >> Term                                        *)
(* args is the set of variables that the inferred condition is      *)
(* based on them. They are actually the arguments of a method.      *)
let check_monotone_decreasing_sequence utils args trans_constr scc scc_trans =
	let unk_info = match trans_constr.term_trans_src with
	| Unknown info -> info
	| _ -> report_error no_pos "Termination Inference: Unexpected transition constraint." 
	in
	let subst = unk_info.unk_params in (* TODO: Mutual recursion *)
	let x1 = fst subst in
	let x2 = snd subst in (* x2 = f(x1) *)
	let x3 = List.map (fun x -> match x with
	  | SpecVar (typ, name, prim) -> SpecVar (typ, fresh_old_name name, prim)) x2 in
	
	let base_cond = trans_constr.term_dst_cond in
	let rec_cond = unk_info.unk_cond in
	let fx = unk_info.unk_trans_ctx in
	let ctx = mkAnd rec_cond fx in
	let def_loop_cond, unk_loop_cond, term_cond_with_rank = 
	begin
		if (utils.imply ctx base_cond) then
			(* CASE 0: The current context implies the terminating *)
			(* condition in the next execution (1-step execution)  *)
			([], [], [(CP.mkTrue no_pos, None)]) (* TRUSTED *)
		else begin
			let prank = find_potential_rank utils (List.combine x2 x1) rec_cond base_cond in
			match prank with
			(* Return the condition of 1-step execution *)
			| None -> ([], [], List.map (fun c -> (c, None)) (simplify_inf_cond utils args base_cond ctx)) (* TRUSTED *)
			| Some (prank, simpl_base_cond) -> begin
				let p1 = prank in
				let p2 = e_apply_subs (List.combine x1 x2) p1 in
				let p3 = e_apply_subs (List.combine x2 x3) p2 in
				(* Condition for decreasing sequence *)
				let dec_cond = mkGt p1 p2 in 
	
				(* CASE 1: The sequence of rank ALWAYS decreasing *)
				(* Fixpoint calculator is used to calculate the   *)
				(* exact condition if base condition is equality  *)
				if (utils.imply ctx dec_cond) then
					let r =
						(* We could not trust the condition returned by FixCalc *)
						if (is_eq_exp simpl_base_cond) then 
							let ic = term_cond_by_fixcalc utils subst (CP.subst_avoid_capture x2 x1 base_cond) ctx in
							(* let _ = print_endline ("\nFIXCALC: " ^ (pr_list !print_pure_formula ic)) in *)
							(* Filter new condition *)
							let ic = List.filter (fun c -> not (utils.imply rec_cond c)) ic in
							if ic = [] then [CP.mkTrue no_pos] 
							else List.map (filter_known_constrs utils rec_cond) ic
						else [CP.mkTrue no_pos] (* TRUST *)
					in
					([], [], List.map (fun c -> (c, Some prank)) r)
							
				(* CASE 2: The sequence ALWAYS increasing          *)
				(* We do not need to check this case, because it   *)
				(* has already been done by the reachability check *)
				
				(* CASE 3: Otherwise, the sequence MAY or MAY NOT decreasing, *)
				(* based on some conditions that need to be inferred          *)
				else begin
					let fx1 = CP.subst_avoid_capture x1 x2 (CP.subst_avoid_capture x2 x3 fx) in
					let compose_ctx = mkAnd 
						(mkExists (diff_svl (CP.fv fx) (x1 @ x2)) fx)
						(mkExists (diff_svl (CP.fv fx1) (x2 @ x3)) fx1)
					in
					(* CASE 3-1 *)
					let is_dec, term_cond_with_rank =
						let test = utils.imply (mkAnd compose_ctx dec_cond) (mkGt p2 p3) in
						if test then
							(* The sequence can be proved monotone strictly decreasing with dec_cond *)
							(* In this case, sometimes the condition for equality base case *)
							(* is NON-LINEAR, that cannot be handled by Fixcalc.            *)
							let rl = simplify_inf_cond utils args dec_cond ctx in
							let rl = List.filter (fun r -> utils.is_sat 
								(mkAnd r (mkGt prank (mkIConst 0)))) rl in
							(test, List.map (fun c -> (c, Some prank)) rl)
						else (test, [])
					in
					(* CASE 3-2 *)
					let inc_cond = mkLte p1 p2 in
					let is_inc, nonterm_cond =
						let test = utils.imply (mkAnd compose_ctx inc_cond) (mkLte p2 p3) in
						(* The sequence is monotone increasing --> Non-termination *)
						if test then 
							let rl = simplify_inf_cond utils args inc_cond ctx in
							let rl = List.filter (fun r -> utils.is_sat 
								(mkAnd r (mkGt prank (mkIConst 0)))) rl in
							(test, rl)
						else (test, [])
					in
					if (is_dec || is_inc) then (nonterm_cond, [], term_cond_with_rank)
					(* The sequence is neither monotone increasing nor monotone decreasing, *)
					(* so that the function returns the condition for one-step execution    *)
					else
						if not (utils.is_sat (mkAnd (mkAnd compose_ctx dec_cond) (mkGt p2 p3))) then 
							(* It is impossible for r(X)>r(X') and r(X')>r(X'') *)
							(* So that, r(X)>r(X') MAY imply r(X)>r(X'')        *)
							(* If r(X)>r(X') |- r(X)>r(X'') Then Term[Rank] *)
							(* Else Term(Base)                              *)
							(* ([], [], List.map (fun c -> (c, None)) (simplify_inf_cond utils args base_cond ctx)) *)
							begin
								let base = List.map (fun c -> (c, None)) (simplify_inf_cond utils args base_cond ctx) in
								if (utils.imply compose_ctx (mkGt p1 p3)) then
									let rank = linear_rank_synthesis utils (x1, x2, x3) compose_ctx in
									match rank with
									| None -> ([], [], base)
									| Some _ -> 
										let loop = List.map (fun c -> (c, rank)) (simplify_inf_cond utils args (mkNot base_cond) ctx) in
										([], [], base @ loop)
								else ([], [], base)
							end
						else
							(* We can find some addition conditions for termination         *)
							(* If A /\ (not B) is SAT (not (A |- B)) and A /\ B is SAT then *)
							(* A /\ C |- B <=> A /\ (not B) |- (not C)                      *)
							
							(*     ctx /\ (p1 > p2) /\ C |- (p2 > p3)                       *)
							(* <=> ctx /\ (p1 > p2) /\ (p2 <= p3) |- not C                  *)
							(*     ctx /\ (p1 > p2) /\ (p2 <= p3) |- (p1-p2) > (p2-p3)      *)
							(* not C = (p1-p2) > (p2-p3) <=> C = (p1-p2) <= (p2-p3)         *)

							let dec_cond = simplify_inf_cond utils args dec_cond ctx in
							let inf_dec_cond = List.concat (List.map (fun dec ->
								let inv = check_inv utils args (x1, x2) ctx dec in
								(* let _ = print_endline ("\n DEC INV: " ^ (pr_list !print_pure_formula inv)) in *)
								let inv = List.filter (fun i -> not (isConstFalse i)) inv in
								List.map (fun i -> mkAnd dec i) inv) dec_cond) in
								
							let inc_cond = simplify_inf_cond utils args inc_cond ctx in
							let inf_inc_cond = List.concat (List.map (fun inc ->
								let inv = check_inv utils args (x1, x2) ctx inc in
								(* let _ = print_endline ("\n INC INV: " ^ (pr_list !print_pure_formula inv)) in *)
								let inv = List.filter (fun i -> not (isConstFalse i)) inv in
								List.map (fun i -> mkAnd inc i) inv) inc_cond) in								

							([], inf_inc_cond, List.map (fun c -> (c, Some prank)) inf_dec_cond)
				end
			end 
		end 
	end
	in
	(* Debugging Information *)
	(* begin                                                                                               *)
	(* 	info_pprint ">>>>>>> check_monotone_decreasing_sequence <<<<<<<";                                  *)
	(* 	info_hprint "Infer NonTerm Cond" (pr_list !print_pure_formula) def_loop_cond;                      *)
	(* 	info_hprint "Infer Term Cond" (pr_list (fun (c, _) -> !print_pure_formula c)) term_cond_with_rank; *)
	(* 	info_pprint "\n";                                                                                  *)
	(* end;                                                                                                *)
	(def_loop_cond, unk_loop_cond, term_cond_with_rank)

(***********************************)
(* Build the graph of reachability *)	
(***********************************)
(* Build a reachability graph from set of termination constraints *)
let rec graph_of_term_constrs t_constrs =
	let tg = TG.empty in
	let tg = List.fold_left (fun g constr ->
		let src = id_of_term_res constr.term_trans_src in
		let dst = id_of_term_res constr.term_trans_dst in
		TG.add_vertex g src;
		TG.add_vertex g dst;
		TG.add_edge g src dst) tg t_constrs
	in tg 

(* and is_neighbors_of_scc (src: TG.V.t list) (dst: TG.V.t list) tg : bool =                        *)
(* 	let neighbors = List.filter (fun m -> not (List.mem m src)) (TGN.list_from_vertices tg src) in *)
(* 	List.exists (fun v -> List.mem v neighbors) dst                                                *)
	
(* Find a set of neighbor scc groups of a scc *)		
and neighbors_of_scc (scc: TG.V.t list) (scc_list: TG.V.t list list) tg : TG.V.t list list =
	let neighbors = List.filter (fun m -> not (List.mem m scc)) (TGN.list_from_vertices tg scc) in
	(* let scc_neighbors = List.find_all (fun s -> is_neighbors_of_scc scc s) scc_list in *) (* Less efficient *)
	let scc_neighbors = List.find_all (fun s -> List.exists (fun m -> List.mem m neighbors) s) scc_list in 
	scc_neighbors

(* Find ALL sccs that can reach from src *)
(* and reachable_sccs_top_down (src: TG.V.t list) (scc_list: TG.V.t list list) tg =                                    *)
(* 	let v_neighbors = List.filter (fun m -> not (List.mem m src)) (TGN.list_from_vertices tg src) in                  *)
(* 	let scc_neighbors, others = List.partition (fun s -> List.exists (fun v -> List.mem v v_neighbors) s) scc_list in *)
(* 	List.fold_left (fun (res, rem) s ->                                                                               *)
(* 		let s_reachable_sccs, rem = reachable_sccs_top_down s rem tg in                                                 *)
(* 		(res @ s_reachable_sccs, rem)) (scc_neighbors, others) scc_neighbors                                            *)

and reachable_sccs_bottom_up (src: (TG.V.t * term_res) list) (scc_list: (TG.V.t * term_res) list list) tg = 
	let id_preds = List.concat (List.map (fun (id, _) -> TG.pred tg id) src) in 
	let scc_preds, others = List.partition (fun s -> List.exists (fun (id, _) -> List.mem id id_preds) s) scc_list in
	List.fold_left (fun (res, rem) s ->
		let s_pred_sccs, rem = reachable_sccs_bottom_up s rem tg in
		(res @ s_pred_sccs, rem)) (scc_preds, others) scc_preds

(* Partition a list of sccs into groups of reachable sccs *)
and partition_scc_list reachable_sccs reach (scc_list: (TG.V.t * term_res) list list) tg = 
	if scc_list = [] then []
	else
		let root, rem = List.fold_left (fun (rt, rm) scc ->
			match rt with
			| Some _ -> (rt, rm @ [scc])
			| None -> 
					if (List.exists (fun (_, res) -> 
						match res with 
						| Unknown _ -> false
						| Term _ -> if reach = RTerm then true else false 
						| Loop _ -> if reach = RLoop then true else false
						| MayLoop _ -> if reach = RMayLoop then true else false) scc) 
					then (Some scc, rm)
					else (rt, rm @ [scc])) (None, []) scc_list in
		match root with
		| None -> [rem]
		| Some root ->
			let root_reachable_sccs, rem = reachable_sccs root rem tg in
			(root::root_reachable_sccs)::(partition_scc_list reachable_sccs reach rem tg)
		
and scc_sort (scc_list: TG.V.t list list) tg : TG.V.t list list =
  let compare_scc scc1 scc2 =
		if (List.mem scc2 (neighbors_of_scc scc1 scc_list tg)) then -1 (* scc1 -> scc2 => [scc1, scc2] *)
		else if (List.mem scc1 (neighbors_of_scc scc2 scc_list tg)) then 1 (* scc2 -> scc1 *)
		else 0
  in List.fast_sort (fun s1 s2 -> compare_scc s1 s2) scc_list 
	
(* Check whether a scc group can reach Term or Loop or not *)	
and may_be_reachable reach scc_group =
	List.exists (fun v -> match v with
		| Unknown _ -> false 
		| Term _ -> if reach = RTerm then true else false 
		| Loop _ -> if reach = RLoop then true else false
		| MayLoop _ -> if reach = RMayLoop then true else false) (List.concat scc_group)

(****************************************)
(** DRIVER FOR SOLVING CONSTRS PROCESS **)	
(****************************************)
let solve_constrs utils args constrs =
	(* args: set of argument of the corresponding method *)
	(* Construct an ACYCLIC graph from SCC to determine DEFINITE LOOP *)
	let tg = graph_of_term_constrs constrs in
	let scc_id_list = scc_sort (TGC.scc_list tg) tg in
	let scc_list = List.map (List.map (fun id -> (id, Hashtbl.find term_res_tbl id))) (List.rev scc_id_list) in
	(***************************************)
	let scc_groups = partition_scc_list reachable_sccs_bottom_up RTerm scc_list tg in (* Divide by TERM *)
	let scc_groups = List.map (List.map (List.map (fun (_, r) -> r))) scc_groups in
	let reach_term, not_reach_term = List.partition (fun sg -> may_be_reachable RTerm sg) scc_groups in	
	(***************************************)
	let scc_groups = partition_scc_list reachable_sccs_bottom_up RLoop scc_list tg in (* Divide by LOOP *)
	let scc_groups = List.map (List.map (List.map (fun (_, r) -> r))) scc_groups in
	let reach_loop, _ = List.partition (fun sg -> may_be_reachable RLoop sg) scc_groups in (* LOOP reachable *)
	(***************************************)	
	let scc_groups = partition_scc_list reachable_sccs_bottom_up RMayLoop scc_list tg in (* Divide by MAYLOOP *)
	let scc_groups = List.map (List.map (List.map (fun (_, r) -> r))) scc_groups in
	let reach_mayloop, _ = List.partition (fun sg -> may_be_reachable RMayLoop sg) scc_groups in (* MAYLOOP reachable *)
	(***************************************)	
	let reach_term = List.concat (List.concat reach_term) in
	let not_reach_term = List.concat (List.concat not_reach_term) in
	let reach_loop = List.concat (List.concat reach_loop) in
	let reach_mayloop = List.concat (List.concat reach_mayloop) in
	(***************************************)	
	(* let mayloop = reach_mayloop @ (Gen.BList.intersect_eq eq_term_res reach_term reach_loop) in *)
	let mustloop = Gen.BList.difference_eq eq_term_res not_reach_term reach_mayloop in
	let loop_subst = List.map (fun unk -> (unk, TSubst (mk_fresh_Loop ()))) mustloop in
	let mayloop_subst = List.map (fun unk -> (unk, TSubst (mk_fresh_MayLoop ()))) reach_mayloop in
	
	let unk_to_term_constrs = List.find_all (fun c -> 
		match c.term_trans_src, c.term_trans_dst with
		| Unknown _, Term _ -> true | _ -> false) constrs in (* Term Reachable *)
	
	let infer_cond = List.map (fun trans_constr ->
		let src = trans_constr.term_trans_src in
		(src, check_monotone_decreasing_sequence utils args trans_constr [] [])) unk_to_term_constrs in
	
	let infer_subst = List.map (fun (unk, (def_loop_cond, unk_loop_cond, term_cond_with_rank)) ->
		let loop_subst = List.map (fun c -> (c, mk_fresh_Loop ())) def_loop_cond in
		let term_subst = List.map (fun (c, r) -> (c, mk_fresh_Term_with_rank r false)) term_cond_with_rank in
		let unk_info = match unk with
		| Unknown info -> info
		| _ -> report_error no_pos "Termination Inference: Unexpected transition constraint."
		in
		let unk_subst = List.map (fun c ->
			let id = fresh_int () in
			let r = Unknown { unk_info with unk_id = id; unk_cond = mkAnd unk_info.unk_cond c } in
			Hashtbl.add term_res_tbl id r; (c, r)) unk_loop_cond in
		let subst = loop_subst @ unk_subst @ term_subst in
		if subst = [] then (unk, TSubst (mk_fresh_MayLoop ()))
		else (unk, TSplit subst)) infer_cond in

	(* print_endline ("scc list: " ^ (pr_list (pr_list (fun (_, r) -> !print_term_res r)) scc_list));    *)
	(* print_endline ("scc groups: " ^ (pr_list (pr_list (pr_list !print_term_res)) scc_groups));        *)
	(* print_endline ("LOOP: " ^ (pr_list !print_term_res mustloop));                                    *)
	(* print_endline ("SUBST: \n" ^ (pr_list (fun (unk, cmd) ->                                          *)
	(* 	(!print_term_res unk) ^ ": " ^ (!print_term_subst_cmd cmd) ^ "\n") (loop_subst @ infer_subst))); *)
	(loop_subst @ mayloop_subst @ infer_subst, tg)

(* Simplified version of the above solve_constrs *)		
let subst_for_scc_with_rank_synthesis utils args trans_constr scc scc_trans =
	let unk_info = match trans_constr.term_trans_src with
	| Unknown info -> info
	| _ -> report_error no_pos "Termination Inference: Unexpected transition constraint."
	in
	let params_subst = unk_info.unk_params in
	let x1 = fst params_subst in
	let x2 = snd params_subst in
	let x3 = List.map (fun x -> match x with
	  | SpecVar (typ, name, prim) -> SpecVar (typ, fresh_old_name name, prim)) x2 in

	let trans_ctx = unk_info.unk_trans_ctx in
	let next_trans_ctx = CP.subst_avoid_capture x1 x2 (CP.subst_avoid_capture x2 x3 trans_ctx) in
	(* Condition for 1-step execution *)
	let ctx = mkAnd unk_info.unk_cond trans_ctx in
	let base_cond = trans_constr.term_dst_cond in
	let compose_ctx = mkAnd
		(mkExists (diff_svl (CP.fv trans_ctx) (x1 @ x2)) trans_ctx)
		(mkExists (diff_svl (CP.fv next_trans_ctx) (x2 @ x3)) next_trans_ctx)
	in
	let rank = linear_rank_synthesis_scc utils (x1, x2) (utils.simplify compose_ctx) scc_trans in
	let subst = match rank with
	| None -> List.map (fun (_, res) -> (res, TSubst (mk_fresh_MayLoop ()))) scc 
	| Some _ -> List.map (fun (_, res) ->  
		let base_subst = List.map (fun c -> (c, mk_fresh_Term_with_rank None true)) (simplify_inf_cond utils args base_cond ctx) in
		let rec_subst = List.map (fun c -> (c, mk_fresh_Term_with_rank rank true)) (simplify_inf_cond utils args (mkNot base_cond) ctx) in
		(res, TSplit (base_subst @ rec_subst))) scc
	in subst

let solve_constrs_with_rank_synthesis utils args constrs =
	let tg = graph_of_term_constrs constrs in
	let scc_id_list = scc_sort (TGC.scc_list tg) tg in
	let scc_list = List.map (List.map (fun id -> (id, Hashtbl.find term_res_tbl id))) (List.rev scc_id_list) in
	
	let unk_to_term_constrs = List.find_all (fun c -> 
		match c.term_trans_src, c.term_trans_dst with
		| Unknown _, Term _ -> true | _ -> false) constrs in (* Term Reachable *)
	
	(* Ranking function for each scc *)
	let subst = List.concat (List.map (fun trans_constr -> 
		let src = trans_constr.term_trans_src in
		let src_id = id_of_term_res src in 
		let scc_src = List.find (fun scc -> List.exists (fun (id, _) -> id == src_id) scc) scc_list in
		let scc_trans = List.find_all (fun c ->
			(List.exists (fun (id, _) -> id == (id_of_term_res c.term_trans_src)) scc_src) &&
			(List.exists (fun (id, _) -> id == (id_of_term_res c.term_trans_dst)) scc_src)) constrs in
		subst_for_scc_with_rank_synthesis utils args trans_constr scc_src scc_trans) unk_to_term_constrs) in
	(subst, tg)

let rec infer_term_spec_one_proc utils proc round pre_trans_constrs =
	if round > !term_run_bound then ()
	else begin
		let mn = proc.proc_name in
		let args = get_method_args proc in
  	let old_spec = look_up_term_spec mn in 
  	let trans_constrs = collect_term_trans_constrs_one_proc utils mn in
		if trans_constrs = [] then ()
		else
			let _ = info_pprint ("ROUND " ^ (string_of_int round)) in
			let subst, tg =
				if (eq_trans_constr_list trans_constrs pre_trans_constrs) then
					solve_constrs_with_rank_synthesis utils args trans_constrs
				else solve_constrs utils args trans_constrs
			in
    	let new_spec = update_term_spec_one_method utils subst tg mn in
    	
    	(* info_hprint "Termination Constraints"                                        *)
    	(* 	(pr_list (fun c -> "\n" ^ (!print_term_trans_constraint c))) trans_constrs; *)
    	(* info_pprint "\n";                                                            *)
    	
			info_hprint "SUBST" (pr_list (fun (unk, cmd) ->
				"\n" ^ (!print_term_res unk) ^ " -> " ^ (!print_term_subst_cmd cmd))) subst;
					
    	info_hprint "Termination Spec" !print_term_spec old_spec;
    	info_pprint "\n";
    		
    	info_hprint "Inferred Termination Spec" !print_term_spec new_spec;
    	info_pprint "\n";
			
			(* info_hprint "Simplified Termination Spec" !print_term_spec (simplify_term_spec new_spec); *)
    	(* info_pprint "\n";                                                                         *)
			
    	infer_term_spec_one_proc utils proc (round+1) trans_constrs
	end

(***************** MAIN *****************)									
let main utils procs =
	List.iter (fun proc ->
		let mn = proc.proc_name in
		let _ = print_endline ("Termination Inference for " ^ mn) in
		infer_term_spec_one_proc utils proc 1 []
	) procs

