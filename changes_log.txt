********************************************************************************************************************************
--By--: Cristina 
--Date--: 07.04.2008
--File--: sleekengine.ml
--Method--: process_pred_def
--Line--: 91

--Change--:
Add the line:
ignore (List.map (fun vdef -> AS.compute_view_x_formula cprog vdef !Globals.n_xpure) cprog.C.prog_view_decls);

--Comments--:
This change is needed in order to compute xpure1 instead of xpure0. 
The field view_x_formula (the pure approximation) from view_decl was initialized with inv0 without calling
the method that was supposed to compute the correct approximation according to the provided n 
(which is method compute_view_x_formula from file astsimp.ml).

--Examples (see file sleek10.slk)--:
checkentail x::ll<n> & x!=null |- x::ll<m> & m >0.
print residue.
Before: Fail.
After: Valid.
true & x != null & m = n

********************************************************************************************************************************
--By--: Cristina 
--Date--: 16.04.2008
--File--: astsimp.ml
--Method--: linearize_heap
--Line--: 2014

--Change--:
let t_var = CP.SpecVar (CP.OType c, fresh_name (), Unprimed) 
replaced by 
let t_var = CP.SpecVar (CP.OType c, c(* --change made on 16.04.2008-- fresh_name ()*), Unprimed) 

--Comments--:
For each data node two more fresh vars were introduced for the actual type
and the extension record (for the oo extension) (see the declaration of h_formula_data from cformula.ml):
- first argument: type variable
- second argument: pointer to the next extension
Now I don't generate fresh vars for those, I just set them to be the
actual data node and the additional constraints disappear. 

--Todo--: Check if/where these first two arguments are really used. We should get rid of them. 

--Examples (see file inst.slk)--:
checkentail x::cell<a> |- x::cell<_>.
print residue.
Valid.
Before: true & f_r_35 = f_r_33 & f_r_36 = f_r_34 & f_r_32 = a
After: true & f_r_28 = a
----------------------------------------------------------------
checkentail x::cell<2> |- x::cell<_>.
print residue.
Valid.
Before: true & f_r_40 = 2 & f_r_44 = f_r_42 & f_r_45 = f_r_43
After: true & f_r_32 = 2
----------------------------------------------------------------
checkentail x::cell<2> |- x::cell<c>.
print residue.
Valid.
Before: true & c = 2 & f_r_53 = f_r_51 & f_r_54 = f_r_52
After: true & c = 2
----------------------------------------------------------------
checkentail x::cell<n> & n=2 |- x::cell<c>.
print residue.
Valid.
Before: true & n = 2 & f_r_61 = f_r_59 & f_r_62 = f_r_60 & c = n
After: true & n = 2 & c = n
----------------------------------------------------------------
checkentail x::cell<2> |- (exists p : p::cell<c> & p=x).
print residue.
Valid.
Before: true & c = 2 & f_r_69 = f_r_67 & f_r_70 = f_r_68
After: true & c = 2

********************************************************************************************************************************
--By--: Cristina 
--Date--: 18.04.2008
--File--: astsimp.ml
--Line--: 132

--Change--:
Added methods:
1. look_for_anonymous_h_formula (h0 : IF.h_formula) : (ident * primed) list
(*
	- added 17.04.2008
	- checks if the heap formula contains anonymous vars
*)	
2. look_for_anonymous_exp_list (args : IP.exp list) : (ident * primed) list 
3. look_for_anonymous_exp (arg : IP.exp) : (ident * primed) list 
4. convert_anonym_to_exist (f0 : IF.formula) : IF.formula 
  		
-- Comments --: Added the code to transform the anonymous vars into existential vars. The names given for the anonymous vars 
start with "Anon_" (see slexer.mll) => Add existential quantifiers for the anonymous vars - those that start with "Anon_".

-- Examples --:
Before:
checkentail x::pair<a,b> |- x::pair<_,_>.
print residue.
Valid.  		
true & f_r_68 = a f_r_69 = b
After:
Valid.
true & 
********************************************************************************************************************************
--By--: Cristina 
--Date--: 18.04.2008
--File--: astsimp.ml
--Line--: 2002
--Method--: match_exp
--Change--:
change 						  
	let quantified_var = if quantify then [fresh_v] else [] in
into	
  let quantified_var = [fresh_v]  in
--Comments--: each fresh variable introduced must be existentially quantified
--Examples--:
Before:
checkentail x::pair<a,a> |- x::pair<c,d>.
print residue.
Valid.  		
true & f_r_68 = a & c = a & d = f_r_68
After:
Valid.
true & c = a & d = a
********************************************************************************************************************************
--By--: Cristina 
--Date--: 09.05.2008
--File--: typechecker.ml
--Line--: 129
--Method--: match_exp
--Change--:
change 						  
	let ext_var = CP.SpecVar (CP.OType c, fresh_name (), Unprimed) in
	let t_var = CP.SpecVar (CP.OType c, fresh_name (), Unprimed) in*)
into		
	let ext_var = CP.SpecVar (CP.OType c, c, Unprimed) in
	 let t_var = CP.SpecVar (CP.OType c, c, Unprimed) in
	 
--Comments--: 
For each data node two more fresh vars were introduced for the actual type and the extension 
record (for the oo extension) (see the declaration of h_formula_data from cformula.ml):
- first argument: type variable
- second argument: pointer to the next extension
Now I don't generate fresh vars for those, I just set them to be the
actual data node and the additional constraints disappear. 

-------------------------------------------------------------
--Examples--:
data pair {int x; int y;}

int foo(pair p)
requires p::pair<a,b> & a+b>0
ensures res = b;
{
        //dprint;
        int temp = p.x + p.y;
        dprint;
        if (temp > 0) {
                dprint;
                return p.y;
        }
        dprint;
        return -1;
}

Before:
print: examples/removeExistVars/ex1.ss:9: ctx:
es_formula: p'::pair<a, b> & a+b > 0 & p' = p & f_r_25 = pair & f_r_24 = pair & f_r_33 = f_r_25 & f_r_32 = f_r_24 & temp' = a+b
es_pure: 
es_heap: true
es_evars: 

print: examples/removeExistVars/ex1.ss:11: ctx:
es_formula: (EX f_r_73 . p'::pair<a, b> & a+b > 0 & p' = p & f_r_25 = pair & f_r_24 = pair & f_r_33 = f_r_25 & f_r_32 = f_r_24 & temp' = a+b & f_r_73 = 0 & temp' > f_r_73 & f_r_20' & f_r_20')
es_pure: 
es_heap: true
es_evars: 

print: examples/removeExistVars/ex1.ss:14: ctx:
es_formula: false & false
es_pure: 
es_heap: true
es_evars: 
SUCCESS
-------------------------------------------------------------
After:
Checking procedure foo$pair... 
print: examples/removeExistVars/ex1.ss:9: ctx:
es_formula: p'::pair<a, b> & a+b > 0 & p' = p & temp' = a+b
es_pure: 
es_heap: true
es_evars: 

print: examples/removeExistVars/ex1.ss:11: ctx:
es_formula: (EX f_r_69 . p'::pair<a, b> & a+b > 0 & p' = p & temp' = a+b & f_r_69 = 0 & temp' > f_r_69 & f_r_20' & f_r_20')
es_pure: 
es_heap: true
es_evars: 

print: examples/removeExistVars/ex1.ss:14: ctx:
es_formula: false & false
es_pure: 
es_heap: true
es_evars: 
SUCCESS
-------------------------------------------------------------