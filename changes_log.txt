********************************************************************************************************************************
--By--: Cristina 
--Date--: 07.04.2008
--File--: sleekengine.ml
--Method--: process_pred_def
--Line--: 91

--Change--:
Add the line:
ignore (List.map (fun vdef -> AS.compute_view_x_formula cprog vdef !Globals.n_xpure) cprog.C.prog_view_decls);

--Comments--:
This change is needed in order to compute xpure1 instead of xpure0. 
The field view_x_formula (the pure approximation) from view_decl was initialized with inv0 without calling
the method that was supposed to compute the correct approximation according to the provided n 
(which is method compute_view_x_formula from file astsimp.ml).

--Examples (see file sleek10.slk)--:
checkentail x::ll<n> & x!=null |- x::ll<m> & m >0.
print residue.
Before: Fail.
After: Valid.
true & x != null & m = n

********************************************************************************************************************************
--By--: Cristina 
--Date--: 16.04.2008
--File--: astsimp.ml
--Method--: linearize_heap
--Line--: 2014

--Change--:
let t_var = CP.SpecVar (CP.OType c, fresh_name (), Unprimed) 
replaced by 
let t_var = CP.SpecVar (CP.OType c, c(* --change made on 16.04.2008-- fresh_name ()*), Unprimed) 

--Comments--:
For each data node two more fresh vars were introduced for the actual type
and the extension record (for the oo extension) (see the declaration of h_formula_data from cformula.ml):
- first argument: type variable
- second argument: pointer to the next extension
Now I don't generate fresh vars for those, I just set them to be the
actual data node and the additional constraints disappear. 

--Todo--: Check if/where these first two arguments are really used. We should get rid of them. 

--Examples (see file inst.slk)--:
checkentail x::cell<a> |- x::cell<_>.
print residue.
Valid.
Before: true & f_r_35 = f_r_33 & f_r_36 = f_r_34 & f_r_32 = a
After: true & f_r_28 = a
----------------------------------------------------------------
checkentail x::cell<2> |- x::cell<_>.
print residue.
Valid.
Before: true & f_r_40 = 2 & f_r_44 = f_r_42 & f_r_45 = f_r_43
After: true & f_r_32 = 2
----------------------------------------------------------------
checkentail x::cell<2> |- x::cell<c>.
print residue.
Valid.
Before: true & c = 2 & f_r_53 = f_r_51 & f_r_54 = f_r_52
After: true & c = 2
----------------------------------------------------------------
checkentail x::cell<n> & n=2 |- x::cell<c>.
print residue.
Valid.
Before: true & n = 2 & f_r_61 = f_r_59 & f_r_62 = f_r_60 & c = n
After: true & n = 2 & c = n
----------------------------------------------------------------
checkentail x::cell<2> |- (exists p : p::cell<c> & p=x).
print residue.
Valid.
Before: true & c = 2 & f_r_69 = f_r_67 & f_r_70 = f_r_68
After: true & c = 2

********************************************************************************************************************************
--By--: Cristina 
--Date--: 18.04.2008
--File--: astsimp.ml
--Line--: 132

--Change--:
Added methods:
1. look_for_anonymous_h_formula (h0 : IF.h_formula) : (ident * primed) list
(*
	- added 17.04.2008
	- checks if the heap formula contains anonymous vars
*)	
2. look_for_anonymous_exp_list (args : IP.exp list) : (ident * primed) list 
3. look_for_anonymous_exp (arg : IP.exp) : (ident * primed) list 
4. convert_anonym_to_exist (f0 : IF.formula) : IF.formula 
  		
-- Comments --: Added the code to transform the anonymous vars into existential vars. The names given for the anonymous vars 
start with "Anon_" (see slexer.mll) => Add existential quantifiers for the anonymous vars - those that start with "Anon_".

-- Examples --:
Before:
checkentail x::pair<a,b> |- x::pair<_,_>.
print residue.
Valid.  		
true & f_r_68 = a f_r_69 = b
After:
Valid.
true & 
********************************************************************************************************************************
--By--: Cristina 
--Date--: 18.04.2008
--File--: astsimp.ml
--Line--: 2002
--Method--: match_exp
--Change--:
change 						  
	let quantified_var = if quantify then [fresh_v] else [] in
into	
  let quantified_var = [fresh_v]  in
--Comments--: each fresh variable introduced must be existentially quantified
--Examples--:
Before:
checkentail x::pair<a,a> |- x::pair<c,d>.
print residue.
Valid.  		
true & f_r_68 = a & c = a & d = f_r_68
After:
Valid.
true & c = a & d = a
********************************************************************************************************************************
--By--: Cristina 
--Date--: 09.05.2008
--File--: typechecker.ml
--Line--: 129
--Method--: match_exp
--Change--:
change 						  
	let ext_var = CP.SpecVar (CP.OType c, fresh_name (), Unprimed) in
	let t_var = CP.SpecVar (CP.OType c, fresh_name (), Unprimed) in*)
into		
	let ext_var = CP.SpecVar (CP.OType c, c, Unprimed) in
	 let t_var = CP.SpecVar (CP.OType c, c, Unprimed) in
	 
--Comments--: 
For each data node two more fresh vars were introduced for the actual type and the extension 
record (for the oo extension) (see the declaration of h_formula_data from cformula.ml):
- first argument: type variable
- second argument: pointer to the next extension
Now I don't generate fresh vars for those, I just set them to be the
actual data node and the additional constraints disappear. 

-------------------------------------------------------------
--Examples--:
data pair {int x; int y;}

int foo(pair p)
requires p::pair<a,b> & a+b>0
ensures res = b;
{
        //dprint;
        int temp = p.x + p.y;
        dprint;
        if (temp > 0) {
                dprint;
                return p.y;
        }
        dprint;
        return -1;
}

Before:
print: examples/removeExistVars/ex1.ss:9: ctx:
es_formula: p'::pair<a, b> & a+b > 0 & p' = p & f_r_25 = pair & f_r_24 = pair & f_r_33 = f_r_25 & f_r_32 = f_r_24 & temp' = a+b
es_pure: 
es_heap: true
es_evars: 

print: examples/removeExistVars/ex1.ss:11: ctx:
es_formula: (EX f_r_73 . p'::pair<a, b> & a+b > 0 & p' = p & f_r_25 = pair & f_r_24 = pair & f_r_33 = f_r_25 & f_r_32 = f_r_24 & temp' = a+b & f_r_73 = 0 & temp' > f_r_73 & f_r_20' & f_r_20')
es_pure: 
es_heap: true
es_evars: 

print: examples/removeExistVars/ex1.ss:14: ctx:
es_formula: false & false
es_pure: 
es_heap: true
es_evars: 
SUCCESS
-------------------------------------------------------------
After:
Checking procedure foo$pair... 
print: examples/removeExistVars/ex1.ss:9: ctx:
es_formula: p'::pair<a, b> & a+b > 0 & p' = p & temp' = a+b
es_pure: 
es_heap: true
es_evars: 

print: examples/removeExistVars/ex1.ss:11: ctx:
es_formula: (EX f_r_69 . p'::pair<a, b> & a+b > 0 & p' = p & temp' = a+b & f_r_69 = 0 & temp' > f_r_69 & f_r_20' & f_r_20')
es_pure: 
es_heap: true
es_evars: 

print: examples/removeExistVars/ex1.ss:14: ctx:
es_formula: false & false
es_pure: 
es_heap: true
es_evars: 
SUCCESS
********************************************************************************************************************************
--By--: Cristina 
--Date--: 10.05.2008
--File--: typechecker.ml + cformula.ml
--Line--: 562
--Method--: process_one in check_exp
-- Remark--: Only did the change for static calls (not for instance calls)
--Change in typechecker.ml --:
add:
	(* existentially quantify the linking variables *)
	let tmp_res2 = CF.add_evars_to_ctx tmp_res  free_vars_fresh in
--Change in cformula.ml --:
defined new methods:  
	- add_exist_vars_to_ctx_list (ctx : context list) (evars	: CP.spec_var list) : (context list) 
	   	* purpose: add a list of existential vars, evars, to each context in the list ctx
	- add_exist_vars_to_ctx (ctx : context) (evars	: CP.spec_var list) : context
			* purpose: add a list of existential vars, evars, to ctx.es_formula 	

--Comments--: 
Free vars are those that appear both in precond and postcond. When a call is performed, the FV in the callee's spec are replaced by fresh 
names to avoid collision. When the precondition is entailed by the current heap state, these vars need to be considered free 
such that bindings for them are moved from the consequent to the antecedent. However, after the postcondition is added, they can 
be existentially quantified such that, if there is a substitution available for them, they will be eliminated. 

-------------------------------------------------------------
--Examples--:
data pair{int x; int y;}

int first(pair p)
requires p::pair<a,_>
ensures p::pair<a, _> &  res = a;
{
        int tmp=p.x;
        return tmp;
}

int addtwice(pair p) 
requires p::pair<a,_>
ensures res = a;  
{
       int t1 = first(p);
       dprint;
       return t1; 
}                
 
-------------------------------------------------------------
Before:
Checking procedure addtwice$pair... 
[typechecker.ml, line 486]: pre (EX Anon_f_r_11 . p::pair<a, Anon_f_r_11> & )
// rename bound vars
[typechecker.ml, line 486]: renamed_pre (EX f_r_19 . p::pair<a, f_r_19> & )
[typechecker.ml, line 486]: post (EX f_r_14, Anon_f_r_12 . p::pair<f_r_14, Anon_f_r_12> & res = a & f_r_14 = a)
[typechecker.ml, line 486]: renamed_post (EX f_r_20, f_r_21 . p::pair<f_r_20, f_r_21> & res = a & f_r_20 = a)
// substitute FV by fresh names to avoid collisions
[typechecker.ml, line 499]: pre after subst (EX f_r_19 . p::pair<f_r_18, f_r_19> & )
[typechecker.ml, line 500]: post after subst (EX f_r_20, f_r_21 . p::pair<f_r_20, f_r_21> & res = f_r_18 & f_r_20 = f_r_18)
[typechecker.ml, line 499]: pre to be entailed (EX f_r_19 . p'::pair<f_r_18, f_r_19> & )
[typechecker.ml, line 476]: context before entailment:
es_formula: (EX f_r_17 . p::pair<a, f_r_17> & p' = p)
es_pure: 
es_heap: true
es_evars: 

Entailment: EX f_r_17 . p::pair<a, f_r_17> & p' = p |- EX f_r_19 . p'::pair<f_r_18, f_r_19>
						EX f_r_17 . p' = p |- EX f_r_19 . f_r_18 = a & f_r_19 = f_r_17
						EX f_r_17 . p' = p & f_r_18 = a |- EX f_r_19 . f_r_19 = f_r_17

[typechecker.ml, line 476]: context after entailment:
es_formula: true & p' = p & f_r_18 = a
es_pure: 
es_heap: p::pair<a, f_r_26>
es_evars: f_r_27

[typechecker.ml, line 476]: context after adding the post:
es_formula: (EX f_r_37, f_r_38, f_r_36 . f_r_36::pair<f_r_37, f_r_38> & f_r_36 = p & f_r_18 = a & res = f_r_18 & f_r_37 = f_r_18 & p' = f_r_36)
es_pure: 
es_heap: true
es_evars: 

[typechecker.ml, line 476]: context after removing exist vars:
es_formula: (EX f_r_38 . p::pair<f_r_18, f_r_38> & f_r_18 = a & res = f_r_18 & p' = p)
es_pure: 
es_heap: true
es_evars: 


print: examples/removeExistVars/ex2.ss:32: final ctx (linkink var f_r_18 is still present):
es_formula: (EX f_r_40 . p::pair<f_r_18, f_r_40> & f_r_18 = a & p' = p & t1' = f_r_18)
es_pure: 
es_heap: true
es_evars: 
SUCCESS
Checking procedure first$pair... SUCCESS


-------------------------------------------------------------
After:

Checking procedure addtwice$pair... 
[typechecker.ml, line 486]: pre (EX Anon_f_r_11 . p::pair<a, Anon_f_r_11> & )
[typechecker.ml, line 486]: renamed_pre (EX f_r_19 . p::pair<a, f_r_19> & )
[typechecker.ml, line 486]: post (EX f_r_14, Anon_f_r_12 . p::pair<f_r_14, Anon_f_r_12> & res = a & f_r_14 = a)
[typechecker.ml, line 486]: renamed_post (EX f_r_20, f_r_21 . p::pair<f_r_20, f_r_21> & res = a & f_r_20 = a)
[typechecker.ml, line 499]: pre after subst (EX f_r_19 . p::pair<f_r_18, f_r_19> & )
[typechecker.ml, line 500]: post after subst (EX f_r_20, f_r_21 . p::pair<f_r_20, f_r_21> & res = f_r_18 & f_r_20 = f_r_18)
[typechecker.ml, line 499]: pre to be entailed (EX f_r_19 . p'::pair<f_r_18, f_r_19> & )
[typechecker.ml, line 476]: context before entailment:
es_formula: (EX f_r_17 . p::pair<a, f_r_17> & p' = p)
es_pure: 
es_heap: true
es_evars: 

[typechecker.ml, line 476]: context after entailment:
es_formula: true & p' = p & f_r_18 = a
es_pure: 
es_heap: p::pair<a, f_r_26>
es_evars: f_r_27

[typechecker.ml, line 476]: context after adding the post:
es_formula: (EX f_r_37, f_r_38, f_r_36 . f_r_36::pair<f_r_37, f_r_38> & f_r_36 = p & f_r_18 = a & res = f_r_18 & f_r_37 = f_r_18 & p' = f_r_36)
es_pure: 
es_heap: true
es_evars: 

[typechecker.ml, line 476]: context after existentially quantify the linking vars:
es_formula: (EX f_r_37, f_r_38, f_r_36, f_r_18 . f_r_36::pair<f_r_37, f_r_38> & f_r_36 = p & f_r_18 = a & res = f_r_18 & f_r_37 = f_r_18 & p' = f_r_36)
es_pure: 
es_heap: true
es_evars: 

[typechecker.ml, line 476]: context after removing exist vars:
es_formula: (EX f_r_38 . p::pair<a, f_r_38> & res = a & p' = p)
es_pure: 
es_heap: true
es_evars: 


print: examples/removeExistVars/ex2.ss:32: final ctx:
es_formula: (EX f_r_40 . p::pair<a, f_r_40> & p' = p & t1' = a)
es_pure: 
es_heap: true
es_evars: 
SUCCESS
Checking procedure first$pair... SUCCESS

********************************************************************************************************************************

