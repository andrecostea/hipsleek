/* singly linked lists */

/* representation of a node */
data node {
	int val;
	node next
}.

relation cons(abstract L, int v, abstract Lt).

relation reverse(abstract L1, abstract L2).

relation append(abstract L1, abstract L2, abstract L3).

relation isempty(abstract L).

axiom cons(L,v,Lp) ==> !(isempty(L)).

axiom isempty(L1) & isempty(L2) & cons(L,v,L1) ==> cons(L,v,L2).

axiom isempty(L) ==> append(L1,L,L1). 

axiom isempty(L) ==> reverse(L,L).

/* view for a singly linked list */
pred ll<L> == self=null & isempty(L)
      or self::node<v, p> * p::ll<Lp> & cons(L,v,Lp)
  inv (self=null & isempty(L) | self!=null & !(isempty(L))).

pred lln<n> == self=null & n=0
      or self::node<v, p> * p::lln<n-1>
  inv  n>=0.

checkentail cons(L1,v_1016,Lp_1018) & ys=ys_1024 & xs=xs_1025 & xs_1025!=null & 
  v_bool_37_967' & xs_1025!=null & v_bool_37_967' & p_1017=tmp_39' & 
  next_40_1023=p_1017 & xs_1025=ys' & tmp_39'=xs' & L1_1026=Lp_1018 & 
  v_1016=v_1032 & p_1033=ys_1024 & L2=Lp_1034 & cons(_,v_1016,L2)
|-  exists L2_1027 : cons(L2_1027,v_1032,Lp_1034).



/*
checkentail p::ll<Lp> * ys1::ll<L2> * xs1::node<v,ys1> & tmp'=xs' & xs=ys' & next=p & 
p=tmp' & xs!=null & xs=xs1 & ys=ys1 & cons(L1,v,Lp)
 |-  xs'::ll<Lp> * ys'::ll<L1>.

checkentail p::lln<np> * ys1::lln<n2> * xs1::node<v,ys1> & tmp'=xs' & xs=ys' & next=p & 
p=tmp' & xs!=null & xs=xs1 & ys=ys1 & n1=np+1
 |-  xs'::lln<np> * ys'::lln<n2+1>.
*/
