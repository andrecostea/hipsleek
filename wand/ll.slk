/* singly linked lists */

/* representation of a node */
data node {
	int val;
	node next
}.

relation cons(abstract L, int v, abstract Lt).

relation reverse(abstract L1, abstract L2).

relation append(abstract L1, abstract L2, abstract L3).

relation isempty(abstract L).

axiom cons(L,v,Lp) ==> !(isempty(L)).

axiom isempty(L) ==> append(L1,L,L1). 

axiom isempty(L) ==> reverse(L,L).

/* view for a singly linked list */
pred ll<L> == self=null & isempty(L)
      or self::node<v, p> * p::ll<Lp> & cons(L,v,Lp)
      inv (self=null & isempty(L) | self!=null & !(isempty(L))).

checkentail
xs_1018!=null & p_1034=ys_1017 & tmp_38'=xs' & ys=ys_1017 & xs=xs_1018 & 
p_1010=tmp_38' & next_38_1016=p_1010 & xs_1018=ys' & (((ys=null & 
isempty(L2)) | (ys!=null & !(isempty(L2))))) & (((p_1010=null & 
isempty(Lp_1011)) | (p_1010!=null & !(isempty(Lp_1011))))) & 
cons(L1,v_1009,Lp_1011) & v_1009=v_1033 & L2=Lp_1035
|- cons(L2_1038,v_1033,Lp_1035).
