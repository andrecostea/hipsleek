  caizh Wed Oct 15 09:04:39 2014 +0800: //class __cflow extends __Exc {}
asankhs Tue Mar 12 16:06:40 2013 +0800: class __DivByZeroErr extends __Error {}
asankhs Tue Mar 12 16:06:40 2013 +0800: class __ArrBoundErr extends __Error {}
  caizh Thu Oct 16 15:10:35 2014 +0800: class ret_int extends __RET { int val }
  caizh Thu Oct 16 15:10:35 2014 +0800: class ret_bool extends __RET { bool val } 
  caizh Thu Oct 16 15:10:35 2014 +0800: class __RET extends __Exc {}
  caizh Thu Oct 16 15:10:35 2014 +0800: 
  caizh Wed Oct 15 09:04:39 2014 +0800: 
  caizh Wed Oct 15 09:04:39 2014 +0800: int __VERIFIER_nondet_int()
  caizh Wed Oct 15 09:04:39 2014 +0800:   requires true
  caizh Wed Oct 15 09:04:39 2014 +0800:   ensures true;
  locle Mon Jun 06 21:20:22 2011 +0800: 
 chinwn Tue Jun 07 04:56:03 2011 +0800: int add___(int a, int b) 
  khanh Tue Feb 28 23:22:46 2012 +0800:   requires true 
 chinwn Tue Jun 07 04:56:03 2011 +0800:   ensures res = a + b;
  locle Mon Jun 06 21:20:22 2011 +0800: 
 chinwn Tue Jun 07 04:56:03 2011 +0800: int minus___(int a, int b) 
  khanh Tue Feb 28 23:22:46 2012 +0800:   requires true
 chinwn Tue Jun 07 04:56:03 2011 +0800:   ensures res = a - b;
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
 chinwn Tue Jun 07 04:56:03 2011 +0800: int mult___(int a, int b) 
chanhle Sat Oct 11 23:02:24 2014 +0800:   requires true 
chanhle Sat Oct 11 23:02:24 2014 +0800:   ensures res = a * b;
chanhle Sat Oct 11 17:26:01 2014 +0800:   
chanhle Sat Oct 11 23:02:24 2014 +0800: int mults___(int a, int b)
chanhle Mon Oct 13 23:54:56 2014 +0800:   //requires true 
chanhle Mon Oct 13 23:54:56 2014 +0800:   //ensures res = a * b;
chanhle Fri Oct 10 12:39:06 2014 +0800:   case {
chanhle Fri Oct 10 12:39:06 2014 +0800:     a = 0 -> ensures res = 0;
chanhle Fri Oct 10 12:39:06 2014 +0800:     a > 0 -> case {
chanhle Fri Oct 10 12:39:06 2014 +0800:       b = 0 -> ensures res = 0;
chanhle Fri Oct 10 12:39:06 2014 +0800:       b < 0 -> ensures res = a * b & res < 0 & res < -a & res < b;
chanhle Fri Oct 10 12:39:06 2014 +0800:       b > 0 -> ensures res = a * b & res > 0 & res > a & res > b;
chanhle Fri Oct 10 12:39:06 2014 +0800:     }
chanhle Fri Oct 10 12:39:06 2014 +0800:     a < 0 -> case {
chanhle Fri Oct 10 12:39:06 2014 +0800:       b = 0 -> ensures res = 0;
chanhle Fri Oct 10 12:39:06 2014 +0800:       b < 0 -> ensures res = a * b & res > 0 & res > -a & res > -b;
chanhle Fri Oct 10 12:39:06 2014 +0800:       b > 0 -> ensures res = a * b & res < 0 & res < a & res < -b;
chanhle Fri Oct 10 12:39:06 2014 +0800:     }
chanhle Fri Oct 10 12:39:06 2014 +0800:   }
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
 chinwn Tue Jun 07 04:56:03 2011 +0800: int div___(int a, int b) 
chanhle Sat Oct 11 23:02:24 2014 +0800: /*
 chinwn Tue Jun 07 04:56:03 2011 +0800:  case {
  locle Mon Jun 06 21:20:22 2011 +0800:   a >= 0 -> case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     b >= 1 -> ensures (exists r: a = b*res + r & res >= 0 & 0 <= r <= b-1);
 chinwn Tue Jun 07 04:56:03 2011 +0800:     b <= -1 -> ensures (exists r: a = b*res + r & res <= 0 & 0 <= r <= -b-1);
        Tue Jun 07 10:13:13 2011 +0800:     /* -1 < b < 1 -> requires false ensures false; */
        Tue Jun 07 10:13:13 2011 +0800:     -1 < b < 1 -> ensures true & flow __DivByZeroErr;
  locle Mon Jun 06 21:20:22 2011 +0800:     }
  locle Mon Jun 06 21:20:22 2011 +0800:   a < 0 -> case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     b >= 1 -> ensures (exists r: a = b*res + r & res <= -1 & 0 <= r <= b-1);
 chinwn Tue Jun 07 04:56:03 2011 +0800:     b <= -1 -> ensures (exists r: a = b*res + r & res >= 1 & 0 <= r <= -b-1);
        Tue Jun 07 10:13:13 2011 +0800:     /* -1 < b < 1 -> requires false ensures false; */
        Tue Jun 07 10:13:13 2011 +0800:     -1 < b < 1 -> ensures true & flow __DivByZeroErr;
  locle Mon Jun 06 21:20:22 2011 +0800:     }
chanhle Sat Oct 11 23:02:24 2014 +0800:   }
chanhle Sat Oct 11 23:02:24 2014 +0800: */
chanhle Sat Oct 11 23:02:24 2014 +0800: 
chanhle Sat Oct 11 23:02:24 2014 +0800:  case {
chanhle Sat Oct 11 23:02:24 2014 +0800:   a >= 0 -> case {
chanhle Sat Oct 11 23:02:24 2014 +0800:     b = 1 -> ensures res = a;
chanhle Sat Oct 11 23:02:24 2014 +0800:     b > 1 -> ensures (exists r: a = b*res + r & 0 <= r <= b-1 & res >= 0 & res < a);
chanhle Sat Oct 11 23:02:24 2014 +0800:     b <= -1 -> ensures (exists r: a = b*res + r & 0 <= r <= -b-1 & res <= 0);
chanhle Sat Oct 11 23:02:24 2014 +0800:     /* -1 < b < 1 -> requires false ensures false; */
chanhle Sat Oct 11 23:02:24 2014 +0800:     -1 < b < 1 -> ensures true & flow __DivByZeroErr;
chanhle Sat Oct 11 23:02:24 2014 +0800:   }
chanhle Sat Oct 11 23:02:24 2014 +0800:   a < 0 -> case {
chanhle Sat Oct 11 23:02:24 2014 +0800:     b >= 1 -> ensures (exists r: a = b*res + r & res <= -1 & 0 <= r <= b-1);
chanhle Sat Oct 11 23:02:24 2014 +0800:     b <= -1 -> ensures (exists r: a = b*res + r & res >= 1 & 0 <= r <= -b-1);
chanhle Sat Oct 11 23:02:24 2014 +0800:     /* -1 < b < 1 -> requires false ensures false; */
chanhle Sat Oct 11 23:02:24 2014 +0800:     -1 < b < 1 -> ensures true & flow __DivByZeroErr;
chanhle Sat Oct 11 23:02:24 2014 +0800:     }
chanhle Sat Oct 11 23:02:24 2014 +0800:   }
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
 chinwn Tue Jun 07 04:56:03 2011 +0800: // why is flow of div2 __Error rather __DivByZeroErr?
 chinwn Tue Jun 07 07:22:35 2011 +0800: int div2(int a, int b)
  khanh Tue Feb 28 23:22:46 2012 +0800:  requires true 
 chinwn Tue Jun 07 04:56:03 2011 +0800:  case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:   b != 0 -> ensures true;
 chinwn Tue Jun 07 04:56:03 2011 +0800:   b = 0 -> ensures true & flow __DivByZeroErr; 
 chinwn Tue Jun 07 04:56:03 2011 +0800:  }
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
  khanh Tue Feb 28 23:22:46 2012 +0800: int div3(int a, int b) 
 chinwn Tue Jun 07 04:56:03 2011 +0800:  case {
  khanh Tue Feb 28 23:22:46 2012 +0800:   b = 0 -> requires false ensures false;
  khanh Tue Feb 28 23:22:46 2012 +0800:   b != 0 -> ensures true;
 chinwn Tue Jun 07 04:56:03 2011 +0800:  }
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
 chinwn Tue Jun 07 04:56:03 2011 +0800: int div4(int a, int b) 
  khanh Tue Feb 28 23:22:46 2012 +0800:   requires b != 0 
 chinwn Tue Jun 07 04:56:03 2011 +0800:   ensures true;
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
  khanh Tue Feb 28 23:22:46 2012 +0800: int mod___(int a, int b) case {
  locle Mon Jun 06 21:20:22 2011 +0800:   a >= 0 -> case {
  khanh Tue Feb 28 16:25:07 2012 +0800: 	b >= 1 -> case {
  khanh Tue Feb 28 16:25:07 2012 +0800: 	  a < b -> ensures res = a;
  khanh Tue Feb 28 16:25:07 2012 +0800: 	  a >= b -> case {
  khanh Tue Feb 28 16:25:07 2012 +0800: 		a < 2*b -> ensures res = a - b;
  khanh Tue Feb 28 16:25:07 2012 +0800: 		a >= 2*b -> ensures (exists q: a = b*q + res & q >= 0 & 0 <= res <= b-1);
  khanh Tue Feb 28 16:25:07 2012 +0800: 	  }
  khanh Tue Feb 28 16:25:07 2012 +0800: 	}
 chinwn Tue Jun 07 04:56:03 2011 +0800:     b <= -1 -> ensures (exists q: a = b*q + res & q <= 0 & 0 <= res <= -b-1);
 chinwn Tue Jun 07 04:56:03 2011 +0800:     -1 < b < 1 -> ensures true & flow __DivByZeroErr;
 chinwn Tue Jun 07 04:56:03 2011 +0800:     /* -1 < b < 1 -> requires false ensures false; */
  locle Mon Jun 06 21:20:22 2011 +0800:   }
  locle Mon Jun 06 21:20:22 2011 +0800:   a < 0 -> case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     b >= 1 -> ensures (exists q: a = b*q + res & q <= -1 & 0 <= res <= b-1);
 chinwn Tue Jun 07 04:56:03 2011 +0800:     b <= -1 -> ensures (exists q: a = b*q + res & q >= 1 & 0 <= res <= -b-1);
 chinwn Tue Jun 07 04:56:03 2011 +0800:     -1 < b < 1 -> ensures true & flow __DivByZeroErr;
 chinwn Tue Jun 07 04:56:03 2011 +0800:     /* -1 < b < 1 -> requires false ensures false; */
  locle Mon Jun 06 21:20:22 2011 +0800:   }
  locle Mon Jun 06 21:20:22 2011 +0800: }
chanhle Fri Nov 23 14:19:35 2012 +0800: 
trungtq Thu Jun 27 22:00:15 2013 +0800: float add___(int a, float b) 
trungtq Thu Jun 27 22:00:15 2013 +0800:   requires true 
trungtq Thu Jun 27 22:00:15 2013 +0800:   ensures res = a + b;
trungtq Thu Jun 27 22:00:15 2013 +0800: 
trungtq Thu Jun 27 22:00:15 2013 +0800: float add___(float a, int b) 
trungtq Thu Jun 27 22:00:15 2013 +0800:   requires true 
trungtq Thu Jun 27 22:00:15 2013 +0800:   ensures res = a + b;
trungtq Thu Jun 27 22:00:15 2013 +0800: 
 chinwn Tue Jun 07 04:56:03 2011 +0800: float add___(float a, float b) 
 chinwn Tue Jun 07 04:56:03 2011 +0800:   requires true 
 chinwn Tue Jun 07 04:56:03 2011 +0800:   ensures res = a + b;
  locle Mon Jun 06 21:20:22 2011 +0800: 
trungtq Thu Jun 27 22:00:15 2013 +0800: 
trungtq Thu Jun 27 22:00:15 2013 +0800: float minus___(int a, float b) 
trungtq Thu Jun 27 22:00:15 2013 +0800:   requires true 
trungtq Thu Jun 27 22:00:15 2013 +0800:   ensures res = a - b;
trungtq Thu Jun 27 22:00:15 2013 +0800: 
trungtq Thu Jun 27 22:00:15 2013 +0800: float minus___(float a, int b) 
trungtq Thu Jun 27 22:00:15 2013 +0800:   requires true 
trungtq Thu Jun 27 22:00:15 2013 +0800:   ensures res = a - b;
trungtq Thu Jun 27 22:00:15 2013 +0800: 
 chinwn Tue Jun 07 04:56:03 2011 +0800: float minus___(float a, float b) 
 chinwn Tue Jun 07 04:56:03 2011 +0800:   requires true 
 chinwn Tue Jun 07 04:56:03 2011 +0800:   ensures res = a - b;
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
trungtq Thu Jun 27 22:00:15 2013 +0800: float mult___(int a, float b) 
trungtq Thu Jun 27 22:00:15 2013 +0800:   requires true 
trungtq Thu Jun 27 22:00:15 2013 +0800:   ensures res = a * b;
trungtq Thu Jun 27 22:00:15 2013 +0800: 
trungtq Thu Jun 27 22:00:15 2013 +0800: float mult___(float a, int b) 
trungtq Thu Jun 27 22:00:15 2013 +0800:   requires true 
trungtq Thu Jun 27 22:00:15 2013 +0800:   ensures res = a * b;
trungtq Thu Jun 27 22:00:15 2013 +0800: 
 chinwn Tue Jun 07 04:56:03 2011 +0800: float mult___(float a, float b) 
 chinwn Tue Jun 07 04:56:03 2011 +0800:   requires true 
 chinwn Tue Jun 07 04:56:03 2011 +0800:   ensures res = a * b;
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
trungtq Thu Jun 27 22:00:15 2013 +0800: 
        Wed Jul 10 11:18:14 2013 +0800: /*
trungtq Thu Jun 27 22:00:15 2013 +0800: float div___(int a, float b)
trungtq Thu Jun 27 22:00:15 2013 +0800:  case {
trungtq Thu Jun 27 22:00:15 2013 +0800:   b = 0.0 -> ensures true & flow __DivByZeroErr;
trungtq Thu Jun 27 22:00:15 2013 +0800:   b != 0.0 -> ensures res = a / b;
trungtq Thu Jun 27 22:00:15 2013 +0800:  }
trungtq Thu Jun 27 22:00:15 2013 +0800: 
trungtq Thu Jun 27 22:00:15 2013 +0800: float div___(float a, int b)
trungtq Thu Jun 27 22:00:15 2013 +0800:  case {
trungtq Thu Jun 27 22:00:15 2013 +0800:   b = 0.0 -> ensures true & flow __DivByZeroErr;
trungtq Thu Jun 27 22:00:15 2013 +0800:   b != 0.0 -> ensures res = a / b;
trungtq Thu Jun 27 22:00:15 2013 +0800:  }
trungtq Thu Jun 27 22:00:15 2013 +0800: 
        Thu Aug 18 18:04:11 2011 +0800: float div___(float a, float b)
 chinwn Tue Jun 07 04:56:03 2011 +0800:  case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:   b = 0.0 -> ensures true & flow __DivByZeroErr;
 chinwn Tue Jun 07 04:56:03 2011 +0800:   b != 0.0 -> ensures res = a / b;
 chinwn Tue Jun 07 04:56:03 2011 +0800:  }
        Wed Jul 10 11:18:14 2013 +0800: */
trungtq Thu Jun 27 22:00:15 2013 +0800: 
  khanh Tue Feb 28 23:22:46 2012 +0800: bool eq___(int a, int b) 
 chinwn Tue Jun 07 04:56:03 2011 +0800:   case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a = b -> ensures res;
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a != b -> ensures !res;}
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
chanhle Thu Oct 27 21:18:02 2011 +0800: /*
 chinwn Tue Jun 07 04:56:03 2011 +0800: bool eq___(float a, float b) 
 chinwn Tue Jun 07 04:56:03 2011 +0800:   case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a = b -> ensures res;
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a != b -> ensures !res;}
chanhle Thu Oct 27 21:18:02 2011 +0800: */
 chinwn Tue Jun 07 04:56:03 2011 +0800: bool neq___(int a, int b) 
 chinwn Tue Jun 07 04:56:03 2011 +0800:   case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a = b -> ensures !res;
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a != b -> ensures res;}
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
  khanh Tue Feb 28 23:22:46 2012 +0800: bool neq___(bool a, bool b) case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a = b -> ensures !res;
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a != b -> ensures res;}
chanhle Thu Oct 27 21:18:02 2011 +0800: /*
  locle Mon Jun 06 21:20:22 2011 +0800: bool neq___(float a, float b) case {
        Tue Jun 07 10:13:13 2011 +0800:     a = b -> ensures !res;
        Tue Jun 07 10:13:13 2011 +0800:     a != b -> ensures res;}
chanhle Thu Oct 27 21:18:02 2011 +0800: */
  khanh Tue Feb 28 23:22:46 2012 +0800: bool lt___(int a, int b) case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a <  b -> ensures  res;
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a >= b -> ensures !res;}
chanhle Thu Oct 27 21:18:02 2011 +0800: /*
  locle Mon Jun 06 21:20:22 2011 +0800: bool lt___(float a, float b) case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a <  b -> ensures  res;
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a >= b -> ensures !res;}
chanhle Thu Oct 27 21:18:02 2011 +0800: */
  khanh Tue Feb 28 23:22:46 2012 +0800: bool lte___(int a, int b) case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a <= b -> ensures  res;
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a >  b -> ensures !res;}
chanhle Thu Oct 27 21:18:02 2011 +0800: /*
  locle Mon Jun 06 21:20:22 2011 +0800: bool lte___(float a, float b) case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a <= b -> ensures  res;
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a >  b -> ensures !res;}
chanhle Thu Oct 27 21:18:02 2011 +0800: */
  khanh Tue Feb 28 23:22:46 2012 +0800: bool gt___(int a, int b) case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a >  b -> ensures  res;
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a <= b -> ensures !res;}
chanhle Thu Oct 27 21:18:02 2011 +0800: /*
  locle Mon Jun 06 21:20:22 2011 +0800: bool gt___(float a, float b) case {
        Tue Jun 07 10:13:13 2011 +0800:     a >  b -> ensures  res;
        Tue Jun 07 10:13:13 2011 +0800:     a <= b -> ensures !res;}
chanhle Thu Oct 27 21:18:02 2011 +0800: */
  khanh Tue Feb 28 23:22:46 2012 +0800: bool gte___(int a, int b) case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a >= b -> ensures  res;
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a <  b -> ensures !res;}
chanhle Thu Oct 27 21:18:02 2011 +0800: /*
  locle Mon Jun 06 21:20:22 2011 +0800: bool gte___(float a, float b) case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a >= b -> ensures  res;
 chinwn Tue Jun 07 04:56:03 2011 +0800:     a <  b -> ensures !res;}
chanhle Thu Oct 27 21:18:02 2011 +0800: */
  khanh Tue Feb 28 23:22:46 2012 +0800: bool land___(bool a, bool b) case {
 chinwn Tue Jun 07 04:56:03 2011 +0800:   a -> case { b -> ensures res; 
 chinwn Tue Jun 07 04:56:03 2011 +0800:               !b -> ensures !res;}
 chinwn Tue Jun 07 04:56:03 2011 +0800:  !a -> ensures !res;}
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
  khanh Tue Feb 28 23:22:46 2012 +0800: bool lor___(bool a, bool b) case {
  locle Mon Jun 06 21:20:22 2011 +0800:   a -> requires true ensures res;
 chinwn Tue Jun 07 04:56:03 2011 +0800:   !a -> case { b -> ensures res; 
 chinwn Tue Jun 07 04:56:03 2011 +0800:                 !b -> ensures !res;}}
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
  khanh Tue Feb 28 23:22:46 2012 +0800: bool not___(bool a) 
 chinwn Tue Jun 07 04:56:03 2011 +0800:    case { a -> ensures !res; 
 chinwn Tue Jun 07 04:56:03 2011 +0800:           !a -> ensures res;}
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
 chinwn Tue Jun 07 04:56:03 2011 +0800: int pow___(int a, int b) 
  khanh Tue Feb 28 23:22:46 2012 +0800:    requires true 
 chinwn Tue Jun 07 04:56:03 2011 +0800:    ensures true;
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
  anhoa Thu Jun 30 13:21:24 2011 +0800: //////////////////////////////////////////////////////////////////
  anhoa Thu Jun 30 13:21:24 2011 +0800: // <OLD> SPECIFICATIONS
  anhoa Thu Jun 30 13:21:24 2011 +0800: //////////////////////////////////////////////////////////////////
  anhoa Thu Jun 30 13:21:24 2011 +0800: //
  anhoa Thu Jun 30 13:21:24 2011 +0800: //relation update_array(int[] a, int i, int v, int[] r) == true.
  anhoa Thu Jun 30 13:21:24 2011 +0800: //
  anhoa Thu Jun 30 13:21:24 2011 +0800: //int array_get_elm_at___(int[] a, int i) 
  anhoa Thu Jun 30 13:21:24 2011 +0800: //   requires true 
  anhoa Thu Jun 30 13:21:24 2011 +0800: //   ensures res = a[i];
  anhoa Thu Jun 30 13:21:24 2011 +0800: //
  anhoa Thu Jun 30 13:21:24 2011 +0800: //int[] update___(int[] a, int i, int v) 
  anhoa Thu Jun 30 13:21:24 2011 +0800: //   requires true 
  anhoa Thu Jun 30 13:21:24 2011 +0800: //   ensures update_array(a,i,v,res);
  anhoa Thu Jun 30 13:21:24 2011 +0800: //
  anhoa Thu Jun 30 13:21:24 2011 +0800: //////////////////////////////////////////////////////////////////
  anhoa Thu Jun 30 13:21:24 2011 +0800: //////////////////////////////////////////////////////////////////
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
 chinwn Tue Jun 07 04:56:03 2011 +0800: 
  anhoa Thu Jun 30 13:21:24 2011 +0800: //////////////////////////////////////////////////////////////////
  anhoa Thu Jun 30 13:21:24 2011 +0800: // <NEW> PRIMITIVE RELATIONS
  anhoa Thu Jun 30 13:21:24 2011 +0800: //////////////////////////////////////////////////////////////////
  anhoa Thu Jun 30 13:21:24 2011 +0800: 
  anhoa Wed Jul 27 14:10:27 2011 +0800: // Special relation to indicate the value to do induction on
  anhoa Wed Jul 27 14:10:27 2011 +0800: relation induce(int value) == true.
  anhoa Wed Jul 27 14:10:27 2011 +0800: 
  anhoa Tue Oct 04 17:15:46 2011 +0800: relation dom(int[] a, int low, int high).
  anhoa Tue Oct 04 17:15:46 2011 +0800: 
vuanhoa Wed Nov 09 10:27:25 2011 +0800: relation domb(bool[] a, int low, int high).
vuanhoa Wed Nov 09 10:27:25 2011 +0800: 
  anhoa Tue Oct 04 17:15:46 2011 +0800: axiom dom(a,low,high) & low<=l & h<=high ==> dom(a,l,h).
  anhoa Thu Jun 30 13:21:24 2011 +0800: 
vuanhoa Wed Nov 09 10:27:25 2011 +0800: axiom domb(a,low,high) & low<=l & h<=high ==> domb(a,l,h).
vuanhoa Wed Nov 09 10:27:25 2011 +0800: 
 bachle Fri Dec 07 16:56:54 2012 +0800: axiom domb(a,low,high) & low<=l | h<=high ==> domb(a,l,h).
 bachle Fri Dec 07 16:56:54 2012 +0800: 
vuanhoa Wed Nov 09 10:27:25 2011 +0800: relation update_array_1d_b(bool[] a, bool[] b, bool val, int i).
vuanhoa Wed Nov 09 10:27:25 2011 +0800: 
vuanhoa Mon Oct 31 11:08:48 2011 +0800: relation update_array_1d(int[] a, int[] r, int val, int i).
 chinwn Wed Oct 05 07:03:44 2011 +0800: 
vuanhoa Mon Oct 31 11:08:48 2011 +0800: relation update_array_2d(int[,] a, int[,] r, int val, int i, int j).
vuanhoa Mon Oct 31 08:49:55 2011 +0800: 
  anhoa Thu Jun 30 13:21:24 2011 +0800: relation amodr(int[] a, int[] b, int i, int j) == 
  anhoa Thu Jun 30 13:21:24 2011 +0800:     forall(k : (i<=k & k<=j | a[k] = b[k])).
  anhoa Thu Jun 30 13:21:24 2011 +0800: 
 chinwn Wed Nov 14 09:28:54 2012 +0800: /*
 chinwn Wed Oct 05 07:03:44 2011 +0800: relation bnd(int[] a, int i, int j, int low, int high) == 
 chinwn Wed Oct 05 07:03:44 2011 +0800:  	(i > j | i<=j & forall ( k : (k < i | k > j | low <= a[k] <= high))).
 chinwn Wed Nov 14 09:28:54 2012 +0800: */
 chinwn Wed Oct 05 07:03:44 2011 +0800: 
  anhoa Thu Jun 30 13:21:24 2011 +0800: //////////////////////////////////////////////////////////////////
  anhoa Thu Jun 30 13:21:24 2011 +0800: //////////////////////////////////////////////////////////////////
  anhoa Thu Jun 30 13:21:24 2011 +0800: 
  anhoa Thu Jun 30 13:21:24 2011 +0800: 
  anhoa Thu Jun 30 13:21:24 2011 +0800: //////////////////////////////////////////////////////////////////
  anhoa Thu Jun 30 13:21:24 2011 +0800: // <NEW> PRIMITIVE FUNCTIONS
  anhoa Thu Jun 30 13:21:24 2011 +0800: //////////////////////////////////////////////////////////////////
        Wed Jun 08 09:10:46 2011 +0800: 
vuanhoa Mon Oct 31 11:08:48 2011 +0800: int array_get_elm_at___1d(int[] a, int i) 
  anhoa Wed Oct 05 11:28:17 2011 +0800:   /* requires [ahalb,ahaub]
 chinwn Wed Oct 05 07:03:44 2011 +0800: 				dom(a,ahalb,ahaub) 
 chinwn Wed Oct 05 07:03:44 2011 +0800: 				& ahalb <= i 
 chinwn Wed Oct 05 07:03:44 2011 +0800: 				& i <= ahaub
 chinwn Wed Oct 05 07:03:44 2011 +0800:   ensures true;
 chinwn Wed Oct 05 07:03:44 2011 +0800:   requires true
 chinwn Wed Oct 05 07:03:44 2011 +0800:   ensures res = a[i];
  anhoa Wed Oct 05 11:28:17 2011 +0800: 	*/
  anhoa Wed Jul 27 14:10:27 2011 +0800: 	requires [ahalb,ahaub]
  anhoa Wed Jul 27 14:10:27 2011 +0800: 				dom(a,ahalb,ahaub) 
  anhoa Wed Jul 27 14:10:27 2011 +0800: 				& ahalb <= i 
  khanh Tue Feb 28 23:22:46 2012 +0800: 				& i <= ahaub
  anhoa Thu Jun 30 13:21:24 2011 +0800: 	ensures res = a[i];
vuanhoa Wed Nov 09 10:27:25 2011 +0800: 	
vuanhoa Wed Nov 09 10:27:25 2011 +0800: bool array_get_elm_at___1d(bool[] a, int i) 
vuanhoa Wed Nov 09 10:27:25 2011 +0800: 	requires [ahalb,ahaub]
vuanhoa Wed Nov 09 10:27:25 2011 +0800: 				domb(a,ahalb,ahaub) 
vuanhoa Wed Nov 09 10:27:25 2011 +0800: 				& ahalb <= i 
  khanh Tue Feb 28 23:22:46 2012 +0800: 				& i <= ahaub
vuanhoa Wed Nov 09 10:27:25 2011 +0800: 	ensures res = a[i];
 chinwn Wed Oct 05 07:03:44 2011 +0800: 
vuanhoa Mon Oct 31 08:49:55 2011 +0800: // 2D array access
vuanhoa Mon Oct 31 08:49:55 2011 +0800: int array_get_elm_at___2d(int[,] a, int i, int j) 
  khanh Tue Feb 28 23:22:46 2012 +0800: 	requires true
vuanhoa Mon Oct 31 08:49:55 2011 +0800: 	ensures res = a[i,j];
  khanh Thu Nov 10 16:50:17 2011 +0800: 
  khanh Thu Nov 10 16:50:17 2011 +0800: /* ************ */
  khanh Thu Nov 10 16:50:17 2011 +0800: /* Concurrency  */
  khanh Thu Nov 10 16:50:17 2011 +0800: /* ************ */
  khanh Sat Dec 03 17:56:56 2011 +0800: /* data tid{ */
  khanh Sat Dec 03 17:56:56 2011 +0800: /* } */
  khanh Thu Nov 10 16:50:17 2011 +0800: 
  khanh Wed Feb 12 11:17:04 2014 +0800: //thread object, carrying resources
  khanh Wed Feb 12 11:17:04 2014 +0800: data thrd{
  khanh Wed Feb 12 11:17:04 2014 +0800: }
  khanh Wed Feb 12 11:17:04 2014 +0800: 
  khanh Wed Apr 03 15:47:05 2013 +0800: data barrier{
  khanh Wed Apr 03 15:47:05 2013 +0800:   int phase;
  khanh Wed Apr 03 15:47:05 2013 +0800: }
  khanh Wed Apr 03 15:47:05 2013 +0800: 
  khanh Thu Oct 11 20:34:37 2012 +0800: data lock{
  khanh Thu Oct 11 20:34:37 2012 +0800: }
  khanh Thu Oct 11 20:34:37 2012 +0800: 
        Tue Mar 06 20:57:47 2012 +0800: int fork()
        Tue Mar 06 20:57:47 2012 +0800:   requires true
        Tue Mar 06 20:57:47 2012 +0800:   ensures true;
  khanh Thu Nov 10 16:50:17 2011 +0800: 
  khanh Mon Feb 24 14:51:25 2014 +0800: void join()
        Tue Mar 06 20:57:47 2012 +0800:   requires true
        Tue Mar 06 20:57:47 2012 +0800:   ensures true;
  khanh Fri Nov 18 20:04:05 2011 +0800: 
        Tue Mar 06 20:57:47 2012 +0800: void init()
        Tue Mar 06 20:57:47 2012 +0800:   requires true
        Tue Mar 06 20:57:47 2012 +0800:   ensures true;
  khanh Sun Jan 08 16:15:58 2012 +0800: 
        Tue Mar 06 20:57:47 2012 +0800: void finalize()
        Tue Mar 06 20:57:47 2012 +0800:   requires true
        Tue Mar 06 20:57:47 2012 +0800:   ensures true;
  khanh Sun Jan 08 16:15:58 2012 +0800: 
        Tue Mar 06 20:57:47 2012 +0800: void acquire()
        Tue Mar 06 20:57:47 2012 +0800:   requires true
        Tue Mar 06 20:57:47 2012 +0800:   ensures true;
  khanh Sun Jan 08 16:15:58 2012 +0800: 
        Tue Mar 06 20:57:47 2012 +0800: void release()
        Tue Mar 06 20:57:47 2012 +0800:   requires true
        Tue Mar 06 20:57:47 2012 +0800:   ensures true;
  khanh Sun Jan 08 16:15:58 2012 +0800: 
  khanh Sun Jan 08 16:15:58 2012 +0800: 
  khanh Fri Nov 18 20:04:05 2011 +0800: /* ************ */
  khanh Fri Nov 18 20:04:05 2011 +0800: /* Concurrency  */
  khanh Fri Nov 18 20:04:05 2011 +0800: /* ************ */
  khanh Fri Nov 18 20:04:05 2011 +0800: 
  khanh Sun Apr 01 14:29:29 2012 +0800: 
  khanh Sun Apr 01 14:29:29 2012 +0800: /* ********>>>*************/
  khanh Sun Apr 01 14:29:29 2012 +0800: /* Pointer translation  */
  khanh Sun Apr 01 14:29:29 2012 +0800: /* ************************/
  khanh Mon Apr 02 17:23:07 2012 +0800: data int_ptr{
  khanh Sun Apr 01 14:29:29 2012 +0800:   int val;
  khanh Sun Apr 01 14:29:29 2012 +0800: }
  khanh Sun Apr 01 14:29:29 2012 +0800: 
  khanh Mon Apr 02 17:23:07 2012 +0800: data int_ptr_ptr{
  khanh Mon Apr 02 17:23:07 2012 +0800:   int_ptr val;
  khanh Mon Apr 02 17:23:07 2012 +0800: }
  khanh Mon Apr 02 17:23:07 2012 +0800: 
  locle Sun Oct 27 16:18:26 2013 +0800: void delete_ptr(int_ptr@R x)
  khanh Mon Dec 31 16:03:21 2012 +0800:   requires x::int_ptr<v>
  khanh Sun Apr 01 14:29:29 2012 +0800:   ensures true;
  khanh Mon Apr 02 17:23:07 2012 +0800: 
  locle Sun Oct 27 16:18:26 2013 +0800: void delete_ptr(int_ptr_ptr@R x)
  khanh Mon Dec 31 16:03:21 2012 +0800:   requires x::int_ptr_ptr<v>
  khanh Mon Apr 02 17:23:07 2012 +0800:   ensures true;
  khanh Mon Apr 02 17:23:07 2012 +0800: 
  khanh Sun Apr 01 14:29:29 2012 +0800: /* ********<<<*************/
  khanh Sun Apr 01 14:29:29 2012 +0800: /* Pointer translation  */
  khanh Sun Apr 01 14:29:29 2012 +0800: /* ************************/
  khanh Sun Apr 01 14:29:29 2012 +0800: 
vuanhoa Mon Oct 31 11:08:48 2011 +0800: int[] update___1d(int v, int[] a, int i)
 chinwn Wed Oct 05 07:03:44 2011 +0800: //void update___(ref int[] a, int i, int v) 
  anhoa Wed Oct 05 11:28:17 2011 +0800: 	/* requires [ahalb,ahaub]
 chinwn Wed Oct 05 01:05:53 2011 +0800: 				dom(a,ahalb,ahaub) 
 chinwn Wed Oct 05 01:05:53 2011 +0800: 				& ahalb <= i 
 chinwn Wed Oct 05 01:05:53 2011 +0800: 				& i <= ahaub
 chinwn Wed Oct 05 07:03:44 2011 +0800:      ensures dom(res,ahalb,ahaub);//'
 chinwn Wed Oct 05 07:03:44 2011 +0800:      requires true
  anhoa Wed Oct 05 11:28:17 2011 +0800: 	 ensures  update_array(a,i,v,res);//' 
  anhoa Wed Oct 05 11:28:17 2011 +0800: 	*/
 chinwn Wed Oct 05 07:03:44 2011 +0800:      /* requires [s,b,low,high] bnd(a,s,b,low,high) & s<=i<=b & low<=v<=high */
 chinwn Wed Oct 05 07:03:44 2011 +0800:      /* ensures bnd(res,s,b,low,high); */
  anhoa Wed Oct 05 11:28:17 2011 +0800: 	requires [ahalb,ahaub]
  anhoa Wed Jul 27 14:10:27 2011 +0800: 				dom(a,ahalb,ahaub) 
  anhoa Wed Jul 27 14:10:27 2011 +0800: 				& ahalb <= i 
  khanh Tue Feb 28 23:22:46 2012 +0800: 				& i <= ahaub
  anhoa Wed Jul 27 14:10:27 2011 +0800: 	ensures dom(res,ahalb,ahaub) 
vuanhoa Mon Oct 31 11:08:48 2011 +0800: 				& update_array_1d(a,res,v,i);
vuanhoa Wed Nov 09 10:27:25 2011 +0800: 				
vuanhoa Wed Nov 09 10:27:25 2011 +0800: 				
vuanhoa Wed Nov 09 10:27:25 2011 +0800: bool[] update___1d(bool v, bool[] a, int i)
  khanh Tue Feb 28 23:22:46 2012 +0800: 	requires [ahalb,ahaub] domb(a,ahalb,ahaub) & ahalb <= i & i <= ahaub
vuanhoa Wed Nov 09 10:27:25 2011 +0800: 	ensures domb(res,ahalb,ahaub) & update_array_1d_b(a,res,v,i);
  anhoa Wed Oct 05 11:28:17 2011 +0800: 
vuanhoa Mon Oct 31 08:49:55 2011 +0800: int[,] update___2d(int v, int[,] a, int i, int j)
  khanh Tue Feb 28 23:22:46 2012 +0800: 	requires true
vuanhoa Mon Oct 31 11:08:48 2011 +0800: 	ensures update_array_2d(a,res,v,i,j);
  anhoa Thu Jun 30 13:21:24 2011 +0800: 
  anhoa Thu Jun 30 13:21:24 2011 +0800: int[] aalloc___(int dim) 
  khanh Tue Feb 28 23:22:46 2012 +0800: 	requires true 
  anhoa Thu Jun 30 13:21:24 2011 +0800: 	ensures dom(res,0,dim-1);
  anhoa Thu Jun 30 13:21:24 2011 +0800: 
trungtq Wed Oct 30 16:28:29 2013 +0800: pred_prim memLoc<heap:bool,size:int>
trungtq Wed Oct 30 16:28:29 2013 +0800:   inv size>0;
trungtq Wed Oct 30 16:28:29 2013 +0800: 
  locle Wed Jan 02 12:58:27 2013 +0800:                                   ///////////////
  locle Wed Jan 02 12:58:27 2013 +0800:                                   /*
  locle Sat Dec 15 22:24:18 2012 +0800: pred_prim RS_mem<i:int>
  locle Sat Dec 15 22:24:18 2012 +0800:  inv i>0 & self!=null;
        Tue Dec 11 11:02:09 2012 +0800: 
  locle Sat Dec 15 22:24:18 2012 +0800: RS_mem malloc(int n)
  locle Sat Dec 15 22:24:18 2012 +0800:  requires n>0
  locle Sat Dec 15 22:24:18 2012 +0800:  ensures  res=null or res::RS_mem<n>;
        Tue Dec 11 11:02:09 2012 +0800: 
  locle Wed Jan 02 13:19:17 2013 +0800: RS_mem malloc(int n)
  locle Wed Jan 02 13:19:17 2013 +0800:  requires n>0
  locle Wed Jan 02 13:19:17 2013 +0800:  ensures  res=null or res::RS_mem<n>;
  locle Wed Jan 02 13:19:17 2013 +0800: 
  locle Sat Dec 15 22:24:18 2012 +0800: item cast_to_ptr(RS_mem p)
  locle Sat Dec 15 22:24:18 2012 +0800:  case {
  locle Sat Dec 15 22:24:18 2012 +0800:   p=null -> ensures res=null;
  locle Sat Dec 15 22:24:18 2012 +0800:   p!=null -> 
  locle Sat Dec 15 22:24:18 2012 +0800:     requires p::RS_mem<a> & a>=size(item)
  locle Sat Dec 15 22:24:18 2012 +0800:     ensures res::item<_>
  locle Sat Dec 15 22:24:18 2012 +0800:  }
 bachle Wed Dec 12 13:58:28 2012 +0800: 
  locle Wed Jan 02 12:58:27 2013 +0800: item cast_to_ptr(RS_mem p)
  locle Wed Jan 02 12:58:27 2013 +0800:  case {
  locle Wed Jan 02 12:58:27 2013 +0800:   p=null -> ensures res=null;
  locle Wed Jan 02 12:58:27 2013 +0800:   p!=null -> 
  locle Wed Jan 02 12:58:27 2013 +0800:     requires p::RS_mem<a> //& a>=size(item)
  locle Wed Jan 02 12:58:27 2013 +0800:     ensures res::item<_>;
  locle Wed Jan 02 12:58:27 2013 +0800:  }
  locle Wed Jan 02 12:58:27 2013 +0800:                                   */
  anhoa Thu Jun 30 13:21:24 2011 +0800: //////////////////////////////////////////////////////////////////
  anhoa Thu Jun 30 13:21:24 2011 +0800: //////////////////////////////////////////////////////////////////
trungtq Sat Feb 02 20:34:59 2013 +0800: 
trungtq Mon Feb 04 21:04:01 2013 +0800: /*
trungtq Sat Feb 02 20:34:59 2013 +0800: data memory {
trungtq Sat Feb 02 20:34:59 2013 +0800:   int size;
trungtq Sat Feb 02 20:34:59 2013 +0800: }
trungtq Sat Feb 02 20:34:59 2013 +0800: 
trungtq Sat Feb 02 20:34:59 2013 +0800: memory malloc(int size)
trungtq Sat Feb 02 20:34:59 2013 +0800:   requires size>0
trungtq Sat Feb 02 20:34:59 2013 +0800:   ensures  res=null or res::memory<size>;
trungtq Mon Feb 04 21:04:01 2013 +0800: */
trungtq Mon Feb 04 02:10:08 2013 +0800: 
trungtq Tue Feb 05 15:09:14 2013 +0800: /*
trungtq Mon Feb 04 21:04:01 2013 +0800: pred_prim RS_mem<i:int>
trungtq Mon Feb 04 21:04:01 2013 +0800:  inv i>0 & self!=null;
trungtq Mon Feb 04 02:10:08 2013 +0800: 
trungtq Mon Feb 04 21:04:01 2013 +0800: RS_mem malloc1(int n)
trungtq Mon Feb 04 21:04:01 2013 +0800:  requires n>0
trungtq Mon Feb 04 21:04:01 2013 +0800:  ensures  res=null or res::RS_mem<n>;
trungtq Tue Feb 05 15:09:14 2013 +0800: */
  khanh Wed Jul 23 16:16:31 2014 +0800: 
  khanh Wed Jul 23 17:04:53 2014 +0800: pred_prim WAIT<b:bag((Object,Object))>;
  khanh Sat Aug 02 16:56:18 2014 +0800: pred_prim WAITS<G:bag((Object,Object)), S:bag(Object), d:Object>;
  khanh Sat Aug 02 16:56:18 2014 +0800: 
  khanh Sat Aug 02 16:56:18 2014 +0800: relation set_comp(bag((Object,Object)) g, bag(Object) S, Object d).
  khanh Sat Aug 02 16:56:18 2014 +0800: relation concrete(bag(Object) g).
  khanh Fri Jul 25 16:03:27 2014 +0800: relation cyclic(bag((Object,Object)) g).
  khanh Fri Jul 25 16:03:27 2014 +0800: relation acyclic(bag((Object,Object)) g).
  khanh Wed Jul 30 18:24:24 2014 +0800: relation waitS(bag((Object,Object)) g, bag(Object) S, Object d).
 chinwn Thu Sep 11 01:48:50 2014 +0800: 
chanhle Mon Apr 07 22:09:23 2014 +0800: int rand_int ()
chanhle Thu Oct 09 15:17:15 2014 +0800:   requires true
chanhle Thu Oct 09 15:17:15 2014 +0800:   ensures true;
chanhle Mon Apr 07 22:09:23 2014 +0800: 
chanhle Mon Apr 07 22:09:23 2014 +0800: bool rand_bool ()
chanhle Thu Oct 09 15:17:15 2014 +0800:   requires true
chanhle Thu Oct 09 15:17:15 2014 +0800:   ensures res or !res;
