=============================================================
# tail-1.ss

Inferred pre is incorrect.

!!! >>>>>> HIP gather infer pre <<<<<<
!!! Inferred Heap :[]
!!! Inferred Pure :[ ann1<=2]

However, --en-sleek-logging-txt gave the correct result:

  es_infer_pure: [ann1<=0; ann1<=2]

Thus hip is not working correctly for this example!

 id: 5; caller: []; line: 12; classic: false; kind: POST; hec_num: 4; evars: []; c_heap: c::node<a,b>@ann1[Orig]
 checkentail emp&ann1<=2 & b=v_node_20_776' & res=v_node_20_776' & a=a_32 & b=b_33 & 
ann1<=0&{FLOW,(22,23)=__norm}[]
 |-  emp&b=res & a=a_32 & b=b_33&{FLOW,(22,23)=__norm}[]. 
res:  [
  emp&ann1<=2 & b=v_node_20_776' & res=v_node_20_776' & a=a_32 & b=b_33 & ann1<=0&{FLOW,(22,23)=__norm}[]
  es_infer_vars/rel: [ann1]
  es_infer_pure: [ann1<=0; ann1<=2]
  ]
*/
=============================================================
# imm/pre.ss

void foo(int n)
 infer [n] requires true ensures n>5;
{
  n=n+2;
  test(n);
}

void test(int n)
 requires n>1 ensures true;

WHY only below:

!!! Inferred Pure :[ 0<=n]

However sleek-logging gives:
  es_infer_pure: [6<=n; 0<=n]
It seems that we did not take into account
the proving of post-condition.

 id: 4; caller: []; line: 4; classic: false; kind: POST; hec_num: 2; evars: []; c_heap: emp
 checkentail emp&n=n_758 & 0<=n&{FLOW,(22,23)=__norm}[]
 |-  emp&5<n&{FLOW,(22,23)=__norm}[]. 
res:  [
  emp&n=n_758 & 0<=n & 6<=n&{FLOW,(22,23)=__norm}[]
  es_infer_vars/rel: [n]
  es_infer_pure: [6<=n; 0<=n]
  ]


*/
=============================================================
# imm/ll-lend-1.ss --field-ann

ll<n,a> == self=null & n=0 or
  self::node<_@a,q>*q::ll<n-1,a>
  inv n>=0;

int length(node p)
  requires p::ll<n,@L>
  ensures p::ll<n,@L> & res=n;

Above should flag an error since @L is present
in the post-condition.

=============================================================
# imm/ll-lend-b.ss --field-ann (solved in ann_1)

ll<n,a1,a2> == self=null & n=0 or
  self::node<_@a1,q@a2>*q::ll<n-1,a1,a2>
  inv n>=0;

int length(node p)
  requires p::ll<n,@M,@A>
  ensures p::ll<n,@M,@A> & res=n;

This currently succeeds but is actually
unsound since we need read permission on p.next
=============================================================
!!FIXED!!
# ll-lend-b.slk --field-ann 

Below should fail.

checkentail p::ll_ann<n,@M,@A> & n>0 |- p::node<_,_@L>.
  // why this succeed?

checkentail p::ll_ann<n,@A,@M> & n>0 |- p::node<_@L,_@M>.
  // why this succeed?
=============================================================
# imm/ll-lend-b.ss --field-ann

int length(node p)
/*
  requires p::ll_ann<n,@A,@L>
  ensures p::ll_ann<n,@A,@A> & res=n;
  requires p::ll_ann<n,@A,@L>
  ensures res=n;
*/
  requires p::ll_ann<n,@A,@L>
  ensures p::ll_ann<n,@A,@L> & res=n;
// should fail due to @L in post-condition
=============================================================
checkentail x::node<_@A>|- x::node<_@L>.

change "Fail.(must) cause: mismatched annotation" with it's actual reason
=============================================================
normalize the residue for:

checkentail x::node<_@v> & v=@A|- true.
<1>x::node<Anon_11@v>@M&0<=v & v=@A&{FLOW,(21,22)=__norm}

====> <1>x::node<Anon_11@A>@M & 0<=v & v=@A & {FLOW,(21,22)=__norm}
=============================================================
# ll-lend-c1.ss

ll<n> == self=null & n=0 or
  self::node<_@A,q@L>*q::ll<n-1>
  inv n>=0;

int length(node p)
  requires p::ll<n>
  ensures p::ll<n> & res=n;
// should fail due to @L in ll<n> post-condition
=============================================================
#sleek0222.slk

residue should eliminate unnecessary exists:
Entail 1: Valid. 

 <1>(exists flted_30_63,flted_30_62,flted_30_61: x::node<p@[@M, @flted_30_63],q@A>@M&flted_30_62=@M & flted_30_61=@M & 2<n & a_66=p & q=q_67 & exists(flted_30_64:flted_30_62=flted_30_64 & @M<:flted_30_64 & @M<:flted_30_64) & exists(flted_30_63:0<=flted_30_63 & flted_30_61=flted_30_63 & @M<:flted_30_63 & @M<:flted_30_63) & exists(flted_30_65:flted_30_65=n+1)&{FLOW,(21,22)=__norm})[]
[[ SEARCH ==>  Fold ==>  Match ==>  COND ==>  Match ==> ]]
=============================================================
unsoud imm without setting  simpl_memset,
due to the fact that h_formula_2_mem detects false on ante 
when encounters * between nodes with disjoint fileds.
eg:
x::node<x@M,x@[@v]> * x::node<x@A,x@A>

=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
