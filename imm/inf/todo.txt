# lend-1.slk --print-type (DONE)

Can you change integer formula back to annotation
formula at Omega.ml. See trans_bool method which
converts b>=1 to b and b<=0 to !b for boolean.

infer [v] p::pair<f,s>@v |- p::pair<a,b>.

GOT: 
Entail (1) : Valid. 
 <1>emp&a:int=f:int & b:int=s:int & v:AnnT<=0&{FLOW,(21,22)=__norm}[]
 inferred pure: [v:AnnT<=0]
[[ SEARCH ==>  Match(p:pair,p:pair) ==> ]]


Expects:
Entail (1) : Valid. 
 <1>emp&v:AnnT<:@M&{FLOW,(21,22)=__norm}[]
 inferred pure: [v:AnnT<:@M]
[[ SEARCH ==>  Match(p:pair,p:pair) ==> ]]
=======================================================
# lend-2.slk --print-type (DONE)

Need to introduce a new type "ann" for annotation?

ERROR: at lend-2.slk_7:42_7:43 
Message: gather_type_info_var : unexpected exception Failure("UNIFICATION ERROR : at location {(7,42),(7,43)} types AnnT and int are inconsistent")
 gather_type_info_b_formula: relation R
Starting z3... 

Why is there an inferred "true"?

Entail (1) : Valid. 
 <1>q::celly<flted_7_16>@w&flted_7_16=2 & R(v,w) & a=f & Anon_11=flted_7_16 & v<=0 & w<=2&{FLOW,(21,22)=__norm}[]
 inferred pure: [true]
 inferred rel: [RELASS [R]: ( R(v,w)) -->  v<=0 & w<=2]
[[ COND ==>  SEARCH ==>  Match(p,p) ==>  SEARCH ==>  Match(q,q) ==> ]]

=======================================================
# lend-3.slk --print-type (IGNORE)

Maybe @imm should be used only for HIP..

infer [@imm] p::cell<f>@v * q::cell<2>@w & R(v,w) 
  |- p::cell<a> * q::cell<_>@L.
print residue.

@imm should pick up all relations with @ann parameters
for inference; where needed. 

Priority to relations, and then variables.

 error: Stream.Error("[infer_type] or [id_list] or CSQUARE expected after OSQUARE (in [id_list_w_itype])")
 at:(Program not linked with -g, cannot print stack backtrace)
=======================================================
# lend-3a.slk --pcp (DONE)

//relation R(int v,int w).
relation R(int v,
   ann w).

Why is the R relation not being printed
by --pcp
=======================================================
# cell-3b.ss

[RELASS [P1]: ( P1(a)) -->  a=@M,
RELDEFN P2: ( b=@M) -->  P2(b)]

 c::cell<v>@a & P1(a) |- c::cell<_>

     P1(a) --> a<:M

 c::cell<v>@a & a<:M |- c::cell<_>@b & P2(b)

     b<:@M -> P2(b)

*************************************
Two problems:
 (1) why numeric for fixcalc?
 (2) Why false for PRE?

*************************************
*******fixcalc of pure relation *******
*************************************
[( P2(b), b=0, P1(a), false)]
*************************************

!!!REL POST :  P2(b)
!!!POST:  b=0
!!!REL PRE :  P1(a)
!!!PRE :  false

*************************************
*******fixcalc of pure relation *******
*************************************
[( P2(b), b=0, P1(a), false)]

=======================================================
# cell-3c.ss

Why is there a check 1 fail?

Checking procedure foo$cell... check 1 fail

!!! >>>>>> HIP gather infer pre <<<<<<
!!!Inferred Heap: []
!!!Inferred Pure: [ true]
Procedure foo$cell SUCCESS.
Stop Omega... 18 invocations 
0 false contexts at: ()

c::cell<v>@a & P1(a) |- c::cell<w>@L

=======================================================
# cell-3c1.slk

infer [P1,P2] 
c::cell<v>@a & P1(a)  & a<:@L 
        |- c::cell<w>@b & P2(b).
print residue.

                              
Why false?
Why a>2?


Entail (2) : Valid. 
 <1>hfalse&false&{FLOW,(21,22)=__norm}[]
 inferred rel: [RELASS [P1]: ( P1(a)) -->  a>2]
[[empty]]
=======================================================
# cell-2.ss

int foo(cell c)
  infer [P1]
  requires c::cell<v>@a & P1(a,b) 
  ensures c::cell<v>@b & v=res;
{
  return c.fst;
}

GOT
===
[RELASS [P1]: ( P1(a,b)) -->  a<:@L]

Post Inference result:
foo$cell
 EBase exists (Expl)[](Impl)[a; v](ex)[]c::cell<v>@L&a<:@L & MayLoop[]&
       {FLOW,(4,5)=__norm#E}[]
         EAssume 
           (exists v_1460: emp&v=res & v_1460=v&{FLOW,(4,5)=__norm#E}[]

# Why b is free?
# What happen to Cell in post

!!!WARNING : uninterpreted free variables [b] in specification.
Checking procedure foo$cell... check 1 fail
=======================================================
# ex4.slk

Verification works but inference fails for ex4a.slk

infer [@field_imm] p::pair<f,s@L> |- p::pair<a,b@M>.
print residue.
expect Fail.

infer [@field_imm] p::pair<f,s@M> |- p::pair<a,b@L>.
print residue.
expect Valid.

# ex4a.slk

infer [@field_imm,a] p::pair<f,s@a> |- p::pair<a,b@L>.
print residue.

Need to fix type error

ERROR: at ex4a-infer-field-imm.slk_6:47_6:48
Message: UNIFICATION ERROR : at location {(Line:6,Col:47),(Line:6,Col:48)} types
 int and AnnT are inconsistent

=======================================================
# ex4c4

infer [@field_imm] p::cell<s@x> |- p::cell<b@L>.
infer [@field_imm] p::pair<_,s@x> |- p::pair<_,b@L>.

Why did the cell fails as expected 
but not pair?

(==solver.ml#7525==)
heap_entail_empty_rhs_heap#1@2@1
heap_entail_empty_rhs_heap#1 inp1 : p::cell<s@[@x]>&b=s&{FLOW,(4,5)=__norm#E}[]
 // missing? es_heap: p::pair<Anon_12,s@A>
 es_infer_obj: [@field_imm]
 es_trace:  SEARCH ==>  Match(p,p) ==> 
 es_infer_vars_rel: []
 es_unsat_flag: false
heap_entail_empty_rhs_heap#1 inp2 : p::cell<s@[@x]>&b=s&{FLOW,(4,5)=__norm#E}[]
heap_entail_empty_rhs_heap#1 inp3 : x<:@L
heap_entail_empty_rhs_heap#1 inp4 :false
heap_entail_empty_rhs_heap#1@2 EXIT: 
MaybeErr Context: 
                   fe_kind: MAY
                   fe_name: logical bug
                   fe_locs: {
                             fc_message:  true |-  x<:@L. LOCS:[0] (may-bug)
   

(==solver.ml#7525==)
heap_entail_empty_rhs_heap#1@4@3
heap_entail_empty_rhs_heap#1 inp1 : p::pair<Anon_28@A,s@[@x]>&Anon_13=Anon_12 & 
b=s&{FLOW,(4,5)=__norm#E}[]
 es_heap: p::pair<Anon_12,s@A>
 es_infer_obj: [@field_imm]
 es_trace:  SEARCH ==>  Match(p,p) ==> 
 es_infer_vars_rel: []
 es_unsat_flag: false
heap_entail_empty_rhs_heap#1 inp2 : p::pair<Anon_28@A,s@[@x]>&Anon_13=Anon_12 & b=s&{FLOW,(4,5)=__norm#E}[]
heap_entail_empty_rhs_heap#1 inp3 : x<:@L
heap_entail_empty_rhs_heap#1 inp4 :false
heap_entail_empty_rhs_heap#1@4 EXIT: [
  p::pair<Anon_28@A,s@[@x]>&Anon_13=Anon_12 & b=s&{FLOW,(4,5)=__norm#E}[]
  ]
=======================================================
#  ex4c5.slk -debug x.log

infer [@field_imm] p::pair<_,s@x> |- p::pair<_,b@L>.

Need to trace how unsound "false" appear below

**solver.ml#8096:diff_flag:false
@1! **solver.ml#8097:super_smart_xpure:false
@1! **solver.ml#8103:xpure_lhs_h1(bef merge): false
@1! **solver.ml#8107:xpure_lhs_h1: false
@1! **solver.ml#8130:xpure_lhs_h1: false
@1! **solver.ml#8131:xpure_lhs_h0_sym (wo pure): false
@1! **solver.ml#8132:xpure_lhs_h1_sym (wo pure): false
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
