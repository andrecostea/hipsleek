# lend-1.slk --print-type (DONE)

Can you change integer formula back to annotation
formula at Omega.ml. See trans_bool method which
converts b>=1 to b and b<=0 to !b for boolean.

infer [v] p::pair<f,s>@v |- p::pair<a,b>.

GOT: 
Entail (1) : Valid. 
 <1>emp&a:int=f:int & b:int=s:int & v:AnnT<=0&{FLOW,(21,22)=__norm}[]
 inferred pure: [v:AnnT<=0]
[[ SEARCH ==>  Match(p:pair,p:pair) ==> ]]


Expects:
Entail (1) : Valid. 
 <1>emp&v:AnnT<:@M&{FLOW,(21,22)=__norm}[]
 inferred pure: [v:AnnT<:@M]
[[ SEARCH ==>  Match(p:pair,p:pair) ==> ]]
=======================================================
# lend-2.slk --print-type (DONE)

Need to introduce a new type "ann" for annotation?

ERROR: at lend-2.slk_7:42_7:43 
Message: gather_type_info_var : unexpected exception Failure("UNIFICATION ERROR : at location {(7,42),(7,43)} types AnnT and int are inconsistent")
 gather_type_info_b_formula: relation R
Starting z3... 

Why is there an inferred "true"?

Entail (1) : Valid. 
 <1>q::celly<flted_7_16>@w&flted_7_16=2 & R(v,w) & a=f & Anon_11=flted_7_16 & v<=0 & w<=2&{FLOW,(21,22)=__norm}[]
 inferred pure: [true]
 inferred rel: [RELASS [R]: ( R(v,w)) -->  v<=0 & w<=2]
[[ COND ==>  SEARCH ==>  Match(p,p) ==>  SEARCH ==>  Match(q,q) ==> ]]

=======================================================
# lend-3.slk --print-type (IGNORE)

Maybe @imm should be used only for HIP..

infer [@imm] p::cell<f>@v * q::cell<2>@w & R(v,w) 
  |- p::cell<a> * q::cell<_>@L.
print residue.

@imm should pick up all relations with @ann parameters
for inference; where needed. 

Priority to relations, and then variables.

 error: Stream.Error("[infer_type] or [id_list] or CSQUARE expected after OSQUARE (in [id_list_w_itype])")
 at:(Program not linked with -g, cannot print stack backtrace)
=======================================================
# lend-3a.slk --pcp (DONE)

//relation R(int v,int w).
relation R(int v,
   ann w).

Why is the R relation not being printed
by --pcp
=======================================================
# cell-3b.ss  (DONE)

[RELASS [P1]: ( P1(a)) -->  a=@M,
RELDEFN P2: ( b=@M) -->  P2(b)]

 c::cell<v>@a & P1(a) |- c::cell<_>

     P1(a) --> a<:M

 c::cell<v>@a & a<:M |- c::cell<_>@b & P2(b)

     b<:@M -> P2(b)

*************************************
Two problems:
 (1) why numeric for fixcalc?
 (2) Why false for PRE?

*************************************
*******fixcalc of pure relation *******
*************************************
[( P2(b), b=0, P1(a), false)]
*************************************

!!!REL POST :  P2(b)
!!!POST:  b=0
!!!REL PRE :  P1(a)
!!!PRE :  false

*************************************
*******fixcalc of pure relation *******
*************************************
[( P2(b), b=0, P1(a), false)]

=======================================================
# cell-3c.ss (DONE)

Why is there a check 1 fail?

Checking procedure foo$cell... check 1 fail

!!! >>>>>> HIP gather infer pre <<<<<<
!!!Inferred Heap: []
!!!Inferred Pure: [ true]
Procedure foo$cell SUCCESS.
Stop Omega... 18 invocations 
0 false contexts at: ()

c::cell<v>@a & P1(a) |- c::cell<w>@L

=======================================================
# cell-3c1.slk

infer [P1,P2] 
c::cell<v>@a & P1(a)  & a<:@L 
        |- c::cell<w>@b & P2(b).
print residue.

                              
Why false?
Why a>2?


Entail (2) : Valid. 
 <1>hfalse&false&{FLOW,(21,22)=__norm}[]
 inferred rel: [RELASS [P1]: ( P1(a)) -->  a>2]
[[empty]]
=======================================================
# cell-2.ss  (DONE)

int foo(cell c)
  infer [P1]
  requires c::cell<v>@a & P1(a,b) 
  ensures c::cell<v>@b & v=res;
{
  return c.fst;
}

GOT
===
[RELASS [P1]: ( P1(a,b)) -->  a<:@L]

Post Inference result:
foo$cell
 EBase exists (Expl)[](Impl)[a; v](ex)[]c::cell<v>@L&a<:@L & MayLoop[]&
       {FLOW,(4,5)=__norm#E}[]
         EAssume 
           (exists v_1460: emp&v=res & v_1460=v&{FLOW,(4,5)=__norm#E}[]

# Why b is free?
# What happen to Cell in post

!!!WARNING : uninterpreted free variables [b] in specification.
Checking procedure foo$cell... check 1 fail
=======================================================
# ex4.slk

Verification works but inference fails for ex4a.slk

infer [@field_imm] p::pair<f,s@L> |- p::pair<a,b@M>.
print residue.
expect Fail.

infer [@field_imm] p::pair<f,s@M> |- p::pair<a,b@L>.
print residue.
expect Valid.

# ex4a.slk

infer [@field_imm,a] p::pair<f,s@a> |- p::pair<a,b@L>.
print residue.

Need to fix type error

ERROR: at ex4a-infer-field-imm.slk_6:47_6:48
Message: UNIFICATION ERROR : at location {(Line:6,Col:47),(Line:6,Col:48)} types
 int and AnnT are inconsistent

=======================================================
# ex4c4

infer [@field_imm] p::cell<s@x> |- p::cell<b@L>.
infer [@field_imm] p::pair<_,s@x> |- p::pair<_,b@L>.

Why did the cell fails as expected 
but not pair?

(==solver.ml#7525==)
heap_entail_empty_rhs_heap#1@2@1
heap_entail_empty_rhs_heap#1 inp1 : p::cell<s@[@x]>&b=s&{FLOW,(4,5)=__norm#E}[]
 // missing? es_heap: p::pair<Anon_12,s@A>
 es_infer_obj: [@field_imm]
 es_trace:  SEARCH ==>  Match(p,p) ==> 
 es_infer_vars_rel: []
 es_unsat_flag: false
heap_entail_empty_rhs_heap#1 inp2 : p::cell<s@[@x]>&b=s&{FLOW,(4,5)=__norm#E}[]
heap_entail_empty_rhs_heap#1 inp3 : x<:@L
heap_entail_empty_rhs_heap#1 inp4 :false
heap_entail_empty_rhs_heap#1@2 EXIT: 
MaybeErr Context: 
                   fe_kind: MAY
                   fe_name: logical bug
                   fe_locs: {
                             fc_message:  true |-  x<:@L. LOCS:[0] (may-bug)
   

(==solver.ml#7525==)
heap_entail_empty_rhs_heap#1@4@3
heap_entail_empty_rhs_heap#1 inp1 : p::pair<Anon_28@A,s@[@x]>&Anon_13=Anon_12 & 
b=s&{FLOW,(4,5)=__norm#E}[]
 es_heap: p::pair<Anon_12,s@A>
 es_infer_obj: [@field_imm]
 es_trace:  SEARCH ==>  Match(p,p) ==> 
 es_infer_vars_rel: []
 es_unsat_flag: false
heap_entail_empty_rhs_heap#1 inp2 : p::pair<Anon_28@A,s@[@x]>&Anon_13=Anon_12 & b=s&{FLOW,(4,5)=__norm#E}[]
heap_entail_empty_rhs_heap#1 inp3 : x<:@L
heap_entail_empty_rhs_heap#1 inp4 :false
heap_entail_empty_rhs_heap#1@4 EXIT: [
  p::pair<Anon_28@A,s@[@x]>&Anon_13=Anon_12 & b=s&{FLOW,(4,5)=__norm#E}[]
  ]
=======================================================
#  ex4c5.slk -debug x.log (needed --etcsu1 & --en-imm-merge)

infer [@field_imm] p::pair<_,s@x> |- p::pair<_,b@L>.

Need to trace how unsound "false" appear below

**solver.ml#8096:diff_flag:false
@1! **solver.ml#8097:super_smart_xpure:false
@1! **solver.ml#8103:xpure_lhs_h1(bef merge): false
@1! **solver.ml#8107:xpure_lhs_h1: false
@1! **solver.ml#8130:xpure_lhs_h1: false
@1! **solver.ml#8131:xpure_lhs_h0_sym (wo pure): false
@1! **solver.ml#8132:xpure_lhs_h1_sym (wo pure): false
=======================================================
# ex5.slk (OK after changing --etcsu1 and --en-imm-merge with --field-imm

# Normalization is not working here..

infer [@field_imm] p::pair<f,s@A> * p::pair<a@A,2> |- false.

(==astsimp.ml#7717==)
normalize_field_ann_heap_node@5
normalize_field_ann_heap_node inp1 : p::pair<f,s@A> * p::pair<a@A,flted_7_14>
normalize_field_ann_heap_node@5 EXIT:( p::pair<f,s@A> * p::pair<a@A,flted_7_14>,?,?)
=======================================================
# Normalization is not working here..

!!! **cformula.ml#15051:holes1:[]
!!! **cformula.ml#15052:holes2:[]
!!! **cformula.ml#15066:inside combine_param_ann
(==astsimp.ml#7726==)
combine_param_ann@1
combine_param_ann inp1 :[@M,@A]
combine_param_ann inp2 :[@A,@M]
combine_param_ann@1 EXIT:[@M,@A]
[Warning] False ctx
=======================================================
# ex5.slk

infer [@field_imm] p::pair<f,s@A> * p::pair<_,2> |- false.

# Why not return false at this point of heap merging?
# maybe can avoid --etcsu1 if you had done this?
  ("--etcsu1",Arg.Set Globals.simpl_memset,"use the old,complicated memset calculator");
# We should avoid this old calculator since it is likely to be obsolete.
# We should focus on improving the merging operation


(==norm.ml#1054==)
merge_alias_nodes_formula@1
merge_alias_nodes_formula inp1 : p::pair<f,s@A> * p::pair<Anon_12,flted_16_15>&f
lted_16_15=2&
{FLOW,(20,21)=__norm#E}[]
merge_alias_nodes_formula@1 EXIT: p::pair<f,s@A> * p::pair<Anon_12,flted_16_15>&
flted_16_15=2&
{FLOW,(20,21)=__norm#E}[]

infer [] ppp::pair<f,s>@A * ppp::pair<_,2>@I |- s=2.
// fails
// what happen to s=2? where is merge
// when @field_imm is added, it succeeds.

should do a merge rather than a removal 

(==sleekengine.ml#1186==)
remove_imm_from_formula@1
remove_imm_from_formula inp1 : ppp::pair<f,s>@A * ppp::pair<Anon_15,flted_31_48>@I&flted_31_48=2&
{FLOW,(20,21)=__norm#E}[]
remove_imm_from_formula@1 EXIT: (emp) * ppp::pair<Anon_15,flted_31_48>@I&ppp!=null & flted_31_48=2&
{FLOW,(20,21)=__norm#E}[]
=======================================================
# ex5c.slk

infer [] p::pair<f>@I & p::pair<2>@I |- false.

unsound to use xpure_heap_mem_enum when there
is /\ in the formula

(====)
h_formula_2_mem@3@2@1
h_formula_2_mem inp1 : (p::pair<f>@I ; ((p::pair<flted_9_13>@I ; (emp))))
h_formula_2_mem inp2 : flted_9_13=2
h_formula_2_mem inp3 :[]
h_formula_2_mem@3 EXIT: [[p]]

(==cvutil.ml#1713==)
xpure_heap_mem_enum#6@2@1
xpure_heap_mem_enum#6 inp1 : (p::pair<f>@I ; ((p::pair<flted_9_13>@I ; (emp))))
xpure_heap_mem_enum#6 inp2 : flted_9_13=2
xpure_heap_mem_enum#6 inp3 :1
xpure_heap_mem_enum#6@2 EXIT: p=1 & p=2 #  [[p]]

=======================================================
When merging, may I suggest the following..

  @A * v  --> v
  @M * v  --> @M & v<:@A
  @I * v  --> @I & v<:@A
  @L * v  --> @L & v<:@A
  v1 * v2 --> v3 & (v3=v2 & v1<:@A | v3=v1 & v2<:A)

=======================================================
# ex3d7.ss

  infer [P1,P2]
  requires c::cell<v>@a & P1(a)
     ensures c::cell<v>@b & P2(a,b,v,res)  ;


[RELASS [P1]: ( P1(a)) -->  a<:@L,
RELDEFN P2: ( res=v & b_1458=a & a<:@L & P1(a)) -->  P2(a,b_1458,v,res)]

I think it is sufficient to leave it as:
!!! **pi.ml#658:PRE :  a<:@L

But to later transform pre/post from:

 EBase exists (Expl)[](Impl)[a; v](ex)[]c::cell<v>@a&a<:@L & 
       MayLoop[]&{FLOW,(4,5)=__norm#E}[]
         EAssume 
           (exists v_1457,b_1458: c::cell<v_1457>@b_1458&v_1457=v & res=v & 
           b_1458=a & a<:@L&{FLOW,(4,5)=__norm#E}[]

To:

 EBase exists (Expl)[](Impl)[a; v](ex)[]c::cell<v>@L & 
       MayLoop[]&{FLOW,(4,5)=__norm#E}[]
         EAssume 
           (exists v_1457,b_1458: res=v &{FLOW,(4,5)=__norm#E}[]


!!! **pi.ml#611: P2(a,b_1458,v,res) = ( res=v & b_1458=a & a<:@L)Pi.infer_pure

!!! **fixcalc.ml#1392:n_base:2
!!! **pi.ml#625:bottom_up_fp:[( P2(a,v,b_1458,res), res=v & b_1458=a & a<:@L)]
!!! **pi.ml#632:fixpoint:[( P2(a,v,b_1458,res), res=v & b_1458=a & a<:@L, P1(a), a<:@L)]
!!! **pi.ml#655:REL POST :  P2(a,v,b_1458,res)
!!! **pi.ml#656:POST:  res=v & b_1458=a & a<:@L
!!! **pi.ml#657:REL PRE :  P1(a)
!!! **pi.ml#658:PRE :  a=@L
=======================================================
# ex3d7.ss --reverify

  infer [P1,P2]
  requires c::cell<v>@a & P1(a)
     ensures  c::cell<v>@b & P2(a,b,v,res)  ;

The above failed, as follows:

Post condition cannot be derived:
  (must) cause:  @L=@L & @L<:b_1458 & @L=b_1458 |-  b_1458=@A. LOCS:[1;0] (must-bug)

despite inferring:

  requires c::cell<v>@a & a=@L
  ensures c::cell<v>@b & res=v & a=@A  ;

We need below, as highlighted in:

  requires c::cell<v>@L
  ensures c::cell<v>@A & res=v  ;
=======================================================
# ex3d7c.slk (DONE)

checkentail x::cell<a>@L |- x::cell<b>@v & v=@A.
print residue.

Entail 2: Fail.(must) cause: @L=v |-  v=@A. LOCS:[0;9] (must-bug)

Solution : either (i) substitute (ii) use explicit
instantation (iii) post-process
*/

checkentail x::cell<a>@L |- (exists v: x::cell<b>@v & v=@A).
print residue.
/*
Residue:
 <1>x::cell<a>@L&b=a&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  Match(x,x) ==> ]]
=======================================================
# ex3d7e.slk  (DONE)

# remove double annotation as it seems redundant
checkentail x::cell<a>@u & u=@L & v=@A  |- x::cell<b>@v & v=@A.
Residue:
 <1>x::cell<a>@[@u, @ann_f_r_23]&v=@A & u=@L & ann_f_r_23=v & u<:ann_f_r_23 & b=a&{FLOW,(20,21)=__norm#E}[]


# support RHS sensitive instantiation for annotation

checkentail x::cell<a>@u & u=@L  |- x::cell<b>@v & v=@A.
Entail 6: Fail.(must) cause: @L<:v & @L=v |-  v=@A. LOCS:[0;32] (must-bug)

instantiated: u=v which gave a wrong instantiation

# soln : change to instantiate v=@A which is present on the RHS before
proceeding to prove u<:v

=======================================================
# ex3d7g.slk (DONE)

checkentail x::cell<a>@u & u=@L |- x::cell<b>@v & v=@A.
print residue.
// <1>x::cell<a>@[@u, @v]&u=@L & v=@A & b=a&{FLOW,(20,21)=__norm#E}[]
// should normalize to @L (DONE)

//(2)
checkentail x::cell<a>@u & u=@L |- x::cell<b>@v & v=@M.
print residue.
// <1>x::cell<a>@[@u, @v]&u=@L & v=@M & b=a&{FLOW,(20,21)=__norm#E}[]
// should fail

//(3)
checkentail x::cell<a>@u & u=@L |- x::cell<b>@v & v=@L.
print residue.
// <1>x::cell<a>@[@u, @v]&u=@L & v=@L & b=a&{FLOW,(20,21)=__norm#E}[]
// should normalize to @A

//(4)
checkentail x::cell<a>@u & u=@L |- x::cell<b>@v.
print residue.
// <1>x::cell<a>@[@u, @v]&u=@L & u=v & b=a&{FLOW,(20,21)=__norm#E}[]
// inst to v=@L
// better to instantiate to @L
=======================================================
# ex3d7i.slk  (DONE)
//(2)

checkentail x::cell<a>@u & u=@L |- x::cell<b>@v & v=@M.
print residue.
// <1>x::cell<a>@[@u, @v]&u=@L & v=@M & b=a&{FLOW,(20,21)=__norm#E}[]
// should fail

fails for node lvl imm but goes through with --field-imm

=======================================================
to add examples in run-fast-test (DONE)

=======================================================

phases with field-imm broken

=======================================================
ex3d8a.slk

checkentail x::cell<a>@u & u=@M |- (exists v: x::cell<b>@v & v<:@A).
print residue.
expect Valid.

 <1>(exists v_21: x::cell<a>@[@M, @v_21]&u=@M & b=a&{FLOW,(20,21)=__norm#E}[]

  Can we have v_21<:A in the eventual instantiation?

checkentail x::cell<a>@u & u=@M |- (exists v: x::cell<b>@v & v=@M).
print residue.
expect Valid.


 <1>(exists v_33: x::cell<a>@[@M, @v_33]&u=@M & b=a&{FLOW,(20,21)=__norm#E}[]

  Can we have v_33=@M in the instantiation?

=======================================================
# ex9d.slk (FIXED)

checkentail x::cell<_>@u & u=@M  |- x::cell<_>@v .
print residue.
expect Valid.

GOT
Residue:
 <1>x::cell<Anon_21>@[@M, @v]&u=@M & u<:v & Anon_22=Anon_21&{FLOW,(20,21)=__norm#E}[]

It may be better to instantiate to v=@A in such scenario,
and thus allow normalization.
=======================================================
# ex9d.slk

checkentail x::cell<_>@u  |- x::cell<_>@v & v=@L.

Entail 7: Valid. 
Residue:
 <1>x::cell<Anon_23>@u&v=@L & Anon_24=Anon_23&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  Match(x,x) ==> ]]

This is unsound, as we have not yet proven u<:v. I think
after instantiation, we need to add u<:v to the RHS for it to
be proven.
=======================================================
# ex9e.slk

infer[R] x::cell<_>@u & u=@M  |- x::cell<_>@v & R(v).

GOT:
---
Residue:
 <1>x::cell<Anon_11>@[@M, @v]&u=@M & u<:v & Anon_12=Anon_11&{FLOW,(20,21)=__norm#E}[]
 inferred rel: [RELDEFN R: ( true) -->  R(v)]
[[ SEARCH ==>  Match(x,x) ==> ]]


infer[R] u=@M & u<:v  |- R(v).
print residue.

--------------------------------


Residue:
 <1>x::cell<Anon_23>@A&u=@M & u=v & Anon_24=Anon_23&{FLOW,(20,21)=__norm#E}[]
 inferred rel: [RELDEFN R: ( v=@M) -->  R(v)]

# I think it is better to instantiate u<:v rather than u=v

We will later obtain:
     u=@M & u<:v --> R(v)
For strongest R(v), we would derive v=@M.
For weakest R(v), we would later derive v=@A.

=======================================================
# ex8a1.slk  (DONE)

# need to convert aaa<=bbb to aaa<:bbb during simplification

 inferred rel: [RELDEFN P2: ( w_1454=res & vvv=res & aaa<:@L & aaa<=bbb & P1(aaa)) -->  P2(aaa,bbb,vvv,res,w_1454)]

=======================================================
# ex8c4.slk (minor)

When is the 2nd enumeration done? Omega or sleek?

infer [a] a<=4 |-  a<=0.
Residue:
 <1>emp&a<=4 & ((a<=0 | 5<=a))&{FLOW,(4,5)=__norm#E}[]
 inferred pure: [(a<=0 | 5<=a)]

infer [a] a<=3 |-  a<=0.
 <1>emp&a<=3 & a!=1 & a!=2 & a!=3&{FLOW,(4,5)=__norm#E}[]
 inferred pure: [a!=3; a!=2; a!=1]
=======================================================
# ex10a2.slk (OK)

infer [P1] c::cell<_>@M |-  c::cell<_>@ww.

# I think we should inst @M<:ww rather than ww=@A

Residue:
 <1>c::cell<Anon_19>@M&ww=@A & Anon_20=Anon_19&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  Match(c,c) ==> ]]

=======================================================
# ex10a3.slk  (OK)

infer [P1] c::cell<_>@M |-  c::cell<_>@ww&P1(ww).

GOT:

 <1>c::cell<Anon_11>@[@M, @ww]&@M<:ww & Anon_12=Anon_11&{FLOW,(20,21)=__norm#E}[]
 inferred rel: [RELDEFN P1: ( true) -->  P1(ww)]

# As relation can be pre or post, we may want to obtain:

 inferred rel: [RELDEFN P1: @M<:ww -->  P1(ww)]

 This would tell us that P1(ww) = ww=@M so that we can
 have that as the strongest post-condition.

 This at least tell us that ww is being used.
 If we had just true --> P(ww), it could be that 
 ww is unused.

=======================================================
ex10a3.slk [DONE}
../../sleek ex10a3-ann-rel.slk -dre "subtype"

in this case we do not need to prove @M<:ww. Maybe when we instantiate
to lhs<:rhs instead of eq or rhs-aware inst,
we do not need to add this obligation to rhs 

(==solver.ml#9842==)
subtype_ann_gen@1
subtype_ann_gen inp1 :impl:[ww,Anon_12]
subtype_ann_gen inp2 :evars:[]
subtype_ann_gen inp3 :@M
subtype_ann_gen inp4 :@ww
subtype_ann_gen inp5 :lhs_f: c::cell<Anon_11>@[@M, @ww]&{FLOW,(20,21)=__norm#E}[]
subtype_ann_gen inp6 :rhs_f: emp&P1(ww)&{FLOW,(20,21)=__norm#E}[]
subtype_ann_gen@1 EXIT:(true,[ @M<:ww],[ @M<:ww],[])
=======================================================
../../hip ex8-node-inf-L-res.ss 


[RELASS [P1]: ( P1(a)) -->  a<:@L,
RELASS [P1]: ( P1(a)) -->  (a=@M | a=@A),
RELDEFN P2: ( v=res & w_1456=5 & a<:@L & @M<:b_1455 & P1(a)) -->  P2(a,b_1455,v,res,w_1456)]
*************************************

Expected algo:
  (i) process pre first
 (ii) use (i) to process post
 (iii) use post fixpt to add info to pre

!!! **pi.ml#637:reloblgs:[( P1(a), (a=@M | a=@A)),( P1(a), a<:@L)]
!!! **pi.ml#638:WN: Need to form initial pre from reloblgs, namely P1(a) = a=@M

choose pre-obligation first:


!!! **pi.ml#634:pre_rel_ids:[P1]
!!! **pi.ml#635:post_rel_ids:[P2]
!!! **pi.ml#636:pre_ref_df:[]
!!! **pi.ml#637:post_ref_df:[( v=res & w_1456=5 & a<:@L & @M<:b_1455 & P1(a), P2(a,b_1455,v,res,w_1456))]
!!! **pi.ml#638:WN: why is pre_rel_df empty? It should be P1(a) = a=@M

    P2(a,b,v,w) ::= a=@M & @M<:b & v=res
                ::= a=@M & @M=b & v=res


RELDEFN P2: ( v=res & w_1456=5 & a<:@L & @M<:b_1455 & P1(a)) -->  P2(a,b_1455,v,res,w_1456)]
RELDEFN P2: ( v=res & w_1456=5 & a=@M & @M<:b_1455 ) -->  P2(a,b_1455,v,res,w_1456)]

=======================================================
../../hip ex8-node-inf-L-res.ss  \\done

!!! **pi.ml#776:>>REL POST :  P2(a,v,b_1456,res,w_1457)
!!! **pi.ml#777:>>POST:  v=res & w_1457=5 & a<:@L & @M<:b_1456 & a=@M
!!! **pi.ml#778:>>REL PRE :  P1(a,v)
!!! **pi.ml#779:>>PRE :  a=@M

post can be simplified to:
!!! **pi.ml#777:>>POST:  v=res & w_1457=5 & @M<:b_1456 & a=@M
=======================================================
# ex8d1.ss

 int x = c.fst;
 return x;

GOT:
!!! **pi.ml#696:reloblgs:[( P1(a,v), a<:@L)]

# I think can strengthen/simplify to:
!!! **pi.ml#696:reloblgs:[( P1(a,v), a=@L)]

!!! **pi.ml#776:>>REL POST :  P2(a,v,b_1450,res,w_1451)
!!! **pi.ml#777:>>POST:  w_1451=res & v=res & a<:@L & a<:b_1450 & a<:@L
!!! **pi.ml#778:>>REL PRE :  P1(a,v)
!!! **pi.ml#779:>>PRE :  a<:@L

Post can simplify to:
!!! **pi.ml#777:>>POST:  w_1451=res & v=res & a<:@L & a<:b_1450 

Derived spec:
------------
requires c::cell<v>@a & a<:@L
ensures  c::cell<w>@b & w=res & v=res & a<:b 

Improving spec: 
---------------
(i) use weakest pre:
(ii) make strongest post:
requires c::cell<v>@a & a=@L
ensures  c::cell<w>@b & w=res & v=res & b=@L 
(iii) drop @L in post
requires c::cell<v>@a & a=@L
ensures  v=res  
=======================================================
# ex8d2.ss \\done

 int x = c.fst;
 if (x>0) c.fst = 5;
 return x;

GOT
---
!!! **pi.ml#770:>>POST:  
((a=@M & res=w_1457 & v=w_1457 & w_1457<=0 & b_1456=@M) 
| (w_1457=5 & a=@M & v=res & b_1456=@M & 1<=res))

Can normalize to:
-----------------
!!! **pi.ml#770:>>POST:  
a=@M & b_1456=@M & ( res=w_1457 & v=w_1457 & w_1457<=0 ) 
                    | (w_1457=5 & v=res & 1<=res)

GOT:
!!! **pi.ml#696:reloblgs:[( P1(a,v), (a=@M | (v<=0 & a<:@L)))]


# I think can strengthen/simplify to:

!!! **pi.ml#696:reloblgs:[( P1(a,v), (a=@M | a<:@L))]
!!! **pi.ml#696:reloblgs:[( P1(a,v), a=@M]

=======================================================

# ex8e1.ss

How was post_ref_df_new derived from post_ref_df?

!!! **pi.ml#696:reloblgs:[( P1(a,v), (a=@M | (v=0 & a<:@L)))]

!!! **pi.ml#702:post_ref_df:[( 
res=0 & w_1470=0 & v=0 & a<:@L & a<:b_1469 & P1(a,v), 
P2(a,b_1469,v,res,w_1470))]
!!! **pi.ml#717:post_ref_df_new:[( 
res=0 & w_1470=0 & v=0 & a<:@L & a<:b_1469 
& 1<=v & a<:@L & P1(a,v) & v_1517+1=v & @M<:a_1516, 
P2(a,b_1469,v,res,w_1470))]
=======================================================
# ex8e2.ss

# Fixcalc need not know @L

!!! **pi.ml#738:sp:compute_fixpoint:[( res=0 & w_1463=0 & v=0 & a<:@L & a<:b_1462 & 1<=v_1495 & a<:@L & 
P1(a,v_1495) & a<:a_1494, P2(a,b_1462,v,res,w_1463))]
!!! **pi.ml#739: P2(a,b_1462,v,res,w_1463) = ( res=0 & w_1463=0 & v=0 & a<:@L & a<:b_1462 & 1<=v_1495 & a<:@L & 
P1(a,v_1495) & a<:a_1494)
!!! PROBLEM with fix-point calculation
ExceptionFailure("Trans_arr.extract_translate_scheme: @L To Be Implemented")Occurred!

=======================================================
# ex8e3.ss

{
 int x = c.fst;
 if (i!=0 && x>0) {
   return 2+foo(c,i-1);
 } else return 0;
}

# Fixcalc need not know @L

!!! PROBLEM with fix-point calculation
ExceptionFailure("Trans_arr.extract_translate_scheme: @L To Be Implemented")Occurred!
=======================================================
          PRE         POST
a<:@M     a=@M        a=@M 
a<:@L     a=@L        a=@M
a<:@A     a=@A        a=@A
@M<:a     ?           ?
@L<:a     ?           a=@A
@A<:a     a=@A        a=@A

=======================================================

# ex8d1.ss

 int x = c.fst;
 return x;

a<:@L should not be in pre anymore. Is it there because of the assumptions?

foo$cell
 EBase exists (Expl)[](Impl)[a; v](ex)[]c::cell<v>@a&a<:@L & a=@L & 
       MayLoop[]&{FLOW,(4,5)=__norm#E}[]
         EAssume 
           (exists b_1450,w_1451: c::cell<w_1451>@b_1450&res=v & w_1451=v & 
           a=@L & b_1450=@A&{FLOW,(4,5)=__norm#E}[]

=======================================================
../../hip ex8e1-loop-write.ss -dre "norm_post_.*\|norm_reloblgs"

should I plug in def of P1(a,v) for the def of P1(a_1516,v_1517) as well?

!!! **pi.ml#678:reldefns:[
( res=0 & w_1470=0 & v=0 & a<:@L & a<:b_1469 & P1(a,v), P2(a,b_1469,v,res,w_1470)),
( 1<=v & a<:@L & P1(a,v) & v_1517+1=v & @M<:a_1516, P1(a_1516,v_1517)),
( a<:@L & v<=(0-1) & P1(a,v) & v_1517+1=v & @M<:a_1516, P1(a_1516,v_1517)),
( a=@M, P1(a,v))]

!!! **pi.ml#679:reldefns_from_oblgs:[( a=@M, P1(a,v))]

!!! **pi.ml#769:>>REL POST :  P2(a,v,b_1469,res,w_1470)
!!! **pi.ml#770:>>POST:  res=0 & w_1470=0 & v=0 & a=@M & b_1469=@M
!!! **pi.ml#771:>>REL PRE :  P1(a,v)
!!! **pi.ml#772:>>PRE :  true ----------> should it be a=@M?

=======================================================
# ex8e1b.slk

Perhaps HOLE has not been substituted?
Can we print HOLE in the sleek logging?

Residue:
 <1>c::cell<v>@a&c'=c & P1(a,v) & fst_15_1443'=v & a<:@L&{FLOW,(20,21)=__norm#E}[]
 inferred rel: [RELASS [P1]: ( P1(a,v)) -->  a<:@L]
[[ SEARCH ==>  Match(c,c') ==> ]]
=======================================================
# ex8e4.ss (DONE at heap_entail_one_context_struc)

# false post is not logged..

!!!Number of sleek log entries 0
!!!Logging logs/sleek_log_ex8e4-false-post_ss.txt

# ex8e5.slk

!!!Number of sleek log entries 0
!!!Logging logs/sleek_log_ex8e5-false-lhs_slk.txt

(==solver.ml#3648==)
heap_entail_one_context_struc#4@4@3@2@1
heap_entail_one_context_struc#4 inp1 :conseq: EBase emp&0<x&{FLOW,(4,5)=__norm#E}[]
heap_entail_one_context_struc#4 inp2 : hfalse&false&{FLOW,(4,5)=__norm#E}[]
 es_orig_ante: Some(hfalse&false&{FLOW,(4,5)=__norm#E}[])
 es_infer_vars_rel: []
heap_entail_one_context_struc#4 inp3 :is_folding:false
heap_entail_one_context_struc#4 inp4 :has_post:true
heap_entail_one_context_struc#4@4 EXIT: [
  hfalse&false&{FLOW,(4,5)=__norm#E}[]
  ]
=======================================================
# ex8e5a.slk

checkentail x::cell<_>@a*x::cell<_>@b |- false.

  unsound to be false/valid.

Entail 1: Valid. 
Residue:
 <1>hfalse&false&{FLOW,(20,21)=__norm#E}[]
Validate 1: Expecting 3 Fail BUT got : Valid

(==cvutil.ml#1720==)
xpure_heap_mem_enum#6@2@1
xpure_heap_mem_enum#6 inp1 : x::cell<Anon_11>@a * x::cell<Anon_12>@b
xpure_heap_mem_enum#6 inp2 : true
xpure_heap_mem_enum#6 inp3 :1
xpure_heap_mem_enum#6@2 EXIT: false #  [[x,x]]

%%%       xpure_heap_mem_enum@2.
%%%        h_formula_2_mem
%%%         build_eset_of_conj_formula
%%%        is_sat_mem_formula

=======================================================
# i-ex7a.ss

# missing   logs/fixcalc.inf

int bsearch(int i, int j)
  infer[P,Q]
  requires P(i,j)
  ensures Q(i,j,res);
{
  if (i>=j) return i;
  int mid = (i+j)/2;
  if (rand()) return bsearch(i,mid);
  return bsearch(mid+1,j);
}

# Below is present in default but not in ann_2 branch. 

!!! **fixcalc.ml#908:No of disjs:1
!!! **fixcalc.ml#913:bottom up
!!! fixcalc file name: logs/fixcalc.inf
(==fixcalc.ml#1337==)
compute_fixpoint_aux@5@4
compute_fixpoint_aux inp1 :[( Q(i,j,res), ((i=res & j<=res) | 
exists(mid_1490:exists(fc_mid_1493:Q(fc_mid_1493,j,res) & fc_mid_1493=1+
mid_1490) & 0<=mid_1490 & mid_1490<j & (i+j)<=(1+(2*mid_1490)) & (2*
mid_1490)<=(i+j)) | exists(mid':0<=mid' & mid'<j & (i+j)<=(1+(2*mid')) & (2*
mid')<=(i+j) & Q(i,mid',res))),1)]
compute_fixpoint_aux inp2 :[P,i,j]
compute_fixpoint_aux@5 EXIT:[( Q(i,j,res), res>=i)]

(==pi.ml#617==)
compute_fixpoint#2@4
compute_fixpoint#2 inp1 :[( 0<=mid_1490 & mid_1490<j & (j+i)<=(1+(2*mid_1490)) & (2*mid_1490)<=(j+i) & 
Q(1+mid_1490,j,res), Q(i,j,res)),
( i=res & j<=res, Q(i,j,res)),
( 0<=mid' & mid'<j & (j+i)<=(1+(2*mid')) & (2*mid')<=(j+i) & Q(i,mid',res), Q(i,j,res))]
compute_fixpoint#2 inp2 :[P,i,j]
compute_fixpoint#2@4 EXIT:[( Q(i,j,res), res>=i)]

!!! **pi.ml#619:bottom_up_fp0:[( Q(i,j,res), res>=i)]
!!! **pi.ml#636:fixpoint:[( Q(i,j,res), res>=i, P(i,j), true)]
!!! **pi.ml#650:>>REL POST :  Q(i,j,res)
!!! **pi.ml#651:>>POST:  res>=i
!!! **pi.ml#652:>>REL PRE :  P(i,j)
!!! **pi.ml#653:>>PRE :  true
======================================================
# ex8e5b.slk 

Why m=n and a=b not in residue.?

checkentail x::cell<m>@a*x::cell<n>@b  |- x!=null.

GOT
===
Residue:
 <1>x::cell<m>@m_21&{FLOW,(20,21)=__norm#E}[]
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
