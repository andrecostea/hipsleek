# lend-1.slk --print-type (DONE)

Can you change integer formula back to annotation
formula at Omega.ml. See trans_bool method which
converts b>=1 to b and b<=0 to !b for boolean.

infer [v] p::pair<f,s>@v |- p::pair<a,b>.

GOT: 
Entail (1) : Valid. 
 <1>emp&a:int=f:int & b:int=s:int & v:AnnT<=0&{FLOW,(21,22)=__norm}[]
 inferred pure: [v:AnnT<=0]
[[ SEARCH ==>  Match(p:pair,p:pair) ==> ]]


Expects:
Entail (1) : Valid. 
 <1>emp&v:AnnT<:@M&{FLOW,(21,22)=__norm}[]
 inferred pure: [v:AnnT<:@M]
[[ SEARCH ==>  Match(p:pair,p:pair) ==> ]]
=======================================================
# lend-2.slk --print-type (DONE)

Need to introduce a new type "ann" for annotation?

ERROR: at lend-2.slk_7:42_7:43 
Message: gather_type_info_var : unexpected exception Failure("UNIFICATION ERROR : at location {(7,42),(7,43)} types AnnT and int are inconsistent")
 gather_type_info_b_formula: relation R
Starting z3... 

Why is there an inferred "true"?

Entail (1) : Valid. 
 <1>q::celly<flted_7_16>@w&flted_7_16=2 & R(v,w) & a=f & Anon_11=flted_7_16 & v<=0 & w<=2&{FLOW,(21,22)=__norm}[]
 inferred pure: [true]
 inferred rel: [RELASS [R]: ( R(v,w)) -->  v<=0 & w<=2]
[[ COND ==>  SEARCH ==>  Match(p,p) ==>  SEARCH ==>  Match(q,q) ==> ]]

=======================================================
# lend-3.slk --print-type (IGNORE)

Maybe @imm should be used only for HIP..

infer [@imm] p::cell<f>@v * q::cell<2>@w & R(v,w) 
  |- p::cell<a> * q::cell<_>@L.
print residue.

@imm should pick up all relations with @ann parameters
for inference; where needed. 

Priority to relations, and then variables.

 error: Stream.Error("[infer_type] or [id_list] or CSQUARE expected after OSQUARE (in [id_list_w_itype])")
 at:(Program not linked with -g, cannot print stack backtrace)
=======================================================
# lend-3a.slk --pcp (DONE)

//relation R(int v,int w).
relation R(int v,
   ann w).

Why is the R relation not being printed
by --pcp
=======================================================
# cell-3b.ss  (DONE)

[RELASS [P1]: ( P1(a)) -->  a=@M,
RELDEFN P2: ( b=@M) -->  P2(b)]

 c::cell<v>@a & P1(a) |- c::cell<_>

     P1(a) --> a<:M

 c::cell<v>@a & a<:M |- c::cell<_>@b & P2(b)

     b<:@M -> P2(b)

*************************************
Two problems:
 (1) why numeric for fixcalc?
 (2) Why false for PRE?

*************************************
*******fixcalc of pure relation *******
*************************************
[( P2(b), b=0, P1(a), false)]
*************************************

!!!REL POST :  P2(b)
!!!POST:  b=0
!!!REL PRE :  P1(a)
!!!PRE :  false

*************************************
*******fixcalc of pure relation *******
*************************************
[( P2(b), b=0, P1(a), false)]

=======================================================
# cell-3c.ss (DONE)

Why is there a check 1 fail?

Checking procedure foo$cell... check 1 fail

!!! >>>>>> HIP gather infer pre <<<<<<
!!!Inferred Heap: []
!!!Inferred Pure: [ true]
Procedure foo$cell SUCCESS.
Stop Omega... 18 invocations 
0 false contexts at: ()

c::cell<v>@a & P1(a) |- c::cell<w>@L

=======================================================
# cell-3c1.slk

infer [P1,P2] 
c::cell<v>@a & P1(a)  & a<:@L 
        |- c::cell<w>@b & P2(b).
print residue.

                              
Why false?
Why a>2?


Entail (2) : Valid. 
 <1>hfalse&false&{FLOW,(21,22)=__norm}[]
 inferred rel: [RELASS [P1]: ( P1(a)) -->  a>2]
[[empty]]
=======================================================
# cell-2.ss  (DONE)

int foo(cell c)
  infer [P1]
  requires c::cell<v>@a & P1(a,b) 
  ensures c::cell<v>@b & v=res;
{
  return c.fst;
}

GOT
===
[RELASS [P1]: ( P1(a,b)) -->  a<:@L]

Post Inference result:
foo$cell
 EBase exists (Expl)[](Impl)[a; v](ex)[]c::cell<v>@L&a<:@L & MayLoop[]&
       {FLOW,(4,5)=__norm#E}[]
         EAssume 
           (exists v_1460: emp&v=res & v_1460=v&{FLOW,(4,5)=__norm#E}[]

# Why b is free?
# What happen to Cell in post

!!!WARNING : uninterpreted free variables [b] in specification.
Checking procedure foo$cell... check 1 fail
=======================================================
# ex4.slk

Verification works but inference fails for ex4a.slk

infer [@field_imm] p::pair<f,s@L> |- p::pair<a,b@M>.
print residue.
expect Fail.

infer [@field_imm] p::pair<f,s@M> |- p::pair<a,b@L>.
print residue.
expect Valid.

# ex4a.slk

infer [@field_imm,a] p::pair<f,s@a> |- p::pair<a,b@L>.
print residue.

Need to fix type error

ERROR: at ex4a-infer-field-imm.slk_6:47_6:48
Message: UNIFICATION ERROR : at location {(Line:6,Col:47),(Line:6,Col:48)} types
 int and AnnT are inconsistent

=======================================================
# ex4c4

infer [@field_imm] p::cell<s@x> |- p::cell<b@L>.
infer [@field_imm] p::pair<_,s@x> |- p::pair<_,b@L>.

Why did the cell fails as expected 
but not pair?

(==solver.ml#7525==)
heap_entail_empty_rhs_heap#1@2@1
heap_entail_empty_rhs_heap#1 inp1 : p::cell<s@[@x]>&b=s&{FLOW,(4,5)=__norm#E}[]
 // missing? es_heap: p::pair<Anon_12,s@A>
 es_infer_obj: [@field_imm]
 es_trace:  SEARCH ==>  Match(p,p) ==> 
 es_infer_vars_rel: []
 es_unsat_flag: false
heap_entail_empty_rhs_heap#1 inp2 : p::cell<s@[@x]>&b=s&{FLOW,(4,5)=__norm#E}[]
heap_entail_empty_rhs_heap#1 inp3 : x<:@L
heap_entail_empty_rhs_heap#1 inp4 :false
heap_entail_empty_rhs_heap#1@2 EXIT: 
MaybeErr Context: 
                   fe_kind: MAY
                   fe_name: logical bug
                   fe_locs: {
                             fc_message:  true |-  x<:@L. LOCS:[0] (may-bug)
   

(==solver.ml#7525==)
heap_entail_empty_rhs_heap#1@4@3
heap_entail_empty_rhs_heap#1 inp1 : p::pair<Anon_28@A,s@[@x]>&Anon_13=Anon_12 & 
b=s&{FLOW,(4,5)=__norm#E}[]
 es_heap: p::pair<Anon_12,s@A>
 es_infer_obj: [@field_imm]
 es_trace:  SEARCH ==>  Match(p,p) ==> 
 es_infer_vars_rel: []
 es_unsat_flag: false
heap_entail_empty_rhs_heap#1 inp2 : p::pair<Anon_28@A,s@[@x]>&Anon_13=Anon_12 & b=s&{FLOW,(4,5)=__norm#E}[]
heap_entail_empty_rhs_heap#1 inp3 : x<:@L
heap_entail_empty_rhs_heap#1 inp4 :false
heap_entail_empty_rhs_heap#1@4 EXIT: [
  p::pair<Anon_28@A,s@[@x]>&Anon_13=Anon_12 & b=s&{FLOW,(4,5)=__norm#E}[]
  ]
=======================================================
#  ex4c5.slk -debug x.log (needed --etcsu1 & --en-imm-merge)

infer [@field_imm] p::pair<_,s@x> |- p::pair<_,b@L>.

Need to trace how unsound "false" appear below

**solver.ml#8096:diff_flag:false
@1! **solver.ml#8097:super_smart_xpure:false
@1! **solver.ml#8103:xpure_lhs_h1(bef merge): false
@1! **solver.ml#8107:xpure_lhs_h1: false
@1! **solver.ml#8130:xpure_lhs_h1: false
@1! **solver.ml#8131:xpure_lhs_h0_sym (wo pure): false
@1! **solver.ml#8132:xpure_lhs_h1_sym (wo pure): false
=======================================================
# ex5.slk (OK after changing --etcsu1 and --en-imm-merge with --field-imm

# Normalization is not working here..

infer [@field_imm] p::pair<f,s@A> * p::pair<a@A,2> |- false.

(==astsimp.ml#7717==)
normalize_field_ann_heap_node@5
normalize_field_ann_heap_node inp1 : p::pair<f,s@A> * p::pair<a@A,flted_7_14>
normalize_field_ann_heap_node@5 EXIT:( p::pair<f,s@A> * p::pair<a@A,flted_7_14>,?,?)
=======================================================
# Normalization is not working here..

!!! **cformula.ml#15051:holes1:[]
!!! **cformula.ml#15052:holes2:[]
!!! **cformula.ml#15066:inside combine_param_ann
(==astsimp.ml#7726==)
combine_param_ann@1
combine_param_ann inp1 :[@M,@A]
combine_param_ann inp2 :[@A,@M]
combine_param_ann@1 EXIT:[@M,@A]
[Warning] False ctx
=======================================================
# ex5.slk

infer [@field_imm] p::pair<f,s@A> * p::pair<_,2> |- false.

# Why not return false at this point of heap merging?
# maybe can avoid --etcsu1 if you had done this?
  ("--etcsu1",Arg.Set Globals.simpl_memset,"use the old,complicated memset calculator");
# We should avoid this old calculator since it is likely to be obsolete.
# We should focus on improving the merging operation


(==norm.ml#1054==)
merge_alias_nodes_formula@1
merge_alias_nodes_formula inp1 : p::pair<f,s@A> * p::pair<Anon_12,flted_16_15>&f
lted_16_15=2&
{FLOW,(20,21)=__norm#E}[]
merge_alias_nodes_formula@1 EXIT: p::pair<f,s@A> * p::pair<Anon_12,flted_16_15>&
flted_16_15=2&
{FLOW,(20,21)=__norm#E}[]

infer [] ppp::pair<f,s>@A * ppp::pair<_,2>@I |- s=2.
// fails
// what happen to s=2? where is merge
// when @field_imm is added, it succeeds.

should do a merge rather than a removal 

(==sleekengine.ml#1186==)
remove_imm_from_formula@1
remove_imm_from_formula inp1 : ppp::pair<f,s>@A * ppp::pair<Anon_15,flted_31_48>@I&flted_31_48=2&
{FLOW,(20,21)=__norm#E}[]
remove_imm_from_formula@1 EXIT: (emp) * ppp::pair<Anon_15,flted_31_48>@I&ppp!=null & flted_31_48=2&
{FLOW,(20,21)=__norm#E}[]
=======================================================
# ex5c.slk

infer [] p::pair<f>@I & p::pair<2>@I |- false.

unsound to use xpure_heap_mem_enum when there
is /\ in the formula

(====)
h_formula_2_mem@3@2@1
h_formula_2_mem inp1 : (p::pair<f>@I ; ((p::pair<flted_9_13>@I ; (emp))))
h_formula_2_mem inp2 : flted_9_13=2
h_formula_2_mem inp3 :[]
h_formula_2_mem@3 EXIT: [[p]]

(==cvutil.ml#1713==)
xpure_heap_mem_enum#6@2@1
xpure_heap_mem_enum#6 inp1 : (p::pair<f>@I ; ((p::pair<flted_9_13>@I ; (emp))))
xpure_heap_mem_enum#6 inp2 : flted_9_13=2
xpure_heap_mem_enum#6 inp3 :1
xpure_heap_mem_enum#6@2 EXIT: p=1 & p=2 #  [[p]]

=======================================================
When merging, may I suggest the following..

  @A * v  --> v
  @M * v  --> @M & v<:@A
  @I * v  --> @I & v<:@A
  @L * v  --> @L & v<:@A
  v1 * v2 --> v3 & (v3=v2 & v1<:@A | v3=v1 & v2<:A)

=======================================================
# ex3d7.ss

  infer [P1,P2]
  requires c::cell<v>@a & P1(a)
     ensures c::cell<v>@b & P2(a,b,v,res)  ;


[RELASS [P1]: ( P1(a)) -->  a<:@L,
RELDEFN P2: ( res=v & b_1458=a & a<:@L & P1(a)) -->  P2(a,b_1458,v,res)]

I think it is sufficient to leave it as:
!!! **pi.ml#658:PRE :  a<:@L

But to later transform pre/post from:

 EBase exists (Expl)[](Impl)[a; v](ex)[]c::cell<v>@a&a<:@L & 
       MayLoop[]&{FLOW,(4,5)=__norm#E}[]
         EAssume 
           (exists v_1457,b_1458: c::cell<v_1457>@b_1458&v_1457=v & res=v & 
           b_1458=a & a<:@L&{FLOW,(4,5)=__norm#E}[]

To:

 EBase exists (Expl)[](Impl)[a; v](ex)[]c::cell<v>@L & 
       MayLoop[]&{FLOW,(4,5)=__norm#E}[]
         EAssume 
           (exists v_1457,b_1458: res=v &{FLOW,(4,5)=__norm#E}[]


!!! **pi.ml#611: P2(a,b_1458,v,res) = ( res=v & b_1458=a & a<:@L)Pi.infer_pure

!!! **fixcalc.ml#1392:n_base:2
!!! **pi.ml#625:bottom_up_fp:[( P2(a,v,b_1458,res), res=v & b_1458=a & a<:@L)]
!!! **pi.ml#632:fixpoint:[( P2(a,v,b_1458,res), res=v & b_1458=a & a<:@L, P1(a), a<:@L)]
!!! **pi.ml#655:REL POST :  P2(a,v,b_1458,res)
!!! **pi.ml#656:POST:  res=v & b_1458=a & a<:@L
!!! **pi.ml#657:REL PRE :  P1(a)
!!! **pi.ml#658:PRE :  a=@L
=======================================================
# ex3d7.ss --reverify

  infer [P1,P2]
  requires c::cell<v>@a & P1(a)
     ensures  c::cell<v>@b & P2(a,b,v,res)  ;

The above failed, as follows:

Post condition cannot be derived:
  (must) cause:  @L=@L & @L<:b_1458 & @L=b_1458 |-  b_1458=@A. LOCS:[1;0] (must-bug)

despite inferring:

  requires c::cell<v>@a & a=@L
  ensures c::cell<v>@b & res=v & a=@A  ;

We need below, as highlighted in:

  requires c::cell<v>@L
  ensures c::cell<v>@A & res=v  ;
=======================================================
# ex3d7c.slk

checkentail x::cell<a>@L |- x::cell<b>@v & v=@A.
print residue.

Entail 2: Fail.(must) cause: @L=v |-  v=@A. LOCS:[0;9] (must-bug)

Solution : either (i) substitute (ii) use explicit
instantation (iii) post-process
*/

checkentail x::cell<a>@L |- (exists v: x::cell<b>@v & v=@A).
print residue.
/*
Residue:
 <1>x::cell<a>@L&b=a&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  Match(x,x) ==> ]]
=======================================================
# ex3d7e.slk  (DONE)

# remove double annotation as it seems redundant
checkentail x::cell<a>@u & u=@L & v=@A  |- x::cell<b>@v & v=@A.
Residue:
 <1>x::cell<a>@[@u, @ann_f_r_23]&v=@A & u=@L & ann_f_r_23=v & u<:ann_f_r_23 & b=a&{FLOW,(20,21)=__norm#E}[]


# support RHS sensitive instantiation for annotation

checkentail x::cell<a>@u & u=@L  |- x::cell<b>@v & v=@A.
Entail 6: Fail.(must) cause: @L<:v & @L=v |-  v=@A. LOCS:[0;32] (must-bug)

instantiated: u=v which gave a wrong instantiation

# soln : change to instantiate v=@A which is present on the RHS before
proceeding to prove u<:v

=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
