# ex13c1.slk

infer [H1,P] H1(q) * s::char_star<v,q> & v!=0 |- P(q).
print residue.

GOT:
 <1>s::char_star<v,q>@M&v!=0&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [H1(q)&true --> P(q)&true]

Expects:
   H1(q) | s::char_star<v,q> --> P(q)

infer [H1,P,@leak] H1(q) * s::char_star<v,q> & v=0 |- true.
print residue.

GOT:
 <1>emp&v=0&{FLOW,(20,21)=__norm#E}[]

Expects:
   H1(q) | s::char_star<v,q> --> emp 
===========================================================================
# ex13c3.slk

infer [P] p::node2<_,null> * s::node2<_,p> |- P(p,s).
print residue.

GOT:
Starting Omega.../usr/local/bin/oc
 <1>s::node2<Anon_13,p>@M&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [p::node2<Anon_12,flted_9_18>@M&
                   flted_9_18=null --> P(p,s@NI)&true]

# Why did we not obtain below. Do we need some flag?
  p::node2<_,null> | s::node2<_,p> --> P(p,s)

===========================================================================
# ex13c4.slk

infer [H1,@leak] H1(q)  |- emp.

# Why isn't classic inference working?

Entail (2) : Fail.(may) cause: H1(q)&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.

===========================================================================
# ex13c.ss

void while1(ref char_star s)
  infer [P]
  requires P(s)
  ensures true;
{
  int x=get_char(s);
  if (x!=0) {
    s = plus_plus_char(s);
    while1(s);
  }
}

  // P(s) 
  //   |- s::chr<v,q>@L
  int x=get_char(s);
  //   P(s) -> s::chr<v,q>*H1(q)
  // s::chr<v,q>*H1(q) & x'=v & s'=s
  if (x!=0) {
    // s::chr<v,q>*H1(q) & x'=v & v!=0 & s'=s
    //   |- s::chr<v,q>
    s = plus_plus_char(s);
    // s::chr<v,q>*H1(q) & x'=v & v!=0 & s'=q
    //   |- P(s')
    while1(s);
    //   H1(q) | s::chr<v,q> & v!=0 --> P(q) 
    // s::chr<v,q> & x'=v & v!=0 & s'=q
    //   |- htrue
    // emp & x'=v & v!=0 & s'=q
  }
  // s::chr<v,q>*H1(q) & x'=v & v=0
  //   |- htrue
  //   H1(q) | s::chr<v,q> & v=0 --> emp 
  // emp & x'=v & v=0
}

  P(s) -> s::chr<v,q>*H1(q)
  H1(q) | s::chr<v,q> & v!=0 --> P(q) 
  H1(q) | s::chr<v,q> & v=0 --> emp

==> add-dangling
  P(s) -> s::chr<v,q>*H1(q)
  H1(q) | s::chr<v,q> & v!=0 --> P(q) 
  H1(q) | s::chr<v,q> & v=0 --> D(q)

==> specialize
  P(s) -> s::chr<v,q> * P(q) & v!=0
  P(s) -> s::chr<v,q> * D(q) & v=0

==> parameterize-dangling
  P(s,d) -> s::chr<v,q> * P(q,d) & v!=0
  P(s,d) -> s::chr<v,d> & v=0

==> unknown segment
  P(x,d) -> U(x,q) * q::chr<0,d>

==> segmented-pred
  P(x,d) -> U(x,q) * q::chr<v,d>
  U(x,q) -> x=q
  U(x,q) -> x::chr<v,q1>*U(q1,q) & v!=0
===========================================================================
# ex14b.slk

  HeapPred U(char_star x,char_star y).
  lemma_infer_pred [U] self::WFG<p> <- U(self,q)*q::char_star<0,p>.

!!! **WARNING****solver.ml#12993:do_match after infer_heap
!!! **solver.ml#12994:rhs_h_matched set:[]
!!! **solver.ml#12995:lhs_h: self_lem_12::WFG<p>@M
!!! **solver.ml#12996:rhs_h: self_lem_12::WFG<p_133>@M
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs :
 HP_134(p,q_132) * HP_135(q_132,self_lem_12)&flted_25_131=0&
{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs :
 HP_137(p,q_132) * HP_138(q_132,self_lem_12)&flted_25_131=0&
{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
Entailing lemma lem_12: Fail. (cex)(may) cause:  emp&flted_25_131=0&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.

!!! fixpoint1:[]
*/

  /*
==> unknown segment
  P(x,d) -> U(x,q) * q::chr<0,d>

==> segmented-pred
  P(x,d) -> U(x,q) * q::chr<v,d>
  U(x,q) -> x=q
  U(x,q) -> x::chr<v,q1>*U(q1,q) & v!=0

===========================================================================
# ex14d.slk

  lemma_infer_pred [U,@classic,@pure_field] self::WFG<p> -> self::WFSeg<q>*U(q,p).

# why is @pure_field not working here?

[ U(q_172,p_173) ::= q_172::char_star<v_174,p_173>@M
 or q_172::char_star<v_174,q_138>@M * q_138::WFG<p_173>@M
 (20,21)]

===========================================================================
# ex14e.slk

  lemma_infer_pred [U,@classic] self::WFG<p> <- self::WFSeg<q>*U(q,p).

# residue problem?

!!! **WARNING****solver.ml#12993:do_match after infer_heap
!!! **solver.ml#12994:rhs_h_matched set:[]
!!! **solver.ml#12995:lhs_h: self_lem_12::WFG<p>@M
!!! **solver.ml#12996:rhs_h: self_lem_12::WFG<p_128>@M
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs : HP_129(p,self_lem_12)&{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs : HP_131(p,self_lem_12)&{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
Entailing lemma lem_12: Fail. (cex)(may) cause:  emp&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.
===========================================================================
# ex14g.slk

  infer [U,@classic,@pure_field] 
   self::char_star<0,p> |- self::WFSeg<q>*U(q,p) .

# What happen to the pure field inference?

<1>emp&self=q&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [q::char_star<flted_33_173,p>@M&true |#|3  --> U(q,p)&true]
[[ Fold ==>  COND ==>  InferHeap]]

id: 4; caller: []; line: 0; classic: true; kind: Sleek_Entail(1); hec_num: 1; evars: []; impl_vars: [q]; infer_vars: [ U]; c_heap: emp; others: [@pure_field,@leak] globals: [@leak,@pure_field]
 checkentail self::char_star<flted_33_104,p>@M&flted_33_104=0&{FLOW,(20,21)=__norm#E}[]
 |-  self::WFSeg<q>@M * U(q,p)&{FLOW,(20,21)=__norm#E}[]. 
hprel_ass: [ q::char_star<flted_33_104,p>@M |#|  --> U(q,p)]
ho_vars: nothing?
res:  1[
    emp&self=q & flted_33_104=0&{FLOW,(20,21)=__norm#E}[]
   es_infer_hp_rel: [q::char_star<flted_33_104,p>@M |#|  --> U(q,p)]
   ]


===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================

