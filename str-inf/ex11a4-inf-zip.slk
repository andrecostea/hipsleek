data node {
  int val; 
  node next; 
}.

pred zip<ys> == 
  self=null & ys=null
  or self::node<_,q> * ys::node<_,q2> * q::zip<q2>
.
  
relation R(int n, int m).

pred ll<n> == 
  self=null & n=0
  or self::node<_,q>*q::ll<n-1>
  inv n>=0.

/*
lemma_infer [R]
  self::zip<ys> <- self::ll<a> * ys::ll<b> & R(a, b).
print residue.
*/

relation P(int n).

/*
infer [@classic] x::ll<n> & P(n) |- emp.
print residue.

infer [n,@classic] x::ll<n> & n=0  |- emp.
 <1>x::ll<n>@M&n=0&{FLOW,(20,21)=__norm#E}[]
*/

infer [n,@classic] x::ll<n>   |- emp.
print residue.


/*
# ex11a4.slk

lemma_safe
  self::zip<ys> <- self::ll<a> * ys::ll<b> & a=b.

# to schedule an infer to ensure emptiness after unfolding below..

and is_classic_lhs_emp prog h1 ante pos =
  let h1_unfold =
  in
  h1_unfold==HEmp || (is_resourceless_h_formula prog h1_unfold)
  || (is_classic_lending_hformula h1_unfold)

do_unfold_for_classic_reasoning@1
do_unfold_for_classic_reasoning inp1 : x::ll<n>@M&{FLOW,(20,21)=__norm#E}[]
do_unfold_for_classic_reasoning@1 EXIT: emp&x=null & n=0&{FLOW,(20,21)=__norm#E}[]
 or (exists flted_15_68,Anon_69,
    q_70: x::node<Anon_69,q_70>@M * q_70::ll<flted_15_68>@M&flted_15_68+1=n&
    {FLOW,(20,21)=__norm#E}[])


(====)
do_unfold_for_classic_reasoning@1
do_unfold_for_classic_reasoning inp1 : x::ll<n>@M&n=0&{FLOW,(20,21)=__norm#E}[]
do_unfold_for_classic_reasoning@1 EXIT: emp&x=null & n=0 & n=0&{FLOW,(20,21)=__norm#E}[]

(====)
do_unfold_for_classic_reasoning@2
do_unfold_for_classic_reasoning inp1 : x::ll<n>@M&n=0&{FLOW,(20,21)=__norm#E}[]
do_unfold_for_classic_reasoning@2 EXIT: emp&x=null & n=0 & n=0&{FLOW,(20,21)=__norm#E}[]




*/

