/* singly linked lists */

/* representation of a node */

data node {
	int val; 
	node next;	
}.

pred ll<> == self = null 
	or self::node<_, q> * q::ll<> 
  inv true.

pred lseg<p> == self = null 
	or self::node<_, q> * q::lseg<p> 
  inv true.

pred app3<> == self::node<_,null> 
	or self::node<_, q> * q::app3<> & q!=null 
  inv self!=null.

HeapPred U(node x).
HeapPred U2(node x,node y).
HeapPred U3(node x,node y).

lemma_infer_pred [U,classic]
  self::app3<> -> self::node<_,q>*U(q).
print residue.


/*
# ex21d1.slk

lemma_infer_pred [U,classic]
  self::app3<> -> self::node<_,q>*U(q).
print residue.

# Chanh: these are based on post-predicate

************************************
*******shape relational assumptions ********
*************************************
[ emp&flted_22_139=null --> U(flted_22_139)&true,
 q_147::node<Anon_152,q_153>@M * GP_154(q_153,q_147@NI)&
  q_147!=null --> U(q_147)&true,
 U(q_153)&q_147!=null --> GP_154(q_153,q_147@NI)&true]

!!! **syn.ml#458:>>>>> Step 1: Adding dangling references <<<<<
!!! **syn.ml#49:Dangling args:[]
!!! **syn.ml#49:Dangling args:[q_153]
!!! **syn.ml#49:Dangling args:[]
!!! **syn.ml#468:Detected dangling vars:
 
  [U(q_153)&q_147!=null |#|  --> GP_154(q_153,q_147); 
   q_147::node<Anon_152,q_153>@M * GP_154(q_153,q_147)&
    q_147!=null |#|  --> U(q_147) * q_153::Dangling<>@M; 
   emp&flted_22_139=null |#|  --> U(flted_22_139)]
!!! **syn.ml#473:>>>>> Step 2: Unfolding <<<<<
 --error:  at:


*/
