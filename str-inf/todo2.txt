# ex14b.slk

  HeapPred U(char_star x,char_star y).
  lemma_infer_pred [U] self::WFG<p> <- U(self,q)*q::char_star<0,p>.

!!! **WARNING****solver.ml#12993:do_match after infer_heap
!!! **solver.ml#12994:rhs_h_matched set:[]
!!! **solver.ml#12995:lhs_h: self_lem_12::WFG<p>@M
!!! **solver.ml#12996:rhs_h: self_lem_12::WFG<p_133>@M
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs :
 HP_134(p,q_132) * HP_135(q_132,self_lem_12)&flted_25_131=0&
{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs :
 HP_137(p,q_132) * HP_138(q_132,self_lem_12)&flted_25_131=0&
{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
Entailing lemma lem_12: Fail. (cex)(may) cause:  emp&flted_25_131=0&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.

!!! fixpoint1:[]
*/

  /*
==> unknown segment
  P(x,d) -> U(x,q) * q::chr<0,d>

==> segmented-pred
  P(x,d) -> U(x,q) * q::chr<v,d>
  U(x,q) -> x=q
  U(x,q) -> x::chr<v,q1>*U(q1,q) & v!=0

===========================================================================
# ex14d.slk

  lemma_infer_pred [U,@classic,@pure_field] self::WFG<p> -> self::WFSeg<q>*U(q,p).

# why is @pure_field not working here?

[ U(q_172,p_173) ::= q_172::char_star<v_174,p_173>@M
 or q_172::char_star<v_174,q_138>@M * q_138::WFG<p_173>@M
 (20,21)]

===========================================================================
# ex14e.slk

  lemma_infer_pred [U,@classic] self::WFG<p> <- self::WFSeg<q>*U(q,p).

# residue problem?

!!! **WARNING****solver.ml#12993:do_match after infer_heap
!!! **solver.ml#12994:rhs_h_matched set:[]
!!! **solver.ml#12995:lhs_h: self_lem_12::WFG<p>@M
!!! **solver.ml#12996:rhs_h: self_lem_12::WFG<p_128>@M
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs : HP_129(p,self_lem_12)&{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs : HP_131(p,self_lem_12)&{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
Entailing lemma lem_12: Fail. (cex)(may) cause:  emp&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.
===========================================================================
# ex14g.slk (FIXED by Loc)

  infer [U,@classic,@pure_field] 
   self::char_star<0,p> |- self::WFSeg<q>*U(q,p) .

# What happen to the pure field inference?

  infer [U,@pure_field] 
   x::char_star<n,p> & n=0 |- U(x,p) .
  print residue.

  inferred hprel: [x::char_star<n,p>@M&true |#|3  --> U(x,p)&true]
   # EXPECTs
   hprel: [x::char_star<n,p>@M& n=0  --> U(x,p)&true]

  infer [U,@pure_field] 
   x::char_star<0,p>  |- U(x,p) .
  print residue.

   hprel: [x::char_star<flted_42_129,p>@M&true |#|3  --> U(x,p)&true]
   # EXPECTs
   hprel: [x::char_star<flted_42_129,p>@M& = flted_42_129null  --> U(x,p)&true]

  infer [U,@classic,@pure_field] 
   self::char_star<0,p> |- self::WFSeg<q>*U(q,p) .
  print residue.

<1>emp&self=q&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [q::char_star<flted_52_120,p>@M&true |#|3  --> U(q,p)&true]
   # EXPECTs
   hprel: [x::char_star<flted_42_129,p>@M& = flted_42_129null  --> U(x,p)&true]
===========================================================================
# ex14g3.slk --esl (WN to fix)

  lemma_infer [U,@pure_field]
       self::WFG<p> -> (exists q: self::WFSeg<q>*U(q,p)).

# Why is @pure_field mssing in entail_state?

id: 4; caller: []; line: 0; classic: true; kind: Verify_Lemma; hec_num: 1; evars: []; impl_vars: []; infer_vars: [ U]; c_heap: emp; others:  es_infer_obj: [] globals: [@leak]
 checkentail (exists flted_16_124: self_lem_12::char_star<flted_16_124,p>@M&
flted_16_124=0&{FLOW,(20,21)=__norm#E}[])
 |-  (exists q_109: self_lem_12::WFSeg<q_109>@M * U(q_109,p)&
{FLOW,(20,21)=__norm#E}[]). 
hprel_ass: [ q_131::char_star<flted_16_130,p>@M |#|  --> U(q_131,p)]
ho_vars: nothing?
res:  1[
    emp&flted_16_130=0&{FLOW,(20,21)=__norm#E}[]
   es_infer_hp_rel: [q_131::char_star<flted_16_130,p>@M |#|  --> U(q_131,p)]
   ]

--dlpi

# Why is infer_obj empty?

 coercion_infer_vars: [U]
 coercion_infer_obj: []

===========================================================================
# ex14g4.slk -dd-esl 4 
# DIFFERS from ex14g3.slk -dd-esl 11

# Why are the dumps of the two proofs different?

infer [U,@pure_field,@classic]
 (exists v_126, q_127: self_lem_12::char_star<v_126,q_127>@M * q_127::WFG<p>@M&v_126!=0 )
 |-  (exists q_109: self_lem_12::WFSeg<q_109>@M * U(q_109,p)). 
   print residue.

# GOT

Residue:
 <1>emp&v_115!=0&{FLOW,(20,21)=__norm#E}[]
[[ Fold ==>  SEARCH ==>  Match(self_lem_12,self_lem_12) ==>  SEARCH ==>  (Lemma ==> lem_12(q_116,q_129)) ==> (left: lem_12) ==>  COND ==>  Match(q_116,q_129) ==>  COND ==>  InferHeap]]

# DIFFERS from ex14g3.slk -dd-esl 11
# HIDDEN

HIDE! id: 17<:11; caller: [11]; line: 30; classic: true; kind: Verify_Lemma; hec_num: 1; evars: [q_142]; impl_vars: []; infer_vars: [ U]; c_heap: emp; others:  es_infer_obj: [] globals: [@pure_field,@leak]
 checkentail self_lem_12::char_star<v_140,q_141>@M * q_141::WFG<p>@M&v_140!=0&
{FLOW,(20,21)=__norm#E}[]
 |-  (exists q_142: U(q_142,p)&self_lem_12=q_142&{FLOW,(20,21)=__norm#E}[]). 
hprel_ass: [ q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)]
ho_vars: nothing?
res:  1[
    emp&v_140!=0&{FLOW,(20,21)=__norm#E}[]
   es_infer_hp_rel: [q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)]
   ]


id: 11; caller: []; line: 0; classic: true; kind: Verify_Lemma; hec_num: 1; evars: []; impl_vars: []; infer_vars: [ U]; c_heap: emp; others:  es_infer_obj: [] globals: [@pure_field,@leak]
 checkentail (exists v_126,
q_127: self_lem_12::char_star<v_126,q_127>@M * q_127::WFG<p>@M&v_126!=0&
{FLOW,(20,21)=__norm#E}[])
 |-  (exists q_109: self_lem_12::WFSeg<q_109>@M * U(q_109,p)&
{FLOW,(20,21)=__norm#E}[]). 

hprel_ass: [ q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)]

ho_vars: nothing?
res:  2[
    emp&v_140!=0&{FLOW,(20,21)=__norm#E}[]
   es_infer_hp_rel: [q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)];
    emp&v_140!=0 & v_143=v_140 & q_144=q_141&{FLOW,(20,21)=__norm#E}[]
   ]
===========================================================================
# ex14b2.slk --dlpi (FIXED)

  lemma_unsafe self::WFG<p> <- U(self,q)*q::char_star<0,p>.

  infer[U,@classic] U(self,q)*q::char_star<0,p> |- self::WFG<p>.
  print residue.
 
 =====================================

 <1>emp&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  (Lemma <== lem_12(UNK)) ==>  Match(UNK) ==>  SEARCH ==>  Match(q,q)]]

 lemma_infer_pred [U] self::WFG<p> <- U(self,q)*q::char_star<0,p>.

# body_view?? // unknown pred U

 head match:WFG
 body view:

# ex14g4.slk --dlpi

 lemma_unsafe
       self::WFG<p> -> (exists q: self::WFSeg<q>*U(q,p)).

 head match:WFG
 body view:WFSeg

!!! **lem_store.ml#42:[Lemma "lem_12":  self::WFG<p>@M&{FLOW,(20,21)=__norm#E}[]<== (exists flted_25_125,
q_126: U(self,q_126) * q_126::char_star<flted_25_125,p>@M&flted_25_125=0&
{FLOW,(20,21)=__norm#E}[])
 head match:WFG
 body view:
 coercion_univ_vars: []
 materialized vars:  []
 coercion_case: Simple
 head:  self::WFG<p>@M&{FLOW,(20,21)=__norm#E}[]
 body:  (exists flted_25_125,
q_126: U(self,q_126) * q_126::char_star<flted_25_125,p>@M&flted_25_125=0&
{FLOW,(20,21)=__norm#E}[])
 head_norm:  (exists p_121: self::WFG<p_121>@M&p_121=p&{FLOW,(20,21)=__norm#E}[])
 body_norm:  EBase 
   (exists flted_25_127,
   q_128: U(self,q_128) * q_128::char_star<flted_25_127,p>@M&flted_25_127=0&
   {FLOW,(20,21)=__norm#E}[])
 coercion_univ_vars: []
 coercion_case: Simple
 coercion_origin: user-given
 coercion_infer_vars: []
 coercion_infer_obj: []
 coercion_kind: LEM_UNSAFE
 coercion_fold: None
]

# no lemma scheduled?

!!! **lemma.ml#259:
Updated lemma store with unsafe repo::[lem_12]
(==solver.ml#11027==)
compute_actions@1
compute_actions inp1 :EQ ptr:[(p_143,p)]
compute_actions inp2 :LHS heap: U(self,q) * q::char_star<flted_27_130,p>@M
compute_actions inp3 :LHS pure: flted_27_130=0
compute_actions inp4 :RHS cand:[ self::WFG<p_143>@M]
compute_actions inp5 :RHS pure: p_143=p
compute_actions inp6 :right alias:[p_143]
compute_actions@1 EXIT: COND =>[
  Prio:2
  InferHeap => ( self::WFG<p_143>@M, emp)
   ;
  Prio:2
  BaseCaseFold =>
    LHS: emp
    RHS: self::WFG<p_143>@M;
  Prio:4
  UnmatchedRHSData =>  self::WFG<p_143>@M
  ]
===========================================================================
# ex14b2.slk (FIXED)

!!! **context.ml#1000:common:[self]
!!! **context.ml#1001:f: U(self,q)
!!! **context.ml#1002:f0: U(self,q) * q::char_star<flted_27_130,p>@M

(==mcpure.ml#2286==)
spatial_ctx_extract@2@1
spatial_ctx_extract inp1 :h_formula: U(self,q) * q::char_star<flted_27_130,p>@M
spatial_ctx_extract inp2 :imm:@M
spatial_ctx_extract inp3 :aset:[self]
spatial_ctx_extract inp4 :rhs_node: self::WFG<p_143>@M
spatial_ctx_extract@2 EXIT:list of match_res:
[ Type: Root
 LHS: self::WFG<p_143>@M
 RHS: self::WFG<p_143>@M
 lhs_rest: U(self,q) * q::char_star<flted_27_130,p>@M
 rhs_rest: emp]
===========================================================================
# ex14b2 --dd-steps (FIXED)

# Can we schedule a matching of UNKNOWN predicates?

!!! **context.ml#2435:process_matches (steps) :
 ### LHS : U(self,q) * q::char_star<flted_27_130,p>@M
 ### RHS : U(self,q_149)
 ### matches :[]
===========================================================================
# ex14b2 --dd-steps (FIXED)

# removed from printing as they are trivial

# Why are there so many NothingToDo? They did not come
  from compute_actions?

!!! **solver.ml#12212:process_action (steps) :
 ### action : NothingToDo => No duplicated nodes!
 ### estate : ex_formula : U(self,q) * q::char_star<flted_27_130,p>@M&flted_27_130=0&{FLOW,(20,21)=__norm#E}[]
 es_heap:emp
 ### conseq :
 (exists flted_25_144,
q_145: U(self,q_145) * q_145::char_star<flted_25_144,p_143>@M&flted_25_144=0&
{FLOW,(20,21)=__norm#E}[])
===========================================================================
# ex14b3.slk -dd-steps (FIXED)


 <1>emp&u=0&{FLOW,(20,21)=__norm#E}[]
[[ Match(UNK) ==>  SEARCH ==>  Match(q,q)]]

# schedule do_match to work with UNK predicates..

!!! **context.ml#2435:process_matches (steps) :
 ### LHS : U(self,q) * q::char_star<flted_8_16,p>@M
 ### RHS : U(self,q1_38)
 ### matches :[]
===========================================================================
# ex14b4a.slk --dd-steps (FIXED)

Added an option:
   --new-base-case-fold-hprel

  infer [U,@classic,@pure_field] self::char_star<0,p> 
    |- U(self,q)*q::char_star<0,p>

# Answer:

 <1>emp&self=q&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [emp&self=q |#|3  --> U(self,q)&true]
[[ SEARCH ==>  BaseCaseFold ==>  SEARCH ==>  Match(self,q)]]

# 11429 is location of base_case_fold operation..

Entail (1) : Fail.(may) cause:UnionR[**solver.ml#11429:,M_unmatched_rhs (infer_collect_hp_rel 3b)]

Residue:
 MaybeErr Context: 
    fe_kind: MAY
    fe_name: separation entailment
    fe_locs: {
        fc_message: do_base_fold_hp_rel (TBI)(U,[self,q])
        fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
      }
    [[ SEARCH ==>  BaseCaseFold]]
   FAIL_UNION 
    fe_kind: MAY
    fe_name: separation entailment
    fe_locs: {
        fc_message: infer_heap_node
        fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
      }
    [[ SEARCH ==>  InferHeap ==>  COND ==>  UnmatchedRHSData]]


# Below is now scheduled as a M_base_case_fold

       | DataNode _,  HRel _  -> 
         (* failwith "TBI"  *)
         let act1 = M_base_case_fold m_res in
         let act2 = M_infer_heap (rhs_node,HEmp) in
         let wt = 2 in
         (wt,Search_action [(wt,act1);(wt,act2)])

I would expect to have:
   self=q <- U(self,q) 
to be generated as a hprel_ass, and
then self=q added as a fold_def prior to do_fold
===========================================================
# ex14b4b.slk (OK)

 infer [U,@classic,@pure_field] self::char_star<0,p> 
   |- U(self,p) .


<1>emp&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [self::char_star<flted_31_104,p>@M&
                   flted_31_104=0 |#|3  --> U(self,p)&true]
[[ SEARCH ==>  InferHeap]]


===========================================================================
# ex14g2.slk (OK)

  lemma_infer [U,@classic,@pure_field] 
       self::WFG<p> -> (exists q: self::WFSeg<q>*U(q,p)).

Two possible outcomes:

    self::WFG<p> -> (exists q: self::WFSeg<q>*q::char_star<0,p>).
    self::WFG<p> -> (exists q: self::WFSeg<q>*q::WFG<p>)

# Why are there two outcomes? Where was the search introduced?
  # choices from folding?

# Perhaps, can choose a state with shorter inferred relational assumption.

Temp Lemma(s) inferred is valid in current context.
Residue:

 <1>emp&{FLOW,(20,21)=__norm#E}[]
    or emp&{FLOW,(20,21)=__norm#E}[]
    
 inferred hprel: [q_131::char_star<flted_16_130,p>@M&
                   flted_16_130=0 |#|3  --> U(q_131,p)&true; 
                  q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M&
                   true |#|3  --> U(q_142,p)&true]
[[ Fold ==>  COND ==>  InferHeap ==> ||OR|| ==>  Fold ==>  COND ==>  InferHeap]]

<2>emp&{FLOW,(20,21)=__norm#E}[]
   or emp&{FLOW,(20,21)=__norm#E}[]
   
inferred hprel: [q_131::char_star<flted_16_130,p>@M&
                  flted_16_130=0 |#|3  --> U(q_131,p)&true]
[[ Fold ==>  SEARCH ==>  Match(self_lem_12,self_lem_12) ==>  SEARCH ==>  (Lemma ==> lem_12(q_141,q_144)) ==> (left: lem_12) ==>  COND ==>  Match(q_141,q_144) ==>  Match(UNK) ==> ||OR|| ==>  Fold ==>  COND ==>  InferHeap]]
===========================================================================
# ex14b5.slk --dlpi

  lemma_infer [U,@classic,@pure_field] self::WFG<p> <- U(self,q)*q::char_star

# How come no relational assumption inferred?
  Was there any unfolding?

 Temp Lemma(s) inferred is valid in current context.
Residue:
 <1>emp&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  (Lemma <== lem_12(UNK)) ==>  Match(UNK) ==>  SEARCH ==>  Match(q_132,q_132)]]

===========================================================================
# ex14b5.slk --dlpi (FIXED - force RHS to be unfolded)

  lemma_infer [U,@classic,@pure_field] self::WFG<p> <- U(self,q)*q::char_star

# How come no relational assumption inferred?
  Was unable to  unfold U(..) on LHS ..

 Temp Lemma(s) inferred is valid in current context.
Residue:
 <1>emp&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  (Lemma <== lem_12(UNK)) ==>  Match(UNK) ==>  SEARCH ==>  Match(q_132,q_132)]]
===========================================================================
# ex14b5.slk 

  lemma_infer [U,@classic,@pure_field] self::WFG<p> <- U(self,q)*q::char_star

Entailing lemma lem_12: Fail. (cex)(may) cause: UnionR[ emp&flted_25_148=0&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.,M_unmatched_rhs (infer_collect_hp_rel 3b)]
===========================================================================
# ex14b5a.slk --dlpi

  infer [U,@classic,@pure_field] U(self,q)*q::char_star<0,p> |- self::char_star<0,p>.

!!! **infer.ml#3951:  classic :true
Entail (1) : Fail.(may) cause:UnionR[base case unfold failed, emp&flted_28_130=0&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.]

!!! **context.ml#2840:compute_action (steps) :
 ### RHS Cand :[ self::char_star<flted_28_149,p_148>@M]
 ### action :
 SEARCH =>[
  Prio:2
  BaseCaseUnfold =>
    LHS: U(self,q)
    RHS: self::char_star<flted_28_149,p_148>@M;
  Prio:2
  InferHeap => ( self::char_star<flted_28_149,p_148>@M, emp)
   
  ]

# I think we may need to schedule two possibilities

  (i)  BaseCaseFold with U(self,q) --> self=q

  (ii) Unfold for Unknown, where:
           U(self,q) --> self::char_star<_,q1>*H(q1,q,self@NI)

I think the notion of InferHeap is too general, and would
need to be dissipated into our more structured commands that
we have already introduced to support verification. This 
instantiation step has been done below, but presumably not 
through sleek?

----------------------------------------------------------\
# Need to schedule a base_case_unfold ..

!!! **context.ml#2465:process_matches (steps) :
 ### LHS : U(self,q) * q::char_star<flted_28_130,p>@M
 ### RHS : self::char_star<flted_28_149,p_148>@M
 ### matches :
[ Type: Root
 LHS: U(self,q)
 RHS: self::char_star<flted_28_149,p_148>@M
 lhs_rest: q::char_star<flted_28_130,p>@M
 rhs_rest: emp]

!!! **context.ml#2833:compute_action (steps) :
 ### RHS Cand :[ self::char_star<flted_28_149,p_148>@M]
 ### action :
 InferHeap => ( self::char_star<flted_28_149,p_148>@M, emp)
===========================================================================
# ex14b5b.slk --dlpi

  infer [U,@classic,@pure_field] U(self,q)*q::char_star<0,p> |- self::char_star<v,qq> * qq::WFG<p> & v!=0.

Entail (1) : Fail.(may) cause:M_unmatched_rhs (infer_collect_hp_rel 3b)

# Need to schedule an unfold for hprel..

!!! **lemma.ml#259:
Updated lemma store with unsafe repo::[lem_12]
!!! **context.ml#2465:process_matches (steps) :
 ### LHS : U(self,q) * q::char_star<flted_28_130,p>@M
 ### RHS : self::char_star<v,qq>@M
 ### matches :
[ Type: Root
 LHS: U(self,q)
 RHS: self::char_star<v,qq>@M
 lhs_rest: q::char_star<flted_28_130,p>@M
 rhs_rest: qq::WFG<p_147>@M]

!!! **context.ml#2465:process_matches (steps) :
 ### LHS : U(self,q) * q::char_star<flted_28_130,p>@M
 ### RHS : qq::WFG<p_147>@M
 ### matches :[]

===========================================================================
# ex14b5a.slk --dlpi

  infer [U,@classic,@pure_field] 
     U(self,q)*q::char_star<0,p> |- self::char_star<0,p>.

 <1>emp&self=q&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U(self,q)&true |#|3  --> emp&self=q]
[[ SEARCH ==>  Unfold 1 ==>  SEARCH ==>  Match(q,self)]]

# Not sure if we need guard of the form:

 [U(self,q)&true |#| q::char_star<0,p>  --> emp&self=q]

Another alternative is:

 U(self,q)&true |#| q::char_star<0,p>  --> 
     self::node<_,qq>*qq::H<q,self@NI> 

But this will subsequently cause a residue problem.

-----------------------------------
[ Type: Root
 LHS: U(self,q)
 RHS: self::char_star<v,qq>@M
 lhs_rest: q::char_star<flted_28_130,p>@M
 rhs_rest: qq::WFG<p_147>@M]

!!! **context.ml#2472:process_matches (steps) :
 ### LHS : U(self,q) * q::char_star<flted_28_130,p>@M
 ### RHS : qq::WFG<p_147>@M
 ### matches :[]

# incorrect compute action!

!!! **context.ml#2840:compute_action (steps) :
 ### RHS Cand :[ self::char_star<v,qq>@M, qq::WFG<p_147>@M]
 ### action :


process_matches@1
process_matches inp1 :lhs_h: U(self,q) * q::char_star<flted_28_130,p>@M
process_matches inp2 :matches:
[ Type: Root
 LHS: U(self,q)
 RHS: self::char_star<v,qq>@M
 lhs_rest: q::char_star<flted_28_130,p>@M
 rhs_rest: qq::WFG<p_147>@M]
process_matches inp3 :rhs_node: self::char_star<v,qq>@M
process_matches inp4 :rhs_rest: qq::WFG<p_147>@M
process_matches@1 EXIT: Prio:2
 SEARCH =>[
  Prio:2
  Unfold 1 =>;
  Prio:2
  InferHeap => ( self::char_star<v,qq>@M, emp)
   
  ]


process_matches@2
process_matches inp1 :lhs_h: U(self,q) * q::char_star<flted_28_130,p>@M
process_matches inp2 :matches:[]
process_matches inp3 :rhs_node: qq::WFG<p_147>@M
process_matches inp4 :rhs_rest: self::char_star<v,qq>@M
process_matches@2 EXIT: Prio:-1
 COND =>[
  Prio:2
  InferHeap => ( qq::WFG<p_147>@M, self::char_star<v,qq>@M)
   ;
  Prio:2
  BaseCaseFold =>;
  Prio:4
  UnmatchedRHSData =>  qq::WFG<p_147>@M
  ]

===========================================================================
# ex16c1.slk (FIXED)

 infer [U,@classic,@pure_field] U(x,q)*q::char_star<0,p>  |- x::WFG<p>.

# Can we trigger lemma, just like ex16c2.slk?

  <1>emp&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [HP_155(p,q@NI)&true |#|3  --> emp&true; 
                  HP_156(q,x@NI)&true |#|3  --> emp&true; 
                  U(x,q) * q::char_star<flted_31_132,p>@M&
                   flted_31_132=0 |#|3  --> x::WFG<p>@M * HP_155(p,q@NI) * 
                                            HP_156(q,x@NI)&
                   true]
[[ SEARCH ==>  InferUnfold ]]

# ex16c2.slk

  infer [@classic,@pure_field] U(x,q)*q::char_star<0,p> 
         |- x::WFG<p>.

[[ SEARCH ==>  (Lemma <== lem_12(UNK)) ==>  Match(UNK) ==>  SEARCH ==>  Match(q,q)]]

===========================================================================
# ex16c3.slk

infer [U,U2,@classic,@pure_field] U(q3,q)*q::char_star<0,p>  |- q3::WFG<p> .



# This schedules an InferUnfold:

!!! **context.ml#2876:compute_action (steps) :
 ### RHS Cand :[ q3::WFG<p_145>@M]
 ### action :
 InferUnfold =>
   LHS: U2(q3,q)
   RHS: q3::WFG<p_145>@M

# Since U2 is inferable, can we also schedule a
  Lemma in the same way as this example:

infer [U,U2,@classic,@pure_field] U(q3,q)*q::char_star<0,p>  |- q3::WFG<p> .

!!! **context.ml#2876:compute_action (steps) :
 ### RHS Cand :[ q3::WFG<p_145>@M]
 ### action :
 SEARCH =>[
  Prio:2
  InferUnfold =>
    LHS: U(q3,q)
    RHS: q3::WFG<p_145>@M;
  Prio:3
  (Lemma <== lem_12) =>
    LHS: U(q3,q)
    RHS: q3::WFG<p_145>@M
  ]

!!! **context.ml#611:XXX body_view:U
!!! **context.ml#612:XXX Matching rhs:U2
(==context.ml#944==)
coerc_mater_match@5@3@2@1
coerc_mater_match inp1 :coercs:[Lemma "lem_12":  self::WFG<p>@M&{FLOW,(20,21)=__norm#E}[]<==]
coerc_mater_match inp2 :WFG
coerc_mater_match inp3 :[q3,p_145]
coerc_mater_match inp4 :[q3]
coerc_mater_match inp5 : U2(q3,q)
coerc_mater_match@5 EXIT:[]

====> if U2 is inferrable..

coerc_mater_match@5 EXIT:[( emp, U3(q3,q), MaterializedArg (self,full,[U]) coerc_defn_mater: <== lem_12)]


(==context.ml#943==)
coerc_mater_match@5@3
coerc_mater_match inp1 :coercs:[Lemma "lem_12":  self::WFG<p>@M&{FLOW,(20,21)=__norm#E}[]<==]
coerc_mater_match inp2 :WFG
coerc_mater_match inp3 :[q3,p_145]
coerc_mater_match inp4 :[q3]
coerc_mater_match inp5 : U(q3,q)
coerc_mater_match@5 EXIT:[( emp, U(q3,q), MaterializedArg (self,full,[U]) coerc_defn_mater: <== lem_12)]

===========================================================================
# ex16c4.slk (FIXED by removing heuristic for matching)

        (* let () = y_winfo_pp "the second condition is heur" in *)
         (* WN : this heuristic caused problem for str-inf/ex16c4.slk *)
         if CP.eq_spec_var hn1 hn2
           (* L2: huer here *)
           (* || (CF.is_exists_hp_rel hn1 estate && eq_fst_ptr (List.map CP.exp_to_sv args1) (List.map CP.exp_to_sv args2)) *)


infer [U2,U,@classic,@pure_field] U2(q3,p)  |- U(q3,p).

Entail (1) : Valid. 
Residue:
 <1>emp&{FLOW,(20,21)=__norm#E}[]
[[ Match(UNK)]]

# How did U2 and U get proven without below?

U2(q3,p) --> U(q3,p)
===========================================================================
# ex16c3b.slk (FIXED)

infer [U2,@classic,@pure_field] U2(q3,q) & D(p)  |- U(q3,qq) & D(qq).
print residue.
// fail
// can we support InferUnfold with instantiation?
//     U2(q3,q) --> U(q3,qq) & qq=q
//  D(p) & qq=q |- D(qq)

# Why did an InferUnfold fail?

!!! **astsimp.ml#8930:impl_var:[]
Entail (2) : Fail.(may) cause:**solver.ml#13222:infer_collect_hp_rel

Residue:

 MaybeErr Context: 
   fe_kind: MAY
   fe_name: separation entailment
   fe_locs: {
     fc_message: infer_heap_node
     fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
   }
 [[ InferUnfold ]]
 CEX:true
===========================================================================
# ex16c3c.slk (FIXED)

infer [U2,@pure_field] U2(q3,q) & q!=null  |- U(q3,qq) .
expect Valid.

# expect Valid since qq is not present on LHS and
can therefore be instanitated.

  U2(q3,q) --> U(q3,qq) & qq=q

-------------------

infer [U2,@pure_field] U2(q3,q) * q::char_star<0,p> & q!=qq  |- U(q3,qq) *qq::char_star<n,p>.
 
infer [U2,@pure_field] U2(q3,q) & q!=qq  |- U(q3,qq) .

# sound instantiation may lead to unsoundness.

 <1>hfalse&false&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U2(q3,q)&q!=q |#|3  --> U(q3,q)&true]

# can we check that qq is not free in LHS before instantiating??
# Also, each such var is instantiated only once.
===========================================================================
# ex16c3c.slk (OK)

infer [U2,@pure_field] U2(q3,q) *q::char_star<0,p>  |- U(q3,qq)*qq::char_star<n,p> .

 <1>emp&qq=q & n=0&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U2(q3,q)&true |#|3  --> U(q3,q)&true]

# Please add the heap guard:

    U2(q3,q)&true |#| q::char<0,_>  --> U(q3,q)&true]
==========================================================================
# ex16c3d.slk: FIXED

infer [U2] U2(q3,q)*q::char_star<0,p>  |- q3::WFG<q> .
print residue.
expect Valid.

# too complex
<1>HP_138(q,q3)&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U2(q3,q) * q::char_star<flted_31_124,p>@M&
                   true |#|3  --> q3::WFG<q>@M * HP_138(q,q3@NI)&true]

# expects 
   U2(q3,q) --> q3::WFG<q>

infer [U2] U2(q3,q)*q::char_star<0,p>  |- q3::WFG<r> .
   U2(q3,q) --> q3::WFG<q4> * HP3(q4,q,q3@NI)

infer [U2] U2(q3,q)*q::char_star<0,p>  |- q3::node<_,r>
   U2(q3,q) --> q3::node<_,q4> * HP3(q4,q,q3@NI)


infer [U2] U2(q3,q)*q::char_star<0,p>  |- q3::WFG<qq> .
print residue.
expect Valid.
//   EXPECTS: U2(q3,q) --> q3::WFG<qq> & qq=q

infer [U2] U2(q3,q)*q::char_star<0,p>  |- q3::WFG<p> .
print residue.
expect Valid.
//   EXPECTS: infer_unfold (on U2) or fold (on WFG)

===========================================================================
# ex16c5b.slk: FIXED

 infer [U2,U3] U2(qq,p) * U3(p,x)  |- qq::char_star<b,p>.

# complex LHS:

 inferred hprel: [U2(qq,p@NI) * U3(p,x@NI)&
                   true |#|3  --> qq::char_star<b_180,p>@M&true]

# expects:

  U2(qq,p@NI) |#|3  --> qq::char_star<b_180,s> * HP(s,p@NI)
  HP(s,p) --> s=p
  U3(p,x) --> emp

--------------------

 infer [U2,U3] U2(qq,p)  |- qq::char_star<b,p>.

# GOT

 <1>emp&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U2(qq,p@NI)&true |#|3  --> qq::char_star<b_167,p>@M&true]
[[ SEARCH ==>  InferUnfold ]]

# BETTER in smaller steps..

  U2(qq,p@NI) |#|3  --> qq::char_star<b_180,s> * HP(s,p@NI)
  HP(s,p) --> s=p
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
