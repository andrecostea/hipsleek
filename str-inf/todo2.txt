# ex14b.slk

  HeapPred U(char_star x,char_star y).
  lemma_infer_pred [U] self::WFG<p> <- U(self,q)*q::char_star<0,p>.

!!! **WARNING****solver.ml#12993:do_match after infer_heap
!!! **solver.ml#12994:rhs_h_matched set:[]
!!! **solver.ml#12995:lhs_h: self_lem_12::WFG<p>@M
!!! **solver.ml#12996:rhs_h: self_lem_12::WFG<p_133>@M
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs :
 HP_134(p,q_132) * HP_135(q_132,self_lem_12)&flted_25_131=0&
{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs :
 HP_137(p,q_132) * HP_138(q_132,self_lem_12)&flted_25_131=0&
{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
Entailing lemma lem_12: Fail. (cex)(may) cause:  emp&flted_25_131=0&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.

!!! fixpoint1:[]
*/

  /*
==> unknown segment
  P(x,d) -> U(x,q) * q::chr<0,d>

==> segmented-pred
  P(x,d) -> U(x,q) * q::chr<v,d>
  U(x,q) -> x=q
  U(x,q) -> x::chr<v,q1>*U(q1,q) & v!=0

===========================================================================
# ex14d.slk

  lemma_infer_pred [U,@classic,@pure_field] self::WFG<p> -> self::WFSeg<q>*U(q,p).

# why is @pure_field not working here?

[ U(q_172,p_173) ::= q_172::char_star<v_174,p_173>@M
 or q_172::char_star<v_174,q_138>@M * q_138::WFG<p_173>@M
 (20,21)]

===========================================================================
# ex14e.slk

  lemma_infer_pred [U,@classic] self::WFG<p> <- self::WFSeg<q>*U(q,p).

# residue problem?

!!! **WARNING****solver.ml#12993:do_match after infer_heap
!!! **solver.ml#12994:rhs_h_matched set:[]
!!! **solver.ml#12995:lhs_h: self_lem_12::WFG<p>@M
!!! **solver.ml#12996:rhs_h: self_lem_12::WFG<p_128>@M
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs : HP_129(p,self_lem_12)&{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs : HP_131(p,self_lem_12)&{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
Entailing lemma lem_12: Fail. (cex)(may) cause:  emp&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.
===========================================================================
# ex14g.slk (FIXED by Loc)

  infer [U,@classic,@pure_field] 
   self::char_star<0,p> |- self::WFSeg<q>*U(q,p) .

# What happen to the pure field inference?

  infer [U,@pure_field] 
   x::char_star<n,p> & n=0 |- U(x,p) .
  print residue.

  inferred hprel: [x::char_star<n,p>@M&true |#|3  --> U(x,p)&true]
   # EXPECTs
   hprel: [x::char_star<n,p>@M& n=0  --> U(x,p)&true]

  infer [U,@pure_field] 
   x::char_star<0,p>  |- U(x,p) .
  print residue.

   hprel: [x::char_star<flted_42_129,p>@M&true |#|3  --> U(x,p)&true]
   # EXPECTs
   hprel: [x::char_star<flted_42_129,p>@M& = flted_42_129null  --> U(x,p)&true]

  infer [U,@classic,@pure_field] 
   self::char_star<0,p> |- self::WFSeg<q>*U(q,p) .
  print residue.

<1>emp&self=q&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [q::char_star<flted_52_120,p>@M&true |#|3  --> U(q,p)&true]
   # EXPECTs
   hprel: [x::char_star<flted_42_129,p>@M& = flted_42_129null  --> U(x,p)&true]
===========================================================================
# ex14g3.slk --esl (WN to fix)

  lemma_infer [U,@pure_field]
       self::WFG<p> -> (exists q: self::WFSeg<q>*U(q,p)).

# Why is @pure_field mssing in entail_state?

id: 4; caller: []; line: 0; classic: true; kind: Verify_Lemma; hec_num: 1; evars: []; impl_vars: []; infer_vars: [ U]; c_heap: emp; others:  es_infer_obj: [] globals: [@leak]
 checkentail (exists flted_16_124: self_lem_12::char_star<flted_16_124,p>@M&
flted_16_124=0&{FLOW,(20,21)=__norm#E}[])
 |-  (exists q_109: self_lem_12::WFSeg<q_109>@M * U(q_109,p)&
{FLOW,(20,21)=__norm#E}[]). 
hprel_ass: [ q_131::char_star<flted_16_130,p>@M |#|  --> U(q_131,p)]
ho_vars: nothing?
res:  1[
    emp&flted_16_130=0&{FLOW,(20,21)=__norm#E}[]
   es_infer_hp_rel: [q_131::char_star<flted_16_130,p>@M |#|  --> U(q_131,p)]
   ]

--dlpi

# Why is infer_obj empty?

 coercion_infer_vars: [U]
 coercion_infer_obj: []

===========================================================================
# ex14g4.slk --esl (Loc?)

  lemma_infer [U,@pure_field]
       self::WFG<p> -> (exists q: self::WFSeg<q>*U(q,p)).

# GOT

Residue:
 <1>emp&v_115!=0&{FLOW,(20,21)=__norm#E}[]
[[ Fold ==>  SEARCH ==>  Match(self_lem_12,self_lem_12) ==>  SEARCH ==>  (Lemma ==> lem_12(q_116,q_129)) ==> (left: lem_12) ==>  COND ==>  Match(q_116,q_129) ==>  COND ==>  InferHeap]]

# DIFFERS from ex14g3.slk --esl

id: 11; caller: []; line: 0; classic: true; kind: Verify_Lemma; hec_num: 1; evars: []; impl_vars: []; infer_vars: [ U]; c_heap: emp; others:  es_infer_obj: [] globals: [@pure_field,@leak]
 checkentail (exists v_126,
q_127: self_lem_12::char_star<v_126,q_127>@M * q_127::WFG<p>@M&v_126!=0&
{FLOW,(20,21)=__norm#E}[])
 |-  (exists q_109: self_lem_12::WFSeg<q_109>@M * U(q_109,p)&
{FLOW,(20,21)=__norm#E}[]). 
hprel_ass: [ q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)]
ho_vars: nothing?
res:  2[
    emp&v_140!=0&{FLOW,(20,21)=__norm#E}[]
   es_infer_hp_rel: [q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)];
    emp&v_140!=0 & v_143=v_140 & q_144=q_141&{FLOW,(20,21)=__norm#E}[]
   ]
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
