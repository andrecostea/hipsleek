# ex14b.slk

  HeapPred U(char_star x,char_star y).
  lemma_infer_pred [U] self::WFG<p> <- U(self,q)*q::char_star<0,p>.

!!! **WARNING****solver.ml#12993:do_match after infer_heap
!!! **solver.ml#12994:rhs_h_matched set:[]
!!! **solver.ml#12995:lhs_h: self_lem_12::WFG<p>@M
!!! **solver.ml#12996:rhs_h: self_lem_12::WFG<p_133>@M
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs :
 HP_134(p,q_132) * HP_135(q_132,self_lem_12)&flted_25_131=0&
{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs :
 HP_137(p,q_132) * HP_138(q_132,self_lem_12)&flted_25_131=0&
{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
Entailing lemma lem_12: Fail. (cex)(may) cause:  emp&flted_25_131=0&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.

!!! fixpoint1:[]
*/

  /*
==> unknown segment
  P(x,d) -> U(x,q) * q::chr<0,d>

==> segmented-pred
  P(x,d) -> U(x,q) * q::chr<v,d>
  U(x,q) -> x=q
  U(x,q) -> x::chr<v,q1>*U(q1,q) & v!=0

===========================================================================
# ex14d.slk

  lemma_infer_pred [U,@classic,@pure_field] self::WFG<p> -> self::WFSeg<q>*U(q,p).

# why is @pure_field not working here?

[ U(q_172,p_173) ::= q_172::char_star<v_174,p_173>@M
 or q_172::char_star<v_174,q_138>@M * q_138::WFG<p_173>@M
 (20,21)]

===========================================================================
# ex14e.slk

  lemma_infer_pred [U,@classic] self::WFG<p> <- self::WFSeg<q>*U(q,p).

# residue problem?

!!! **WARNING****solver.ml#12993:do_match after infer_heap
!!! **solver.ml#12994:rhs_h_matched set:[]
!!! **solver.ml#12995:lhs_h: self_lem_12::WFG<p>@M
!!! **solver.ml#12996:rhs_h: self_lem_12::WFG<p_128>@M
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs : HP_129(p,self_lem_12)&{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs : HP_131(p,self_lem_12)&{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
Entailing lemma lem_12: Fail. (cex)(may) cause:  emp&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.
===========================================================================
# ex14g.slk (FIXED by Loc)

  infer [U,@classic,@pure_field] 
   self::char_star<0,p> |- self::WFSeg<q>*U(q,p) .

# What happen to the pure field inference?

  infer [U,@pure_field] 
   x::char_star<n,p> & n=0 |- U(x,p) .
  print residue.

  inferred hprel: [x::char_star<n,p>@M&true |#|3  --> U(x,p)&true]
   # EXPECTs
   hprel: [x::char_star<n,p>@M& n=0  --> U(x,p)&true]

  infer [U,@pure_field] 
   x::char_star<0,p>  |- U(x,p) .
  print residue.

   hprel: [x::char_star<flted_42_129,p>@M&true |#|3  --> U(x,p)&true]
   # EXPECTs
   hprel: [x::char_star<flted_42_129,p>@M& = flted_42_129null  --> U(x,p)&true]

  infer [U,@classic,@pure_field] 
   self::char_star<0,p> |- self::WFSeg<q>*U(q,p) .
  print residue.

<1>emp&self=q&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [q::char_star<flted_52_120,p>@M&true |#|3  --> U(q,p)&true]
   # EXPECTs
   hprel: [x::char_star<flted_42_129,p>@M& = flted_42_129null  --> U(x,p)&true]
===========================================================================
# ex14g3.slk --esl (WN to fix)

  lemma_infer [U,@pure_field]
       self::WFG<p> -> (exists q: self::WFSeg<q>*U(q,p)).

# Why is @pure_field mssing in entail_state?

id: 4; caller: []; line: 0; classic: true; kind: Verify_Lemma; hec_num: 1; evars: []; impl_vars: []; infer_vars: [ U]; c_heap: emp; others:  es_infer_obj: [] globals: [@leak]
 checkentail (exists flted_16_124: self_lem_12::char_star<flted_16_124,p>@M&
flted_16_124=0&{FLOW,(20,21)=__norm#E}[])
 |-  (exists q_109: self_lem_12::WFSeg<q_109>@M * U(q_109,p)&
{FLOW,(20,21)=__norm#E}[]). 
hprel_ass: [ q_131::char_star<flted_16_130,p>@M |#|  --> U(q_131,p)]
ho_vars: nothing?
res:  1[
    emp&flted_16_130=0&{FLOW,(20,21)=__norm#E}[]
   es_infer_hp_rel: [q_131::char_star<flted_16_130,p>@M |#|  --> U(q_131,p)]
   ]

--dlpi

# Why is infer_obj empty?

 coercion_infer_vars: [U]
 coercion_infer_obj: []

===========================================================================
# ex14g4.slk --esl (Loc?)

  lemma_infer [U,@pure_field]
       self::WFG<p> -> (exists q: self::WFSeg<q>*U(q,p)).

# GOT

Residue:
 <1>emp&v_115!=0&{FLOW,(20,21)=__norm#E}[]
[[ Fold ==>  SEARCH ==>  Match(self_lem_12,self_lem_12) ==>  SEARCH ==>  (Lemma ==> lem_12(q_116,q_129)) ==> (left: lem_12) ==>  COND ==>  Match(q_116,q_129) ==>  COND ==>  InferHeap]]

# DIFFERS from ex14g3.slk --esl
# HIDDEN

HIDE! id: 17<:11; caller: [11]; line: 30; classic: true; kind: Verify_Lemma; hec_num: 1; evars: [q_142]; impl_vars: []; infer_vars: [ U]; c_heap: emp; others:  es_infer_obj: [] globals: [@pure_field,@leak]
 checkentail self_lem_12::char_star<v_140,q_141>@M * q_141::WFG<p>@M&v_140!=0&
{FLOW,(20,21)=__norm#E}[]
 |-  (exists q_142: U(q_142,p)&self_lem_12=q_142&{FLOW,(20,21)=__norm#E}[]). 
hprel_ass: [ q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)]
ho_vars: nothing?
res:  1[
    emp&v_140!=0&{FLOW,(20,21)=__norm#E}[]
   es_infer_hp_rel: [q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)]
   ]


id: 11; caller: []; line: 0; classic: true; kind: Verify_Lemma; hec_num: 1; evars: []; impl_vars: []; infer_vars: [ U]; c_heap: emp; others:  es_infer_obj: [] globals: [@pure_field,@leak]
 checkentail (exists v_126,
q_127: self_lem_12::char_star<v_126,q_127>@M * q_127::WFG<p>@M&v_126!=0&
{FLOW,(20,21)=__norm#E}[])
 |-  (exists q_109: self_lem_12::WFSeg<q_109>@M * U(q_109,p)&
{FLOW,(20,21)=__norm#E}[]). 
hprel_ass: [ q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)]
ho_vars: nothing?
res:  2[
    emp&v_140!=0&{FLOW,(20,21)=__norm#E}[]
   es_infer_hp_rel: [q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)];
    emp&v_140!=0 & v_143=v_140 & q_144=q_141&{FLOW,(20,21)=__norm#E}[]
   ]
===========================================================================
# ex14b2.slk --dlpi (WN to fix)

 lemma_infer_pred [U] self::WFG<p> <- U(self,q)*q::char_star<0,p>.

# body_view?? // unknown pred U

 head match:WFG
 body view:

# ex14g4.slk --dlpi

 lemma_unsafe
       self::WFG<p> -> (exists q: self::WFSeg<q>*U(q,p)).

 head match:WFG
 body view:WFSeg

!!! **lem_store.ml#42:[Lemma "lem_12":  self::WFG<p>@M&{FLOW,(20,21)=__norm#E}[]<== (exists flted_25_125,
q_126: U(self,q_126) * q_126::char_star<flted_25_125,p>@M&flted_25_125=0&
{FLOW,(20,21)=__norm#E}[])
 head match:WFG
 body view:
 coercion_univ_vars: []
 materialized vars:  []
 coercion_case: Simple
 head:  self::WFG<p>@M&{FLOW,(20,21)=__norm#E}[]
 body:  (exists flted_25_125,
q_126: U(self,q_126) * q_126::char_star<flted_25_125,p>@M&flted_25_125=0&
{FLOW,(20,21)=__norm#E}[])
 head_norm:  (exists p_121: self::WFG<p_121>@M&p_121=p&{FLOW,(20,21)=__norm#E}[])
 body_norm:  EBase 
   (exists flted_25_127,
   q_128: U(self,q_128) * q_128::char_star<flted_25_127,p>@M&flted_25_127=0&
   {FLOW,(20,21)=__norm#E}[])
 coercion_univ_vars: []
 coercion_case: Simple
 coercion_origin: user-given
 coercion_infer_vars: []
 coercion_infer_obj: []
 coercion_kind: LEM_UNSAFE
 coercion_fold: None
]

# no lemma scheduled?

!!! **lemma.ml#259:
Updated lemma store with unsafe repo::[lem_12]
(==solver.ml#11027==)
compute_actions@1
compute_actions inp1 :EQ ptr:[(p_143,p)]
compute_actions inp2 :LHS heap: U(self,q) * q::char_star<flted_27_130,p>@M
compute_actions inp3 :LHS pure: flted_27_130=0
compute_actions inp4 :RHS cand:[ self::WFG<p_143>@M]
compute_actions inp5 :RHS pure: p_143=p
compute_actions inp6 :right alias:[p_143]
compute_actions@1 EXIT: COND =>[
  Prio:2
  InferHeap => ( self::WFG<p_143>@M, emp)
   ;
  Prio:2
  BaseCaseFold =>
    LHS: emp
    RHS: self::WFG<p_143>@M;
  Prio:4
  UnmatchedRHSData =>  self::WFG<p_143>@M
  ]
===========================================================================
# ex14b2.slk

!!! **context.ml#1000:common:[self]
!!! **context.ml#1001:f: U(self,q)
!!! **context.ml#1002:f0: U(self,q) * q::char_star<flted_27_130,p>@M

(==mcpure.ml#2286==)
spatial_ctx_extract@2@1
spatial_ctx_extract inp1 :h_formula: U(self,q) * q::char_star<flted_27_130,p>@M
spatial_ctx_extract inp2 :imm:@M
spatial_ctx_extract inp3 :aset:[self]
spatial_ctx_extract inp4 :rhs_node: self::WFG<p_143>@M
spatial_ctx_extract@2 EXIT:list of match_res:
[ Type: Root
 LHS: self::WFG<p_143>@M
 RHS: self::WFG<p_143>@M
 lhs_rest: U(self,q) * q::char_star<flted_27_130,p>@M
 rhs_rest: emp]
===========================================================================
===========================================================================
===========================================================================
===========================================================================
