# ex14b.slk

  HeapPred U(char_star x,char_star y).
  lemma_infer_pred [U] self::WFG<p> <- U(self,q)*q::char_star<0,p>.

!!! **WARNING****solver.ml#12993:do_match after infer_heap
!!! **solver.ml#12994:rhs_h_matched set:[]
!!! **solver.ml#12995:lhs_h: self_lem_12::WFG<p>@M
!!! **solver.ml#12996:rhs_h: self_lem_12::WFG<p_133>@M
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs :
 HP_134(p,q_132) * HP_135(q_132,self_lem_12)&flted_25_131=0&
{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs :
 HP_137(p,q_132) * HP_138(q_132,self_lem_12)&flted_25_131=0&
{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
Entailing lemma lem_12: Fail. (cex)(may) cause:  emp&flted_25_131=0&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.

!!! fixpoint1:[]
*/

  /*
==> unknown segment
  P(x,d) -> U(x,q) * q::chr<0,d>

==> segmented-pred
  P(x,d) -> U(x,q) * q::chr<v,d>
  U(x,q) -> x=q
  U(x,q) -> x::chr<v,q1>*U(q1,q) & v!=0

===========================================================================
# ex14d.slk

  lemma_infer_pred [U,@classic,@pure_field] self::WFG<p> -> self::WFSeg<q>*U(q,p).

# why is @pure_field not working here?

[ U(q_172,p_173) ::= q_172::char_star<v_174,p_173>@M
 or q_172::char_star<v_174,q_138>@M * q_138::WFG<p_173>@M
 (20,21)]

===========================================================================
# ex14e.slk

  lemma_infer_pred [U,@classic] self::WFG<p> <- self::WFSeg<q>*U(q,p).

# residue problem?

!!! **WARNING****solver.ml#12993:do_match after infer_heap
!!! **solver.ml#12994:rhs_h_matched set:[]
!!! **solver.ml#12995:lhs_h: self_lem_12::WFG<p>@M
!!! **solver.ml#12996:rhs_h: self_lem_12::WFG<p_128>@M
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs : HP_129(p,self_lem_12)&{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
!!! **infer.ml#3897:>>>>>> infer_hp_rel <<<<<<
!!! **infer.ml#3898:  lhs : HP_131(p,self_lem_12)&{FLOW,(20,21)=__norm#E}[]
!!! **infer.ml#3899:  classic :true
Entailing lemma lem_12: Fail. (cex)(may) cause:  emp&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.
===========================================================================
# ex14g.slk (FIXED by Loc)

  infer [U,@classic,@pure_field] 
   self::char_star<0,p> |- self::WFSeg<q>*U(q,p) .

# What happen to the pure field inference?

  infer [U,@pure_field] 
   x::char_star<n,p> & n=0 |- U(x,p) .
  print residue.

  inferred hprel: [x::char_star<n,p>@M&true |#|3  --> U(x,p)&true]
   # EXPECTs
   hprel: [x::char_star<n,p>@M& n=0  --> U(x,p)&true]

  infer [U,@pure_field] 
   x::char_star<0,p>  |- U(x,p) .
  print residue.

   hprel: [x::char_star<flted_42_129,p>@M&true |#|3  --> U(x,p)&true]
   # EXPECTs
   hprel: [x::char_star<flted_42_129,p>@M& = flted_42_129null  --> U(x,p)&true]

  infer [U,@classic,@pure_field] 
   self::char_star<0,p> |- self::WFSeg<q>*U(q,p) .
  print residue.

<1>emp&self=q&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [q::char_star<flted_52_120,p>@M&true |#|3  --> U(q,p)&true]
   # EXPECTs
   hprel: [x::char_star<flted_42_129,p>@M& = flted_42_129null  --> U(x,p)&true]
===========================================================================
# ex14g3.slk --esl (WN to fix)

  lemma_infer [U,@pure_field]
       self::WFG<p> -> (exists q: self::WFSeg<q>*U(q,p)).

# Why is @pure_field mssing in entail_state?

id: 4; caller: []; line: 0; classic: true; kind: Verify_Lemma; hec_num: 1; evars: []; impl_vars: []; infer_vars: [ U]; c_heap: emp; others:  es_infer_obj: [] globals: [@leak]
 checkentail (exists flted_16_124: self_lem_12::char_star<flted_16_124,p>@M&
flted_16_124=0&{FLOW,(20,21)=__norm#E}[])
 |-  (exists q_109: self_lem_12::WFSeg<q_109>@M * U(q_109,p)&
{FLOW,(20,21)=__norm#E}[]). 
hprel_ass: [ q_131::char_star<flted_16_130,p>@M |#|  --> U(q_131,p)]
ho_vars: nothing?
res:  1[
    emp&flted_16_130=0&{FLOW,(20,21)=__norm#E}[]
   es_infer_hp_rel: [q_131::char_star<flted_16_130,p>@M |#|  --> U(q_131,p)]
   ]

--dlpi

# Why is infer_obj empty?

 coercion_infer_vars: [U]
 coercion_infer_obj: []

===========================================================================
# ex14g4.slk -dd-esl 4 
# DIFFERS from ex14g3.slk -dd-esl 11

# Why are the dumps of the two proofs different?

infer [U,@pure_field,@classic]
 (exists v_126, q_127: self_lem_12::char_star<v_126,q_127>@M * q_127::WFG<p>@M&v_126!=0 )
 |-  (exists q_109: self_lem_12::WFSeg<q_109>@M * U(q_109,p)). 
   print residue.

# GOT

Residue:
 <1>emp&v_115!=0&{FLOW,(20,21)=__norm#E}[]
[[ Fold ==>  SEARCH ==>  Match(self_lem_12,self_lem_12) ==>  SEARCH ==>  (Lemma ==> lem_12(q_116,q_129)) ==> (left: lem_12) ==>  COND ==>  Match(q_116,q_129) ==>  COND ==>  InferHeap]]

# DIFFERS from ex14g3.slk -dd-esl 11
# HIDDEN

HIDE! id: 17<:11; caller: [11]; line: 30; classic: true; kind: Verify_Lemma; hec_num: 1; evars: [q_142]; impl_vars: []; infer_vars: [ U]; c_heap: emp; others:  es_infer_obj: [] globals: [@pure_field,@leak]
 checkentail self_lem_12::char_star<v_140,q_141>@M * q_141::WFG<p>@M&v_140!=0&
{FLOW,(20,21)=__norm#E}[]
 |-  (exists q_142: U(q_142,p)&self_lem_12=q_142&{FLOW,(20,21)=__norm#E}[]). 
hprel_ass: [ q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)]
ho_vars: nothing?
res:  1[
    emp&v_140!=0&{FLOW,(20,21)=__norm#E}[]
   es_infer_hp_rel: [q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)]
   ]


id: 11; caller: []; line: 0; classic: true; kind: Verify_Lemma; hec_num: 1; evars: []; impl_vars: []; infer_vars: [ U]; c_heap: emp; others:  es_infer_obj: [] globals: [@pure_field,@leak]
 checkentail (exists v_126,
q_127: self_lem_12::char_star<v_126,q_127>@M * q_127::WFG<p>@M&v_126!=0&
{FLOW,(20,21)=__norm#E}[])
 |-  (exists q_109: self_lem_12::WFSeg<q_109>@M * U(q_109,p)&
{FLOW,(20,21)=__norm#E}[]). 

hprel_ass: [ q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)]

ho_vars: nothing?
res:  2[
    emp&v_140!=0&{FLOW,(20,21)=__norm#E}[]
   es_infer_hp_rel: [q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M |#|  --> U(q_142,p)];
    emp&v_140!=0 & v_143=v_140 & q_144=q_141&{FLOW,(20,21)=__norm#E}[]
   ]
===========================================================================
# ex14b2.slk --dlpi (FIXED)

  lemma_unsafe self::WFG<p> <- U(self,q)*q::char_star<0,p>.

  infer[U,@classic] U(self,q)*q::char_star<0,p> |- self::WFG<p>.
  print residue.
 
 =====================================

 <1>emp&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  (Lemma <== lem_12(UNK)) ==>  Match(UNK) ==>  SEARCH ==>  Match(q,q)]]

 lemma_infer_pred [U] self::WFG<p> <- U(self,q)*q::char_star<0,p>.

# body_view?? // unknown pred U

 head match:WFG
 body view:

# ex14g4.slk --dlpi

 lemma_unsafe
       self::WFG<p> -> (exists q: self::WFSeg<q>*U(q,p)).

 head match:WFG
 body view:WFSeg

!!! **lem_store.ml#42:[Lemma "lem_12":  self::WFG<p>@M&{FLOW,(20,21)=__norm#E}[]<== (exists flted_25_125,
q_126: U(self,q_126) * q_126::char_star<flted_25_125,p>@M&flted_25_125=0&
{FLOW,(20,21)=__norm#E}[])
 head match:WFG
 body view:
 coercion_univ_vars: []
 materialized vars:  []
 coercion_case: Simple
 head:  self::WFG<p>@M&{FLOW,(20,21)=__norm#E}[]
 body:  (exists flted_25_125,
q_126: U(self,q_126) * q_126::char_star<flted_25_125,p>@M&flted_25_125=0&
{FLOW,(20,21)=__norm#E}[])
 head_norm:  (exists p_121: self::WFG<p_121>@M&p_121=p&{FLOW,(20,21)=__norm#E}[])
 body_norm:  EBase 
   (exists flted_25_127,
   q_128: U(self,q_128) * q_128::char_star<flted_25_127,p>@M&flted_25_127=0&
   {FLOW,(20,21)=__norm#E}[])
 coercion_univ_vars: []
 coercion_case: Simple
 coercion_origin: user-given
 coercion_infer_vars: []
 coercion_infer_obj: []
 coercion_kind: LEM_UNSAFE
 coercion_fold: None
]

# no lemma scheduled?

!!! **lemma.ml#259:
Updated lemma store with unsafe repo::[lem_12]
(==solver.ml#11027==)
compute_actions@1
compute_actions inp1 :EQ ptr:[(p_143,p)]
compute_actions inp2 :LHS heap: U(self,q) * q::char_star<flted_27_130,p>@M
compute_actions inp3 :LHS pure: flted_27_130=0
compute_actions inp4 :RHS cand:[ self::WFG<p_143>@M]
compute_actions inp5 :RHS pure: p_143=p
compute_actions inp6 :right alias:[p_143]
compute_actions@1 EXIT: COND =>[
  Prio:2
  InferHeap => ( self::WFG<p_143>@M, emp)
   ;
  Prio:2
  BaseCaseFold =>
    LHS: emp
    RHS: self::WFG<p_143>@M;
  Prio:4
  UnmatchedRHSData =>  self::WFG<p_143>@M
  ]
===========================================================================
# ex14b2.slk (FIXED)

!!! **context.ml#1000:common:[self]
!!! **context.ml#1001:f: U(self,q)
!!! **context.ml#1002:f0: U(self,q) * q::char_star<flted_27_130,p>@M

(==mcpure.ml#2286==)
spatial_ctx_extract@2@1
spatial_ctx_extract inp1 :h_formula: U(self,q) * q::char_star<flted_27_130,p>@M
spatial_ctx_extract inp2 :imm:@M
spatial_ctx_extract inp3 :aset:[self]
spatial_ctx_extract inp4 :rhs_node: self::WFG<p_143>@M
spatial_ctx_extract@2 EXIT:list of match_res:
[ Type: Root
 LHS: self::WFG<p_143>@M
 RHS: self::WFG<p_143>@M
 lhs_rest: U(self,q) * q::char_star<flted_27_130,p>@M
 rhs_rest: emp]
===========================================================================
# ex14b2 --dd-steps (FIXED)

# Can we schedule a matching of UNKNOWN predicates?

!!! **context.ml#2435:process_matches (steps) :
 ### LHS : U(self,q) * q::char_star<flted_27_130,p>@M
 ### RHS : U(self,q_149)
 ### matches :[]
===========================================================================
# ex14b2 --dd-steps (FIXED)

# removed from printing as they are trivial

# Why are there so many NothingToDo? They did not come
  from compute_actions?

!!! **solver.ml#12212:process_action (steps) :
 ### action : NothingToDo => No duplicated nodes!
 ### estate : ex_formula : U(self,q) * q::char_star<flted_27_130,p>@M&flted_27_130=0&{FLOW,(20,21)=__norm#E}[]
 es_heap:emp
 ### conseq :
 (exists flted_25_144,
q_145: U(self,q_145) * q_145::char_star<flted_25_144,p_143>@M&flted_25_144=0&
{FLOW,(20,21)=__norm#E}[])
===========================================================================
# ex14b3.slk -dd-steps (FIXED)


 <1>emp&u=0&{FLOW,(20,21)=__norm#E}[]
[[ Match(UNK) ==>  SEARCH ==>  Match(q,q)]]

# schedule do_match to work with UNK predicates..

!!! **context.ml#2435:process_matches (steps) :
 ### LHS : U(self,q) * q::char_star<flted_8_16,p>@M
 ### RHS : U(self,q1_38)
 ### matches :[]
===========================================================================
# ex14b4a.slk --dd-steps (FIXED)

Added an option:
   --new-base-case-fold-hprel

  infer [U,@classic,@pure_field] self::char_star<0,p> 
    |- U(self,q)*q::char_star<0,p>

# Answer:

 <1>emp&self=q&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [emp&self=q |#|3  --> U(self,q)&true]
[[ SEARCH ==>  BaseCaseFold ==>  SEARCH ==>  Match(self,q)]]

# 11429 is location of base_case_fold operation..

Entail (1) : Fail.(may) cause:UnionR[**solver.ml#11429:,M_unmatched_rhs (infer_collect_hp_rel 3b)]

Residue:
 MaybeErr Context: 
    fe_kind: MAY
    fe_name: separation entailment
    fe_locs: {
        fc_message: do_base_fold_hp_rel (TBI)(U,[self,q])
        fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
      }
    [[ SEARCH ==>  BaseCaseFold]]
   FAIL_UNION 
    fe_kind: MAY
    fe_name: separation entailment
    fe_locs: {
        fc_message: infer_heap_node
        fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
      }
    [[ SEARCH ==>  InferHeap ==>  COND ==>  UnmatchedRHSData]]


# Below is now scheduled as a M_base_case_fold

       | DataNode _,  HRel _  -> 
         (* failwith "TBI"  *)
         let act1 = M_base_case_fold m_res in
         let act2 = M_infer_heap (rhs_node,HEmp) in
         let wt = 2 in
         (wt,Search_action [(wt,act1);(wt,act2)])

I would expect to have:
   self=q <- U(self,q) 
to be generated as a hprel_ass, and
then self=q added as a fold_def prior to do_fold
===========================================================
# ex14b4b.slk (OK)

 infer [U,@classic,@pure_field] self::char_star<0,p> 
   |- U(self,p) .


<1>emp&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [self::char_star<flted_31_104,p>@M&
                   flted_31_104=0 |#|3  --> U(self,p)&true]
[[ SEARCH ==>  InferHeap]]


===========================================================================
# ex14g2.slk (OK)

  lemma_infer [U,@classic,@pure_field] 
       self::WFG<p> -> (exists q: self::WFSeg<q>*U(q,p)).

Two possible outcomes:

    self::WFG<p> -> (exists q: self::WFSeg<q>*q::char_star<0,p>).
    self::WFG<p> -> (exists q: self::WFSeg<q>*q::WFG<p>)

# Why are there two outcomes? Where was the search introduced?
  # choices from folding?

# Perhaps, can choose a state with shorter inferred relational assumption.

Temp Lemma(s) inferred is valid in current context.
Residue:

 <1>emp&{FLOW,(20,21)=__norm#E}[]
    or emp&{FLOW,(20,21)=__norm#E}[]
    
 inferred hprel: [q_131::char_star<flted_16_130,p>@M&
                   flted_16_130=0 |#|3  --> U(q_131,p)&true; 
                  q_142::char_star<v_140,q_141>@M * q_141::WFG<p>@M&
                   true |#|3  --> U(q_142,p)&true]
[[ Fold ==>  COND ==>  InferHeap ==> ||OR|| ==>  Fold ==>  COND ==>  InferHeap]]

<2>emp&{FLOW,(20,21)=__norm#E}[]
   or emp&{FLOW,(20,21)=__norm#E}[]
   
inferred hprel: [q_131::char_star<flted_16_130,p>@M&
                  flted_16_130=0 |#|3  --> U(q_131,p)&true]
[[ Fold ==>  SEARCH ==>  Match(self_lem_12,self_lem_12) ==>  SEARCH ==>  (Lemma ==> lem_12(q_141,q_144)) ==> (left: lem_12) ==>  COND ==>  Match(q_141,q_144) ==>  Match(UNK) ==> ||OR|| ==>  Fold ==>  COND ==>  InferHeap]]
===========================================================================
# ex14b5.slk --dlpi

  lemma_infer [U,@classic,@pure_field] self::WFG<p> <- U(self,q)*q::char_star

# How come no relational assumption inferred?
  Was there any unfolding?

 Temp Lemma(s) inferred is valid in current context.
Residue:
 <1>emp&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  (Lemma <== lem_12(UNK)) ==>  Match(UNK) ==>  SEARCH ==>  Match(q_132,q_132)]]

===========================================================================
# ex14b5.slk --dlpi (FIXED - force RHS to be unfolded)

  lemma_infer [U,@classic,@pure_field] self::WFG<p> <- U(self,q)*q::char_star

# How come no relational assumption inferred?
  Was unable to  unfold U(..) on LHS ..

 Temp Lemma(s) inferred is valid in current context.
Residue:
 <1>emp&{FLOW,(20,21)=__norm#E}[]
[[ SEARCH ==>  (Lemma <== lem_12(UNK)) ==>  Match(UNK) ==>  SEARCH ==>  Match(q_132,q_132)]]
===========================================================================
# ex14b5.slk 

  lemma_infer [U,@classic,@pure_field] self::WFG<p> <- U(self,q)*q::char_star

Entailing lemma lem_12: Fail. (cex)(may) cause: UnionR[ emp&flted_25_148=0&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.,M_unmatched_rhs (infer_collect_hp_rel 3b)]
===========================================================================
# ex14b5a.slk --dlpi

  infer [U,@classic,@pure_field] U(self,q)*q::char_star<0,p> |- self::char_star<0,p>.

!!! **infer.ml#3951:  classic :true
Entail (1) : Fail.(may) cause:UnionR[base case unfold failed, emp&flted_28_130=0&{FLOW,(20,21)=__norm#E}[]: possible memory leak failure : residue is forbidden.]

!!! **context.ml#2840:compute_action (steps) :
 ### RHS Cand :[ self::char_star<flted_28_149,p_148>@M]
 ### action :
 SEARCH =>[
  Prio:2
  BaseCaseUnfold =>
    LHS: U(self,q)
    RHS: self::char_star<flted_28_149,p_148>@M;
  Prio:2
  InferHeap => ( self::char_star<flted_28_149,p_148>@M, emp)
   
  ]

# I think we may need to schedule two possibilities

  (i)  BaseCaseFold with U(self,q) --> self=q

  (ii) Unfold for Unknown, where:
           U(self,q) --> self::char_star<_,q1>*H(q1,q,self@NI)

I think the notion of InferHeap is too general, and would
need to be dissipated into our more structured commands that
we have already introduced to support verification. This 
instantiation step has been done below, but presumably not 
through sleek?

----------------------------------------------------------\
# Need to schedule a base_case_unfold ..

!!! **context.ml#2465:process_matches (steps) :
 ### LHS : U(self,q) * q::char_star<flted_28_130,p>@M
 ### RHS : self::char_star<flted_28_149,p_148>@M
 ### matches :
[ Type: Root
 LHS: U(self,q)
 RHS: self::char_star<flted_28_149,p_148>@M
 lhs_rest: q::char_star<flted_28_130,p>@M
 rhs_rest: emp]

!!! **context.ml#2833:compute_action (steps) :
 ### RHS Cand :[ self::char_star<flted_28_149,p_148>@M]
 ### action :
 InferHeap => ( self::char_star<flted_28_149,p_148>@M, emp)
===========================================================================
# ex14b5b.slk --dlpi

  infer [U,@classic,@pure_field] U(self,q)*q::char_star<0,p> |- self::char_star<v,qq> * qq::WFG<p> & v!=0.

Entail (1) : Fail.(may) cause:M_unmatched_rhs (infer_collect_hp_rel 3b)

# Need to schedule an unfold for hprel..

!!! **lemma.ml#259:
Updated lemma store with unsafe repo::[lem_12]
!!! **context.ml#2465:process_matches (steps) :
 ### LHS : U(self,q) * q::char_star<flted_28_130,p>@M
 ### RHS : self::char_star<v,qq>@M
 ### matches :
[ Type: Root
 LHS: U(self,q)
 RHS: self::char_star<v,qq>@M
 lhs_rest: q::char_star<flted_28_130,p>@M
 rhs_rest: qq::WFG<p_147>@M]

!!! **context.ml#2465:process_matches (steps) :
 ### LHS : U(self,q) * q::char_star<flted_28_130,p>@M
 ### RHS : qq::WFG<p_147>@M
 ### matches :[]

===========================================================================
# ex14b5a.slk --dlpi

  infer [U,@classic,@pure_field] 
     U(self,q)*q::char_star<0,p> |- self::char_star<0,p>.

 <1>emp&self=q&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U(self,q)&true |#|3  --> emp&self=q]
[[ SEARCH ==>  Unfold 1 ==>  SEARCH ==>  Match(q,self)]]

# Not sure if we need guard of the form:

 [U(self,q)&true |#| q::char_star<0,p>  --> emp&self=q]

Another alternative is:

 U(self,q)&true |#| q::char_star<0,p>  --> 
     self::node<_,qq>*qq::H<q,self@NI> 

But this will subsequently cause a residue problem.

-----------------------------------
[ Type: Root
 LHS: U(self,q)
 RHS: self::char_star<v,qq>@M
 lhs_rest: q::char_star<flted_28_130,p>@M
 rhs_rest: qq::WFG<p_147>@M]

!!! **context.ml#2472:process_matches (steps) :
 ### LHS : U(self,q) * q::char_star<flted_28_130,p>@M
 ### RHS : qq::WFG<p_147>@M
 ### matches :[]

# incorrect compute action!

!!! **context.ml#2840:compute_action (steps) :
 ### RHS Cand :[ self::char_star<v,qq>@M, qq::WFG<p_147>@M]
 ### action :


process_matches@1
process_matches inp1 :lhs_h: U(self,q) * q::char_star<flted_28_130,p>@M
process_matches inp2 :matches:
[ Type: Root
 LHS: U(self,q)
 RHS: self::char_star<v,qq>@M
 lhs_rest: q::char_star<flted_28_130,p>@M
 rhs_rest: qq::WFG<p_147>@M]
process_matches inp3 :rhs_node: self::char_star<v,qq>@M
process_matches inp4 :rhs_rest: qq::WFG<p_147>@M
process_matches@1 EXIT: Prio:2
 SEARCH =>[
  Prio:2
  Unfold 1 =>;
  Prio:2
  InferHeap => ( self::char_star<v,qq>@M, emp)
   
  ]


process_matches@2
process_matches inp1 :lhs_h: U(self,q) * q::char_star<flted_28_130,p>@M
process_matches inp2 :matches:[]
process_matches inp3 :rhs_node: qq::WFG<p_147>@M
process_matches inp4 :rhs_rest: self::char_star<v,qq>@M
process_matches@2 EXIT: Prio:-1
 COND =>[
  Prio:2
  InferHeap => ( qq::WFG<p_147>@M, self::char_star<v,qq>@M)
   ;
  Prio:2
  BaseCaseFold =>;
  Prio:4
  UnmatchedRHSData =>  qq::WFG<p_147>@M
  ]

===========================================================================
# ex16c1.slk (FIXED)

 infer [U,@classic,@pure_field] U(x,q)*q::char_star<0,p>  |- x::WFG<p>.

# Can we trigger lemma, just like ex16c2.slk?

  <1>emp&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [HP_155(p,q@NI)&true |#|3  --> emp&true; 
                  HP_156(q,x@NI)&true |#|3  --> emp&true; 
                  U(x,q) * q::char_star<flted_31_132,p>@M&
                   flted_31_132=0 |#|3  --> x::WFG<p>@M * HP_155(p,q@NI) * 
                                            HP_156(q,x@NI)&
                   true]
[[ SEARCH ==>  InferUnfold ]]

# ex16c2.slk

  infer [@classic,@pure_field] U(x,q)*q::char_star<0,p> 
         |- x::WFG<p>.

[[ SEARCH ==>  (Lemma <== lem_12(UNK)) ==>  Match(UNK) ==>  SEARCH ==>  Match(q,q)]]

===========================================================================
# ex16c3.slk

infer [U,U2,@classic,@pure_field] U(q3,q)*q::char_star<0,p>  |- q3::WFG<p> .


# This schedules an InferUnfold:

!!! **context.ml#2876:compute_action (steps) :
 ### RHS Cand :[ q3::WFG<p_145>@M]
 ### action :
 InferUnfold =>
   LHS: U2(q3,q)
   RHS: q3::WFG<p_145>@M

# Since U2 is inferable, can we also schedule a
  Lemma in the same way as this example:

infer [U,U2,@classic,@pure_field] U(q3,q)*q::char_star<0,p>  |- q3::WFG<p> .

!!! **context.ml#2876:compute_action (steps) :
 ### RHS Cand :[ q3::WFG<p_145>@M]
 ### action :
 SEARCH =>[
  Prio:2
  InferUnfold =>
    LHS: U(q3,q)
    RHS: q3::WFG<p_145>@M;
  Prio:3
  (Lemma <== lem_12) =>
    LHS: U(q3,q)
    RHS: q3::WFG<p_145>@M
  ]

!!! **context.ml#611:XXX body_view:U
!!! **context.ml#612:XXX Matching rhs:U2
(==context.ml#944==)
coerc_mater_match@5@3@2@1
coerc_mater_match inp1 :coercs:[Lemma "lem_12":  self::WFG<p>@M&{FLOW,(20,21)=__norm#E}[]<==]
coerc_mater_match inp2 :WFG
coerc_mater_match inp3 :[q3,p_145]
coerc_mater_match inp4 :[q3]
coerc_mater_match inp5 : U2(q3,q)
coerc_mater_match@5 EXIT:[]

====> if U2 is inferrable..

coerc_mater_match@5 EXIT:[( emp, U3(q3,q), MaterializedArg (self,full,[U]) coerc_defn_mater: <== lem_12)]


(==context.ml#943==)
coerc_mater_match@5@3
coerc_mater_match inp1 :coercs:[Lemma "lem_12":  self::WFG<p>@M&{FLOW,(20,21)=__norm#E}[]<==]
coerc_mater_match inp2 :WFG
coerc_mater_match inp3 :[q3,p_145]
coerc_mater_match inp4 :[q3]
coerc_mater_match inp5 : U(q3,q)
coerc_mater_match@5 EXIT:[( emp, U(q3,q), MaterializedArg (self,full,[U]) coerc_defn_mater: <== lem_12)]

===========================================================================
# ex16c4.slk (FIXED by removing heuristic for matching)

        (* let () = y_winfo_pp "the second condition is heur" in *)
         (* WN : this heuristic caused problem for str-inf/ex16c4.slk *)
         if CP.eq_spec_var hn1 hn2
           (* L2: huer here *)
           (* || (CF.is_exists_hp_rel hn1 estate && eq_fst_ptr (List.map CP.exp_to_sv args1) (List.map CP.exp_to_sv args2)) *)


infer [U2,U,@classic,@pure_field] U2(q3,p)  |- U(q3,p).

Entail (1) : Valid. 
Residue:
 <1>emp&{FLOW,(20,21)=__norm#E}[]
[[ Match(UNK)]]

# How did U2 and U get proven without below?

U2(q3,p) --> U(q3,p)
===========================================================================
# ex16c3b.slk (FIXED)

infer [U2,@classic,@pure_field] U2(q3,q) & D(p)  |- U(q3,qq) & D(qq).
print residue.
// fail
// can we support InferUnfold with instantiation?
//     U2(q3,q) --> U(q3,qq) & qq=q
//  D(p) & qq=q |- D(qq)

# Why did an InferUnfold fail?

!!! **astsimp.ml#8930:impl_var:[]
Entail (2) : Fail.(may) cause:**solver.ml#13222:infer_collect_hp_rel

Residue:

 MaybeErr Context: 
   fe_kind: MAY
   fe_name: separation entailment
   fe_locs: {
     fc_message: infer_heap_node
     fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
   }
 [[ InferUnfold ]]
 CEX:true
===========================================================================
# ex16c3c.slk (FIXED)

infer [U2,@pure_field] U2(q3,q) & q!=null  |- U(q3,qq) .
expect Valid.

# expect Valid since qq is not present on LHS and
can therefore be instanitated.

  U2(q3,q) --> U(q3,qq) & qq=q

-------------------

infer [U2,@pure_field] U2(q3,q) * q::char_star<0,p> & q!=qq  |- U(q3,qq) *qq::char_star<n,p>.
 
infer [U2,@pure_field] U2(q3,q) & q!=qq  |- U(q3,qq) .

# sound instantiation may lead to unsoundness.

 <1>hfalse&false&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U2(q3,q)&q!=q |#|3  --> U(q3,q)&true]

# can we check that qq is not free in LHS before instantiating??
# Also, each such var is instantiated only once.
===========================================================================
# ex16c3c.slk (OK)

infer [U2,@pure_field] U2(q3,q) *q::char_star<0,p>  |- U(q3,qq)*qq::char_star<n,p> .

 <1>emp&qq=q & n=0&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U2(q3,q)&true |#|3  --> U(q3,q)&true]

# Please add the heap guard:

    U2(q3,q)&true |#| q::char<0,_>  --> U(q3,q)&true]
==========================================================================
# ex16c3d.slk: FIXED

infer [U2] U2(q3,q)*q::char_star<0,p>  |- q3::WFG<q> .
print residue.
expect Valid.

# too complex
<1>HP_138(q,q3)&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U2(q3,q) * q::char_star<flted_31_124,p>@M&
                   true |#|3  --> q3::WFG<q>@M * HP_138(q,q3@NI)&true]

# expects 
   U2(q3,q) --> q3::WFG<q>

infer [U2] U2(q3,q)*q::char_star<0,p>  |- q3::WFG<r> .
   U2(q3,q) --> q3::WFG<q4> * HP3(q4,q,q3@NI)

infer [U2] U2(q3,q)*q::char_star<0,p>  |- q3::node<_,r>
   U2(q3,q) --> q3::node<_,q4> * HP3(q4,q,q3@NI)


infer [U2] U2(q3,q)*q::char_star<0,p>  |- q3::WFG<qq> .
print residue.
expect Valid.
//   EXPECTS: U2(q3,q) --> q3::WFG<qq> & qq=q

infer [U2] U2(q3,q)*q::char_star<0,p>  |- q3::WFG<p> .
print residue.
expect Valid.
//   EXPECTS: infer_unfold (on U2) or fold (on WFG)

===========================================================================
# ex16c5b.slk: FIXED

 infer [U2,U3] U2(qq,p) * U3(p,x)  |- qq::char_star<b,p>.

# complex LHS:

 inferred hprel: [U2(qq,p@NI) * U3(p,x@NI)&
                   true |#|3  --> qq::char_star<b_180,p>@M&true]

# expects:

  U2(qq,p@NI) |#|3  --> qq::char_star<b_180,s> * HP(s,p@NI)
  HP(s,p) --> s=p
  U3(p,x) --> emp

--------------------

 infer [U2,U3] U2(qq,p)  |- qq::char_star<b,p>.

# GOT

 <1>emp&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U2(qq,p@NI)&true |#|3  --> qq::char_star<b_167,p>@M&true]
[[ SEARCH ==>  InferUnfold ]]

# BETTER in smaller steps..

  U2(qq,p@NI) |#|3  --> qq::char_star<b_180,s> * HP(s,p@NI)
  HP(s,p) --> s=p
===========================================================================
# ex13e2.slk (FIXED - reset old-infer-collect )

infer[Q,@classic,@pure_field]
 s::char_star<v_1631,q_1632>@M * Q(q,s',p_1648)&
q_1616!=null & q=q_1632 & Anon_18=v_1631 & v!=0 & Anon_19=q_1632 & 
v=v_1631 & v_1631!=0 & p_1630=q_1616 & s_1647=s & p_1614=p & 
flted_10_1615=0 & v_bool_37_1602' & q_1651=p_1630 & p_1614=p_1648 
 |-  Q(s,s',p).

# (1) fold may be done in two steps
# (2) Where did spurious relational assumption in ex13e.ss came from?
   (1;0)emp&s=s' & s=p & s'=p |#|  --> Q(s,s',p)]
===========================================================================
# ex16c3d.slk: FIXED

infer [U2] U2(q3,q)*q::char_star<0,p>  |- q3::WFG<p> .

# We should avoid complex LHS. I suggest FAILING since p is
  free, and we cannot prove q=p.
# complex LHS should only be enabled old_infer_complex_lhs which
  I just added

Entail (8) : Valid. 
Residue:
 <1>emp&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U2(q3,q) * q::char_star<flted_83_216,p>@M&
                   true |#|3  --> q3::WFG<p>@M&true]
[[ InferUnfold ]]

WRONG : why is there a q=p in the relational assumption?

 <1>q::char_star<flted_83_218,p>@M * HP_232(p,q3)&flted_83_218=0&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U2(q3,p)&q=p |#| q::char_star<flted_83_218,p>@M&
                   true --> q3::WFG<p>@M * HP_232(p,q3@NI)&true]
[[ InferUnfold ]]

===========================================================================
# ex16c5b.slk: FIXED

//(8) 
 infer [U] U(x,p)  |- x::char_star<v,qq>.
 print residue.


 <1>HP_275(qq,x)&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U(x,p)&
                   true |#|3  --> x::char_star<v_273,qq_274>@M * 
                                  HP_275(qq_274,x@NI)&
                   true]

# p is still missing, I would expect @NI parameters to be added:

 residue: HP_271(qq,p,x@NI)
 U(x,p)& --> x::char_star<v_269,qq_270>@M * HP_271(qq_270,p,x@NI)&

----------

 //(6)
 infer [U2,U3] U2(qq,p) & qq=p  |- qq::char_star<b,qq>.
 print residue.
expect Valid.

# Why is there an UNFOLD scheduled?

# infer_unfold should work like (5)

 MaybeErr Context: 
    fe_kind: MAY
    fe_name: separation entailment
    fe_locs: {
        fc_message: infer_heap_node
        fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
      }
    [[ SEARCH ==>  Unfold 1 ==>  COND ==>  UnmatchedRHSData]]
   FAIL_UNION 
    fe_kind: MAY
    fe_name: separation entailment
    fe_locs: {
        fc_message: infer_heap_node
        fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
      }
    [[ SEARCH ==>  InferUnfold ]]
   
 CEX:true
Validate 6: Expecting(3)Valid BUT got : Fail_May
===========================================================================
# ex16c6a.slk

//(1)
 infer [U2a] U2a(self,q) |- U2(self,q).
 print residue.
/*
 <1>emp&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U2a(self,q)&true |#|3  --> U2(self,q)&true]
[[ InferUnfold ]]
*/

//(2)
 infer [U3] U3(self,_,q) |- U2(self,q).
 print residue.
 // Why fail? Similar to (1).

//(3)
 infer [U2] U2(self,q)*q::char_star<0,p> |- self::WFG<p>.
 print residue.

 <1>emp&{FLOW,(20,21)=__norm#E}[]
 inferred hprel: [U2(self,q)&true |#| q::char_star<flted_41_150,p>@M&
                   true --> U(self,q)&true]
[[ SEARCH ==>  (Lemma <== lem_12(UNK)) ==>  InferUnfold  ==>  SEARCH ==>  Match(q,q_169)]]

//(4)
 infer [U3] U3(self,_,q)*q::char_star<0,p> |- self::WFG<p>.
 print residue.
 // Why fail? Similar to (3).
===========================================================================
# ex16c6b.slk -show-push-list "es_infer_hp_rel"

# Please avoid complex LHS (@ 2nd InferUnfold):

!!! **infer.ml#3837:mis-matched:(false,false,false)
push_list(es_infer_hp_rel):[ U(self,qqq) * qqq::char_star<flted_32_137,p>@M&
  flted_32_137=0 |#|  --> self::char_star<v_155,q2_156>@M * 
                          HP_157(v_155,self) * HP_158(q2_156,self)]

(==solver.ml#13282==)
infer_collect_hp_rel#1@4@3@2
infer_collect_hp_rel#1 inp1 :lhs_node: U(self,qqq)
infer_collect_hp_rel#1 inp2 :rhs_node: self::char_star<v,q2>@M
infer_collect_hp_rel#1 inp3 :lhs: U(self,qqq) * qqq::char_star<flted_32_137,p>@M&flted_32_137=0&
{FLOW,(20,21)=__norm#E}[]
infer_collect_hp_rel#1 inp4 :rhs:
 self::char_star<v,q2>@M * q2::WFG<p_154>@M&v!=0 & p_154=p&
{FLOW,(20,21)=__norm#E}[]
infer_collect_hp_rel#1 inp5 :es: U(self,qqq) * qqq::char_star<flted_32_137,p>@M&flted_32_137=0
infer_collect_hp_rel#1@4 EXIT:(true,2: es_formula: 
 HP_157(v_155,self) * HP_158(q2_156,self)&flted_32_137=0&
 {FLOW,(20,21)=__norm#E}[]
 es_infer_vars_hp_rel: [U; HP_157; HP_158]
 es_infer_hp_rel: [U(self,qqq) * qqq::char_star<flted_32_137,p>@M&
                    flted_32_137=0 |#|  --> self::char_star<v_155,q2_156>@M * 
                                            HP_157(v_155,self) * 
                                            HP_158(q2_156,self)],3:abd heap: self::char_star<v_155,q2_156>@M,4:None,5:None)
===========================================================================
# ex16c3d11.slk:

infer [U2] U2(q3,q)*q::char_star<1,p>  |- q3::WFG<qq> * qq::WFG<p>.
print residue.
expect Fail.

===========================================================================
# ex16c6c2.slk

 infer [U3,U2,@pure_field,@classic] U3(self,q,x)*q::char_star<0,p> 
    |- U2(self,qq) * qq::char_star<0,p>.

# need to instantiate q to qq for above to succeed.
  Need to look into the context of calls to decide that qq can
  be so instantiated,

!!! **solver.ml#12409:process_action (steps) :
 ### action :
 InferUnfold =>
   Type: Root
   LHS: U3(self,q,x)
   RHS: U2(self,qq)
   lhs_rest: q::char_star<flted_10_19,p>@M
   rhs_rest: qq::char_star<flted_11_41,p_40>@M
 ### estate : ex_formula : U3(self,q,x) * q::char_star<flted_10_19,p>@M&flted_10_19=0&{FLOW,(20,21)=__norm#E}[]
 es_heap:emp
 ### conseq : U2(self,qq) * qq::char_star<flted_11_41,p_40>@M&flted_11_41=0 & p_40=p&
{FLOW,(20,21)=__norm#E}[]
===========================================================================
# ex16d1d.slk dre "infer_c" -show-push-list "es_infer_hp_rel"

# to fix infer_collect for folding:

  push_list(es_infer_hp_rel):[ self::char_star<v,q2>@M |#|  --> U(self,p)]

# since p is global and q2 does not match it, we need to schedule:
  where v!=null is picked due to the use of @pure_field

 self::char_star<v,q2>@M * HP(q2,p) & v!=null  
         --> U(self,p)

# Let us use a flag --en-infer-back-ptr to obtain:

 self::char_star<v,q2>@M * HP(q2,p,self@NI) & v!=null  
         --> U(self,p)

(==solver.ml#13319==)
infer_collect_hp_rel#1@4@3@2
infer_collect_hp_rel#1 inp1 :lhs_node: self::char_star<v,q2>@M
infer_collect_hp_rel#1 inp2 :rhs_node: U(self,p)
infer_collect_hp_rel#1 inp3 :lhs:
 self::char_star<v,q2>@M * q2::char_star<flted_29_106,p>@M&
v!=0 & flted_29_106=0&{FLOW,(20,21)=__norm#E}[]
infer_collect_hp_rel#1 inp4 :rhs: U(self,p)&{FLOW,(20,21)=__norm#E}[]
infer_collect_hp_rel#1 inp5 :es:
 self::char_star<v,q2>@M * q2::char_star<flted_29_106,p>@M&
v!=0 & flted_29_106=0
infer_collect_hp_rel#1@4 EXIT:(true,2: es_formula: 
 emp&v!=0 & flted_29_106=0&{FLOW,(20,21)=__norm#E}[]
 es_infer_vars_hp_rel: [U]
 es_infer_hp_rel: [self::char_star<v,q2>@M |#|  --> U(self,p)],3:abd heap: U(self,p),4:Some( self::char_star<v,q2>@M),5:None)

==========================================================================
# ex16d1c.slk dre "process_one_m" (WN to fix) (FIXED)

 infer [U,@pure_field,@classic] 
   self::char_star<v,q2>* q2::char_star<0,p> & v!=0  |-  U(self,p).
 print residue.

# is there a smarter base-case-fold scheduling?

(==context.ml#2600==)
process_one_match@1
process_one_match inp1 :match_res:
 Type: Root
 LHS: self::char_star<v,q2>@M
 RHS: U(self,p)
 lhs_rest: q2::char_star<flted_29_106,p>@M
 rhs_rest: emp
process_one_match inp2 :lhs_h: self::char_star<v,q2>@M * q2::char_star<flted_29_106,p>@M
process_one_match inp3 :lhs_p: v!=0 & flted_29_106=0
process_one_match inp4 :rhs_node: U(self,p)
process_one_match inp5 :rhs_rest: emp
process_one_match inp6 :rhs_p: true
process_one_match inp7 :([],None)
process_one_match@1 EXIT: Prio:1
 SEARCH =>[
  Prio:1
  BaseCaseFold =>;
  Prio:1
  InferFold =>
  ]
===========================================================================
# ex16d1b.slk -dre "process_one_m"  (WN to fix) (OK)

(FIXED)
process_one_match@2 EXIT: Prio:4
 NothingToDo => No common parameters :  q2::WFG<p>@M vs  U(self,q)

# should not schedule lemma if there are no common materialization ..

(==context.ml#2602==)
process_one_match@2
process_one_match inp1 :match_res: Type: MaterializedArg (self,full,[U]) coerc_defn_mater: ==> lem_12
 LHS: q2::WFG<p>@M
 RHS: U(self,q)
 lhs_rest: self::char_star<v,q2>@M
 rhs_rest: q::char_star<flted_29_146,p_145>@M
process_one_match inp2 :lhs_h: self::char_star<v,q2>@M * q2::WFG<p>@M
process_one_match inp3 :lhs_p: v!=0
process_one_match inp4 :rhs_node: U(self,q)
process_one_match inp5 :rhs_rest: q::char_star<flted_29_146,p_145>@M
process_one_match inp6 :rhs_p: flted_29_146=0 & p_145=p
process_one_match inp7 :([(p_145,p)],None)
process_one_match@2 EXIT: Prio:1
 (Lemma ==> lem_12) =>

===========================================================================
# ex16d2b.slk -dre "process_one_m" (FIXED)

 infer [U,@pure_field,@classic] 
   q2::WFG<p> & v!=0 & q2=q3  |-  U2(q3,q)*q::char_star<0,p>.
   
(==context.ml#2727==)
process_one_match@1
process_one_match inp1 :match_res:
 Type: Root
 LHS: q2::WFG<p>@M
 RHS: U2(q3,q)
 lhs_rest: emp
 rhs_rest: q::char_star<flted_33_149,p_148>@M
 rhs_inst: []
process_one_match inp2 :lhs_h: q2::WFG<p>@M
process_one_match inp3 :lhs_p: q2=q3 & v!=0
process_one_match inp4 :rhs_node: U2(q3,q)
process_one_match inp5 :rhs_rest: q::char_star<flted_33_149,p_148>@M
process_one_match inp6 :rhs_p: flted_33_149=0 & p_148=p
process_one_match inp7 :([(p_148,p)],None)
process_one_match@1 EXIT: Prio:2
 InferFold =>
===========================================================================
# str-inf/ex16d2a.slk -dre "rewrite_coercion\|coer_target"
  (FIXED by removing it via old-coer-target *)

# run-fast-test not affected by removal or coer-target

Total number of errors: 26 in files:
Total verification time: 140.69 second
	Time spent in main process: 89.88 second
	Time spent in child processes: 50.81 second
	Number of false contexts: 414

 infer [U,@pure_field,@classic] 
   q2::WFG<p> & v!=0 & q2=q3  |-  U(q3,q)*q::char_star<0,p>.

# Why is coer_target needed?
  Need to fix this to work with HRel?

(==solver.ml#14066==)
coer_target@1
coer_target inp1 :node: q2::WFG<p>@M
coer_target inp2 :target_rhs: q2::WFG<p>@M&q2=q3 & v!=0&{FLOW,(20,21)=__norm#E}[]
coer_target inp3 :lhs: U(q3,q) * q::char_star<flted_34_149,p_148>@M&flted_34_149=0 & p_148=p&
{FLOW,(20,21)=__norm#E}[]
coer_target inp4 :rhs_eqset:[(p_148,p)]
coer_target@1 EXIT:false

# Why Rewrite cannot be applied?
===========================================================================
# ex16d2c1.slk -dre "process_one_m" (OK)

 infer [U2,@classic] U(q2,q_155) & q2=q3  |-  U2(q3,q).

# Why infer_fold fail?

  EXPECTS:  U2(q2,q) <-- U(q2,q)

  Do we represent FOLD as U(..) <-- RHS

!!! **solver.ml#12425:process_action (steps) :
 ### action :
 InferFold =>
   Type: Root
   LHS: U(q2,q_155)
   RHS: U2(q3,q)
   lhs_rest: emp
   rhs_rest: emp
   rhs_inst: []
 ### estate :
 ex_formula : U(q2,q_155)&q2=q3&{FLOW,(20,21)=__norm#E}[]
 es_heap:emp
 ### conseq : U2(q3,q)&{FLOW,(20,21)=__norm#E}[]

!!! **lemma.ml#259:
Updated lemma store with unsafe repo::[lem_12]
(==solver.ml#13337==)
infer_collect_hp_rel#1@1
infer_collect_hp_rel#1 inp1 :lhs_node: U(q2,q_155)
infer_collect_hp_rel#1 inp2 :rhs_node: U2(q3,q)
infer_collect_hp_rel#1 inp3 :lhs: U(q2,q_155)&q2=q3&{FLOW,(20,21)=__norm#E}[]
infer_collect_hp_rel#1 inp4 :rhs: U2(q3,q)&{FLOW,(20,21)=__norm#E}[]
infer_collect_hp_rel#1 inp5 :es: U(q2,q_155)&q2=q3
infer_collect_hp_rel#1@1 EXIT:(true,2: es_formula: 
 U(q2,q_155)&q2=q3&{FLOW,(20,21)=__norm#E}[]
 es_infer_vars_hp_rel: [U2]
 es_infer_hp_rel: [emp |#|  --> U2(q2,q)],3:abd heap: U2(q2,q),4:Some( emp),5:None)
===========================================================================
# ex16d2c2.slk 

# No need to instantiate q is already known on LHS..

//(5)
infer [U2,@classic] U(q2,q_155)  & q2=q3 & q_155=q  |-  U2(q3,q).
 expect Valid.
// expects U(q2,q_155) --> U2(q2,q_155)


Entail (1) : Fail.(may) cause:**inferHP.ml#265:Can not inst
Validate 1: Expecting(3)Valid BUT got : Fail_May

===========================================================================
# ex16d1d.slk dre "infer_c" -show-push-list "es_infer_hp_rel"

# to fix infer_collect for folding:

  push_list(es_infer_hp_rel):[ self::char_star<v,q2>@M |#|  --> U(self,p)]

# since p is global and q2 does not match it, we need to schedule:
  where v!=null is picked due to the use of @pure_field

 self::char_star<v,q2>@M * HP(q2,p) & v!=null  
         --> U(self,p)

# Let us use a flag --en-infer-back-ptr to obtain:

 self::char_star<v,q2>@M * HP(q2,p,self@NI) & v!=null  
         --> U(self,p)

(==solver.ml#13319==)
infer_collect_hp_rel#1@4@3@2
infer_collect_hp_rel#1 inp1 :lhs_node: self::char_star<v,q2>@M
infer_collect_hp_rel#1 inp2 :rhs_node: U(self,p)
infer_collect_hp_rel#1 inp3 :lhs:
 self::char_star<v,q2>@M * q2::char_star<flted_29_106,p>@M&
v!=0 & flted_29_106=0&{FLOW,(20,21)=__norm#E}[]
infer_collect_hp_rel#1 inp4 :rhs: U(self,p)&{FLOW,(20,21)=__norm#E}[]
infer_collect_hp_rel#1 inp5 :es:
 self::char_star<v,q2>@M * q2::char_star<flted_29_106,p>@M&
v!=0 & flted_29_106=0
infer_collect_hp_rel#1@4 EXIT:(true,2: es_formula: 
 emp&v!=0 & flted_29_106=0&{FLOW,(20,21)=__norm#E}[]
 es_infer_vars_hp_rel: [U]
 es_infer_hp_rel: [self::char_star<v,q2>@M |#|  --> U(self,p)],3:abd heap: U(self,p),4:Some( self::char_star<v,q2>@M),5:None)

===========================================================================
# ex16d1d1.slk dre "infer_c" -show-push-list ".*hp_"

infer [U,@classic] 
   self::char_star<v,q2>* q2::char_star<0,p> & v!=0  |-  U(self,p).
 print residue.

# Can omit v!=0 if @pure_field absent..

push_list(es_infer_hp_rel):[ 
self::char_star<v,q2>@M * GP_118(q2,self,p)&v!=0 |#|  --> U(self,p)]

===========================================================================
# ex16d1d1.slk dre "infer_c" -show-push-list ".*hp_" --dis-infer-back-ptr

infer [U,@classic] 
   self::char_star<v,q2>* q2::char_star<0,p> & v!=0  |-  U(self,p).
 print residue.

# GOT:
push_list(es_infer_hp_rel):[ self::char_star<v,q2>@M |#|  --> U(self,p)]

# EXPECT:
  self::char_star<v,q2>@M * GP_118(q2,p) |#|  --> U(self,p)

===========================================================================
# ex16d1d2.slk dre "infer_c" -show-push-list ".*hp_"

//(1)

infer [U,@pure_field,@classic] 
   self::char_star<v,q2>* q2::char_star<0,p> & v!=0  |-  U(self,p).
 print residue.

# I think can use just GP_30(q2,self,p), otherwise we may
  have too many parameters.

push_list(es_infer_hp_rel):[ self::char_star<v,q2>@M * GP_30(q2,self,p,v)&v!=0 


===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
===========================================================================
