
After discussing with Cristian, it seems we
need rel assumption of the form below.

  H0(lf8) |#| x::node<lf8,q> & q!=null--> H(p)
  H0(lf8) |#| x::node<lf8,r9>@M&r9=null --> emp,

This seems critical to obtain a sound solution for
guard/tree-1.ss. We thought also about putting guards
into formula, but could not really find a use for it in
verification. It seems we mainly need it in shape
analysis. Hence, I think we will leave the guard 
feature for just sa-core for now.

# tree-1.slk

infer [P,Q]  x::node<p,q>*P(p) & q!=null |- Q(p).
print residue.

This inference is too weak.

 <1>x::node<p,q>@M&q!=null&{FLOW,(21,22)=__norm}[]
 inferred hprel: [P(p) --> Q(p)]

Can we obtain instead:

 <1>x::node<p,q>@M&q!=null&{FLOW,(21,22)=__norm}[]

   P(p) |#| x::node<p,q> & q!=null--> Q(p)

This gives relational information that q!=null is required.

==========================================================
# tree-1b.slk

relAssume 
   H0(lf8) * H1(r9) * x::node<lf8,r9> &r9=null  --> G(x).

shape_split_base [H0,H1][G].

/*
# tree-1b.slk

  Obtained: 
 [ H0(lf8) * x::node<lf8,r9>@M&r9=null --> G(x),
  H1(r9)&r9=null --> emp]

This split is not clean. Can we obtain instead:

  x::node<lf8,r9>@M&r9=null --> G(x),
  H0(lf8) |#| x::node<lf8,r9>@M&r9=null --> emp,
  H1(r9)&r9=null --> emp]

==========================================================
# guard/tree-2.ss  (try tree-2.slk)

GOT
===
 // PRE_REC
(1;0)HP_955(left_27_952,p@NI)&
p=parent_27_951 |#| x::node<p,left_27_952,right_27_953>@M --> H(x@NI,left_27_952),

EXPECT
======

(1;0)HP_955(left_27_952,p@NI)&
p=parent_27_951 |#| x::node<p,left_27_952,right_27_953>@M
  & &right_27_953!=null  --> H(x@NI,left_27_952),
==========================================================
# tree-2.ss

Got:

 H(p_1004,x_1005) ::=  H(x_1005,l8) * x_1005::node<p7,l8,r9>@M * 
    H(x_1005,r9)&r9!=null & p_1004=p7
    or H(x_1005,l8) * x_1005::node<p7,l8,r9>@M&
        r9=null & p_1004=p7

EXPECT:
 H(p7,x_1005) ::=  H(x_1005,l8) * x_1005::node<p7,l8,r9>@M * 
    H(x_1005,r9)&r9!=null 
    or x_1005::node<p7,l8,r9>@M & r9=null 

==========================================================
# tll-2.slk

infer[H,G,HP_964,HP_965,HP_966]
  HP_964(left_31_961,t) * HP_966(next_31_963,t) * 
x::node<left_31_961,right_31_962,next_31_963>@M * G(right_31_962,l_47',t')&
t=t' & x=x' & right_31_962!=null & !(v_bool_31_942') & right_31_962!=null & 
!(v_bool_31_942') & left_31_961=v_node_41_940'
 |-  H(v_node_41_940',l_47').
print residue.

GOT
 inferred [HP_964(left_31_961,t@NI) --> H(left_31_961,l_47'@NI)]

EXPECT:
 HP_964(left_31_961,t@NI) | x::node<left_31_961,r,_>@M & r=null  
     --> H(left_31_961,l_47'@NI)]
==========================================================
# parent-2.slk (see also parent.ss)

Two issues
 (i) do we still use _pure_of_H3(..)
 (ii) can we narrow to single predicate?

infer [H0,H3] H0(parent_32_966,p) * H3(next_32_969,p) * 
x::node<parent_32_966,next_32_969>@M&x=x' & p=p' & 
parent_32_966=pp_47'
 |-  emp&p=pp_47'. 
print residue.

 <1>H0(parent_32_966,p) * H3(next_32_969,p) * x::node<parent_32_966,next_32_969>@M&x=x' & p=p' & parent_32_966=pp_47' & p=parent_32_966&{FLOW,(21,22)=__norm}[]
 inferred pure: [true]
 inferred rel: [RELASS [_pure_of_H0,_pure_of_H3]: ( _pure_of_H0(parent_32_966,p) & _pure_of_H3(next_32_969,p)) -->  p=parent_32_966]
[[empty]]

Expecting:
  H0(pp,p) --> p=pp
==========================================================
# parent.ss (see parent-2.slk)

How come rel ass from ASSERT not present here?

[ // BIND
(0)H(x,p@NI) --> x::node<parent_20_900,next_20_901>@M * 
HP_902(parent_20_900,p@NI) * 
HP_903(next_20_901,p@NI),
 // POST
(0)HP_902(parent_20_900,p@NI) * HP_903(next_20_901,p@NI) * 
x::node<p,next_20_901>@M&
p=parent_20_900 --> G(x,p@NI)]

*/
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
==========================================================
