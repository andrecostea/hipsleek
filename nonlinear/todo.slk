# ex2a.slk -tp oc --esl (FIXED)

(==omega.ml#634==)
drop_nonlinear_formula_rev@11
drop_nonlinear_formula_rev inp1 : (not((6<a & 1<=(a*b))) | 0<=a)
drop_nonlinear_formula_rev@11 EXIT: (not((6<a & true)) | 0<=a)

 id: 1<-1; prover: OMEGA CALCULATOR; loc: _0:0_0:0; kind: Sleek_Entail(1)
 raw proof:SAT:{[a, b] : ((1 <= 0=0))};
 raw result:{[a,b]  : FALSE }
 Sat:  1<=(a*b)
 res: UNSAT

------

At worst, we should replace a*b>=1 by true
as a weakening measure.

However, I like to suggest the following algorithm, we do this:

(1)  subs all constants (maybe use eqmap)

  checkentail b=1  & a*b>=1 |- a>=0
  ==>
  checkentail b=1  & a*1>=1 |- a>=0


(2)  extract non-linear term to place on LHS, if possible.

   checkentail a*b>=1 |- a>=0.
   ==>
   checkentail z=a*b & z>=1 |- a>=0.

(3)  weaken LHS & strengthen RHS


   checkentail z=a*b & z>=1 |- a>=0.
   ==>
   checkentail true & z>=1 |- a>=0.

Examples
========
Using the above algorithm, we can support the following examples:

   checkentail a*b>=1 |- b*a>=0.
   ==> Step 2 (z is a fresh var)
   checkentail z=a*b & z>=1 |- z>=0.
   ==> Step 3
   checkentail true & z>=1 |- z>=0.

   checkentail true |- b*a>=0.
   ==> Step 2
   checkentail z=b*a & true |- z>=0.
   ==> Step 3
   checkentail true & true |- z>=0.

   checkentail true |- (exists b: b*a>=0).
   ==> Step 2 // fail to linearize as b is not free
   checkentail true |- (exists b: b*a>=0).
   ==> Step 3
   checkentail true |- (exists b: false).

========================================================

# ex2b.slk -tp oc

-tp z3

seems to perform correctly but not -tp oc
========================================================
# ex2c.slk -tp oc

-tp z3
========================================================
# ex2c1.slk -tp z3 (FIXED: changeed to x_dinfo_pp)

Can messages be suppressed or are they from simplify?

!!! **solver.ml#8270:super_smart_xpure:falseOmega Error Exp:Globals.Illegal_Prover_Format("[omega.ml] Non-linear arithmetic is not supported by Omega.")
 Formula: exists(b_17:(b_17*a)<=1 & 0<=(b_17*a))
Omega Error Exp:Globals.Illegal_Prover_Format("[omega.ml] Non-linear arithmetic is not supported by Omega.")
 Formula: exists(b_17:(b_17*a)<=1 & 0<=(b_17*a))

!!! split_ante1 : true
!!! split_ante1_sym : trueOmega Error Exp:Globals.Illegal_Prover_Format("[omega.ml] Non-linear arithmetic is not supported by Omega.")
 Formula: exists(b_17:(b_17*a)<=1 & 0<=(b_17*a))

========================================================

print_endline_q in VarGen.ml
print_endline_quiet in Gen.ml

========================================================
# ex2.slk -dre ".*nonlinear\|.*Omega.is_"

Why below called twice?

(==omega.ml#631==)
drop_nonlinear_formula_rev@34@33@32@29@28@27@26@24@23@22@21@20@19@18
drop_nonlinear_formula_rev inp1 : (not(1<=(aaa*b)) | 0<=aaa)
drop_nonlinear_formula_rev@34 EXIT: (not(true) | 0<=aaa)

(==omega.ml#631==)
drop_nonlinear_formula_rev@51@50@49@46@45@44@43@41@40@39@38@37@36@35
drop_nonlinear_formula_rev inp1 : (not(1<=(aaa*b)) | 0<=aaa)
drop_nonlinear_formula_rev@51 EXIT: (not(true) | 0<=aaa)


Why below called twice?

(==omega.ml#518==)
drop_nonlinear_formula@8@7
drop_nonlinear_formula inp1 : 0<=aaa
drop_nonlinear_formula@8 EXIT: 0<=aaa

(==tpdispatcher.ml#1736==)
Omega.is_sat_ops@7
Omega.is_sat_ops inp1 : 0<=aaa
Omega.is_sat_ops@7 EXIT:true

(==omega.ml#518==)
drop_nonlinear_formula@10@9
drop_nonlinear_formula inp1 : 1<=(aaa*b) & 0<=aaa
drop_nonlinear_formula@10 EXIT: true & 0<=aaa

(==tpdispatcher.ml#1736==)
Omega.is_sat_ops@9
Omega.is_sat_ops inp1 : 1<=(aaa*b) & 0<=aaa
Omega.is_sat_ops@9 EXIT:true


(==omega.ml#518==)
drop_nonlinear_formula@14@13
drop_nonlinear_formula inp1 : 0<=aaa
drop_nonlinear_formula@14 EXIT: 0<=aaa

(==tpdispatcher.ml#1736==)
Omega.is_sat_ops@13
Omega.is_sat_ops inp1 : 0<=aaa
Omega.is_sat_ops@13 EXIT:true
========================================================
# ex3b.slk -tp oc --esl

-tp z3

seems to perform correctly but not -tp oc

WhY (5-7) VALID WITH drop_nonlinear?

dangerous to simplify RHS ..

 id: 5<0; prover: OMEGA CALCULATOR; loc: _0:0_0:0; kind: Sleek_Entail(1)
 raw proof:SIMPLIFY:{[a] : ( (exists (bbbb_15:((0=0)))) )};
 raw result:{[a]}
 Simplify:  exists(bbbb_15:0<=(bbbb_15*a))
 res:  true
========================================================
# ex3d1.slk

Why is there x!=y?

!!! **solver.ml#8263:xpure_lhs_h1: x=1 & y=2 & x!=y
!!! **solver.ml#8264:xpure_lhs_h1_sym: x!=null & y!=null & x!=y
========================================================
# ex3d2.slk -dre "xpure_heap"

# Why did we not enumerate y=2?

(==cvutil.ml#1532==)
h_formula_2_mem@61@60
h_formula_2_mem inp1 : xxx::node<y>@M * y::ll<n>@M
h_formula_2_mem inp2 : 0<n
h_formula_2_mem inp3 :[]
h_formula_2_mem@61 EXIT: [[xxx,y]]

!!! **cast.ml#1315:look_up_view_baga: baga= :[]
!!! **cast.ml#1318:look_up_view_baga: baga= :Some([([self], 1<=n),([], self=null & n=0)])
!!! **cast.ml#1326:baga (subst)= :[([y], 1<=n),([], y=null & n=0)]
!!! **cast.ml#1335:baga (filtered)= :[]
(==cvutil.ml#1533==)
xpure_heap_symbolic_i@62@60
xpure_heap_symbolic_i inp1 :0
xpure_heap_symbolic_i inp2 : xxx::node<y>@M * y::ll<n>@M
xpure_heap_symbolic_i@62 EXIT:( xxx!=null & 0<=n,[xxx],false)

(==astsimp.ml#7795==)
xpure_heap_symbolic#999@60
xpure_heap_symbolic#999 inp1 :0
xpure_heap_symbolic#999 inp2 : xxx::node<y>@M * y::ll<n>@M
xpure_heap_symbolic#999 inp3 : 0<n
xpure_heap_symbolic#999@60 EXIT: xxx!=null & 0<=n#[xxx]# [[xxx,y]]true

----
(==cvutil.ml#1162==)
h_formula_2_mem@65@64@63
h_formula_2_mem inp1 : xxx::node<y>@M * y::ll<n>@M
h_formula_2_mem inp2 : 0<n
h_formula_2_mem inp3 :[]
h_formula_2_mem@65 EXIT: [[xxx,y]]

!!! **cvutil.ml#1165:memset: [[xxx,y]]
(==cvutil.ml#1734==)
xpure_heap_mem_enum#6@64@63
xpure_heap_mem_enum#6 inp1 : xxx::node<y>@M * y::ll<n>@M
xpure_heap_mem_enum#6 inp2 : 0<n
xpure_heap_mem_enum#6 inp3 :1
xpure_heap_mem_enum#6@64 EXIT: xxx=1 & (((y=null & n=0) | (1<=n & y!=null))) #  [[xxx,y]]

(==solver.ml#2794==)
xpure_heap#1@63
xpure_heap#1 inp1 : xxx::node<y>@M * y::ll<n>@M
xpure_heap#1 inp2 : 0<n
xpure_heap#1 inp3 :1
xpure_heap#1@63 EXIT:( xxx=1 & (((y=null & n=0) | (1<=n & y!=null))) & xxx!=y,[], [])#true
========================================================
# ex3d4.slk --inv-baga

Why isn't there a normalization?
What is the diff between baga_over and baga_over (unfolded)?

  baga inv: [([self], n>=1),([self], n>=1)]
  baga over inv: [([self], n>=1),([self], n>=1)]
  baga over inv (unfolded): [([self], n>=1),([self], n>=1)]
  baga under inv: [([self], n>=1),([self], n>=1)]
========================================================
# ex4c.slk

Can we use eqmap of LHS for conseq but
how far can we go?

Fails for implication
=====================
!!! **cpure.ml#11034:emap[]
(==omega.ml#632==)
subs_const_var_formula@2
subs_const_var_formula inp1 : (not((a=1 & 1<=b)) | 1<=(a*b))
subs_const_var_formula@2 EXIT: (not((a=1 & 1<=b)) | 1<=(a*b))

========================================================
========================================================
========================================================
========================================================
========================================================
========================================================
========================================================
========================================================
========================================================
========================================================
========================================================
========================================================
========================================================
