(*
26.11.2008
todo: disable the default logging for omega
*)

open Globals
open Cast
open Cformula
open Prooftracer

module CP = Cpure
module Err = Error
module TP = Tpdispatcher

let enable_distribution = ref true

type find_node_result =
  | Failed (* p2 (of p2::c2<V2> coming from the RHS) is not in FV(LHS) *)
  | NoMatch (* p2 \in FV(LHS), but no aliased node is found *)
  | Match of ((h_formula * match_type) list * h_formula) (* found p1::c1<V1> such that p1=p2 *)
	  (* first component: list of matching nodes. The flags tell if a match happens
		 at the root pointer or at a materialized argument, such as the
		 tail pointer of a list with tail pointer.
		 second component: the remaining of the heap after all the matching nodes are
		 taken away. *)

and match_type =
  | Root
  | MaterializedArg
  | Arg

let no_diff = ref false (* if true, then xpure_symbolic will drop the disequality generated by * *)

let no_check_outer_vars = ref false (*  *)

(*
   Find the type (class name) of a variable
   Result is (cbot, ctop, exact).

   When exact is true, t = ctop and cbot = "".
   When exact is false, cbot < t <: ctop
*)

(* satisfiability check *)
(* and is_satisfiable (f : constr) : bool = *)

(*
  compute_inv:
  if false then use view_x_formula for invariant
  if true then use view_invariant (user-supplied invariant) to compute view_x_formula
*)

(*
let rec geq_null = function
  | CP.And (a,b,x) -> CP.And (geq_null a, geq_null b, x)
  | CP.Or (a,b,x) -> CP.Or (geq_null a, geq_null b, x)
  | CP.Not (a,x) -> CP.Not (geq_null a, x)
  | CP.Forall (z,a,x) -> CP.Forall (z, geq_null a, x)
  | CP.Exists (z,a,x) -> CP.Exists (z, geq_null a, x)
  | CP.BForm b -> begin match b with
    | CP.Neq (a, CP.Null nl, l) -> CP.BForm (CP.Gt (a, CP.Null nl, l))
(*    | CP.Neq (a, CP.Null nl, l) -> CP.BForm (CP.Neq (a, CP.Null nl, l))*)
    | x -> CP.BForm x
  end
;;
*)

let rec xpure (prog : prog_decl) (f0 : formula) : (CP.formula * (branch_label * CP.formula) list) = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let pf1, pf1b = xpure prog f1 in
	  let pf2, pf2b = xpure prog f2 in
(*      if pf1b = [] && pf2b = [] then (CP.mkOr pf1 pf2 pos, [])
      else*)
      let branches = Util.remove_dups (fst (List.split pf1b) @ (fst (List.split pf2b))) in
      let map_fun branch =
        try 
          let l1 = List.assoc branch pf1b in
          try
            let l2 = List.assoc branch pf2b in
            CP.mkOr l1 l2 pos
          with Not_found -> CP.mkTrue no_pos
        with Not_found -> CP.mkTrue no_pos
      in
      let map_fun b = (b, map_fun b) in
      (CP.mkOr pf1 pf2 pos), (List.map map_fun branches)
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
           formula_base_branches = br;
		   formula_base_pos = pos}) ->
	  let (ph, phb) = xpure_heap prog h 1 in
      let phb = CP.merge_branches phb br in
	  let res_form = CP.mkAnd ph p pos in
	  (res_form, (List.map (fun (l, x) -> (l, CP.mkAnd x res_form pos)) phb))
  | Exists ({formula_exists_qvars = qvars;
			 formula_exists_heap = qh;
			 formula_exists_pure = qp;
             formula_exists_branches = br;
			 formula_exists_pos = pos}) ->
	  let (pqh, pqhb) = xpure_heap prog qh 1 in
      let pqhb = CP.merge_branches pqhb br in
	  let sqvars = (* List.map CP.to_int_var *) qvars in
	  let tmp1 = CP.mkAnd pqh qp pos in
      let wrap_exists f = List.fold_left
		(fun f -> fun qv -> CP.Exists (qv, f, pos)) f sqvars
	  in
	  let res_form = wrap_exists tmp1 in
	  (res_form, (List.map (fun (l, x) -> (l, wrap_exists (CP.mkAnd x tmp1 pos))) pqhb))

(*and pointers_nonnegative prog h =
  let pf = xpure_heap prog h 1 in
  let rec aux_exp = function
    | CP.Var (v, _) -> [v]
    | CP.Add (l, r, _)
    | CP.Subtract (l, r, _)
    | CP.Max (l, r, _)
    | CP.Min (l, r, _) -> (aux_exp l) @ (aux_exp r)
    | CP.Mult (_, r, _) -> (aux_exp r)
    | _ -> []
  in
  let rec aux = function
    | CP.Not (f, _) -> aux f
    | CP.Forall (v, f, _)
    | CP.Exists (v, f, _) -> List.filter (fun e -> e <> v) (aux f)
    | CP.And (f, g, _) -> (aux f) @ (aux g)
    | CP.Or (f, g, _) -> (aux f) @ (aux g)
    | CP.BForm bf -> match bf with
      | CP.BVar (v, _) -> [v]
      | CP.Gt (l, r, _)
      | CP.Gte (l, r, _)
      | CP.Lte (l, r, _)
      | CP.Eq (l, r, _)
      | CP.Neq (l, r, _)
      | CP.Lt (l, r, _) -> (aux_exp l) @ (aux_exp r)
      | CP.EqMax (l, r, t, _)
      | CP.EqMin (l, r, t, _) -> (aux_exp l) @ (aux_exp r) @ (aux_exp t)
      | _ -> []
  in
  let fvariables = Util.remove_dups (aux pf) in
  let pointers = List.filter (fun x -> match x with CP.SpecVar(CP.OType _, _, _) -> true | _ -> false) fvariables in
  let inequalties = List.map (fun x -> CP.BForm (CP.Gte (CP.Var (x, no_pos), CP.IConst (0, no_pos), no_pos))) pointers in
  let formula = List.fold_left (fun f ineq -> CP.And (f, ineq, no_pos)) pf inequalties in
  let formula = pf in
  formula*)

and xpure_heap (prog : prog_decl) (h0 : h_formula) (use_xpure0 :int) : (CP.formula * (branch_label * CP.formula) list) = match h0 with
  | DataNode ({h_formula_data_node = p;
			   h_formula_data_pos = pos}) ->
	  let i = fresh_int2 () in
	  let non_null = CP.mkEqVarInt p i pos in
	  (non_null, [])
  | ViewNode ({h_formula_view_node = p;
			   h_formula_view_name = c;
			   h_formula_view_arguments = vs;
			   h_formula_view_pos = pos}) ->
	  let vdef = look_up_view_def pos prog.prog_view_decls c in
	  let rec helper addrs =
		match addrs with
		  | a :: rest ->
			  let i = fresh_int () in
			  let non_null = CP.mkEqVarInt a i pos in
			  let rest_f = helper rest in
			  let res_form = CP.mkAnd non_null rest_f pos in
				res_form
		  | [] -> CP.mkTrue pos in
	  (*let vaddrs = CP.fresh_spec_vars vdef.view_addr_vars in*)
	  (*--- 09.05.2008 *)
		(*let _ = (print_string ("\n[solver.ml, line 152]: fresh name = " ^ (Cprinter.string_of_spec_var_list vaddrs) ^ "!!!!!!!!!!!\n")) in*)
		(*09.05.2008 ---*)
	  (*let non_null = helper vaddrs in*)
	  let vinv = 
        match use_xpure0 with
        | -1 -> (CP.mkTrue no_pos, [])
        | 0 -> vdef.view_user_inv
        | _ -> vdef.view_x_formula
      in
	  let from_svs = CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed) :: vdef.view_vars in
	  let to_svs = p :: vs in
      let (f, b) = vinv in
      let subst_fun = CP.subst_avoid_capture from_svs to_svs in
      let tmp1 = subst_fun f, List.map (fun (x,y) -> x, subst_fun y) b in
	  (*let tmp2 = CP.mkAnd non_null tmp1 pos in*)
	  (* let tmp3 = CP.mkExists vaddrs tmp2 pos in *)
		(* tmp3 *)
		tmp1
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) ->
	  let (ph1, ph1b) = xpure_heap prog h1 use_xpure0 in
	  let (ph2, ph2b) = xpure_heap prog h2 use_xpure0 in
	  let res_form = (CP.mkAnd ph1 ph2 pos, CP.merge_branches ph1b ph2b) in
		res_form
  | HTrue -> (CP.mkTrue no_pos, [])
  | HFalse -> (CP.mkFalse no_pos, [])

and xpure_symbolic (prog : prog_decl) (f0 : formula) branch : (CP.formula * CP.spec_var list) = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let ipf1, avars1 = xpure_symbolic prog f1 branch in
	  let ipf2, avars2 = xpure_symbolic prog f2 branch in
	  let res_f = CP.mkOr ipf1 ipf2 pos in
		(res_f, avars1 @ avars2)
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
		   formula_base_pos = pos}) ->
	  let ph, addrs = xpure_heap_symbolic prog h branch in
	  let res_form = CP.mkAnd ph p pos in
		(res_form, addrs)
  | Exists ({formula_exists_qvars = qvars;
			 formula_exists_heap = qh;
			 formula_exists_pure = qp;
			 formula_exists_pos = pos}) ->
	  let pqh, addrs = xpure_heap_symbolic prog qh branch in
	  let sqvars = (* List.map CP.to_int_var *) qvars in
	  let tmp1 = CP.mkAnd pqh qp pos in
	  let res_form = List.fold_left (fun f -> fun qv -> CP.Exists (qv, f, pos)) tmp1 sqvars in
		(res_form, addrs)

and xpure_heap_symbolic (prog : prog_decl) (h0 : h_formula) branch : (CP.formula * CP.spec_var list) = match h0 with
  | DataNode ({h_formula_data_node = p;
			   h_formula_data_pos = pos}) ->
	  let i = ("addr"^(fresh_trailer ())) in
	  (*--- 09.05.2008 *)
	  (*let _ = (print_string ("\n[solver.ml, line 199]: fresh name = " ^ i ^ "!!!!!!!!!!!\n")) in*)
		(*09.05.2008 ---*)
	  let vi = CP.SpecVar (CP.type_of_spec_var p, i, Unprimed) in
	  let non_zero = CP.BForm (CP.Neq (CP.Var (vi, pos), CP.Null pos, pos)) in
(*
	  let vi = CP.SpecVar (int_type, i, Unprimed) in
	  let non_zero = CP.BForm (CP.Gt (CP.Var (vi, pos), CP.IConst (0, pos), pos)) in
*)
	  let tmp1 = CP.mkEqVar p vi pos in
	  let tmp2 = CP.mkAnd tmp1 non_zero pos in
		(tmp2, [vi])
  | ViewNode ({h_formula_view_node = p;
			   h_formula_view_name = c;
			   h_formula_view_arguments = vs;
			   h_formula_view_pos = pos}) ->
	  let vdef = look_up_view_def pos prog.prog_view_decls c in
	  let vinv = CP.combine_branch branch vdef.view_x_formula in (* views have been ordered such that this dependency is respected *)
	  let from_svs = CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed) :: vdef.view_vars in
	  let to_svs = p :: vs in
	  let tmp1 = CP.subst_avoid_capture from_svs to_svs vinv in
	  let from_addrs = vdef.view_addr_vars in
	  let to_addrs = CP.fresh_spec_vars from_addrs in
	  (*--- 09.05.2008 *)
		(*let _ = (print_string ("\n[solver.ml, line 225]: fresh name = " ^ (Cprinter.string_of_spec_var_list to_addrs) ^ "!!!!!!!!!!!\n")) in*)
		(*09.05.2008 ---*)
	  let tmp2 = CP.subst (List.combine from_addrs to_addrs) tmp1 in (* no capture can happen *)
		(tmp2, to_addrs)
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) ->
	  let ph1, addrs1 = xpure_heap_symbolic prog h1 branch in
	  let ph2, addrs2 = xpure_heap_symbolic prog h2 branch in
	  let all_diff =
		if !no_diff then P.mkTrue no_pos
		else pairwise_diff addrs1 addrs2 pos in
	  let tmp1 = CP.mkAnd ph1 ph2 pos in
	  let res_form = CP.mkAnd tmp1 all_diff pos in
		(res_form, addrs1 @ addrs2)
  | HTrue -> (P.mkTrue no_pos, [])
  | HFalse -> (P.mkFalse no_pos, [])

and xpure_symbolic_no_exists (prog : prog_decl) (f0 : formula) : (CP.formula * (branch_label * CP.formula) list * CP.spec_var list) = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let ipf1, pf1b, avars1 = xpure_symbolic_no_exists prog f1 in
	  let ipf2, pf2b, avars2 = xpure_symbolic_no_exists prog f2 in
      let branches = Util.remove_dups (fst (List.split pf1b) @ (fst (List.split pf2b))) in
      (*List.iter (print_endline) branches;*)
      let map_fun branch =
        try 
          let l1 = List.assoc branch pf1b in
          try
            let l2 = List.assoc branch pf2b in
            CP.mkOr l1 l2 pos
          with Not_found -> l1
        with Not_found -> List.assoc branch pf2b
      in
      let map_fun b = (b, map_fun b) in
      let res_form = (CP.mkOr ipf1 ipf2 pos) in
      let br = (List.map map_fun branches) in
      (*print_endline ("Xpure_Symbolic1: " ^ Cprinter.string_of_pure_formula_branches (ipf1, pf1b));
      print_endline ("Xpure_Symbolic2: " ^ Cprinter.string_of_pure_formula_branches (ipf2, pf2b));
      print_endline ("Xpure_SymbolicOr: " ^ Cprinter.string_of_pure_formula_branches (res_form, br));*)
      (res_form, br, (avars1 @ avars2))
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
           formula_base_branches = fbr;
		   formula_base_pos = pos}) ->
	  let ph, br, addrs = xpure_heap_symbolic_no_exists prog h in
	  let res_form = CP.mkAnd ph p pos in
      let br = List.map (fun (l, x) -> (l, CP.mkAnd x res_form pos)) (CP.merge_branches br fbr) in
	  (res_form, br, addrs)
  | Exists ({formula_exists_qvars = qvars;
			 formula_exists_heap = qh;
			 formula_exists_pure = qp;
             formula_exists_branches = fbr;
			 formula_exists_pos = pos}) ->
	  let pqh, br, addrs' = xpure_heap_symbolic_no_exists prog qh in
	  let sqvars = (* List.map CP.to_int_var *) qvars in
	  let tmp1 = CP.mkAnd pqh qp pos in
	  let addrs = CP.difference addrs' sqvars in
      let wrap_exists f =
        let fv = CP.fv f in
        let sqvars = List.filter (fun sv -> List.mem sv fv) sqvars in
        List.fold_left (fun f -> fun qv -> CP.Exists (qv, f, pos)) f sqvars
      in
      let br = List.map (fun (l, x) -> (l, wrap_exists (CP.mkAnd x tmp1 pos))) (CP.merge_branches br fbr) in
	  let res_form = wrap_exists tmp1 in
	  (res_form, br, addrs)

and xpure_heap_symbolic_no_exists (prog : prog_decl) (h0 : h_formula) : (CP.formula * (branch_label * CP.formula) list * CP.spec_var list) = match h0 with
  | DataNode ({h_formula_data_node = p;
			   h_formula_data_pos = pos}) ->
(*
	  let non_zero = CP.BForm (CP.Gt (CP.Var (p, pos), CP.IConst (0, pos), pos)) in
*)
	  let non_zero = CP.BForm (CP.Neq (CP.Var (p, pos), CP.Null pos, pos)) in
		(non_zero, [], [p])
  | ViewNode ({h_formula_view_node = p;
			   h_formula_view_name = c;
			   h_formula_view_arguments = vs;
			   h_formula_view_pos = pos}) ->
	  let vdef = look_up_view_def pos prog.prog_view_decls c in
	  let vinv, vinv_b = vdef.view_x_formula in (* views have been ordered such that this dependency is respected *)
	  let from_svs = CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed) :: vdef.view_vars in
	  let to_svs = p :: vs in
	  let from_addrs = vdef.view_addr_vars in
	  let to_addrs = CP.fresh_spec_vars from_addrs in
      let subst_fun f =
	    let tmp1 = CP.subst_avoid_capture from_svs to_svs f in
	    CP.subst (List.combine from_addrs to_addrs) tmp1 (* no capture can happen *)
      in
      (subst_fun vinv, List.map (fun (l,x) -> (l, subst_fun x)) vinv_b, to_addrs)
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) ->
	  let ph1, b1, addrs1 = xpure_heap_symbolic_no_exists prog h1 in
	  let ph2, b2, addrs2 = xpure_heap_symbolic_no_exists prog h2 in
	  let all_diff =
		if !no_diff then P.mkTrue no_pos
		else pairwise_diff addrs1 addrs2 pos in
	  let tmp1 = CP.mkAnd ph1 ph2 pos in
	  let res_form = CP.mkAnd tmp1 all_diff pos in
		(res_form, CP.merge_branches b1 b2, addrs1 @ addrs2)
  | HTrue -> (P.mkTrue no_pos, [], [])
  | HFalse -> (P.mkFalse no_pos, [], [])


(* xpure of consumed precondition *)
and xpure_consumed_pre (prog : prog_decl) (f0 : formula) : (CP.formula * (branch_label * CP.formula) list) = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let ipf1, pf1b = xpure_consumed_pre prog f1 in
	  let ipf2, pf2b = xpure_consumed_pre prog f2 in
      let branches = Util.remove_dups (fst (List.split pf1b) @ (fst (List.split pf2b))) in
      let map_fun branch =
        try 
          let l1 = List.assoc branch pf1b in
          try
            let l2 = List.assoc branch pf2b in
            CP.mkOr l1 l2 pos
          with Not_found -> CP.mkTrue no_pos
        with Not_found -> CP.mkTrue no_pos
      in
      let map_fun b = (b, map_fun b) in
      (CP.mkOr ipf1 ipf2 pos), (List.map map_fun branches)
  | Base ({formula_base_heap = h;
		   formula_base_pos = pos}) ->
	  let (ph, phb) = xpure_consumed_pre_heap prog h in
	  (ph, (List.map (fun (l, x) -> (l, CP.mkAnd x ph pos)) phb))
  | Exists ({formula_exists_qvars = qvars;
			 formula_exists_heap = qh;
			 formula_exists_pure = qp;
			 formula_exists_pos = pos}) ->
	  let (pqh, pqhb) = xpure_consumed_pre_heap prog qh in
	  let res_form = CP.mkExists qvars pqh pos in
	  (pqh, (List.map (fun (l, x) -> (l, CP.mkAnd x res_form pos)) pqhb))

and xpure_consumed_pre_heap (prog : prog_decl) (h0 : h_formula) : (CP.formula * (branch_label * CP.formula) list) = match h0 with
  | DataNode ({h_formula_data_node = p;
			   h_formula_data_pos = pos}) -> (CP.mkTrue pos, [])
  | ViewNode ({h_formula_view_node = p;
			   h_formula_view_name = c;
			   h_formula_view_arguments = vs;
			   h_formula_view_pos = pos}) ->
	  let vdef = look_up_view_def pos prog.prog_view_decls c in
	  let vinv, vinv_b = vdef.view_user_inv in (* views have been ordered such that this dependency is respected *)
	  let from_svs = CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed) :: vdef.view_vars in
	  let to_svs = p :: vs in
	  let tmp1 = CP.subst_avoid_capture from_svs to_svs vinv in
      let tmp1b = List.map (fun (l,f) -> (l, CP.subst_avoid_capture from_svs to_svs f)) vinv_b in
	  tmp1, tmp1b
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) ->
	  let (ph1, ph1b) = xpure_consumed_pre_heap prog h1 in
	  let (ph2, ph2b) = xpure_consumed_pre_heap prog h2 in
	  let tmp1 = (CP.mkAnd ph1 ph2 pos, CP.merge_branches ph1b ph2b) in
		tmp1
  | HTrue -> (P.mkTrue no_pos, [])
  | HFalse -> (P.mkFalse no_pos, [])

(*
and xpure_combine (f1 : CP.formula) (f2 : CP.formula) pos =
  let new_f1 = CP.rename_top_level_bound_vars f1 in
  let new_f2 = CP.rename_top_level_bound_vars f2 in
  let qvars1, bare_1 = CP.split_ex_quantifiers new_f1 in
  let qvars2, bare_2 = CP.split_ex_quantifiers new_f2 in
  let all_diff = pairwise_diff qvars1 qvars2 pos in
  let tmp1 = CP.mkAnd bare_1 bare_2 pos in
  let tmp2 = CP.mkAnd tmp1 all_diff pos in
  let res_f = CP.mkExists (qvars1 @ qvars2) tmp2 pos in
	res_f
*)

and pairwise_diff svars10 svars20 pos =
  let rec diff_one sv svars = match svars with
	| sv2 :: rest ->
		let tmp1 = diff_one sv rest in
		let tmp2 = CP.mkNeqVar sv sv2 pos in
		let res = CP.mkAnd tmp1 tmp2 pos in
		  res
	| [] -> CP.mkTrue pos
  in
	if U.empty svars20 then
	  CP.mkTrue pos
	else
	  match svars10 with
		| sv :: rest ->
			let tmp1 = pairwise_diff rest svars20 pos in
			let tmp2 = diff_one sv svars20 in
			let res = CP.mkAnd tmp1 tmp2 pos in
			  res
		| [] -> CP.mkTrue pos


(* split conseq to a node to be checked at the next step and *)
(* a the remaining part to be checked recursively            *)
and split_linear_node (h : h_formula) : (h_formula * h_formula) = match h with
  | HTrue -> (HTrue, HTrue)
  | HFalse -> (HFalse, HFalse)
  | DataNode _ | ViewNode _ -> (h, HTrue)
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) -> begin
	  match h1 with
		| HTrue -> print_string ("\n\n!!!This shouldn't happen!!!\n\n"); split_linear_node h2 (* this shouldn't happen anyway *)
		| _ ->
			let ln1, r1 = split_linear_node h1 in
			  (ln1, mkStarH r1 h2 pos)
	end

(* find a node from the left hand side *)
and find_node prog lhs_h lhs_p (ps : CP.spec_var list) pos : find_node_result =
  let rec merge_results rs1 rs2 = match rs1 with
	| Failed -> rs2
	| NoMatch -> begin
		match rs2 with
		  | Failed -> rs1
		  | _ -> rs2
	  end
	| Match l1 -> begin
		match rs2 with
		  | Failed -> rs1
		  | NoMatch -> rs1
		  | Match l2 -> rs1 (*TODO: fix it Match (l1 @ l2) *)
	  end in
  let tmp1 = List.map (fun p -> find_node_one prog lhs_h lhs_p p pos) ps in
  let tmp2 = List.fold_left merge_results Failed tmp1 in
	tmp2

and find_node_one prog lhs_h lhs_p (p : CP.spec_var) pos : find_node_result =
  let lhs_fv = (h_fv lhs_h) @ (CP.fv lhs_p) in
	if CP.mem p lhs_fv then
	  let eqns' = ptr_equations lhs_p in
	  let eqns = (p, p) :: eqns' in
	  let asets = alias eqns in
	  let paset = get_aset asets p in (* find the alias set containing p *)
		if U.empty paset then begin (* can this case happen *)
		  failwith ("Error in getting aliases for "
					^ (Cprinter.string_of_spec_var p))
		end else
		  let anodes, resth1 = get_aliased_node prog lhs_h paset in
			if U.empty anodes (*|| CP.mem CP.null_var paset*) then
			  NoMatch (* can't find an aliased node, but p is mentioned in LHS *)
			else
			  Match (anodes, resth1)
	else begin
(*
	  Debug.devel_pprint ("find_node: no aliased node for "
						  ^ (Cprinter.string_of_spec_var p)
						  ^ " is found in lhs\n\n") pos;
	  Failed (* if p doesn't appear in LHS, entailment surely fails *)
*)
	  Debug.devel_pprint ("find_node: " ^ (Cprinter.string_of_spec_var p) ^ " is not mentioned in lhs\n\n") pos;
	  NoMatch
	end

and h_mvars prog (h : h_formula) : CP.spec_var list = match h with
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) -> Util.remove_dups (h_fv h1 @ h_fv h2)
  | DataNode ({h_formula_data_node = v}) -> [v]
  | ViewNode ({h_formula_view_node = v;
			   h_formula_view_arguments = vargs;
			   h_formula_view_name = c}) -> begin
	  let vdef = look_up_view_def_raw prog.prog_view_decls c in
	  let mvs = CP.subst_var_list_avoid_capture vdef.view_vars vargs vdef.view_materialized_vars in
	  let mvars = if CP.mem v mvs then mvs else v :: mvs in
		mvars
	end
  | HTrue | HFalse -> []


(* assume that f is a satisfiable conjunct *)
and ptr_equations (f : CP.formula) : (CP.spec_var * CP.spec_var) list = match f with
  | CP.And (f1, f2, pos) -> (ptr_equations f1) @ (ptr_equations f2)
  | CP.BForm bf -> begin
	  match bf with
		| CP.Eq (e1, e2, _) ->
			if CP.can_be_aliased e1 && CP.can_be_aliased e2 then
			  let sv1 = CP.get_alias e1 in
			  let sv2 = CP.get_alias e2 in
				[(sv1, sv2)]
				  (* (CP.Var (sv1, _), CP.Var (sv2, _), _) -> [(sv1, sv2)]
					 will put this back when modifying the simplification of pure formula to
					 preserve types of variables
					 if CP.is_object_var sv1 then [(sv1, sv2)]
					 else []
				  *)
			else []
		| _ -> []
	end
  | _ -> []

(* computes must-alias sets from equalities, maintains the invariant *)
(* that these sets form a partition. *)
and alias (ptr_eqs : (CP.spec_var * CP.spec_var) list) : CP.spec_var list list = match ptr_eqs with
  | (v1, v2) :: rest -> begin
	  let rest_sets = alias rest in
	  let search (v : CP.spec_var) (asets : CP.spec_var list list) =
		List.partition (fun aset -> CP.mem v aset) asets in
	  let av1, rest1 = search v1 rest_sets in
	  let av2, rest2 = search v2 rest1 in
	  let v1v2_set = U.remove_dups (List.concat ([v1; v2] :: (av1 @ av2))) in
		v1v2_set :: rest2
	end
  | [] -> []

and get_aset (aset : CP.spec_var list list) (v : CP.spec_var) : CP.spec_var list =
  let tmp = List.filter (fun a -> CP.mem v a) aset in
	match tmp with
	  | [] -> []
	  | [s] -> s
	  | _ -> failwith ((Cprinter.string_of_spec_var v) ^ " appears in more than one alias sets")

(* return a list of nodes from heap f that appears in *)
(* alias set aset. The flag associated with each node *)
(* lets us know if the match is at the root pointer,  *)
(* or at materialized args,...                        *)
and get_aliased_node prog (f0 : h_formula) (aset : CP.spec_var list) : ((h_formula * match_type) list * h_formula) =
  let rec alias_helper f = match f with
	| HTrue | HFalse -> ([], f)
	| DataNode ({h_formula_data_node = p1}) ->
		if CP.mem p1 aset then ([(f, Root)], HTrue)
		else ([], f)
	| ViewNode ({h_formula_view_node = p1;
				 h_formula_view_arguments = vs1;
				 h_formula_view_name = c}) ->
		if CP.mem p1 aset then
		  ([(f, Root)], HTrue)
		else
		  let vdef = look_up_view_def_raw prog.prog_view_decls c in
		  let mvs = CP.subst_var_list_avoid_capture vdef.view_vars vs1
			vdef.view_materialized_vars
		  in
			if List.exists (fun v -> CP.mem v aset) mvs then
			  ([(f, MaterializedArg)], HTrue)
			else if List.exists (fun v -> CP.mem v aset) vs1 then
			  ([(f, Arg)], HTrue)
			else
			  ([], f)
	| Star ({h_formula_star_h1 = f1;
			 h_formula_star_h2 = f2;
			 h_formula_star_pos = pos}) ->
		let n1, r1 = alias_helper f1 in
		let n2, r2 = alias_helper f2 in
		  (n1 @ n2, mkStarH r1 r2 pos)
  in
	alias_helper f0


and combine_context_and prog (ctx : context) (f : Cpure.formula) : context = match ctx with
  | Ctx es -> 
		let r1,r2 = combine_and es.es_formula f in
		if r2 then elim_unsat_ctx prog (Ctx {es with es_formula = r1})
		else Ctx {es with es_formula = r1}
  | OCtx (c1, c2) ->
	  let nc1 = combine_context_and prog c1 f in
	  let nc2 = combine_context_and prog c2 f in
	  let res = (mkOCtx nc1 nc2 no_pos) in
		res

(* expand all predicates in a definition *)

and expand_all_preds prog f0 : formula = match f0 with
  | Or (({formula_or_f1 = f1;
		  formula_or_f2 = f2}) as or_f) -> begin
	  let ef1 = expand_all_preds prog f1 in
	  let ef2 = expand_all_preds prog f2 in
		Or ({or_f with formula_or_f1 = ef1; formula_or_f2 = ef2})
	end
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
		   formula_base_pos =pos}) -> begin
	  let proots = find_pred_roots_heap h in
	  let ef0 = List.fold_left (fun f -> fun v -> unfold prog f v pos) f0 proots in
		ef0
	end
  | Exists ({formula_exists_qvars = qvars;
			 formula_exists_heap = qh;
			 formula_exists_pure = qp;
			 formula_exists_pos = pos}) -> begin
	  let proots = find_pred_roots_heap qh in
	  let f = Base ({formula_base_heap = qh;
					 formula_base_pure = qp;
					 formula_base_type = TypeTrue;
                     formula_base_branches = [];
					 formula_base_pos = pos}) in
	  let ef = List.fold_left (fun f -> fun v -> unfold prog f v pos) f proots in
	  let ef0 = push_exists qvars ef in
		ef0
	end

and find_pred_roots f0 = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2}) -> begin
	  let pr1 = find_pred_roots f1 in
	  let pr2 = find_pred_roots f2 in
	  let tmp = CP.remove_dups (pr1 @ pr2) in
		tmp
	end
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
		   formula_base_pos =pos}) -> find_pred_roots_heap h
  | Exists ({formula_exists_qvars = qvars;
			 formula_exists_heap = qh;
			 formula_exists_pure = qp;
			 formula_exists_pos = pos}) -> begin
	  let tmp1 = find_pred_roots_heap qh in
	  let tmp2 = CP.difference tmp1 qvars in
		tmp2
	end

and find_pred_roots_heap h0 = match h0 with
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) -> begin
	  let pr1 = find_pred_roots_heap h1 in
	  let pr2 = find_pred_roots_heap h2 in
	  let tmp = CP.remove_dups (pr1 @ pr2) in
		tmp
	end
  | ViewNode ({h_formula_view_node = p}) -> [p]
  | DataNode _ | HTrue | HFalse -> []

(* unfolding *)
and unfold_context prog (ctx : context) (v : CP.spec_var) (pos : loc) : context = match ctx with
  | OCtx (c1, c2) ->
	  let new_c1 = unfold_context prog c1 v pos in
	  let new_c2 = unfold_context prog c2 v pos in
		or_context new_c1 new_c2
  | Ctx es ->
	  let unfolded_f = unfold prog es.es_formula v pos in
	  let res = build_context ctx unfolded_f pos in
		res

and unfold prog (f : formula) (v : CP.spec_var) (pos : loc) : formula = match f with
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
           formula_base_branches = b;
		   formula_base_pos = pos}) -> 
             unfold_baref prog h p v pos b [] 
  | Exists _ -> (*report_error pos ("malfunction: trying to unfold in an existentially quantified formula!!!")*)
	  let rf = rename_bound_vars f in
	  let qvars, baref = split_quantifiers rf in
	  let h, p, b, t = split_components baref in
	  let uf = unfold_baref prog h p v pos b qvars in
		uf
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let uf1 = unfold prog f1 v pos in
	  let uf2 = unfold prog f2 v pos in
	  let resform = mkOr uf1 uf2 pos in
		resform

and unfold_baref prog (h : h_formula) (p : CP.formula) (v : CP.spec_var) pos b qvars: formula =
  let asets = alias (ptr_equations p) in
  let aset' = get_aset asets v in
  let aset = if CP.mem v aset' then aset' else v :: aset' in
  let unfolded_h = unfold_heap prog h aset v pos in
  let pure_f = formula_of_pure p pos in
  let pure_f = replace_branches b pure_f in
  (*let pure_f = struc_formula_of_formula pure_f pos in*)
  let tmp_form = normalize_combine unfolded_h pure_f pos in
  let resform = if (List.length qvars) >0 then push_exists qvars tmp_form else tmp_form in
  let res_form = elim_unsat prog resform in
  (*let res_form = elim_struc_unsat prog tmp_form in*)
	(*
	  print_string ("\nunfolded_h:\n" ^ (Cprinter.string_of_formula unfolded_h) ^ "\n");
	  print_string ("\ntmp_form:\n" ^ (Cprinter.string_of_formula tmp_form) ^ "\n");
	  print_string ("\nres_form:\n" ^ (Cprinter.string_of_formula res_form) ^ "\n");
	*)
	res_form

and unfold_heap prog (f : h_formula) (aset : CP.spec_var list) (v : CP.spec_var) pos : formula = match f with
  | ViewNode ({h_formula_view_node = p;
			   h_formula_view_name = c;
			   h_formula_view_origins = origs;
			   h_formula_view_arguments = vs}) ->
	  if CP.mem p aset then
		let vdef = Cast.look_up_view_def pos prog.prog_view_decls c in
		let renamed_view_formula = rename_bound_vars vdef.view_un_struc_formula in
		let fr_vars = (CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed))
		  :: vdef.view_vars in
		let to_vars = v :: vs in
		(* let tmp_form = normalize renamed_view_formula
		   (formula_of_pure vdef.Cast.view_x_formula pos) pos in
		   let res_form = subst_avoid_capture fr_vars to_vars tmp_form in *)
		let res_form = subst_avoid_capture fr_vars to_vars renamed_view_formula in
		let res_form = add_origins res_form origs in
		(*let res_form = struc_to_formula res_form in*)
		  res_form
	  else
		formula_of_heap f pos
  | Star ({h_formula_star_h1 = f1;
		   h_formula_star_h2 = f2}) ->
	  let uf1 = unfold_heap prog f1 aset v pos in
	  let uf2 = unfold_heap prog f2 aset v pos in
		normalize_combine uf1 uf2 pos
  | _ -> formula_of_heap f pos

(*
  vvars: variables of interest
  evars: those involving this will be on the rhs
  otherwise move to the lhs
*)
and split_universal ((f0 : CP.formula), f0b) (evars : CP.spec_var list) (vvars : CP.spec_var list) (pos : loc) 
    : ((CP.formula * (branch_label * CP.formula) list) * (CP.formula * (branch_label * CP.formula) list) * (CP.spec_var list)) =
  let rec split f = match f with
	| CP.And (f1, f2, _) ->
		let app1, cpp1 = split f1 in
		let app2, cpp2 = split f2 in
		  (CP.mkAnd app1 app2 pos, CP.mkAnd cpp1 cpp2 pos)
	| _ ->
		let fvars = CP.fv f in
		  if CP.disjoint fvars vvars then
			(CP.mkTrue pos, CP.mkTrue pos) (* just ignore the formula in this case as
											  it is disjoint
											  from the set of variables of interest *)
		  else
		  (*
		  	- 23.05.2008 -
				Current actions are:
		    (i) discard E2(g) which has already been proven
		    (ii) move E1(f.g) to LHS for implicit instantiation
		   (iii) leave E3(e,f,g) to RHS for linking existential var e

		 What we added here: -->Step (iii) can be also improved by additionally moving (exists e : E3(e,f,g)) to the LHS.
		  *)
		  if not (CP.disjoint evars fvars) then (* to conseq *)
		  	(CP.mkTrue pos, f)
		  else (* to ante *)
				(f, CP.mkTrue pos)
	in
	(* -- added on 21.05.2008 *)
	(* try to obtain as much as a CNF form as possible so that the splitting of bindings between antecedent and consequent is more accurate *)
	let f = (normalize_to_CNF f0 pos) in
    let fb = (List.map (fun (l,f) -> (l, normalize_to_CNF f pos)) f0b) in
	(* added on 21.05.2008 -- *)
	(*
	let _ = (print_string ("\n[solver.ml, split_universal]: Pure formula: " ^ (Cprinter.string_of_pure_formula f0) ^ "\n")) in
  let _ = (print_string ("[solver.ml, split_universal]: Pure formula in simplified cnf: " ^ (Cprinter.string_of_pure_formula f) ^ "\n")) in
  *)
  let to_ante, to_conseq = split f in
  let tmp_l = List.map (fun (l, f) -> (l, split f)) fb in
  let labels, pairs = List.split tmp_l in
  let to_ante_f, to_conseq_f = List.split pairs in
  let to_ante_b, to_conseq_b = (List.combine labels to_ante_f), (List.combine labels to_conseq_f) in

  let conseq_fv = CP.fv to_conseq in
  let conseq_fv_b = (List.map (fun (l,f) -> CP.fv f) to_conseq_b) in
  let instantiate = List.filter (fun v -> List.mem v evars) conseq_fv in
  let instantiate_b = List.map (fun fv_list -> List.filter (fun v -> List.mem v evars) fv_list) conseq_fv_b in
  let wrapped_to_conseq = List.fold_left (fun f v -> CP.Exists (v, f, pos)) to_conseq instantiate in
  let wrapped_to_conseq_b = List.map2 (fun to_conseq instantiate -> List.fold_left (fun f v -> CP.Exists (v, f, pos)) to_conseq instantiate) to_conseq_f instantiate_b in
  let to_ante =
    if CP.fv wrapped_to_conseq <> [] then CP.And (to_ante, wrapped_to_conseq, no_pos) else to_ante
  in
  let to_ante_f = List.map2 (fun to_ante wrapped_to_conseq ->
    if CP.fv wrapped_to_conseq <> [] then CP.And (to_ante, wrapped_to_conseq, no_pos) else to_ante
  ) to_ante_f wrapped_to_conseq_b in
  let to_ante_b = List.combine labels to_ante_f in
  (*t evars = explicitly_quantified @ evars in*)
  Debug.devel_pprint ("split_universal: evars: "
						^ (String.concat ", "
							 (List.map Cprinter.string_of_spec_var evars))) pos;
	Debug.devel_pprint ("split_universal: vvars: "
						^ (String.concat ", "
							 (List.map Cprinter.string_of_spec_var vvars))) pos;
	Debug.devel_pprint ("split_universal: to_ante: "
						^ (Cprinter.string_of_pure_formula_branches (to_ante, to_ante_b))) pos;
	Debug.devel_pprint ("split_universal: to_conseq: "
						^ (Cprinter.string_of_pure_formula_branches (to_conseq, to_conseq_b))) pos;
	let fvars = CP.fv f in

	(* 27.05.2008 *)
	if !Globals.move_exist_to_LHS & (not(Util.empty (CP.difference fvars evars)) & not(Util.empty evars))	then
		(* there still are free vars whose bondings were not moved to the LHS --> existentially quantify the whole formula and move it to the LHS *)
		(* Ex.:  ex e. f1<e & e<=g or ex e. (f=1 & e=2 \/ f=2 & e=3) *)
		(*let _ = print_string("\n[solver.ml, split_universal]: No FV in  " ^ (Cprinter.string_of_pure_formula f) ^ "\n") in*)
      (* Branches not handled here yet *)
	  let new_f = discard_uninteresting_constraint f vvars in
	  (((CP.mkAnd to_ante (CP.mkExists evars new_f pos) pos), []), (to_conseq, to_conseq_b), evars)
	else ((to_ante, to_ante_b), (to_conseq, to_conseq_b), evars)


(**************************************************************)
(**************************************************************)
(**************************************************************)
(*
	We do a simplified translation towards CNF where we only take out the common
 	conjuncts from all the disjuncts:

	Ex:
 (a=1 & b=1) \/ (a=2 & b=2) - nothing common between the two disjuncts
 (a=1 & b=1 & c=3) \/ (a=2 & b=2 & c=3) ->  c=3 & ((a=1 & b=1) \/ (a=2 & b=2))
*)

and normalize_to_CNF (f : CP.formula) pos : CP.formula = match f with
	| CP.Or (f1, f2, p) ->
		let conj, disj1, disj2 = (find_common_conjs f1 f2 p) in
			(*
			let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: f1: " ^ (Cprinter.string_of_pure_formula f1) ^ "\n")) in
			let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: f2: " ^ (Cprinter.string_of_pure_formula f2) ^ "\n")) in
			let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: Conj: " ^ (Cprinter.string_of_pure_formula conj) ^ "\n")) in
			let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: disj1: " ^ (Cprinter.string_of_pure_formula disj1) ^ "\n")) in
			let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: disj2: " ^ (Cprinter.string_of_pure_formula disj2) ^ "\n")) in
			*)
			(CP.mkAnd conj (CP.mkOr disj1 disj2 p) p)
  | CP.And (f1, f2, p) -> CP.And(normalize_to_CNF f1 p, normalize_to_CNF f2 p, p)
	| CP.Not (f1, p) -> CP.Not(normalize_to_CNF f1 p, p)
	| CP.Forall (sp, f1, p) -> CP.Forall(sp, normalize_to_CNF f1 p, p)
	| CP.Exists (sp, f1, p) -> CP.Exists(sp, normalize_to_CNF f1 p, p)
  | _ -> f

(* take two formulas f1 and f2 and returns:
	- the formula containing the commom conjuncts
	- the formula representing what's left of f1
	- the formula representing what's left of f2
*)

and find_common_conjs (f1 : CP.formula) (f2 : CP.formula) pos : (CP.formula * CP.formula * CP.formula) = match f1 with
	| CP.BForm(b) ->
		if (List.exists (fun c -> (CP.eq_pure_formula c f1)) (CP.list_of_conjs f2)) then
			begin
				(f1, (CP.mkTrue pos), (remove_conj f2 f1 pos))
			end
		else
			(*
			let _ = (print_string ("\n[cpure.ml, find_common_conjs]: no common conj between: \n")) in
			let _ = (print_string ("\t\t " ^ (Cprinter.string_of_pure_formula f1) ^ "\n")) in
			let _ = (print_string ("\t\t " ^ (Cprinter.string_of_pure_formula f2) ^ "\n")) in
			let _ = (print_string ("\n[cpure.ml, find_common_conjs]: list of conj for f2: " ^ (Cprinter.string_of_pure_formula_list (CP.list_of_conjs f2)) ^ "\n")) in
			*)
			((CP.mkTrue pos), f1, f2)
	| CP.And(f11, f12, p) ->
		let outer_conj, new_f1, new_f2 = (find_common_conjs f11 f2 p) in
		let outer_conj_prim, new_f1_prim, new_f2_prim  = (find_common_conjs f12 new_f2 p) in
		((CP.mkAnd outer_conj outer_conj_prim p), (CP.mkAnd new_f1 new_f1_prim p), new_f2_prim)
	| CP.Or(f11, f12, p) ->
		let new_f11 = (normalize_to_CNF f11 p) in
		let new_f12 = (normalize_to_CNF f12 p) in
        (CP.mkTrue pos),(CP.mkOr new_f11 new_f12 p),f2
	| _ -> ((CP.mkTrue pos), f1, f2)

and remove_conj (f : CP.formula) (conj : CP.formula) pos : CP.formula = match f with
	| CP.BForm(b1) ->
		begin
			match conj with
			|CP.BForm(b2) ->
				if (CP.eq_b_formula b1 b2) then
					(CP.mkTrue pos)
				else f
			| _ -> f
		end
	| CP.And(f1, f2, p) ->
		(CP.mkAnd (remove_conj f1 conj p) (remove_conj f2 conj p) p)
	| CP.Not(f1, p) -> CP.Not((remove_conj f1 conj p), p)
	| _ -> f

(**************************************************************)
(**************************************************************)
(**************************************************************)

(* 21.05.2008 *)
(*
	Say we have three kinds of vars
  f - free, g - global (from the view definition), e - existential
	Assume, we have expression at the end of folding:
  E1(f,g) & E2(g) & E3(e,f,g)

	First action is to discard E2(g) which has already been proven

 (discard_uninteresting_constraint f vvars) only maintains those vars containing vvars, which are vars of interest
*)

and discard_uninteresting_constraint (f : CP.formula) (vvars: CP.spec_var list) : CP.formula = match f with
	| CP.BForm _ ->
		if CP.disjoint (CP.fv f) vvars then (CP.mkTrue no_pos)
		else f
  | CP.And(f1, f2, l) -> CP.And(discard_uninteresting_constraint f1 vvars, discard_uninteresting_constraint f2 vvars, l)
  | CP.Or(f1, f2, l) -> CP.Or(discard_uninteresting_constraint f1 vvars, discard_uninteresting_constraint f2 vvars, l)
  | CP.Not(f1, l) -> CP.Not(discard_uninteresting_constraint f1 vvars, l)
  | _ -> f


(**************************************************************)
(**************************************************************)
(**************************************************************)

(* fold some constraints in f1 to view v under pure pointer *)
(* constraint pp and Presburger constraint pres             *)
and fold prog (ctx : context) (view : h_formula) (pure : CP.formula) (pos : loc): (context list * proof) = match view with
  | ViewNode ({h_formula_view_node = p;
			   h_formula_view_name = c;
			   h_formula_view_arguments = vs}) -> begin
	  try
		let vdef = look_up_view_def_raw prog.Cast.prog_view_decls c in
		let renamed_view_formula = rename_struc_bound_vars vdef.Cast.view_formula in
					(*(if use_base_case then match vdef.Cast.view_base_case with 
							| None -> vdef.Cast.view_formula
							| Some s -> s
						else vdef.Cast.view_formula) in*)						
		let fr_vars = (CP.SpecVar (CP.OType vdef.Cast.view_data_name, self, Unprimed))
		  :: vdef.view_vars in
		let to_vars = p :: vs in
		let view_form = subst_struc_avoid_capture fr_vars to_vars renamed_view_formula in
		let view_form = add_struc_origins view_form (get_view_origins view) in
		  Debug.devel_pprint ("fold: view_form:\n"
							  ^ (Cprinter.string_of_struc_formula view_form)) pos;
		  let estate = estate_of_context ctx pos in
		  let new_es = {estate with es_evars = vs (*Util.remove_dups (vs @ estate.es_evars)*)} in
		  let new_ctx = Ctx new_es in
		  let rs0, fold_prf = heap_entail_one_context_struc prog true false false new_ctx view_form pos in
		  let tmp_vars = p :: (estate.es_evars @ vs) in
		  (**************************************)
		  (*        process_one 								*)
		  (**************************************)
		  let rec process_one rs1 =
			Debug.devel_pprint ("fold: rs1:\n"
								^ (Cprinter.string_of_context rs1)) pos;
			match rs1 with
			  | OCtx (c1, c2) ->
				  (*
					It is no longer safe to assume that rs will be conjunctive.
					The recursive folding entailment call (via case splitting
					for example) can turn ctx to a disjunctive one, hence making
					rs disjunctive.
				  *)
				  let tmp1 = process_one c1 in
				  let tmp2 = process_one c2 in
				  let tmp3 = (mkOCtx tmp1 tmp2 pos) in
					tmp3
			  | Ctx es ->
				  (* let es = estate_of_context rs pos in *)
				  let w = CP.difference es.es_evars tmp_vars in
				  let tmp_pure = elim_exists_pure w es.es_pure pos in
				  let res_rs = Ctx {es with es_evars = estate.es_evars; es_pure = tmp_pure} in
					Debug.devel_pprint ("fold: context at beginning of fold: "
										^ (Cprinter.string_of_spec_var p) ^ "\n"
										^ (Cprinter.string_of_context ctx)) pos;
					Debug.devel_pprint ("fold: context at end of fold: "
										^ (Cprinter.string_of_spec_var p) ^ "\n"
										^ (Cprinter.string_of_context res_rs)) pos;
					Debug.devel_pprint ("fold: es.es_pure: "
										^ (Cprinter.string_of_pure_formula_branches es.es_pure)) pos;
					res_rs in
		  let res = List.map process_one rs0 in
			(res, fold_prf)
	  with
		| Not_found -> ([], Failure)
	end
  | _ ->
	  Debug.devel_pprint ("fold: second parameter is not a view: "
						  ^ (Cprinter.string_of_h_formula view)) pos;
	  ([], Failure)

and process_fold_result prog is_folding estate fold_rs0 p2 vs2 base2 pos : (context list * proof list) =
  let pure2 = base2.formula_base_pure in
  let resth2 = base2.formula_base_heap in
  let type2 = base2.formula_base_type in
  let branches2 = base2.formula_base_branches in
  let rec process_one fold_rs1 = match fold_rs1 with
	| OCtx (c1, c2) ->
		let tmp1, prf1 = process_one c1 in
		let tmp2, prf2 = process_one c2 in
		let tmp3 = or_context_list tmp1 tmp2 in
		let prf3 = Prooftracer.mkOrLeft fold_rs1 (Base base2) [prf1; prf2] in
		  (tmp3, prf3)
	| Ctx fold_es ->
		(*	let fold_es = estate_of_context fold_rs pos in *)
		(* remove the constraints involving only global variabls *)
		(* 20.05.2008 *)
		(*let _ = print_string ("[solver.ml, process_fold_result]: Context: " ^ Cprinter.string_of_context fold_rs1 ^ "\n") in
		let _ = (print_string ("\n[solver.ml, process_fold_result]: Pure formula: " ^ (Cprinter.string_of_pure_formula fold_es.es_pure) ^ "\n")) in
		let new_pure = discard_redundant_constraint fold_es.es_pure vs2 in
		let _ = (print_string ("[solver.ml, process_fold_result]: Global vars: " ^ (Cprinter.string_of_spec_var_list vs2) ^ "\n")) in
		let _ = (print_string ("[solver.ml, process_fold_result]: Pure formula after discarding globals: " ^ (Cprinter.string_of_pure_formula new_pure) ^ "\n")) in*)
		(* 20.05.2008 *)
		let (to_ante, to_ante_br), (to_conseq, to_conseq_br), new_evars = split_universal fold_es.es_pure fold_es.es_evars vs2 pos in
		let tmp_conseq = mkBase resth2 pure2 type2 branches2 pos in
		let new_conseq = normalize tmp_conseq
		  (CF.replace_branches to_conseq_br (formula_of_pure to_conseq pos)) pos in
		let new_ante = normalize fold_es.es_formula
		  (CF.replace_branches to_ante_br (formula_of_pure to_ante pos)) pos in
		let new_consumed = fold_es.es_heap in
		let new_es = {estate with es_heap = new_consumed;
						es_formula = new_ante;
                        es_evars = new_evars } in
		let new_ctx = Ctx new_es in
		  Debug.devel_pprint ("process_fold_result: new_ctx after folding: "
							  ^ (Cprinter.string_of_spec_var p2) ^ "\n"
							  ^ (Cprinter.string_of_context new_ctx)) pos;
		  Debug.devel_pprint ("process_fold_result: vs2: "
							  ^ (String.concat ", "
								   (List.map Cprinter.string_of_spec_var vs2))) pos;
		  Debug.devel_pprint ("process_fold_result: to_ante: "
							  ^ (Cprinter.string_of_pure_formula to_ante)) pos;
		  Debug.devel_pprint ("process_fold_result: to_conseq: "
							  ^ (Cprinter.string_of_pure_formula to_conseq)) pos;
		  Debug.devel_pprint ("process_fold_result: new_conseq:\n"
							  ^ (Cprinter.string_of_formula new_conseq)) pos;
		  let rest_rs, prf = heap_entail_one_context prog is_folding false
			new_ctx new_conseq pos
		  in
			Debug.devel_pprint ("process_fold_result: context at end fold: "
								^ (Cprinter.string_of_spec_var p2) ^ "\n"
								^ (Cprinter.string_of_context_list rest_rs)) pos;
			(rest_rs, prf) in
  let tmp1 = List.map process_one fold_rs0 in
  let tmp2, tmp_prfs1 = List.split tmp1 in
  let res = List.concat tmp2 in
	(res, tmp_prfs1)

					(*
					(* part of formula involving max/min/neq, part not *)
					and pick_up_pres pres = match pres with
					  | Presburger.BConstr (Presburger.EqMax _) -> (pres, Presburger.mkTrue)
					  | Presburger.BConstr (Presburger.EqMin _) -> (pres, Presburger.mkTrue)
					  | Presburger.BConstr (Presburger.ANeq _) -> (pres, Presburger.mkTrue)
					  | Presburger.PAnd (p1, p2) ->
						  let mp1, nmp1 = pick_up_pres p1 in
						  let mp2, nmp2 = pick_up_pres p2 in
							(Presburger.mkAnd mp1 mp2, Presburger.mkAnd nmp1 nmp2)
					  | _ -> (Presburger.mkTrue, pres)

					(*TODO: still not completed yet *)
					and elim_exists_pres (w : spec_var list) (f : Presburger.pConstr) =
					  let tmp1 = Presburger.force_to_exists w f in
					  let tmp2 = TP.pairwisecheck tmp1 in
						tmp2
						  (*
							and elim_exists_pres (w : spec_var list) (f0 : Presburger.pConstr) =
							let drop_exists (f : Presburger.pConstr) : Presburger.pConstr =
							f
							in
							let f1, f2 = pick_up_pres f0 in
							let tmp1 = Presburger.force_to_exists w f2 in
							let tmp2 = TP.pairwisecheck tmp1 in
							let tmp3 = Presburger.mkAnd f1 tmp2 in
							let tmp4 = Presburger.force_to_exists w tmp3 in
							tmp4
						  (* some more processing of tmp4 is needed *)
						  *)

					and elim_exists_pp (w : spec_var list) (f0 : ppConstr) pos =
					  let rec drop_exists (f : ppConstr) : ppConstr = match f with
						| PPAnd (f1, f2, _) ->
							let df1 = drop_exists f1 in
							let df2 = drop_exists f2 in
							let tmp = mkAndPP df1 df2 pos in
							  tmp
						| OEq (sv1, sv2, _) ->
							if List.mem sv1 w || List.mem sv2 w then
							  report_error pos ("elim_exists: " ^ (string_of_ppconstr f) ^ " should have been eliminated")
							else
							  f
						| _ ->
							let fvars = ppfv f in
							  if Util.disjoint fvars w then
								f
							  else
								PPTrue in
					  let tmp1 = Constr (Presburger.mkTrue, f0, HTrue, pos) in
					  let tmp2 = mkExists w tmp1 pos in
					  let tmp3 = elim_exists tmp2 in
						match tmp3 with
						  | Or _ -> report_error pos ("elim_exists_pp: Or is generated from Constr!!!")
						  | Constr _ ->
							  let _, tmp_pp, _ = split_components tmp3 in
								tmp_pp
						  | Exists _ ->
							  let quants, baref = split_quantifiers tmp3 in
							  let _, tmp_pp, _ = split_components baref in
							  let tmp = drop_exists tmp_pp in
								tmp
					*)
(*added 09-05-2008 , by Cristian, checks that after the RHS existential elimination the newly introduced variables will no appear in the residue*)
and redundant_existential_check (svs : CP.spec_var list) (ctx0 : context) =
   match ctx0 with
	| Ctx es -> let free_var_list = (fv es.es_formula) in
					begin if (not ( CP.disjoint svs free_var_list)) then
						Debug.devel_pprint ("Some variable introduced by existential elimination where found in the residue") no_pos end
	| OCtx (c1, c2) ->
	  let _ = redundant_existential_check svs c1 in
	  (redundant_existential_check svs c2)

and elim_exists_pure w (f, b) pos =
  (elim_exists_pure_branch w f pos, List.map (fun (l, f) -> (l, elim_exists_pure_branch w f pos)) b)

and elim_exists_pure_branch (w : CP.spec_var list) (f0 : CP.formula) pos =
  let f = CP.mkExists w f0 pos in
  let simplified_f = TP.simplify f in
	simplified_f

(* --- added 11.05.2008 *)
and elim_exists_ctx_list (ctx0 : context list) = match ctx0 with
  | [] -> []
  | h::rest -> (elim_exists_ctx h)::(elim_exists_ctx_list rest)
(* end added 11.05.2008 --- *)

and elim_exists_ctx (ctx0 : context) = match ctx0 with
  | Ctx es ->
	  let f_prim = elim_exists es.es_formula in
	  (* 05.06.08 *)
	  (* we also try to eliminate exist vars for which a find a substitution of the form v = exp from the pure part *)
	  (*let _ = print_string("[solver.ml, elim_exists_ctx]: Formula before exp exist elim: " ^ Cprinter.string_of_formula f_prim ^ "\n") in*)
	  let f = elim_exists_exp f_prim in

	  (*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_formula f ^ "\n") in*)

		let qvar, base = CF.split_quantifiers f in
		let h, p, b, t = CF.split_components base in
		let simpl_p =
			(* if the flag is enabled --> simplify the pure part *)
			if !Globals.simplify_pure then (simpl_pure_formula p)
			else p
		in
		let simpl_f = CF.mkExists qvar h simpl_p t b no_pos in
		(*let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_formula simpl_f ^ "\n") in *)
	  Ctx {es with es_formula = simpl_f}
  | OCtx (c1, c2) ->
	  let sc1 = elim_exists_ctx c1 in
	  let sc2 = elim_exists_ctx c2 in
	  let result = or_context sc1 sc2 in
		result

and elim_ante_evars (ctx : context) : context = match ctx with
  | OCtx (c1, c2) ->
	  let ec1 = elim_ante_evars c1 in
	  let ec2 = elim_ante_evars c2 in
		or_context ec1 ec2
  | Ctx es ->
(*
	  let tmp = List.map CP.name_of_spec_var es.es_ante_evars in
	  let _ = print_string ("\nante_evars: " ^ (String.concat ", " tmp) ^ "\n") in
*)
	  let f = push_exists es.es_ante_evars es.es_formula in
	  let ef = elim_exists f in
		Ctx {es with es_formula = ef }

(*and elim_unsat_ctx_list (prog : prog_decl) (cl0 : context list) =
  let tmp = List.map (elim_unsat_ctx prog) cl0 in
  let res = List.filter (fun c -> not (isFalseCtx c)) tmp in
	res
*)

and elim_unsat_ctx (prog : prog_decl) (ctx0 : context) =
(*  print_endline "elim_unsat_ctx";*)
  let rec unsat_helper ctx = match ctx with
	| Ctx es ->
		let f = es.es_formula in
		let _ = reset_int2 () in
        let (pf, pfb) = xpure prog f in
			        let fold_fun (is_ok, ctx) (_, pf1b) =
			          if not is_ok then (false, ctx) else
					let _ = reset_int2 () in
			          if TP.is_sat (*(CP.And (pf,*) pf1b(*, no_pos))*) then (true, ctx) else
					  (false, false_ctx no_pos)
			        in
        if pfb = [] then 
          let is_ok = TP.is_sat pf in
          (is_ok, if is_ok then ctx else 
		     (* let _ = print_string ("\n non sat formula: "^(Cprinter.string_of_formula f)^
			  "\n non sat approx pure formula: "^
			  (Cprinter.string_of_pure_formula pf)^"\n") in*)
			  false_ctx no_pos)
        else
          List.fold_left fold_fun (true, ctx) pfb
	| OCtx (c1, c2) ->
		let b1, sc1 = unsat_helper c1 in
		let b2, sc2 = unsat_helper c2 in
		  if b1 then
			if b2 then
			  (true, or_context sc1 sc2)
			else
			  (true, sc1)
		  else
			if b2 then
			  (true, sc2)
			else
			  (false, false_ctx no_pos) in
  let b, sc = unsat_helper ctx0 in
	sc
(*
and elim_struc_unsat prog (f:struc_formula):struc_formula = 
	let helper f = match f with
	|EBase b -> EBase{b with formula_ext_base = elim_unsat prog b.formula_ext_base;
							 formula_ext_continuation = elim_struc_unsat prog b.formula_ext_continuation;}
	|ECase b -> ECase{b with formula_case_branches = (List.fold_left
																(fun a (c1,c2)-> if (TP.is_sat c1) then (c1,(elim_struc_unsat prog c2))::a else a)
													[] b.formula_case_branches)}	
	| EAssume (x,b) -> EAssume (x,(elim_unsat prog b)) in
	List.map (fun c-> helper c) f
	*)
and elim_unsat (prog : prog_decl) (f : formula) = match f with
  | Or _ -> elim_unsat_all prog f
  | _ -> f

and elim_unsat_all prog (f : formula) = match f with
  | Base _ | Exists _ ->
	  let _ = reset_int2 () in
(*      print_endline (Cprinter.string_of_formula f);*)
	  let pf, pfb = xpure prog f in
      let fold_fun is_ok (label, pf1b) =
(*        print_endline (label);
        print_endline (Cprinter.string_of_pure_formula pf);
        print_endline (Cprinter.string_of_pure_formula pf1b);*)
        if not is_ok then false else
        if TP.is_sat (CP.And (pf, pf1b, no_pos)) then true else false
      in
      let is_ok =
        if pfb = [] then TP.is_sat pf else
        List.fold_left fold_fun true pfb
      in
(*      if is_ok then print_endline "elim_unsat_all: true" else print_endline "elim_unsat_all: false";*)
      if is_ok then f else mkFalse (pos_of_formula f)
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let nf1 = elim_unsat_all prog f1 in
	  let nf2 = elim_unsat_all prog f2 in
		mkOr nf1 nf2 pos

(* extracts those involve free vars from a set of equations  - here free means that it is not existential and it is not meant for explicit instantiation *)
and get_eqns_free (st : ((CP.spec_var * CP.spec_var) * branch_label) list) (evars : CP.spec_var list) (expl_inst : CP.spec_var list) pos : (CP.formula * (branch_label * CP.formula) list) = match st with
  | ((fr, t), br_label) :: rest ->
	  let (rest_eqns, rest_eqns_br) = get_eqns_free rest evars expl_inst pos in
		if (CP.mem fr evars) || (CP.mem fr expl_inst)  (*TODO: should this be uncommented? || List.mem t evars *) then
		  (rest_eqns, rest_eqns_br)
		else
		  let tmp = CP.mkEqVar fr t pos in
          if br_label = "" then
		    let res = CP.mkAnd tmp rest_eqns pos in
            (res, rest_eqns_br)
          else
            (rest_eqns, CP.add_to_branches br_label tmp rest_eqns_br)
  | [] -> (CP.mkTrue pos, [])

(*
	- extract the equations for the variables that are to be explicitly instantiated
	- remove the variables already instantiated from ivars
	- expl_vars will contain the vars that are next to be explicitly instantiated: for each equation ivar = v, it adds v to the list of vars that will be explicitly instantiated later
*)
and get_eqns_expl_inst (st : (CP.spec_var * CP.spec_var) list) (ivars : CP.spec_var list) (*(expl_vars : CP.spec_var list) *)pos : (CP.formula list * CP.spec_var list * CP.spec_var list) = match st with
  | (fr, t) :: rest ->
		if (CP.mem fr ivars) then
		  let ivars' = (List.filter (fun x -> not(CP.eq_spec_var fr x)) ivars) in
		  let (rest_eqns, ivars_new, expl_vars_new) = get_eqns_expl_inst rest ivars' pos in
		  let tmp = CP.mkEqVar fr t pos in
		  let res = [tmp]@rest_eqns in
			(*let _ = print_string ("expl_inst: " ^ (Cprinter.string_of_pure_formula tmp) ^ "\n") in*)
			(res, ivars_new, t::expl_vars_new)
		else (
		if (CP.mem t ivars) then
		  let ivars' = (List.filter (fun x -> not(CP.eq_spec_var t x)) ivars) in
		  let (rest_eqns, ivars_new, expl_vars_new) = get_eqns_expl_inst rest ivars' pos in
		  let tmp = CP.mkEqVar t fr pos in
		  let res = [tmp]@rest_eqns in
			(*let _ = print_string ("expl_inst: " ^ (Cprinter.string_of_pure_formula tmp) ^ "\n") in*)
			(res, ivars_new, fr::expl_vars_new)
		else
			(get_eqns_expl_inst rest ivars pos)
		)
  | [] -> ([], ivars, [])

(*  extract the equations for the variables that are to be explicitly instantiated from the residue - a Cpure.formula *)
(* get the equation for the existential variable used in the
   following variable elimination ex x. (x=y & P(x)) <=> P(y).
   The function also returns the remainder of the formula after
   the equation is extracted. It stops searching upon seeing
   Or/Exists/Forall. The equations returned are only of form
   v1 = v2 so that they can be applied to heap nodes. *)
and get_subst_equation (f : CP.formula) (v : CP.spec_var) : ((CP.spec_var * CP.spec_var) list * CP.formula) = match f with
  | CP.And (f1, f2, pos) ->
	  let st1, rf1 = get_subst_equation f1 v in
		if List.length st1 > 0 then (* should never be more than 1 *)
		  (st1, CP.mkAnd rf1 f2 pos)
		else
		  let st2, rf2 = get_subst_equation f2 v in
			(st2, CP.mkAnd f1 rf2 pos)

  | CP.BForm bf -> get_subst_equation_b_formula bf v
  | _ -> ([], f)

and get_subst_equation_b_formula (f : CP.b_formula) (v : CP.spec_var) : ((CP.spec_var * CP.spec_var) list * CP.formula) = match f with
  | CP.Eq (e1, e2, pos) -> begin
	  match e1, e2 with
		| CP.Var (sv1, pos1), CP.Var (sv2, pos2) ->
			if CP.eq_spec_var sv1 v then ([(v, sv2)], CP.mkTrue no_pos)
			else if CP.eq_spec_var sv2 v then ([(v, sv1)], CP.mkTrue no_pos)
			else ([], CP.BForm f)
		| _ -> ([], CP.BForm f)
	end
  | _ -> ([], CP.BForm f)

(* removing existentail using ex x. (x=y & P(x)) <=> P(y) *)
and elim_exists (f0 : formula) : formula = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let ef1 = elim_exists f1 in
	  let ef2 = elim_exists f2 in
		mkOr ef1 ef2 pos
  | Base _ -> f0
  | Exists ({formula_exists_qvars = qvar :: rest_qvars;
			 formula_exists_heap = h;
			 formula_exists_pure = p;
			 formula_exists_type = t;
             formula_exists_branches = b;
			 formula_exists_pos = pos}) ->
	  let st, pp1 = get_subst_equation p qvar in
		if List.length st = 1 then
		  let tmp = mkBase h pp1 t b pos in
		  let new_baref = subst st tmp in
		  let tmp2 = add_quantifiers rest_qvars new_baref in
		  let tmp3 = elim_exists tmp2 in
			tmp3
		else (* if qvar is not equated to any variables, try the next one *)
		  let tmp1 = mkExists rest_qvars h p t b pos in
		  let tmp2 = elim_exists tmp1 in
		  let tmp3 = add_quantifiers [qvar] tmp2 in
			tmp3
  | Exists _ -> failwith ("Solver.elim_exists: Exists with an empty list of quantified variables")

(**************************************************************)
(* heap entailment                                            *)
(**************************************************************)

and filter_set (cl : context list) : context list =
  if !Globals.use_set || U.empty cl then cl
  else [List.hd cl]

(* check entailment:                                          *)
(* each entailment should produce one proof, be it failure or *)
(* success. *)
and heap_entail_struc (prog : prog_decl) (is_folding : bool) (is_universal : bool) (has_post: bool)(cl : context list) (conseq : struc_formula) pos : (context list * proof) =
	if !Globals.use_set || U.empty cl then
	let tmp1 = List.map (fun c -> heap_entail_one_context_struc prog is_folding is_universal has_post c conseq pos) cl in
	let tmp2, tmp_prfs = List.split tmp1 in
	let prf = mkContextList cl conseq tmp_prfs in
	let tmp = List.concat tmp2 in
    (tmp, prf)
  else
	let tmp1, tmp2 = heap_entail_one_context_struc prog is_folding is_universal has_post (List.hd cl) conseq pos in
	  (tmp1, tmp2)
		  

and heap_entail_one_context_struc (prog : prog_decl) (is_folding : bool) (is_universal : bool) has_post (ctx : context) (conseq : struc_formula) pos : (context list * proof) =
  Debug.devel_pprint ("heap_entail_one_context_struc:"
					  ^ "\nctx:\n" ^ (Cprinter.string_of_context ctx)
					  ^ "\nconseq:\n" ^ (Cprinter.string_of_struc_formula conseq)) pos;
  if isFalseCtx ctx then
	(* check this first so that false => false is true (with false residual) *)
	([false_ctx pos], UnsatAnte)
  else(* if isConstFalse conseq then
	([], UnsatConseq)
  else *)if isConstETrue conseq then
	([ctx], TrueConseq)
  else
	let ctx1 = (*if !Globals.elim_unsat then elim_unsat_ctx prog ctx else *) ctx in
	  if isFalseCtx ctx1 then
		([false_ctx pos], UnsatAnte)
	  else
		let result, prf = heap_entail_after_sat_struc prog is_folding is_universal has_post ctx1 conseq pos in

		  (result, prf)

and heap_entail_after_sat_struc prog is_folding is_universal has_post ctx conseq pos : (context list * proof) = match ctx with
  | OCtx (c1, c2) ->
	  Debug.devel_pprint ("heap_entail_after_sat_struc:"
						  ^ "\nctx:\n" ^ (Cprinter.string_of_context ctx)
						  ^ "\nconseq:\n" ^ (Cprinter.string_of_struc_formula conseq)) pos;
	  let rs1, prf1 = heap_entail_after_sat_struc prog is_folding is_universal has_post c1 conseq pos in
		if not (U.empty rs1) then
		  let rs2, prf2 = heap_entail_after_sat_struc prog is_folding is_universal has_post c2 conseq pos in
			if not (U.empty rs2) then
			  let rs = or_context_list rs1 rs2 in
				(* there's no need to do filtering here as rs1 and rs2
				   only contain one set each if the flag is set *)
			  let prf = mkOrStrucLeft ctx conseq [prf1; prf2] in
				(rs, prf)
			else
			  ([], mkOrStrucLeft ctx conseq [prf2]) (* failure is caused by second branch *)
		else
		  ([], mkOrStrucLeft ctx conseq [prf1]) (* failure is caused by first branch *)
  | _ -> begin
	  Debug.devel_pprint ("heap_entail_after_sat_struc: invoking heap_entail_conjunct_lhs_struc"
						  ^ "\ncontext:\n" ^ (Cprinter.string_of_context ctx)
						  ^ "\nconseq:\n" ^ (Cprinter.string_of_struc_formula conseq)) pos;
	  let tmp, prf = heap_entail_conjunct_lhs_struc prog is_folding is_universal has_post ctx conseq pos in
		(filter_set tmp, prf)
	end

	  
and heap_entail_conjunct_lhs_struc 
(prog : prog_decl) 
(is_folding : bool) 
(is_universal : bool) 
(has_post:bool)
(ctx : context) 
(conseq : struc_formula) pos : (context list * proof) =

let rec inner_entailer (ctx : context) (conseq : struc_formula): (context list) * proof = 
	let rec helper (ctx : context) (f:ext_formula) : (context list) * proof = match f with
	| ECase b   -> 
					(*let _ = print_string ("\nstart case: "^(Cprinter.string_of_ext_formula f)^"\n") in*)
					if (List.length b.formula_case_exists)>0 then 
						 let ws = CP.fresh_spec_vars b.formula_case_exists in
						 let st = List.combine b.formula_case_exists ws in
					     let new_struc = subst_struc st [(ECase {b with formula_case_exists = []})]in
					     let new_ctx = push_exists_context ws ctx in
						 let nc,np = inner_entailer new_ctx new_struc in 
						 (nc,(mkEexStep ctx [f] np))
				    else if (List.length b.formula_case_branches )=0 then ([ctx],UnsatAnte)
					else let r = List.map (fun (c1,c2)-> 
							let n_ctx = combine_context_and prog ctx c1 in
							(*let n_ctx = elim_unsat_ctx prog n_ctx in*)
							(* let _ = print_string ("\n\n for branch "^(Cprinter.string_of_struc_formula c2)^"\n got context: "^
							 (Cprinter.string_of_context n_ctx)^" \n for which: "^(string_of_bool (isFalseCtx n_ctx)) ^"\n") in*)
							 if (isFalseCtx n_ctx) then ([n_ctx],UnsatAnte)
							else
								inner_entailer n_ctx c2
							) b.formula_case_branches in
						 let rez1,rez2 = List.split r in
						if (List.exists (fun c-> ((List.length c) = 0)) rez1) then ([], mkOrStrucLeft ctx conseq rez2)
						else
							let rez1 = List.fold_left (fun a c-> or_context_list a c) (List.hd rez1) (List.tl rez1) in
					(rez1,(mkCaseStep ctx [f] rez2))
	| EBase ({
	     formula_ext_explicit_inst =expl_inst;
		 formula_ext_implicit_inst = impl_inst;
		 formula_ext_exists = base_exists;
		 formula_ext_base = formula_base;
		 formula_ext_continuation = formula_cont;
		 formula_ext_pos = struc_pos;
	} as b)  -> if (List.length base_exists)>0 then 
						 let ws = CP.fresh_spec_vars base_exists in
						 let st = List.combine base_exists ws in
					     let new_struc = subst_struc st [(EBase {b with formula_ext_exists = []})]in
					     let new_ctx = push_exists_context ws ctx in
						 let nc,np = inner_entailer new_ctx new_struc in 
						 (nc,(mkEexStep ctx [f] np))
				    else 
					let n_ctx = (push_expl_impl_context expl_inst impl_inst ctx ) in
					let n_ctx_list, prf = heap_entail_one_context prog is_folding  is_universal n_ctx formula_base pos in
					(*let _ = print_string ("pp: "^(Cprinter.string_of_spec_var_list b.formula_ext_explicit_inst)^"\n"^
					(Cprinter.string_of_spec_var_list b.formula_ext_implicit_inst)^"\n"^
					(Cprinter.string_of_context n_ctx)^"\n conseqqq: "^
					(Cprinter.string_of_ext_formula f)^"\n"
						) in*)
					(*let n_ctx_list = List.filter  (fun c -> not (isFalseCtx c)) n_ctx_list in*)
					let n_ctx_list = List.map (fun c-> pop_expl_impl_context expl_inst impl_inst c) n_ctx_list in
					(*let _= print_string ("\n wrrap inst: "^(string_of_int (List.length formula_cont))^"\n"^
										(Cprinter.string_of_spec_var_list (expl_inst@impl_inst))^"\n") in*)
					if (Util.empty n_ctx_list) then ([],prf)
					else
						if (List.length formula_cont)>0 then
							let res, n_rpf = List.split (List.map (fun c->inner_entailer c formula_cont) n_ctx_list) in
							let res = List.concat res in							
							let res = if !wrap_exists_implicit_explicit then  
										let inst_list = (expl_inst@impl_inst) in
										List.map ( fun c-> push_exists_context inst_list c) res 
									  else res in
							(res, (mkBaseStep ctx [f] prf (mkCaseStep ctx [f] n_rpf)))
						else	 
							let res = if !wrap_exists_implicit_explicit then  
										let inst_list = (expl_inst@impl_inst) in	
										List.map ( fun c-> push_exists_context inst_list c) n_ctx_list 
								  else n_ctx_list in
						(*let _ = print_string ("\nresidue: "^(Cprinter.string_of_context_list res)^"\n  "^(string_of_bool (isFalseCtx (List.hd res)))^"\n") in*)
						(res,prf)
	| EAssume (ref_vars, post) -> if not has_post then report_error pos "malfunction: this formula can not have a post condition!"
					else
						let rs = CF.clear_entailment_history ctx in
						let rs1 = CF.compose_context_formula rs post ref_vars pos in
						let rs2 = elim_unsat_ctx prog rs1 in
						(*let _ = print_string (
						"\n rs1:"^
						(Cprinter.string_of_context rs1)
						^"\n rs2:"^
						(Cprinter.string_of_context rs2)^"\n"
						) in*)
						([rs2],TrueConseq)
	in
	(*let _ = print_string ("\n inner entailer: "^(string_of_int (List.length conseq))^"\n") in
	let _ = print_string ("\n thre conseq : "^(if ((List.length conseq)==3) then (Cprinter.string_of_struc_formula conseq) else "")^"\n") in*)
	if (List.length conseq)>0 then	
		let r = List.map (helper ctx) conseq in
		(*let _ = print_string ("\n r: "^(string_of_int (List.length r))^"\n") in*)
		let l1,l2 = List.split r in
		((List.concat l1),(mkCaseStep ctx conseq l2))
	else 
		([ctx],TrueConseq)in
	inner_entailer ctx conseq	

	
and heap_entail (prog : prog_decl) (is_folding : bool) (is_universal : bool) (cl : context list) (conseq : formula) pos : (context list * proof) =
  if !Globals.use_set || U.empty cl then
	let tmp1 = List.map (fun c -> heap_entail_one_context prog is_folding is_universal c conseq pos) cl in
	(*let _ = print_string ("\n init: "^(string_of_int (List.length cl))^"\n final: "^(string_of_int (List.length cl))^"\n("^
	(List.fold_left (fun a (c,_)-> a^","^(string_of_int(List.length c))) " " tmp1)^"\n") in*)
	let tmp2, tmp_prfs = List.split tmp1 in
	let prf = mkContextList cl (Cformula.formula_to_struc_formula conseq) tmp_prfs in
	let tmp = List.concat tmp2 in
    (tmp, prf)
  else
	let tmp1, tmp2 = heap_entail_one_context prog is_folding is_universal (List.hd cl) conseq pos in

	  (tmp1, tmp2)

and heap_entail_one_context (prog : prog_decl) (is_folding : bool) (is_universal : bool) (ctx : context) (conseq : formula) pos : (context list * proof) =
  Debug.devel_pprint ("heap_entail_one_context:"
					  ^ "\nctx:\n" ^ (Cprinter.string_of_context ctx)
					  ^ "\nconseq:\n" ^ (Cprinter.string_of_formula conseq)) pos;
  if isFalseCtx ctx then
	(* check this first so that false => false is true (with false residual) *)
	([false_ctx pos], UnsatAnte)
  else (*if isConstFalse conseq then
	([], UnsatConseq)
  else *)if isConstTrue conseq then
	([ctx], TrueConseq)
  else
	let ctx1 = (*if !Globals.elim_unsat then elim_unsat_ctx prog ctx else *) ctx in
	  if isFalseCtx ctx1 then
		([false_ctx pos], UnsatAnte)
	  else
		let result, prf = heap_entail_after_sat prog is_folding is_universal ctx1 conseq pos in

		  (result, prf)

and heap_entail_after_sat prog is_folding is_universal ctx conseq pos : (context list * proof) = match ctx with
  | OCtx (c1, c2) ->
	  Debug.devel_pprint ("heap_entail_after_sat:"
						  ^ "\nctx:\n" ^ (Cprinter.string_of_context ctx)
						  ^ "\nconseq:\n" ^ (Cprinter.string_of_formula conseq)) pos;
	  let rs1, prf1 = heap_entail_after_sat prog is_folding is_universal c1 conseq pos in
		if not (U.empty rs1) then
		  let rs2, prf2 = heap_entail_after_sat prog is_folding is_universal c2 conseq pos in
			if not (U.empty rs2) then
			  let rs = or_context_list rs1 rs2 in
				(* there's no need to do filtering here as rs1 and rs2
				   only contain one set each if the flag is set *)
			  let prf = mkOrLeft ctx conseq [prf1; prf2] in
				(rs, prf)
			else
			  ([], mkOrLeft ctx conseq [prf2]) (* failure is caused by second branch *)
		else
		  ([], mkOrLeft ctx conseq [prf1]) (* failure is caused by first branch *)
  | _ -> begin
	  Debug.devel_pprint ("heap_entail_after_sat: invoking heap_entail_conjunct_lhs"
						  ^ "\ncontext:\n" ^ (Cprinter.string_of_context ctx)
						  ^ "\nconseq:\n" ^ (Cprinter.string_of_formula conseq)) pos;
	  let tmp, prf = heap_entail_conjunct_lhs prog is_folding is_universal ctx conseq pos in
		(filter_set tmp, prf)
	end


(* check entailment when lhs is normal-form, rhs is a conjunct *)
and heap_entail_conjunct_lhs prog is_folding is_universal ctx conseq pos : (context list * proof) = match conseq with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos1}) ->
	  Debug.devel_pprint ("heap_entail_conjunct_lhs: \nante:\n"
						  ^ (Cprinter.string_of_context ctx)
						  ^ "\nconseq:\n"
						  ^ (Cprinter.string_of_formula conseq)) pos;
	  if !Globals.use_set then
		let rs1, prf1 = heap_entail_conjunct_lhs prog is_folding is_universal ctx f1 pos in
		let rs2, prf2 = heap_entail_conjunct_lhs prog is_folding is_universal ctx f2 pos in
		  if (U.empty rs1) & (U.empty rs2) then
			([], mkOrRight ctx conseq [prf1; prf2])
		  else if U.empty rs1 then
			(rs2, mkOrRight ctx conseq
			   (if !Globals.trace_all then [prf1; prf2] else [prf2]))
		  else if U.empty rs2 then
			(rs1, mkOrRight ctx conseq
			   (if !Globals.trace_all then [prf1; prf2] else [prf1]))
		  else
			(rs1 @ rs2, mkOrRight ctx conseq [prf1; prf2])
	  else
		let rs1, prf1 = heap_entail_conjunct_lhs prog is_folding is_universal ctx f1 pos in
		  if U.empty rs1 then
			let rs2, prf2 = heap_entail_conjunct_lhs prog is_folding is_universal ctx f2 pos in
			  (filter_set rs2, prf2)
		  else
			(filter_set rs1, prf1)
  | _ -> begin
	  Debug.devel_pprint ("heap_entail_conjunct_lhs: invoking heap_entail_conjunct") pos;
	  let ret = heap_entail_conjunct prog is_folding is_universal ctx conseq pos in
      ret
	end

(* 23.10.2008 *)
(* for empty RHS heap:
	- move the explicit instantiations from the RHS to the LHS
	- remove the explicit instantiated vars from the existential vars of the conseq
	- add the existential vars from the conseq to the existential vars from the antecedent
- f represents the consequent
*)
and move_lemma_expl_inst_ctx_list (ctx : context list) (f : formula) : context list =
	List.map (fun x -> move_lemma_expl_inst_ctx x f) ctx

and move_lemma_expl_inst_ctx	(ctx : context) (f : formula) : context =
	match ctx with
		| CF.Ctx(es) ->
			(*let _ = print_string("[cformula.ml]: move expl_inst: " ^ (Cprinter.string_of_formula f)  ^ "\n") in	 *)
			(* the expl vars were made existential while they were kept in the consequent - therefore, now we remove them from es_evars *)
			let new_es = (pop_exists_estate es.es_expl_vars es) in
			let new_es' = {new_es with
				(* existential vars from conseq are made existential in the entecedent *)
				es_ante_evars = new_es.es_ante_evars @ new_es.es_evars;
				es_formula = (CF.mkStar new_es.es_formula f no_pos)
			}
			in CF.Ctx(new_es')
		| CF.OCtx(c1, c2) ->
			CF.OCtx((move_lemma_expl_inst_ctx c1 f), (move_lemma_expl_inst_ctx c2 f))


and move_expl_inst_ctx_list (ctx:context list)(f:CP.formula):context list = 
	let rec helper (c:context):context = match c with
		| CF.Ctx es  ->
			let f1 = CP.mkExists (es.es_gen_impl_vars@es.es_evars) f no_pos in
			(*let _ = print_string ("\n push before:"^(Cprinter.string_of_pure_formula f)^"\n after: "
			^(Cprinter.string_of_pure_formula f1)^"\n") in*)
			let f1 = CP.elim_exists f1 in
			let f1 = formula_of_pure f1 no_pos in
			let new_es' = {es with
				(* existential vars from conseq are made existential in the entecedent *)
				es_gen_expl_vars = []; 
				es_gen_impl_vars = [];
				es_ante_evars = es.es_ante_evars @ es.es_evars;
				es_formula = (CF.mkStar es.es_formula f1 no_pos)
			}
			in CF.Ctx(new_es')
		| CF.OCtx(c1, c2) ->
			CF.mkOCtx (helper c1) (helper c2) no_pos in
	List.map helper ctx
			
(* from a list containing equaltions of the form vi = wi -> obtain two lists [vi]  and [wi] *)
and obtain_subst l =
	match l with
		| CP.BForm(CP.Eq(CP.Var(e1, _), CP.Var(e2, _), _))::r -> ((e1::(fst (obtain_subst r))), (e2::(snd (obtain_subst r))))
		| _::r -> ((fst (obtain_subst r)), (snd (obtain_subst r)))
		| [] -> ([],[])

(*************************************** 06.11.08 *******************************************************************)
(**********************************************************************************************************************)
(* check whether the target of a coercion is in the RHS of the entailment *)
(* coer: the coercion lemma to be applied *)
(* node: the node to which the coercion applies *)
(* lhs and rhs - the antecedent and consequent, respectively *)
and coer_target prog (coer : coercion_decl) node (rhs : CF.formula) (lhs : CF.formula) : bool =
	let coer_lhs = coer.coercion_head in
	let coer_rhs = coer.coercion_body in
	let coer_lhs_heap, coer_lhs_guard, coer_lhs_branches, _ = split_components coer_lhs in
	let rhs_heap, rhs_pure, rhs_branches, _ = split_components rhs in
	let lhs_heap, lhs_pure, lhs_branches, _ = split_components lhs in
	(*let _ = print_string("coer_lhs_heap = " ^ (Cprinter.string_of_h_formula coer_lhs_heap) ^ "\n") in
	let _ = print_string("node = " ^ (Cprinter.string_of_h_formula node) ^ "\n") in*)
	(* node - the node to which we want to apply the coercion rule *)
	(* need to find the substitution *)
	match node, coer_lhs_heap with
		| ViewNode ({h_formula_view_node = p1;
					h_formula_view_name = c1;
					h_formula_view_origins = origs;
					h_formula_view_arguments = ps1}),
		ViewNode ({h_formula_view_node = p2;
					h_formula_view_name = c2;
					h_formula_view_arguments = ps2}) when c1=c2 ->
			begin
			(* apply the substitution *)
			let coer_rhs_new = subst_avoid_capture (p2 :: ps2) (p1 :: ps1) coer_rhs in
			let coer_lhs_new = subst_avoid_capture (p2 :: ps2) (p1 :: ps1) coer_lhs in
			(*let _ = print_string("coer_rhs = " ^ (Cprinter.string_of_formula coer_rhs) ^ "\n") in*)
			(*let _ = print_string("coer_rhs_new = " ^ (Cprinter.string_of_formula coer_rhs_new) ^ "\n") in *)
			(* find the targets from the RHS of the coercion *)
			let top_level_vars = (CF.f_top_level_vars coer_rhs_new) in
			let target = (List.filter (fun x -> List.mem x top_level_vars) (CF.fv coer_rhs_new)) in
			let target = (List.filter (fun x -> (List.mem x (CF.fv coer_lhs_new))) target) in
			(*let _ = print_string ("Target:" ^ (Cprinter.string_of_spec_var_list target) ^ "\n") in*)
			let coer_rhs_h, _, _, _ = (split_components coer_rhs_new) in
			(* check for each target if it appears in the consequent *)
			let all_targets = (List.map (fun x -> (check_one_target prog x lhs_pure rhs_pure rhs_heap coer_rhs_h)) target) in
				let rec find_one_target all_targets = match all_targets with
					| true :: r -> true
					| false :: r -> (find_one_target r)
					| [] -> false
				in
				(* need to find at least one target *)
				(find_one_target all_targets)
			end
(* given a spec var -> return the entire node *)
and get_node (sv : CP.spec_var) (f : CF.h_formula) : CF.h_formula =
	match f with
	| Star({ h_formula_star_h1 = f1; h_formula_star_h2 = f2}) ->
		let res1 = (get_node sv f1) in
			begin
			 match res1 with
			 | HFalse -> (get_node sv f2)
			 | _ -> res1
			end
	| DataNode({h_formula_data_node = sv1; h_formula_data_name = name}) ->
		if (CP.eq_spec_var sv sv1)
			then f
			else HFalse
	| ViewNode({h_formula_view_node = sv1; h_formula_view_name = name}) ->
		if (CP.eq_spec_var sv sv1)
			then f
			else HFalse
	| _ -> HFalse

(* check whether target appears in rhs *)
(* we need lhs_pure to compute the alias set of target *)
and check_one_target prog (target : CP.spec_var) (lhs_pure : CP.formula) (rhs_p : CP.formula) (rhs_h : CF.h_formula) (coer_rhs_h : CF.h_formula): bool =
	(*let _ = print_string("check_one_target: target: " ^ (Cprinter.string_of_spec_var target) ^ "\n") in*)
	let lhs_eqns = ptr_equations lhs_pure in
	let lhs_asets = alias lhs_eqns in
	let lhs_targetasets1 = get_aset lhs_asets target in
	let lhs_targetasets =
		if CP.mem target lhs_targetasets1 then lhs_targetasets1
		else target :: lhs_targetasets1 in
		let fnode_results = (find_node prog rhs_h rhs_p lhs_targetasets no_pos) in
		begin
		match fnode_results with
			| Failed -> (*let _ = print_string("[check_one_target]: failed\n") in*) false
			| NoMatch -> (*let _ = print_string("[check_one_target]: no match\n") in*) false
			| Match (matches, resth1) ->
				begin
				match matches with
					| (anode, r_flag) :: rest ->
						begin
							let target_node = get_node target coer_rhs_h in
							let _ = Debug.devel_pprint ("Target: " ^ (Cprinter.string_of_h_formula target_node) ^ "\n") no_pos in
							let _ = Debug.devel_pprint ("Target match: " ^ (Cprinter.string_of_h_formula anode) ^ "\n") no_pos in
							begin
							match target_node, anode with
								| ViewNode ({h_formula_view_node = p1;
											 h_formula_view_name = c1}),
								  ViewNode ({h_formula_view_node = p2;
											 h_formula_view_name = c2}) when c1=c2 ->
											((*print_string("[check_one_target]: target match found\n"); *)true)
								| DataNode ({h_formula_data_node = p1;
											 h_formula_data_name = c1}),
								  DataNode ({h_formula_data_node = p2;
											 h_formula_data_name = c2}) when c1=c2 ->
											((*print_string("[check_one_target]: target match found\n");*) true)
								| _ ->	false
							end
						end
					| [] -> false
				end
		end

(* checks whether a coercion is distributive *)
and is_distributive	(coer : coercion_decl) : bool =
	let coer_lhs = coer.coercion_head in
	let coer_rhs = coer.coercion_body in
	let coer_lhs_heap, _, _, _ = split_components coer_lhs in
	let coer_rhs_heap, _, _, _ = split_components coer_rhs in
	let top_level_lhs = top_level_vars coer_lhs_heap in
	let top_level_rhs = top_level_vars coer_rhs_heap in
	not(List.mem false (List.map (fun x -> check_one_node x top_level_rhs coer_lhs_heap coer_rhs_heap) top_level_lhs))

(*  checks whether sv is present on the lhs and points to the same view *)
and check_one_node (sv : CP.spec_var) (top_level_rhs : CP.spec_var list) (lhs_heap : CF.h_formula) (rhs_heap : CF.h_formula) : bool =
	match top_level_rhs with
	| h :: r ->
		if (CP.eq_spec_var h sv) && (String.compare (CF.get_node_name (get_node sv lhs_heap)) (CF.get_node_name (get_node h rhs_heap))) == 0 then
			true
		else (check_one_node sv r lhs_heap rhs_heap)
	| [] -> false

(* returns the list of free vars from the rhs that do not appear in the lhs *)
and fv_rhs (lhs : CF.formula) (rhs : CF.formula) : CP.spec_var list =
	let lhs_fv = (CF.fv lhs) in
	let rhs_fv = (CF.fv rhs) in
		(List.filter (fun x -> not(List.mem x lhs_fv)) rhs_fv)

(* check the entailment of two conjuncts  *)
(* return value: if fst res = true, then  *)
(* snd res is the residual. Otherwise     *)
(* snd res is the constraint that causes  *)
(* the check to fail.                     *)
and heap_entail_conjunct (prog : prog_decl) (is_folding : bool) (is_universal : bool) (ctx0 : context) (conseq : formula) pos : (context list * proof) =
  Debug.devel_pprint ("heap_entail_conjunct:"
					  ^ "\ncontext:\n" ^ (Cprinter.string_of_context ctx0)
					  ^ "\nconseq:\n" ^ (Cprinter.string_of_formula conseq)) pos;
  match ctx0 with
	| Ctx estate -> begin
		let ante = estate.es_formula in
		  match ante with
			| Exists ({formula_exists_qvars = qvars;
					   formula_exists_heap = qh;
					   formula_exists_pure = qp;
					   formula_exists_type = qt;
                       formula_exists_branches = qb;
					   formula_exists_pos = pos}) ->
				(* eliminating existential quantifiers from the LHS *)
				(* ws are the newly generated fresh vars for the existentially quantified vars in the LHS *)
				let ws = CP.fresh_spec_vars qvars in
				(*--- 09.05.2008 *)
				(*let _ = (print_string ("\n[solver.ml, line 1183]: fresh name = " ^ (Cprinter.string_of_spec_var_list ws) ^ "!!!!!!!!!!!\n")) in*)
				(*09.05.2008 ---*)
				let st = List.combine qvars ws in
				let baref = mkBase qh qp qt qb pos in
				let new_baref = subst st baref in
				(* new ctx is the new context after substituting the fresh vars for the exist quantified vars *)
				let new_ctx = Ctx {estate with
									 es_formula = new_baref;
									 es_ante_evars = ws @ estate.es_ante_evars } in
				(* call the entailment procedure for the new context - with the existential vars substituted by fresh vars *)
				let rs, prf1 = heap_entail_conjunct prog is_folding is_universal new_ctx conseq pos in
				(* --- added 11.05.2008 *)
				let new_rs =
					if !Globals.wrap_exist then
						(* the fresh vars - that have been used to substitute the existenaltially quantified vars - need to be existentially quantified after the entailment *)
						(CF.add_exist_vars_to_ctx_list rs ws)
					else
						rs
				in
				(* log the transformation for the proof tracere *)
				let prf = mkExLeft ctx0 conseq qvars ws prf1 in
				  (new_rs, prf)
			| _ -> begin
				match conseq with
				  | Exists ({formula_exists_qvars = qvars;
							 formula_exists_heap = qh;
							 formula_exists_pure = qp;
							 formula_exists_type = qt;
                             formula_exists_branches = qb;
							 formula_exists_pos = pos}) ->
					  (* quantifiers on the RHS. Keep them for later processing *)
					  let ws = CP.fresh_spec_vars qvars in
					  let st = List.combine qvars ws in
					  let baref = mkBase qh qp qt qb pos in
					  let new_baref = subst st baref in
					  let new_ctx = Ctx {estate with es_evars = ws @ estate.es_evars} in
					  let tmp_rs, tmp_prf = heap_entail_conjunct prog is_folding is_universal new_ctx new_baref pos in
					  if not (U.empty tmp_rs) then
						  let prf = mkExRight ctx0 conseq qvars ws tmp_prf in
						  (*added 09-05-2008 , by Cristian, checks that after the RHS existential elimination the newly introduced variables will no appear in the residue hence no need to quantify*)
						  let _ = List.map (redundant_existential_check ws) tmp_rs in
						  (*let res_ctx_prim = List.map (push_exists_context ws) tmp_rs in*)
						  let res_ctx_prim  = tmp_rs in
						  let res_ctx =
							if !Globals.elim_exists then List.map elim_exists_ctx res_ctx_prim
							else res_ctx_prim
						  in
							(res_ctx, prf)
						else ([], tmp_prf) (* entailment fails *)
				  | _ ->
					  let h1, p1, br1, t1 = split_components ante in
					  let h2, p2, br2, t2 = split_components conseq in
					  	match h2 with
						  | HFalse (* -> ([], UnsatConseq)  entailment fails *)
						  | HTrue -> begin
							  Debug.devel_pprint ("heap_entail_conjunct: "
												  ^ "conseq has an empty heap component"
												  ^ "\ncontext:\n"
												  ^ (Cprinter.string_of_context ctx0)
												  ^ "\nconseq:\n"
												  ^ (Cprinter.string_of_formula conseq)) pos;
							  let b1 = { formula_base_heap = h1;
										 formula_base_pure = p1;
										 formula_base_type = t1;
                                         formula_base_branches = br1;
										 formula_base_pos = pos } in
								(* 23.10.2008 *)
(*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)
(* at the end of an entailment due to the epplication of an universal lemma, we need to move the explicit instantiation to the antecedent  *)
(* Remark: for universal lemmas we use the explicit instantiation mechanism,  while, for the rest of the cases, we use implicit instantiation *)
(*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)
								let ctx, proof = heap_entail_empty_rhs_heap prog is_folding is_universal estate b1 p2 br2 pos in
								
								let new_ctx =
									if is_universal then ((*print_string ("YES Expl inst!!\n");*) move_lemma_expl_inst_ctx_list ctx conseq)
									else ((*print_string ("NO Expl inst!!\n");*) ctx )
								in
								let new_ctx = move_expl_inst_ctx_list new_ctx p2 in
								(*let _ = print_string("heap_entail_conjunct:moved_insts: old: \n" ^(Cprinter.string_of_estate estate)^"\n-->"^
								(Cprinter.string_of_pure_formula p2)^
								"\n new: "^
								(Cprinter.string_of_context_list ctx)) in*)
									(new_ctx, proof)
							end
						  | _ -> begin
							  Debug.devel_pprint ("heap_entail_conjunct: "
												  ^ "conseq has an non-empty heap component"
												  ^ "\ncontext:\n"
												  ^ (Cprinter.string_of_context ctx0)
												  ^ "\nconseq:\n"
												  ^ (Cprinter.string_of_formula conseq)) pos;
							  let b1 = { formula_base_heap = h1;
										 formula_base_pure = p1;
										 formula_base_type = t1;
                                         formula_base_branches = br1;
										 formula_base_pos = pos } in
							  let b2 = { formula_base_heap = h2;
										 formula_base_pure = p2;
										 formula_base_type = t2;
                                         formula_base_branches = br2;
										 formula_base_pos = pos } in
								heap_entail_non_empty_rhs_heap prog is_folding is_universal ctx0 estate ante conseq b1 b2 pos
							end
			  end
	  end
	| _ -> report_error pos ("heap_entail_conjunct: context is disjunctive!!!")

and heap_entail_build_pure_check (evars : CP.spec_var list) (ante : CP.formula) (conseq : CP.formula) pos : (CP.formula * CP.formula) =
  let avars = CP.fv ante in
  let sevars = (* List.map CP.to_int_var *) evars in
  let outer_vars, inner_vars = List.partition (fun v -> CP.mem v avars) sevars in
  let tmp1 = CP.mkExists inner_vars conseq no_pos in
	if U.empty outer_vars then
	  (ante, tmp1)
	else
(*TODO: fix this
*)
	  let tmp2 = CP.mkExists sevars conseq no_pos in
		(ante, tmp2)
(*
	  Error.report_error {
		Error.error_loc = pos;
		Error.error_text = ("heap_entail_build_pure_check: outer_vars: "
							^ (String.concat ", "
								 (List.map CP.name_of_spec_var outer_vars))) }
*)
 
and heap_entail_empty_rhs_heap (prog : prog_decl) (is_folding : bool) (is_universal : bool) estate lhs rhs_p rhs_p_br pos : (context list * proof) =
  (*print_endline ("RHS: " ^ Cprinter.string_of_pure_formula_branches (rhs_p, rhs_p_br));*)
  (*print_endline ("LHS: " ^ Cprinter.string_of_formula (CF.formula_of_base lhs));*)
  let lhs_h = lhs.formula_base_heap in
  let lhs_p = lhs.formula_base_pure in
  let lhs_t = lhs.formula_base_type in
  let lhs_b = lhs.formula_base_branches in
  let _ = reset_int2 () in
  let xpure_lhs_h, xpure_lhs_h_b = xpure_heap prog (mkStarH lhs_h estate.es_heap pos) 1 in
(*  print_endline ("XPURE1: " ^ Cprinter.string_of_pure_formula_branches (xpure_lhs_h, xpure_lhs_h_b));*)
  let xpure_lhs_h0, xpure_lhs_h0_b = xpure_heap prog (mkStarH lhs_h estate.es_heap pos) 0 in
  (*print_endline ("consumed: "^(Cprinter.string_of_context (Cformula.Ctx estate)));
  print_endline ("XPURE0: " ^ Cprinter.string_of_pure_formula_branches (xpure_lhs_h0, xpure_lhs_h0_b));*)
  let fold_fun is_ok (branch_id, rhs_p) =
	if (is_ok = false) then false else begin
      let tmp1 = CP.mkAnd (CP.combine_branch branch_id (xpure_lhs_h, xpure_lhs_h_b)) (CP.combine_branch branch_id (lhs_p, lhs_b)) pos in
      let new_ante, new_conseq = heap_entail_build_pure_check (estate.es_evars@estate.es_gen_expl_vars) tmp1 rhs_p pos in
      let tmp2 = CP.mkAnd (CP.combine_branch branch_id (xpure_lhs_h0, xpure_lhs_h0_b)) (CP.combine_branch branch_id (lhs_p, lhs_b)) pos in
      let new_ante0, new_conseq0 = heap_entail_build_pure_check (estate.es_evars@estate.es_gen_expl_vars)  tmp2 rhs_p pos in
      (*(print_endline ("branch: " ^ branch_id ^ (Cprinter.string_of_pure_formula (CP.combine_branch branch_id (xpure_lhs_h, xpure_lhs_h_b))));*)
      let res = CP.isConstTrue rhs_p || TP.imply new_ante0 new_conseq0 || 
	  (((new_ante <> new_ante0) || (new_conseq <> new_conseq0)) && TP.imply new_ante new_conseq) in
      let res = 
        if res = false && branch_id = "" then
          let branches = Util.remove_dups (List.map (fun (bid, _) -> bid) (xpure_lhs_h_b @ lhs_b)) in
          let fold_fun is_ok branch_id_added =
            if is_ok then true else
            let tmp1 = CP.mkAnd (CP.combine_branch branch_id_added (xpure_lhs_h, xpure_lhs_h_b)) (CP.combine_branch branch_id_added (lhs_p, lhs_b)) pos in
            let new_ante, new_conseq = heap_entail_build_pure_check (estate.es_evars@estate.es_gen_expl_vars)  tmp1 rhs_p pos in
			(*let _ = print_string ("\n new ante: "^(Cprinter.string_of_pure_formula new_ante)^"\n new conseq: "^
				(Cprinter.string_of_pure_formula new_conseq)^"\n") in*)
            TP.imply new_ante new_conseq
          in
          List.fold_left fold_fun false branches
        else res
      in
      (*print_endline branch_id;
      print_endline ("RHS_P: " ^ Cprinter.string_of_pure_formula rhs_p);
      print_endline ("ANTE: " ^ Cprinter.string_of_pure_formula new_ante);
      print_endline ("CONSEQ: " ^ Cprinter.string_of_pure_formula new_conseq);
      if res then print_endline "ok" else print_endline "notok";*)
      res
    end
  in
  let prf = mkPure estate (CP.mkTrue no_pos) (CP.mkTrue no_pos) true None in
  if List.fold_left fold_fun true (("", rhs_p) :: rhs_p_br) then begin
	let res_delta = mkBase lhs_h lhs_p lhs_t lhs_b no_pos in
	if is_folding then begin
	  let res_es = {estate with es_formula = res_delta; es_pure = (rhs_p, rhs_p_br)} in
	  let res_ctx = Ctx res_es in
	  Debug.devel_pprint ("heap_entail_empty_heap: folding: formula is valid") pos;
	  Debug.devel_pprint ("heap_entail_empty_heap: folding: res_ctx:\n" ^ (Cprinter.string_of_context res_ctx)) pos;
	  ([res_ctx], prf)
	end else begin
	  let res_ctx = Ctx {estate with es_formula = res_delta} in
	  Debug.devel_pprint ("heap_entail_empty_heap: formula is valid") pos;
	  Debug.devel_pprint ("heap_entail_empty_heap: res_ctx:\n" ^ (Cprinter.string_of_context res_ctx)) pos;
	  ([res_ctx], prf)
	end
  end else begin
	Debug.devel_pprint ("heap_entail_conjunct: formula is not valid\n") pos;
	([], prf)
  end

and heap_entail_non_empty_rhs_heap prog is_folding is_universal ctx0 estate ante conseq lhs_b rhs_b pos : (context list * proof) =
  let lhs_h = lhs_b.formula_base_heap in
  let lhs_p = lhs_b.formula_base_pure in
  let lhs_t = lhs_b.formula_base_type in
  let lhs_br = lhs_b.formula_base_branches in
  let rhs_h = rhs_b.formula_base_heap in
  let rhs_p = rhs_b.formula_base_pure in
  let rhs_t = rhs_b.formula_base_type in
  let rhs_br = rhs_b.formula_base_branches in
  let ln2, resth2 = split_linear_node rhs_h in
	match ln2 with
	  | DataNode ({h_formula_data_node = p2;
				   h_formula_data_name = c2;
				   h_formula_data_arguments = v2;
				   h_formula_data_pos = pos2})
	  | ViewNode ({h_formula_view_node = p2;
				   h_formula_view_name = c2;
				   h_formula_view_arguments = v2;
				   h_formula_view_pos = pos2}) -> begin
		  Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: trying to prove "
							  ^ (Cprinter.string_of_h_formula ln2)) pos;
(************************************)
(* the folding process *)
(* process folding. var_to_fold is the variable from the LHS to fold to *)
(************************************)
(****************************************************************************************************************************************************************************)
(* do_fold *)
(****************************************************************************************************************************************************************************)
		  let do_fold_w_ctx fold_ctx var_to_fold = 
			let view_to_fold = ViewNode ({h_formula_view_node = var_to_fold;
										  h_formula_view_name = c2;
										  h_formula_view_arguments = v2;
										  h_formula_view_modes = get_view_modes ln2;
										  h_formula_view_coercible = true;
										  h_formula_view_origins = get_view_origins ln2;
										  h_formula_view_pos = pos2}) in
			let fold_rs, fold_prf = fold prog fold_ctx view_to_fold (P.mkTrue pos) pos in
			  if not (U.empty fold_rs) then
				let b = { formula_base_heap = resth2;
						  formula_base_pure = rhs_p;
						  formula_base_type = rhs_t;
                          formula_base_branches = rhs_br;
						  formula_base_pos = pos } in
				let tmp, tmp_prf = process_fold_result prog is_folding
				  estate fold_rs p2 v2 b pos in
				let prf = mkFold ctx0 conseq p2 fold_prf tmp_prf in
				  (tmp, prf)
			  else begin
				Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: unable to fold:\n"
									^ (Cprinter.string_of_context ctx0) ^ "\n"
									^ "to:ln2: "
									^ (Cprinter.string_of_h_formula ln2)
									^ "\nrhs_p: "
									^ (Cprinter.string_of_pure_formula rhs_p)) pos;
				([], fold_prf)
			  end in
		  let do_fold (var_to_fold : CP.spec_var) =
			let fold_ctx = Ctx {(empty_es pos) with es_formula = ante;
								  es_heap = estate.es_heap;
								  es_evars = estate.es_evars;
								  es_gen_expl_vars = estate.es_gen_expl_vars; 
								  es_gen_impl_vars = estate.es_gen_impl_vars; 
								  es_ante_evars = estate.es_ante_evars} in
			do_fold_w_ctx fold_ctx var_to_fold  in
			
		  
(****************************************************************************************************************************************************************************)
(* end do_fold *)
(****************************************************************************************************************************************************************************)
(****************************************************************************************************************************************************************************)
(* back into heap_entail_non_empty_rhs_heap *)
(****************************************************************************************************************************************************************************)
		  (*
			 find nodes from LHS matching p2. Matching can occur at root
			 or at an argument.

			 The search is quite aggressive for now. It not only looks for
			 nodes (from LHS) aliased to p2, but also nodes that are aliased
			 (using lhs_p) to variables aliased (using rhs_p) to p2.

			 TODO: show that this is ok.
		  *)
		  (*let rhs_eqns = ptr_equations rhs_p in
		  let rhs_asets = alias rhs_eqns in
		  let rhs_p2asets1 = get_aset rhs_asets p2 in
		  let rhs_p2asets =
			if CP.mem p2 rhs_p2asets1 then rhs_p2asets1
			else p2 :: rhs_p2asets1 in*)
		  let fnode_results = find_node_one prog lhs_h lhs_p p2(*rhs_p2asets*) pos in
		 (* let _ = print_string ("\n asets: "^(Cprinter.string_of_spec_var_list rhs_p2asets)^"\n") in*)
		 (* let _ = print_string ("\n p2: "^(Cprinter.string_of_spec_var p2)^
				(*"\n r asets: "^(List.fold_left (fun a c1-> (a^(Cprinter.string_of_spec_var c1))) "" rhs_p2asets)^*)
				"\n match result:"^
				( match fnode_results with
					| Failed -> "Failed match "
					| NoMatch -> "No Match"
					| Match (c1,_) -> "Match: "^
						(List.fold_left (fun a (c,c2)-> a^" "^(Cprinter.string_of_h_formula c)) "" c1))^"\n") in*)
			match fnode_results with
			  | Failed -> (*let _ = print_string("failed\n") in*) ([], NoAlias) (* p2 is not mentioned in LHS, failure *)
			  | NoMatch -> begin (* p2 is mentioned in LHS, but no matching
									node/predicate is found *)
				  (*let _ = print_string("no match\n") in*)
				  if is_data ln2 then begin (* fail *)
					Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
										^ "no aliased node for data node "
										^ (Cprinter.string_of_h_formula ln2)
										^ " is found in LHS\n") pos;
					([], NoAlias)
				  end
				  else begin (* attempting to fold against the base case *)
					Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
										^ "folding with no node on lhs: "
										^ (Cprinter.string_of_spec_var p2)
										^ "\ncontext:\n"
										^ (Cprinter.string_of_context ctx0)
										^ "\nln2:\n"
										^ (Cprinter.string_of_h_formula ln2)
										^ "\nrhs_p:\n"
										^ (Cprinter.string_of_pure_formula rhs_p)) pos;
					(* get a variable from the lhs that are aliased with p2 to use in the folding
					  let tmp_vars1 = CP.fv lhs_p in
					  let tmp_vars2 = List.filter (fun v -> CP.mem v p2aset) tmp_vars1 in
					  let var_to_fold = List.hd tmp_vars2 in (there must be at least one)
					*)
						do_fold p2 (* p2 is mentioned in LHS, p2 can be fold target *)
					  (* var_to_fold *)
				  end (* end of emty anodes case *)
				end
			  | Match (matches, resth1) -> begin
				  (* one or more aliased nodes are found, try all of them one by one. *)
				  (* When trying a node, add the remaining back to resth1. *)
				  let check_aliased_node (anode, r_flag) resth1 =
					(*let _ = print_string("match: " ^ (Cprinter.string_of_h_formula anode) ^ " for " ^ (Cprinter.string_of_h_formula ln2) ^ "\n") in
					let _ = print_string("conseq: " ^ (Cprinter.string_of_formula conseq) ^ "\n") in*)
					(* r_flag = true if the match happen at root pointer *)
					match anode with
					  | ViewNode ({h_formula_view_node = p1;
								   h_formula_view_name = c1;
								   h_formula_view_arguments = v1;
								   h_formula_view_pos = pos1})
					  | DataNode ({h_formula_data_node = p1;
								   h_formula_data_name = c1;
								   h_formula_data_arguments = v1;
								   h_formula_data_pos = pos1}) ->

						  (* helper functions for coercion *)

						  (*
							Applying universally-quantified lemmas. Here are the steps:
							- Compute the set of universal variables. If the set is
							empty, then just do normal rewriting. (this has been done by apply_universal).
							- Split the guard out. Change it to existential to check
							for satisfiability.
							- Do the rewriting.
							- Perform entailment with rewritten formula
							- Filter subformulas from the pure part of the consequent
							that are related to the guard. This provides us with the instantiation.

							Now it only works when applying to the antecedent.
						  *)
						(* new version:
							- forall v*. H /\ G -> B
							- match H and the node/predicate to be coerced and obtain the substitution \rho
						*)
(*******************************************************************************************************************************************************************************************)
(*
			Summary of the coercion helper methods:
			- check the guard in do_universal and rewrite_coercion
			-  rewrite_coercion called in apply_left_coercion and apply_right_coercion
			- apply_left_coercion called in do_coercion
			- apply_right_coercion called in do_coercion
			- do_coercion called in heap_entail_non_empty_rhs_heap --------- the main coercion helper
			- do_universal called in apply_universal
			- apply_universal called in do_coercion

*)
(*******************************************************************************************************************************************************************************************)
						(* do_universal *)
(*******************************************************************************************************************************************************************************************)

						let do_universal node f coer : (context list * proof) =
						begin
							(* rename the bound vars *)
							let f_univ_vars = CP.fresh_spec_vars coer.coercion_univ_vars in
(*
							let _ = print_string ("univ_vars: "   ^ (String.concat ", "   (List.map CP.name_of_spec_var  coer.coercion_univ_vars)) ^ "\n") in
*)
							(*let _ = print_string ("[do_univ]: rename the univ boudn vars: " ^ (String.concat ", " (List.map CP.name_of_spec_var f_univ_vars)) ^ "\n") in	*)
							let tmp_rho = List.combine coer.coercion_univ_vars f_univ_vars in
							let coer_lhs = CF.subst tmp_rho coer.coercion_head in
							let coer_rhs = CF.subst tmp_rho coer.coercion_body in
							(************************************************************************)
							(* also rename the free vars from the rhs that do not appear in the lhs *)
							let lhs_fv = (fv_rhs coer_lhs coer_rhs) in
							let fresh_lhs_fv = CP.fresh_spec_vars lhs_fv in
							let tmp_rho = List.combine lhs_fv fresh_lhs_fv in
							let coer_lhs = CF.subst tmp_rho coer_lhs in
							let coer_rhs = CF.subst tmp_rho coer_rhs in
							let lhs_heap, lhs_guard, lhs_branches, _ = split_components coer_lhs in
							  match node, lhs_heap with
								| ViewNode ({h_formula_view_node = p1;
											 h_formula_view_name = c1;
											 h_formula_view_origins = origs;
											 h_formula_view_arguments = ps1}),
								  ViewNode ({h_formula_view_node = p2;
											 h_formula_view_name = c2;
											 h_formula_view_arguments = ps2}) when c1=c2 -> begin
									(* the lemma application heuristic:
									- if the flag 	lemma_heuristic in true then we use both coerce& match - each lemma application must be followed by a match  - and history
									- if the flag is false, we only use coerce&distribute&match
									*)
									let apply_coer = (coer_target prog coer anode (CF.formula_of_base rhs_b) (CF.formula_of_base lhs_b)) in
									if (!Globals.lemma_heuristic && 		(* use coerce&match together with the history mechanism *)
										(not(apply_coer) 					(* the target is not present *)
										or (get_estate_must_match estate))  (* must match *)
										&& (List.mem coer.coercion_body_view origs
										or List.mem coer.coercion_head_view origs))  (* there is a cycle *)
									or 	(not(!Globals.lemma_heuristic) &&   (* use coerce&distribute&match*)
										(not(apply_coer) or 				(* the target is not present *)
										((get_estate_must_match estate) 	(* must match *)
										&& (not(!enable_distribution) 		(* distributive coercion is not allowed *)
										or not(is_distributive coer))))) 	(* coercion is not distributive *)
									then
										(Debug.devel_pprint("[do_universal]: Coercion cannot be applied!") pos; ([], Failure))
									else	(* we can apply coercion *)
									begin
									  if (not(!Globals.lemma_heuristic) && get_estate_must_match estate) then
										((*print_string("disable distribution\n");*) enable_distribution := false);
									  (* the \rho substitution \rho (B) and  \rho(G) is performed *)
									  let lhs_guard_new = CP.subst_avoid_capture (p2 :: ps2) (p1 :: ps1) lhs_guard in
                                      let lhs_branches_new = List.map (fun (s, f) -> (s, (CP.subst_avoid_capture (p2 :: ps2) (p1 :: ps1) f))) lhs_branches in
									  let coer_rhs_new1 = subst_avoid_capture (p2 :: ps2) (p1 :: ps1) coer_rhs in
									  let coer_rhs_new = add_origins coer_rhs_new1 (coer.coercion_head_view :: origs) in
									  let _ = reset_int2 () in
									  (*let xpure_lhs = xpure prog f in*)
(*************************************************************************************************************************************************************************)
(* delay the guard check *)
(* for now, just add it to the consequent *)
(*************************************************************************************************************************************************************************)
										(*let guard_to_check = CP.mkExists f_univ_vars lhs_guard_new pos in*)
										(*let _ = print_string("xpure_lhs: " ^ (Cprinter.string_of_pure_formula xpure_lhs) ^ "\n") in
										let _ = print_string("guard: " ^ (Cprinter.string_of_pure_formula guard_to_check) ^ "\n") in*)
										let new_f = normalize coer_rhs_new f pos in
										(* add the guard to the consequent  - however, the guard check is delayed *)
                                        let formula = replace_branches lhs_branches_new (formula_of_pure lhs_guard_new pos) in
										let new_conseq = normalize conseq formula pos in
										let new_estate = {estate with
															es_evars = f_univ_vars @ estate.es_evars;
															(* the new universal vars to be instantiated *)
															es_ivars = f_univ_vars @ estate.es_ivars;
															es_formula = new_f;
															es_must_match = true
														} in
										let new_ctx = Ctx new_estate in
										let res, prf = heap_entail prog is_folding true [new_ctx] new_conseq pos in
										(res, prf)
								  end
								end
								| _ -> ([], Failure)
						end
						in
						  (*
							Rewrites f by matching node with coer_lhs to obtain a substitution.
							The substitution is then applied to coer_rhs, which is then *-joined
							with f and then normalized.

							If the first component of the returned value is true, the rewrite
							is successful and the coercion performed. Otherwise, the rewrite is
							not performed (due to the guard).
						  *)
(*******************************************************************************************************************************************************************************************)
						(* rewrite_coercion *)
(*******************************************************************************************************************************************************************************************)
						let rewrite_coercion node f coer : (bool * formula) =
							(* This function also needs to add the name and the origin list
							   of the source view to the origin list of the target view. It
							   needs to check if the target view in coer_rhs belongs to the
							   list of origins of node. If so, don't apply the coercion *)
						(******************** here it was the test for coerce&match *************************)
							let coer_lhs = coer.coercion_head in
							let coer_rhs = coer.coercion_body in
							let lhs_heap, lhs_guard, lhs_branches, _ = split_components coer_lhs in
							  match node, lhs_heap with
								| ViewNode ({h_formula_view_node = p1;
											 h_formula_view_name = c1;
											 h_formula_view_origins = origs;
											 h_formula_view_arguments = ps1}),
								  ViewNode ({h_formula_view_node = p2;
											 h_formula_view_name = c2;
											 h_formula_view_arguments = ps2}) when c1=c2 -> begin
(*
									let _ = print_string ("body_view: " ^ coer.coercion_body_view ^ "\n") in
									let _ = print_string ("head_view: " ^ coer.coercion_head_view ^ "\n") in
									let _ = print_string ("origs: " ^ (String.concat ", " origs) ^ "\n") in
*)
(*************************************************************)
(* replace with the coerce&match mechanism *)
(*************************************************************)
								let apply_coer = (coer_target prog coer node (CF.formula_of_base rhs_b) (CF.formula_of_base lhs_b)) in
								(* the lemma application heuristic:
								- if the flag 	lemma_heuristic in true then we use both coerce& match and history
								- if the flag is false, we only use coerce&distribute&match
								*)
								if (!Globals.lemma_heuristic
									&& (not(apply_coer) (* coerce&match+history *)
									or (get_estate_must_match estate))
									&& (List.mem coer.coercion_body_view origs
									or List.mem coer.coercion_head_view origs))
									or 	(not(!Globals.lemma_heuristic) && (* coerce&distribute&match *)
									(not(apply_coer) or 	(* the target is not present *)
									((get_estate_must_match estate) (* must match *)
									&& (not(!enable_distribution) (* distributive coercion is not allowed *)
									or not(is_distributive coer))))) (* coercion is not distributive *)
									then

									(Debug.devel_pprint("[do_universal]: Coercion cannot be applied!") pos; (false, mkTrue no_pos))
								else
								(* we can apply coercion *)
								begin
									(* apply \rho (G)	and \rho(B) *)
									let lhs_guard_new = CP.subst_avoid_capture (p2 :: ps2) (p1 :: ps1) lhs_guard in
                                    (*let lhs_branches_new = List.map (fun (s, f) -> (s, (CP.subst_avoid_capture (p2 :: ps2) (p1 :: ps1) f))) lhs_branches in*)
									let coer_rhs_new1 = subst_avoid_capture (p2 :: ps2) (p1 :: ps1) coer_rhs in
									let coer_rhs_new = add_origins coer_rhs_new1 (coer.coercion_head_view :: origs) in
									let _ = reset_int2 () in
									let xpure_lhs, xpure_lhs_b = xpure prog f in
(*******************************************************************************************************************************************************************************************)
(* test the guard again in rewrite_coercion
- for now we only revise the universal lemmas handled by apply_universal --> the check stays here as it is *)
(*******************************************************************************************************************************************************************************************)
										(* is it necessary to xpure (node * f) instead ? *)
										if TP.imply xpure_lhs lhs_guard_new then
										  let new_f = normalize coer_rhs_new f pos in
											(if (not(!Globals.lemma_heuristic) && get_estate_must_match estate) then
											((*print_string("disable distribution\n"); *)enable_distribution := false);
											(true, new_f))
										else if !Globals.case_split then begin
										(*
											Doing case splitting based on the guard.
										*)
										  Debug.devel_pprint
											("rewrite_coercion: guard is not satisfied, " ^ "splitting.\n") pos;
										  let neg_guard = CP.mkNot lhs_guard_new pos in
										  let f0 = normalize f
											(formula_of_heap node pos) pos in
										  let f1 = normalize f0
											(formula_of_pure neg_guard pos) pos in
											(* unfold the case with the negation of the guard. *)
										  let f1 = unfold prog f1 p1 pos in
										  let f2 = normalize f0
											(formula_of_pure lhs_guard_new pos) pos in
											(* f2 need no unfolding, since next time
											   coercion is reapplied,
											   the guard is guaranteed to be satisified *)
										  let new_f = mkOr f1 f2 pos in
											if (not(!Globals.lemma_heuristic) && (get_estate_must_match estate)) then
											((*print_string("disable distribution\n"); *)enable_distribution := false);
											(true, new_f)
										end else begin
										  Debug.devel_pprint
											("rewrite_coercion: guard is not satisfied, "
											 ^ "no splitting.\n") pos;
										  (false, mkTrue no_pos)
										end
								  end
							end
								| _ -> (false, mkTrue no_pos)
							(*end	*)
							in
(*******************************************************************************************************************************************************************************************)
						  let apply_universal coer =
(*******************************************************************************************************************************************************************************************)
							flush stdout;
							if Util.empty coer.coercion_univ_vars then ([], Failure)
							else begin
							  let f = mkBase resth1 lhs_p lhs_t lhs_br pos in (* Assume coercions have no branches *)
							  let _ = Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: apply_universal: "
														  ^ "c1 = " ^ c1 ^ ", c2 = " ^ c2 ^ "\n") pos in
								do_universal anode f coer
							end
						  in

(*******************************************************************************************************************************************************************************************)
(* apply_left_coercion *)
(*******************************************************************************************************************************************************************************************)
						let apply_left_coercion coer =
							(*let _ = print_string("left coercion\n") in*)
							let f = mkBase resth1 lhs_p lhs_t lhs_br pos in
							let _ = Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
														^ "left_coercion: c1 = "
														^ c1 ^ "\n") pos in
								let ok, new_lhs = rewrite_coercion anode f coer in
								  if ok then begin
									let new_ctx1 = build_context ctx0 new_lhs pos in
									  (* let new_ctx = set_context_formula ctx0 new_lhs in *)
									let new_ctx = (set_context_must_match new_ctx1) in
									let res, tmp_prf = heap_entail prog is_folding false [new_ctx] conseq pos in
									let prf = mkCoercionLeft ctx0 conseq coer.coercion_head
									  coer.coercion_body tmp_prf coer.coercion_name
									in
									  (res, [prf])
								  end else ([], [])
						in

(*******************************************************************************************************************************************************************************************)
(* apply_right_coercion *)
(*******************************************************************************************************************************************************************************************)
						  let apply_right_coercion coer =
							(*let _ = print_string("right coercion\n") in*)
							let f = mkBase resth2 rhs_p rhs_t [] pos in
							let _ = Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
														^ "right_coercion: c2 = "
														^ c2 ^ "\n") pos in
							  if is_coercible ln2 then
									let ok, new_rhs = rewrite_coercion ln2 f coer in
									  if ok then begin
										let new_ctx = (set_context_must_match ctx0) in
										let res, tmp_prf = heap_entail prog is_folding false [new_ctx] new_rhs pos in
										let prf = mkCoercionRight ctx0 conseq coer.coercion_head
										  coer.coercion_body tmp_prf  coer.coercion_name
										in
										  (res, [prf])
									  end else ([], [])
							  else ([], []) in

(*******************************************************************************************************************************************************************************************)
					(* do_coercion *)
(*******************************************************************************************************************************************************************************************)
						  let do_coercion () =
							Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: do_coercion: " ^ "c1 = " ^ c1 ^ ", c2 = " ^ c2 ^ "\n") pos;
							let coers1 = look_up_coercion_def_raw prog.prog_left_coercions c1 in
							let coers1, univ_coers = List.partition (fun c -> Util.empty c.coercion_univ_vars) coers1 in
							  (* universal coercions *)
							(*let _ = print_string("[do_coercion]: number of univ coer " ^ (string_of_int (List.length univ_coers)) ^ "--> call apply universal \n") in*)
							let univ_res_tmp = List.map apply_universal univ_coers in
							let univ_res, _ = List.split univ_res_tmp in
							let univ_res = List.concat univ_res in
							  (* left coercions *)
							(*let _ = print_string("[do_coercion]: number of univ coer " ^ (string_of_int (List.length coers1)) ^ "--> call apply_left_coercion\n") in  *)
							let tmp1 = List.map apply_left_coercion coers1 in
							let tmp_res1, tmp_prf1 = List.split tmp1 in
							let tmp_res1 = List.concat tmp_res1 in
							let tmp_prf1 = List.concat tmp_prf1 in
							  (* a quick hack *)
							let tmp_res1 = univ_res @ tmp_res1 in
							  (* right coercions *)
							let coers2 = look_up_coercion_def_raw prog.prog_right_coercions c2 in
							let tmp2 = List.map apply_right_coercion coers2 in
							let tmp_res2, tmp_prf2 = List.split tmp2 in
							let tmp_res2 = List.concat tmp_res2 in
							let tmp_prf2 = List.concat tmp_prf2 in
							  if U.empty tmp_res1 & U.empty tmp_res2 then
							    (*let _ = print_string ("all failed\n") in*)
								([], tmp_prf1 @ tmp_prf2) (* report all failed proof in failure *)
							  else if U.empty tmp_res1 then
								(*let _ = print_string ("not all failed1\n") in*)
								(tmp_res2, tmp_prf2) (* only report the successful branch *)
							  else if U.empty tmp_res2 then
								(*let _ = print_string ("not all failed2\n") in*)
								(tmp_res1, tmp_prf1) (* only report the successful branch *)
							  else
								(*let _ = print_string ("not all failed3\n") in*)
								(tmp_res2 @ tmp_res1, tmp_prf1 @ tmp_prf2)
						  in
(*******************************************************************************************************************************************************************************************)
(*  back in heap_entail_non_empty_rhs_heap *)
(*******************************************************************************************************************************************************************************************)
						  (********************************)
						  (* start the main case analysis *)
						  (********************************)

							if r_flag = Root then begin (* matching occurs at root *)
								 
							  if c1 = c2 then 
							  let ans = if (not(is_data ln2)) then 
											let vd = (look_up_view_def_raw prog.prog_view_decls c2) in
											match vd.view_base_case with
												| None ->  
												(*let _ = print_string ("\ndoing a unfold for a missing base case\n") in*)
													let fold_ctx = Ctx {(empty_es pos) with es_formula = ante;
														  es_heap = estate.es_heap;
														  es_evars = estate.es_evars;
														  es_gen_expl_vars = estate.es_gen_expl_vars; 
														  es_gen_impl_vars = estate.es_gen_impl_vars; 
														  es_ante_evars = estate.es_ante_evars} in
													let null_formula = Cformula.formula_of_pure 
														(Cpure.BForm 
														(Cpure.Eq ((Cpure.Var (p2,no_pos)),(Cpure.Null no_pos),no_pos)
														) 
														) no_pos in
													let rs,prf = (heap_entail_one_context prog true false fold_ctx null_formula no_pos) in
													let r = if (List.length rs) <>1 then None
													else 
													
													Some (do_fold_w_ctx (normalize_context_formula (List.hd rs) null_formula pos) p2) in
													(*let _ = print_string ("\finishing a unfold for a missing base case\n") in*)
													r
												| Some (bc1,bc2) -> 
													(*let _ = print_string ("\ndoing a unfold for abase case\n") in*)
													let fold_ctx = Ctx {(empty_es pos) with es_formula = ante;
														  es_heap = estate.es_heap;
														  es_evars = estate.es_evars;
														  es_gen_expl_vars = estate.es_gen_expl_vars; 
														  es_gen_impl_vars = estate.es_gen_impl_vars; 
														  es_ante_evars = estate.es_ante_evars} in
													let fr_vars = (CP.SpecVar (CP.OType vd.Cast.view_data_name, self, Unprimed)) :: vd.view_vars in			
													let to_vars = p2 :: v1 in
													let bc1 = subst_struc_avoid_capture fr_vars to_vars bc1 in
													let bc2 = subst_avoid_capture fr_vars to_vars bc2 in
													(*let _ = print_string ("\n"^(Cprinter.string_of_context fold_ctx)^"\n"^
													(Cprinter.string_of_struc_formula bc1)^"\n"^
													(Cprinter.string_of_formula bc2)^"\n") in
													*)
													
													let rs,prf = (heap_entail_one_context_struc prog true false false fold_ctx bc1 pos) in
													(*let _ = print_string ("\n"^(Cprinter.string_of_context fold_ctx)^"\n"^
													(Cprinter.string_of_struc_formula bc1)^"\n"^
													(string_of_int (List.length rs))^"\n "^(Cprinter.string_of_context_list rs)^"\n") in*)
													let r = if (List.length rs) <>1 then None
													else 
														let r = (normalize_context_formula_combine (List.hd rs) bc2 pos) in
														Some (do_fold_w_ctx r p2)
													in
													(*let _ = print_string ("\finishing a unfold for abase case\n") in*)
													r
											else None in
							  match ans with 
							  | Some x -> x
							  | _ ->
								begin (* base case reduction *)
								(*let _ = print_string ("\n exact match \n") in*)
								Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: using " ^ (Cprinter.string_of_h_formula anode)	^ " to prove " ^ (Cprinter.string_of_h_formula ln2)) pos;
								(*let _ = print_string ("alias: " ^ (Cprinter.string_of_h_formula anode)	^ " for " ^ (Cprinter.string_of_h_formula ln2) ^ "\n") in*)
		                        let label_list =
                                  try 
                                    let vdef = Cast.look_up_view_def_raw prog.prog_view_decls c1 in
                                    vdef.Cast.view_labels
                                  with Not_found -> List.map (fun _ -> "") v1
                                in
								let rho = List.combine v2 v1 in
								let (expl_inst, ivars', expl_vars') = (get_eqns_expl_inst rho estate.es_ivars pos) in
								(* to_lhs only contains bindings for free vars that are not to be explicitly instantiated *)
								let rho = List.combine rho label_list in
                                (*List.iter (fun ((v2,v1),label) -> print_endline ("^\nCombine: " ^ label ^ " " ^ (Cprinter.string_of_spec_var v1) ^ " " ^ (Cprinter.string_of_spec_var v2))) rho;*)
								let to_lhs, to_lhs_br = get_eqns_free rho estate.es_evars (estate.es_expl_vars@expl_vars'@estate.es_gen_expl_vars) pos in
								(*let _ = print_endline("to_lhs " ^ c1 ^ ": " ^ (Cprinter.string_of_pure_formula_branches (to_lhs, to_lhs_br))) in*)
(*todo: the expl_vars i think whould be expl_vars - exist_vars: verify the any expl_inst is not in the expl_vars *)
								(*********************************************************************)
								(* handle both explicit and implicit instantiation *)
								(* for the universal vars from universal lemmas, we use the explicit instantiation mechanism,  while, for the rest of the cases, we use implicit instantiation *)
								(* explicit instantiation is like delaying the movement of the bindings for the free vars from the RHS to the LHS *)
								(********************************************************************)
								let new_ante = (mkBase resth1 (CP.mkAnd lhs_p to_lhs pos) lhs_t (CP.merge_branches lhs_br to_lhs_br) pos) in
								let tmp_conseq = mkBase resth2 rhs_p rhs_t rhs_br pos in
								(* apply the new bindings to the consequent *)
								let tmp_conseq' = subst_avoid_capture v2 v1 tmp_conseq in
								let tmp_h2, tmp_p2, tmp_b2, _ = split_components tmp_conseq' in
								let new_conseq = mkBase tmp_h2 tmp_p2 rhs_t tmp_b2 pos in
								let new_consumed = mkStarH anode estate.es_heap pos in
								let new_es = {estate with es_formula = new_ante;
											(* add the new vars to be explicitly instantiated *)
											es_expl_vars = estate.es_expl_vars@expl_vars';
											(* update ivars - basically, those univ vars for which binsings have been found will be removed:
												for each new binding uvar = x, uvar will be removed from es_ivars and x will be added to the es_expl_vars *)
											es_ivars = ivars';
											es_heap = new_consumed} in
								let new_subst = (obtain_subst expl_inst) in
								(* apply the explicit instantiations to the consequent *)
								let new_conseq = subst_avoid_capture (fst new_subst) (snd new_subst) new_conseq in
								(* for each expl inst vi = wi: make wi existential + remove vi from the exist vars *)
								let new_es' = {new_es with es_evars = new_es.es_evars @ (snd new_subst); es_must_match = false} in
					            let new_es = pop_exists_estate (fst new_subst) new_es' in
								let new_ctx = Ctx new_es in
									Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
													  ^ "new_ctx after matching: "
													  ^ (Cprinter.string_of_spec_var p2) ^ "\n"
													  ^ (Cprinter.string_of_context new_ctx)) pos;
									Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
													  ^ "new_conseq after matching:\n"
													  ^ (Cprinter.string_of_formula new_conseq))
										pos;
								let res_es1, prf1 = heap_entail_conjunct prog is_folding is_universal
									new_ctx new_conseq pos in
								let copy_enable_distribution = !enable_distribution in
								let res_es2, prf2 =
(*******************************************************************************************************************************************************************************************)
(* call to do_coercion *)
(* try coercion as well *)
(*******************************************************************************************************************************************************************************************)
								if is_view anode then
									(Debug.devel_pprint ("do_coercion for " ^ (Cprinter.string_of_h_formula anode) ^ "\n") pos;
									do_coercion ())
								else
                                  ([], [])
                                in
                                (*print_endline ("\nRES_ES2: " ^ Cprinter.string_of_context_list res_es2);*)
								enable_distribution := copy_enable_distribution;
								let prf1 = mkMatch ctx0 conseq ln2 [prf1] in
								let prf = mkMatch ctx0 conseq ln2 (prf1 :: prf2) in
								(* prf is the combined proof of both matching and coercion *)
								if U.empty res_es1 & U.empty res_es2 then
								  (*let _ = print_string ("both fail\n") in	 *)
								  ([], prf) (* both fail *)
								else if U.empty res_es1 then
								  (*let _ = print_string ("first fails\n") in	*)
								  (res_es2, mkCoercion2 ctx0 conseq prf2)
								else if U.empty res_es2 then
								  begin
									if (not(prf1 = Failure)) then
									  enable_distribution := true;
									(*print_string("enable distribution\n");*)
									(res_es1, prf1)
								  end
								else (* both ok *)
								  (res_es2 @ res_es1, prf)
							  end else if is_view ln2 && is_data anode then begin (* fold *)
								Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: folding: "
													^ (Cprinter.string_of_spec_var p2)
													^ "\nante:\n"
													^ (Cprinter.string_of_formula ante)
													^ "\nln2:\n"
													^ (Cprinter.string_of_h_formula ln2)
													^ "\nrhs_p:\n"
													^ (Cprinter.string_of_pure_formula rhs_p)) pos;
								do_fold p2
							  end else if is_data ln2 && is_view anode then begin (* unfold *)
								let delta1 = unfold prog ante p1 pos in
								let ctx1 = build_context ctx0 delta1 pos in
								let res_rs, prf1 = heap_entail_one_context prog
								  is_folding is_universal ctx1 conseq pos in
								let prf = mkUnfold ctx0 conseq anode prf1 in
								  (res_rs, prf)
							  end else if !Globals.use_coercion then begin
								(* two different predicates match, try coercion *)
								Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: " ^ "trying coercion") pos;
								let res, prfs = do_coercion () in
								let prf = mkCoercion2 ctx0 conseq prfs in
								  (res, prf)
							  end else begin
								Debug.devel_pprint ("heap_entail_conjunct: " ^ "can't reduce, fold, unfold") pos;
								([], Failure)
							  end
							end else if !Globals.use_coercion then
							  (* there is a match at some node, but not at root *)
							  (*if is_data ln2 && r_flag = Arg then begin
								Debug.devel_pprint ("heap_entail_conjunct: matching of data node"
													^ " with non-materialized argument") pos;
								([], NoAlias) (* there no hope an alias at
												 non-materialized arg would expose an object *)
							  end else*)
								let res, prfs = do_coercion () in
								let prf = mkCoercion2 ctx0 conseq prfs in
								  (res, prf)
							else
							  ([], NoAlias)
					  | _ -> report_error pos
						  ("heap_entail_conjunct: something wrong has happened "
						   ^ "with get_aliased_node") in

				  (* check one match *)
				  let rec check_node_helper all_nodes remaining_nodes : (context list * proof list) = match all_nodes with
					| (anode, r_flag) :: rest ->
						let tmp_rest = List.map fst rest in
						let rest_heap = List.fold_left (fun h1 -> fun h2 -> mkStarH h1 h2 pos)
						  resth1 (remaining_nodes @ tmp_rest) in
						let rs1, prf1 = check_aliased_node (anode, r_flag) rest_heap in
						let rs2, prfs2 =
						  if !Globals.use_set then check_node_helper rest
							(anode :: remaining_nodes)
						  else ([], [])
						in
						(rs1 @ rs2, prf1 :: prfs2)
					| [] -> ([], []) in

				  (* finally, check all matches  *)
				  let rs, prfs = check_node_helper matches [] in
(*
					if U.empty rs && is_view ln2 && is_complex_heap lhs_h then begin
					   ln2 may be an empty view, check that and if so,
                         restart entailment check without ln2 
                  let pure_lhs = CP.merge_branches lhs_br (formula_of_pure lhs_p pos) in
                  let pure_ctx = set_context_formula ctx0 pure_lhs in
						 let ln2_f = formula_of_heap ln2 pos in
						   let rs1 = heap_entail_conjunct prog is_folding pure_ctx ln2_f pos in 
                  let rs1, fold_prf = fold prog pure_ctx ln2 (CP.mkTrue pos) pos in
                  if U.empty rs1 then
					  let fold_prf = mkFold ctx0 conseq p2 fold_prf [] in
					  let prf = mkMMatch ctx0 conseq ln2 (fold_prf :: prfs) in
					  ([], prf)
				  else begin
					  let lhs_hf = formula_of_heap lhs_h pos in
					  let new_rs1 = List.map
                          (fun c -> normalize_context_formula c lhs_hf pos) rs1 in
						  let b = { formula_base_heap = resth2;
									formula_base_pure = rhs_p;
									formula_base_type = rhs_t;
									formula_base_pos = pos } in
						  let tmp, tmp_prfs = process_fold_result prog
                            is_folding estate new_rs1 p2 v2 b pos in
						  let prf = mkFold ctx0 conseq p2 fold_prf tmp_prfs in
							(tmp, prf)
				  end
				end else
*)
					  let prf =
						if U.empty (List.tl prfs) then List.hd prfs
						else mkMMatch ctx0 conseq ln2 prfs
					  in
						(rs, prf)
				end
		end
	  | HFalse | HTrue | Star _ -> failwith ("heap_entail_conjunct: "
											 ^ "something bad has happened to split_linear_node")

(*************************************************************************************************************************
	05.06.2008:
	Utilities for existential quantifier elimination:
	- before we were only searching for substitutions of the form v1 = v2 and then substitute ex v1. P(v1) --> P(v2)
	- now, we want to be more aggressive and search for substitutions of the form v1 = exp2; however, we can only apply these substitutions to the pure part
	(due to the way shape predicates are recorded --> root pointer and args are suppose to be spec vars)
	- also check that v1 is not contained in FV(exp2)
*************************************************************************************************************************)

(* apply elim_exist_exp_loop until no change *)
and elim_exists_exp (f0 : formula) : (formula) =
	let f, flag = elim_exists_exp_loop f0 in
		if flag then (elim_exists_exp f)
		else begin
			(*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_formula f ^ "\n") in
			let qvar, base = CF.split_quantifiers f in
			let h, p, t = CF.split_components base in
			let simpl_p = elim_exists_pure qvar p no_pos in
			let simpl_f = CF.mkExists qvar h simpl_p t no_pos in
			let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_formula simpl_f ^ "\n") in
				simpl_f *) f
		end

(* removing existentail using ex x. (x=e & P(x)) <=> P(e) *)
and elim_exists_exp_loop (f0 : formula) : (formula * bool) = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let ef1, flag1 = elim_exists_exp_loop f1 in
	  let ef2, flag2 = elim_exists_exp_loop f2 in
		(mkOr ef1 ef2 pos, flag1 & flag2)
  | Base _ -> (f0, false)
  | Exists ({formula_exists_qvars = qvar :: rest_qvars;
			 formula_exists_heap = h;
			 formula_exists_pure = p;
			 formula_exists_type = t;
             formula_exists_branches = b;
			 formula_exists_pos = pos}) ->
		let fvh = h_fv h in
		(*let _ = print_string("Try to eliminate " ^ Cprinter.string_of_spec_var qvar ^ "\n") in*)
		if  not(List.exists (fun sv -> CP.eq_spec_var sv qvar) fvh) then
		(*List.mem qvar fvh)	then*) (* if it does not appear in the heap part --> we try to eliminate *)
		(*let _ = print_string("fv(h) = " ^ Cprinter.string_of_spec_var_list fvh ^ "\n") in*)
		  let st, pp1 = get_subst_equation_exp p qvar in
		  if List.length st > 0 then (* if there exists one substitution  - actually we only take the first one -> therefore, the list should only have one elem *)
		  	(* basically we only apply one substitution *)
		  	let one_subst = List.hd st in
		  	(*let _ = print_string ("\nLength = " ^ string_of_int (List.length st) ^ "\n") in
		  	  let _ =  print_string("\n Using the subst var: " ^ Cprinter.string_of_spec_var (fst one_subst) ^ "\texp: " ^ Cprinter.string_of_formula_exp (snd one_subst) ^ "\n") in*)
		  	let tmp = mkBase h pp1 t b pos in
		  	(*let _ = (print_string (" Base formula: " ^ (Cprinter.string_of_formula tmp) ^ "\n")) in*)
			let new_baref = subst_exp [one_subst] tmp in
 		  	(*let _ = (print_string (" new_baref: " ^ (Cprinter.string_of_formula new_baref) ^ "\n")) in*)
			let tmp2 = add_quantifiers rest_qvars new_baref in
			let tmp3, _ = elim_exists_exp_loop tmp2 in
			(tmp3, true)
		  else (* if qvar is not equated to any variables, try the next one *)
			let tmp1 = mkExists rest_qvars h p t b pos in
			let tmp2, flag = elim_exists_exp_loop tmp1 in
			let tmp3 = add_quantifiers [qvar] tmp2 in
			(tmp3, flag)
		else (* anyway it's going to stay in the heap part so we can't eliminate --> try eliminate the rest of them, and then add it back to the exist quantified vars *)
		  let tmp1 = mkExists rest_qvars h p t b pos in
		  let tmp2, flag = elim_exists_exp_loop tmp1 in
		  let tmp3 = add_quantifiers [qvar] tmp2 in
				((push_exists [qvar] tmp3), flag)

  | Exists _ -> failwith ("Solver.elim_exists: Exists with an empty list of quantified variables")

and get_subst_equation_exp (f : CP.formula) (v : CP.spec_var) : ((CP.spec_var * CP.exp) list * CP.formula) = match f with
  | CP.And (f1, f2, pos) ->
	  let st1, rf1 = get_subst_equation_exp f1 v in
		if List.length st1 > 0 then (* should never be more than 1 *)
		  (st1, CP.mkAnd rf1 f2 pos)
		else
		  let st2, rf2 = get_subst_equation_exp f2 v in
			(st2, CP.mkAnd f1 rf2 pos)
  | CP.BForm bf -> get_subst_equation_b_formula_exp bf v
  | _ -> ([], f)

and get_subst_equation_b_formula_exp (f : CP.b_formula) (v : CP.spec_var) : ((CP.spec_var * CP.exp) list * CP.formula) = match f with
  | CP.Eq (e1, e2, pos) -> begin
	  match e1 with
		| CP.Var (sv1, pos1) ->
			(* check for equality and for circularity -> if v=e then v should not appear in FV(e) *)
			if (CP.eq_spec_var sv1 v) && (not (List.exists (fun sv -> CP.eq_spec_var sv v) (CP.afv e2)))
				(*(List.mem v (CP.afv e2))) *)
				then ([(v, e2)], CP.mkTrue no_pos)
			else
			begin
				match e2 with
				| CP.Var (sv2, pos2) ->
				if CP.eq_spec_var sv2 v && (not (List.exists (fun sv -> CP.eq_spec_var sv v) (CP.afv e1)))
					(*(not (List.mem v (CP.afv e1))) *)
					then ([(v, e1)], CP.mkTrue no_pos)
				else ([], CP.BForm f)
				| _ -> ([], CP.BForm f)
			end
		| _ ->
			begin
				match e2 with
				| CP.Var (sv2, pos2) ->
				if CP.eq_spec_var sv2 v && (not (List.exists (fun sv -> CP.eq_spec_var sv v) (CP.afv e1)))
					(*(not (List.mem v (CP.afv e1))) *)
					then ([(v, e1)], CP.mkTrue no_pos)
				else ([], CP.BForm f)
				| _ -> ([], CP.BForm f)
			end
	end
	| _ -> ([], CP.BForm f)

(******************************************************************************************************************
	10.06.2008
	Utilities for simplifications:
	- whenever the pure part contains some arithmetic formula that can be further simplified --> call the theorem prover to perform the simplification
	Ex. x = 1 + 0 --> simplify to x = 1
******************************************************************************************************************)
and simpl_pure_formula (f : CP.formula) : CP.formula = match f with
  | CP.And (f1, f2, pos) -> CP.mkAnd (simpl_pure_formula f1) (simpl_pure_formula f2) pos
  | CP.Or (f1, f2, pos) -> CP.mkOr (simpl_pure_formula f1) (simpl_pure_formula f2) pos
  | CP.Not (f1, pos) -> CP.mkNot (simpl_pure_formula f1) pos
  | CP.Forall (sv, f1, pos) -> CP.mkForall [sv] (simpl_pure_formula f1) pos
  | CP.Exists (sv, f1, pos) -> CP.mkExists [sv] (simpl_pure_formula f1) pos
  | CP.BForm (f1) ->
  		let simpl_f = CP.BForm(simpl_b_formula f1) in
    	(*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_pure_formula f ^ "\n") in
			let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_pure_formula simpl_f ^ "\n") in*)
			simpl_f

and simpl_b_formula (f : CP.b_formula) : CP.b_formula =  match f with
	| CP.Lt (e1, e2, pos)
	| CP.Lte (e1, e2, pos)
	| CP.Gt (e1, e2, pos)
	| CP.Gte (e1, e2, pos)
	| CP.Eq (e1, e2, pos)
	| CP.Neq (e1, e2, pos)
	| CP.BagSub (e1, e2, pos) ->
		if ((count_iconst e1) > 1) or ((count_iconst e2) > 1) then
			(*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_b_formula f ^ "\n") in*)
			let simpl_f = TP.simplify (CP.BForm(f)) in
  		begin
  		match simpl_f with
  		| CP.BForm(simpl_f1) ->
  			(*let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_b_formula simpl_f1 ^ "\n") in*)
  			simpl_f1
  		| _ -> f
  		end
  	else f
	| CP.EqMax (e1, e2, e3, pos)
	| CP.EqMin (e1, e2, e3, pos) ->
		if ((count_iconst e1) > 1) or ((count_iconst e2) > 1) or ((count_iconst e3) > 1) then
			(*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_b_formula f ^ "\n") in*)
			let simpl_f = TP.simplify (CP.BForm(f)) in
  		begin
  		match simpl_f with
  		| CP.BForm(simpl_f1) ->
  			(*let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_b_formula simpl_f1 ^ "\n") in*)
  			simpl_f1
  		| _ -> f
  		end
  	else f
  | CP.BagIn (sv, e1, pos)
  | CP.BagNotIn (sv, e1, pos) ->
  	if ((count_iconst e1) > 1) then
			(*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_b_formula f ^ "\n") in*)
			let simpl_f = TP.simplify (CP.BForm(f)) in
  		begin
  		match simpl_f with
  		| CP.BForm(simpl_f1) ->
  			(*let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_b_formula simpl_f1 ^ "\n") in*)
  			simpl_f1
  		| _ -> f
  		end
  	else f
	| _ -> f

(*
	- count how many int constants are contained in one expression
	- if there are more than 1 --> means that we can simplify further (by performing the operation)
*)
and count_iconst (f : CP.exp) = match f with
  | CP.Subtract (e1, e2, _)
  | CP.Add (e1, e2, _) -> ((count_iconst e1) + (count_iconst e2))
  | CP.Mult (_, e2, _) -> (1 + (count_iconst e2))
	| CP.IConst _ -> 1
	| _ -> 0

and combine_struc (f1:struc_formula)(f2:struc_formula) :struc_formula = 
	let rec combine_ext_struc (f1:ext_formula)(f2:ext_formula):ext_formula = match f1 with
	| ECase b -> let r = match f2 with
					| ECase d ->
						let comb = (List.fold_left (fun a1 (c11,c12)-> a1@(List.map (fun (c21,c22)-> 
						((Cpure.mkAnd c11 c21 d.formula_case_pos),c12,c22)) b.formula_case_branches) ) [] d.formula_case_branches) in
						let comb = List.fold_left (fun a (c1,c2,c3)-> 
							if (Tpdispatcher.is_sat c1) then a
							else (c1,(combine_struc c2 c3))::a)[] comb in
						ECase {b with 
							formula_case_exists = b.formula_case_exists@d.formula_case_exists;
							formula_case_branches = comb}
					| EBase d ->
						ECase {b with formula_case_branches =  (List.map (fun (c1,c2)-> (c1,(combine_struc [f2] c2))) b.formula_case_branches)}
					| EAssume _ -> ECase ({b with formula_case_branches = List.map (fun (c1,c2)-> (c1,(combine_struc c2 [f2])))
							 b.formula_case_branches}) in r	
	| EBase b -> let r = match f2 with
					| ECase d ->
					 ECase {d with 	 formula_case_branches =  (List.map (fun (c1,c2)-> (c1,(combine_struc [f1] c2))) d.formula_case_branches)}
					| EBase d -> EBase 
					{
					 formula_ext_explicit_inst = b.formula_ext_explicit_inst @ d.formula_ext_explicit_inst;
					 formula_ext_implicit_inst = b.formula_ext_implicit_inst @ d.formula_ext_implicit_inst;
					 formula_ext_exists = b.formula_ext_exists @ d.formula_ext_exists;
					 formula_ext_base = normalize_combine b.formula_ext_base d.formula_ext_base b.formula_ext_pos ;
					 formula_ext_continuation = combine_struc b.formula_ext_continuation d.formula_ext_continuation;
					 formula_ext_pos = b.formula_ext_pos
					}
					| EAssume _ -> EBase ({b with formula_ext_continuation = combine_struc b.formula_ext_continuation [f2]}) in r
	| EAssume (x1,b)-> let r = match f2 with
					| ECase d -> combine_ext_struc f2 f1
					| EBase d -> combine_ext_struc f2 f1 
					| EAssume (x2,d) -> EAssume ((x1@x2),(normalize_combine b d (Cformula.pos_of_formula d))) in r in
List.fold_left (fun b c1->b@(List.map (fun c2->(combine_ext_struc c1 c2)) f2)) [] f1


and compose_struc_formula (delta : struc_formula) (phi : struc_formula) (x : CP.spec_var list) (pos : loc) =
  let rs = CP.fresh_spec_vars x in
  (*--- 09.05.2000 *)
	(*let _ = (print_string ("\n[cformula.ml, line 533]: fresh name = " ^ (string_of_spec_var_list rs) ^ "!!!!!!!!!!!\n")) in*)
	(*09.05.2000 ---*)
  let rho1 = List.combine (List.map CP.to_unprimed x) rs in
  let rho2 = List.combine (List.map CP.to_primed x) rs in
  let new_delta = subst_struc rho2 delta in
  let new_phi = subst_struc rho1 phi in
  let new_f = combine_struc new_delta new_phi in
  let resform = push_struc_exists rs new_f in
	resform	