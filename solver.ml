(*
26.11.2008
todo: disable the default logging for omega
*)


open Globals
open Cast
open Cformula
open Prooftracer

module CP = Cpure
module MCP = Mcpure
module Err = Error
module TP = Tpdispatcher

let rec filter_formula_memo f = 
  match f with
    | Or c -> mkOr (filter_formula_memo c.formula_or_f1) (filter_formula_memo c.formula_or_f2) no_pos
    | Base b-> 
      let fv = (h_fv b.formula_base_heap)@(MCP.mfv b.formula_base_pure) in
      let nmem = MCP.filter_useless_memo_pure TP.simplify fv b.formula_base_pure in
      Base {b with formula_base_pure = nmem;}
    | Exists e-> 
      let fv = (h_fv e.formula_exists_heap)@(MCP.mfv e.formula_exists_pure)@e.formula_exists_qvars in
      let nmem = MCP.filter_useless_memo_pure TP.simplify fv e.formula_exists_pure in
      Exists {e with formula_exists_pure = nmem;}

(*find what conditions are required in order for the antecedent node to be pruned sufficiently
  to match the conseq, if the conditions relate only to universal variables then move them to the right*)
let prune_branches_subsume prog univ_vars lhs_node rhs_node = match lhs_node,rhs_node with
  | DataNode dn1, DataNode dn2-> 
    (match (dn1.h_formula_data_remaining_branches,dn2.h_formula_data_remaining_branches) with
      | None,None -> (true, None)
      | Some l1, Some l2 -> (Util.subset l1 l2, None)
      | _ -> (false, None))
  | ViewNode vn1, ViewNode vn2->
    (match (vn1.h_formula_view_remaining_branches,vn2.h_formula_view_remaining_branches) with
      | None,None -> (true, None)
      | Some l1, Some l2 -> 
        if (Util.subset l1 l2) then (true, None)
        else if (Util.subset l2 l1) then 
          let need_prunning = Util.difference l1 l2 in
          let v_def = look_up_view_def no_pos prog.prog_view_decls vn1.h_formula_view_name in
          let to_vars = vn1.h_formula_view_node:: vn1.h_formula_view_arguments in
          let self_v = CP.SpecVar (CP.OType v_def.view_data_name, self, 
                  if (CP.is_primed vn1.h_formula_view_node) then Primed else Unprimed) in
          let from_vars = self_v::v_def.view_vars in
          let subst_vars = List.combine from_vars to_vars in
          let new_cond = List.map (fun (c1,c2)-> (CP.b_subst subst_vars c1,c2)) v_def.view_prune_conditions in         
          let new_cond = List.filter (fun (c1,c2)-> 
                (Util.subset (CP.bfv c1) univ_vars)&&((List.length (Util.intersect need_prunning c2))>0)) new_cond in
          if (Util.subset need_prunning (List.concat (List.map snd new_cond))) then
            let inst_forms = CP.conj_of_list (List.map (fun (c,_)-> CP.BForm ((MCP.memo_f_neg c),None)) new_cond) no_pos in
            (true, Some inst_forms)
          else (false, None)
        else (false, None)
      | _ -> (false, None))
  | _ -> (false, None)      

let clear_entailment_history_es (es :entail_state) :context = 
  Ctx {(es_cache_same es (empty_es (mkTrueFlow ()) no_pos)) with 
    es_formula = filter_formula_memo es.es_formula; es_path_label = es.es_path_label;es_prior_steps= es.es_prior_steps;} 
 
let clear_entailment_history (ctx : context) : context =  
  transform_context clear_entailment_history_es ctx
  
let clear_entailment_history_list (ctx : list_context) : list_context = 
  transform_list_context (clear_entailment_history_es,(fun c->c)) ctx 

let clear_entailment_history_partial_list (ctx : list_partial_context) : list_partial_context = 
  transform_list_partial_context (clear_entailment_history_es,(fun c->c)) ctx 



let fail_ctx_stk = ref ([]:fail_type list)
(*
let push_fail_ctx p = 
    fail_ctx_stk:=p::!fail_ctx_stk

let pop_fail_ctx () = 
  fail_ctx_stk:=  match !fail_ctx_stk with
    | [] -> []
    | h::t -> t
  *) 
let previous_failure () = not(U.empty !fail_ctx_stk)
   


let enable_distribution = ref true
let imp_no = ref 1


class entailhist =
object (self)
  val en_hist = Hashtbl.create 40
    
  method init () = Hashtbl.clear en_hist
    
  method upd_opt (pid : control_path_id) (rs: list_context) (errmsg: string) =
    match pid with 
	None -> failwith errmsg;
      | Some (pid_i,_) -> Hashtbl.add en_hist pid_i rs

  method upd (pid : formula_label) (rs: list_context) =
    let pid_i,_ = pid in
      Hashtbl.add en_hist pid_i rs

  method get (id : int) : list_context list =
    Hashtbl.find_all en_hist id

end

let entail_hist = new entailhist 





type find_node_result =
  | Failed (* p2 (of p2::c2<V2> coming from the RHS) is not in FV(LHS) *)
  | NoMatch (* p2 \in FV(LHS), but no aliased node is found *)
  | Match of (Context.context list) (* found p1::c1<V1> such that p1=p2 *)
  
let no_diff = ref false (* if true, then xpure_symbolic will drop the disequality generated by * *)

let no_check_outer_vars = ref false 

let rec xpure (prog : prog_decl) (f0 : formula) : (MCP.memo_pure * (branch_label * CP.formula) list) = match f0 with
  | Or ({ formula_or_f1 = f1;
          formula_or_f2 = f2;
          formula_or_pos = pos}) ->
      let pf1, pf1b = xpure prog f1 in
      let pf2, pf2b = xpure prog f2 in
      let branches = Util.remove_dups (fst (List.split pf1b) @ (fst (List.split pf2b))) in
      let map_fun branch =
        try 
          let l1 = List.assoc branch pf1b in
          try
            let l2 = List.assoc branch pf2b in
            CP.mkOr l1 l2 None pos
          with Not_found -> CP.mkTrue no_pos
        with Not_found -> CP.mkTrue no_pos
      in
      let map_fun b = (b, map_fun b) in
	  (MCP.mkOr_mems pf1 pf2 ), (List.map map_fun branches)
  | Base ({ formula_base_heap = h;
            formula_base_pure = p;
            formula_base_branches = br;
            formula_base_pos = pos}) ->
      let (ph, phb) = xpure_heap prog h 1 in
      let phb = CP.merge_branches phb br in
      let rb = if (List.length phb) = 0 then []
        else
          let r = MCP.fold_mem_lst (MCP.fold_mem_lst (CP.mkTrue pos) false true ph) false true p in     
          List.map (fun (l, x) -> (l, CP.mkAnd x r pos)) phb in          
      ((MCP.merge_mems p ph true), rb)
  | Exists ({ formula_exists_qvars = qvars;
              formula_exists_heap = qh;
              formula_exists_pure = qp;
              formula_exists_branches = br;
              formula_exists_pos = pos}) ->
      let (pqh, pqhb) = xpure_heap prog qh 1 in
      let pqhb = CP.merge_branches pqhb br in
      let sqvars = (* List.map CP.to_int_var *) qvars in
      let tmp1 = MCP.merge_mems qp pqh true in
      let r_f = MCP.memo_pure_push_exists sqvars tmp1 in
      let rb = if (List.length pqhb)=0 then []
        else 
          let r = MCP.fold_mem_lst (MCP.fold_mem_lst (CP.mkTrue pos) false true pqh) false true qp in     
          let wrap_exists f = List.fold_left (fun f -> fun qv -> CP.Exists (qv, f, None, pos)) f sqvars in
          (List.map (fun (l, x) -> (l, wrap_exists (CP.mkAnd x r pos))) pqhb) in
	  (r_f, rb)

and xpure_heap (prog : prog_decl) (h0 : h_formula) (use_xpure0 :int) : (MCP.memo_pure * (branch_label * CP.formula) list) = match h0 with
  | DataNode ({h_formula_data_node = p;
                h_formula_data_pos = pos}) ->
      let i = fresh_int2 () in
      let non_null = CP.mkEqVarInt p i pos in
	  (MCP.memoise_add_pure (MCP.mkMTrue pos) non_null, [])
  | ViewNode ({h_formula_view_node = p;
                h_formula_view_name = c;
                h_formula_view_arguments = vs;
                h_formula_view_remaining_branches = rm_br;
                h_formula_view_pos = pos}) ->
      let vdef = look_up_view_def pos prog.prog_view_decls c in
      let rec helper addrs =
	    match addrs with
	      | a :: rest ->
	          let i = fresh_int () in
	          let non_null = CP.mkEqVarInt a i pos in
	          let rest_f = helper rest in
	          let res_form = CP.mkAnd non_null rest_f pos in
		      res_form
	      | [] -> CP.mkTrue pos in
      (match rm_br with
        | Some l -> (MCP.mkMTrue no_pos, [])
        | None -> 
          let vinv = match use_xpure0 with
                    | -1 -> (MCP.mkMTrue no_pos, [])
                    | 0 -> vdef.view_user_inv
                    | _ -> vdef.view_x_formula in
          (*let _ = print_string ("xpure "^(string_of_int use_xpure0)^" of : "^(Cprinter.string_of_h_formula h0)^"\n invariant: "^
                               (Cprinter.string_of_memo_pure_formula_branches vinv)^"\n") in*)
          let from_svs = CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed) :: vdef.view_vars in
          let to_svs = p :: vs in
          let (f, b) = vinv in
          let subst_m_fun = MCP.subst_avoid_capture_memo from_svs to_svs in
          let subst_fun = CP.subst_avoid_capture from_svs to_svs in
          let tmp1 = subst_m_fun f, List.map (fun (x,y) -> x, subst_fun y) b in
          tmp1)
     
  | Star ({h_formula_star_h1 = h1;
            h_formula_star_h2 = h2;
            h_formula_star_pos = pos}) ->
      let (ph1, ph1b) = xpure_heap prog h1 use_xpure0 in
      let (ph2, ph2b) = xpure_heap prog h2 use_xpure0 in
      let res_form = (MCP.merge_mems ph1 ph2 true, CP.merge_branches ph1b ph2b) in
	  res_form
  | HTrue  -> (MCP.mkMTrue no_pos, [])
  | HFalse -> (MCP.mkMFalse no_pos, [])

and xpure_symbolic (prog : prog_decl) (f0 : formula) branch : (MCP.memo_pure * CP.spec_var list) = match f0 with
  | Or ({formula_or_f1 = f1;
          formula_or_f2 = f2;
          formula_or_pos = pos}) ->
      let ipf1, avars1 = xpure_symbolic prog f1 branch in
      let ipf2, avars2 = xpure_symbolic prog f2 branch in
      let res_f = MCP.mkOr_mems ipf1 ipf2 in
	  (res_f, avars1 @ avars2)
  | Base ({formula_base_heap = h;
            formula_base_pure = p;
            formula_base_pos = pos}) ->
      let ph, addrs = xpure_heap_symbolic prog h branch in
      let res_form = MCP.memoise_add_pure p ph in
      (res_form, addrs)
  | Exists ({formula_exists_qvars = qvars;
              formula_exists_heap = qh;
              formula_exists_pure = qp;
              formula_exists_pos = pos}) ->
      let pqh, addrs = xpure_heap_symbolic prog qh branch in
      let sqvars = (* List.map CP.to_int_var *) qvars in
      let tmp1 = MCP.memoise_add_pure qp pqh in
      let res_form = MCP.memo_pure_push_exists sqvars tmp1 in
	  (res_form, addrs)

and xpure_heap_symbolic (prog : prog_decl) (h0 : h_formula) branch : (CP.formula * CP.spec_var list) = match h0 with
  | DataNode ({h_formula_data_node = p;
              h_formula_data_label = lbl;
              h_formula_data_remaining_branches = rm_br;
              h_formula_data_pos = pos}) ->
      let i = ("addr"^(fresh_trailer ())) in
      let vi = CP.SpecVar (CP.type_of_spec_var p, i, Unprimed) in
      let non_zero = match rm_br with
        | None -> P.BForm (CP.Neq (CP.Var (vi, pos), CP.Null pos, pos),lbl)
        | Some _ -> CP.mkTrue no_pos  in
      let tmp1 = CP.mkEqVar p vi pos in
      let tmp2 = CP.mkAnd tmp1 non_zero pos in
	  (tmp2, [vi])
  | ViewNode ({h_formula_view_node = p;
              h_formula_view_name = c;
              h_formula_view_arguments = vs;
              h_formula_view_remaining_branches = lbl_lst;
              h_formula_view_pruning_conditions = prune_conds;
              h_formula_view_pos = pos}) ->
    (match lbl_lst with
      | None -> 
        let vdef = look_up_view_def pos prog.prog_view_decls c in
        let vxf = (MCP.fold_mem_lst (CP.mkTrue no_pos) false true (fst vdef.view_x_formula), snd vdef.view_x_formula) in
        let vinv = CP.combine_branch branch vxf in
        let from_svs = CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed) :: vdef.view_vars in
        let to_svs = p :: vs in
        let tmp1 = CP.subst_avoid_capture from_svs to_svs vinv in
        let from_addrs = vdef.view_addr_vars in
        let to_addrs = CP.fresh_spec_vars from_addrs in
        let tmp2 = CP.subst (List.combine from_addrs to_addrs) tmp1 in (* no capture can happen *)
      (tmp2, to_addrs)
      | Some _ ->  (P.mkTrue no_pos, []))
  | Star ({h_formula_star_h1 = h1;
          h_formula_star_h2 = h2;
          h_formula_star_pos = pos}) ->
      let ph1, addrs1 = xpure_heap_symbolic prog h1 branch in
      let ph2, addrs2 = xpure_heap_symbolic prog h2 branch in
      let all_diff =
	    if !no_diff then P.mkTrue no_pos
	    else pairwise_diff addrs1 addrs2 pos in
      let tmp1 = CP.mkAnd ph1 ph2 pos in
      let res_form = CP.mkAnd tmp1 all_diff pos in
	  (res_form, addrs1 @ addrs2)
  | HTrue -> (P.mkTrue no_pos, [])
  | HFalse -> (P.mkFalse no_pos, [])

and xpure_symbolic_no_exists (prog : prog_decl) (f0 : formula) : (MCP.memo_pure * (branch_label * CP.formula) list * CP.spec_var list) = match f0 with
  | Or ({ formula_or_f1 = f1;
          formula_or_f2 = f2;
          formula_or_pos = pos}) ->
      let ipf1, pf1b, avars1 = xpure_symbolic_no_exists prog f1 in
      let ipf2, pf2b, avars2 = xpure_symbolic_no_exists prog f2 in
      let branches = Util.remove_dups (fst (List.split pf1b) @ (fst (List.split pf2b))) in
	  (*List.iter (print_endline) branches;*)
      let map_fun branch =
        try 
          let l1 = List.assoc branch pf1b in
          try
            let l2 = List.assoc branch pf2b in
		    CP.mkOr l1 l2 None pos
          with Not_found -> CP.mkTrue pos
        with Not_found -> CP.mkTrue pos
      in
      let map_fun b = (b, map_fun b) in
      let res_form = MCP.mkOr_mems ipf1 ipf2  in
      let br = (List.map map_fun branches) in
	  (*print_endline ("Xpure_Symbolic1: " ^ Cprinter.string_of_pure_formula_branches (ipf1, pf1b));*)
	  (res_form, br, (avars1 @ avars2))
  | Base ({ formula_base_heap = h;
            formula_base_pure = p;
            formula_base_branches = fbr;
            formula_base_pos = pos}) ->
      let ph, br, addrs = xpure_heap_symbolic_no_exists prog h in
      let n_p = MCP.merge_mems p ph true in
      let n_br = CP.merge_branches br fbr in      
      let r_br = if (List.length n_br)=0 then []
        else 
          let res_form = MCP.fold_mem_lst (MCP.fold_mem_lst (CP.mkTrue no_pos) false true ph) false true p in      
          List.map (fun (l, x) -> (l, CP.mkAnd x res_form pos)) n_br in
	  (n_p, r_br, addrs)
  | Exists ({ formula_exists_qvars = qvars;
              formula_exists_heap = qh;
              formula_exists_pure = qp;
              formula_exists_branches = fbr;
              formula_exists_pos = pos}) ->
      let pqh, br, addrs' = xpure_heap_symbolic_no_exists prog qh in
      let sqvars = (* List.map CP.to_int_var *) qvars in
      let addrs = Util.difference_f CP.eq_spec_var addrs' sqvars in
      let tmp1 = MCP.merge_mems qp pqh true in
      let res_form = MCP.memo_pure_push_exists sqvars tmp1 in
      let n_br = CP.merge_branches br fbr in      
      let wrap_exists f =
        let fv = CP.fv f in
        let sqvars = List.filter (fun sv -> List.mem sv fv) sqvars in
        List.fold_left (fun f -> fun qv -> CP.Exists (qv, f,None, pos)) f sqvars
      in
      let rb = if (List.length n_br)=0 then []
        else 
          let r = MCP.fold_mem_lst (MCP.fold_mem_lst (CP.mkTrue no_pos) false true pqh) false true qp in
          List.map (fun (l, x) -> (l, wrap_exists (CP.mkAnd x r pos))) n_br in
	  (res_form, rb, addrs)

and xpure_heap_symbolic_no_exists (prog : prog_decl) (h0 : h_formula) : (MCP.memo_pure * (branch_label * CP.formula) list * CP.spec_var list) = 
  xpure_heap_symbolic_no_exists_i prog h0 1
    
and xpure_heap_symbolic_no_exists_i (prog : prog_decl) (h0 : h_formula) i: (MCP.memo_pure * (branch_label * CP.formula) list * CP.spec_var list) = match h0 with
  | DataNode ({ h_formula_data_node = p;
                h_formula_data_label = lbl;
                h_formula_data_pos = pos}) ->
      let non_zero = CP.BForm (CP.Neq (CP.Var (p, pos), CP.Null pos, pos),lbl) in
	  (MCP.memoise_add_pure (MCP.mkMTrue pos) non_zero, [], [p])
  | ViewNode ({ h_formula_view_node = p;
                h_formula_view_name = c;
                h_formula_view_arguments = vs;
                h_formula_view_remaining_branches = lbl_lst;
                h_formula_view_pos = pos}) ->
    (match lbl_lst with
      | None ->
          let vdef = look_up_view_def pos prog.prog_view_decls c in
          let vinv, vinv_b = if (i=1) then vdef.view_x_formula else vdef.view_user_inv in       
          let from_svs = CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed) :: vdef.view_vars in
          let to_svs = p :: vs in
          let from_addrs = vdef.view_addr_vars in
          let to_addrs = CP.fresh_spec_vars from_addrs in
          let subst_m_fun f =
            let tmp1 = MCP.subst_avoid_capture_memo from_svs to_svs f in
            MCP.memo_subst (List.combine from_addrs to_addrs) tmp1 (* no capture can happen *) in
          let subst_fun f =
            let tmp1 = CP.subst_avoid_capture from_svs to_svs f in
            CP.subst (List.combine from_addrs to_addrs) tmp1 (* no capture can happen *) in           
        (subst_m_fun vinv, List.map (fun (l,x) -> (l, subst_fun x)) vinv_b, [] (*to_addrs*)) 
      | Some _ -> (MCP.mkMTrue no_pos, [], []))
  | Star ({ h_formula_star_h1 = h1;
            h_formula_star_h2 = h2;
            h_formula_star_pos = pos}) ->
      let ph1, b1, addrs1 = xpure_heap_symbolic_no_exists_i prog h1 i in
      let ph2, b2, addrs2 = xpure_heap_symbolic_no_exists_i prog h2 i in
      let all_diff =
	    if !no_diff then P.mkTrue no_pos
	    else pairwise_diff addrs1 addrs2 pos in
      let tmp1 = MCP.merge_mems ph1 ph2 true in
      let res_form = MCP.memoise_add_pure tmp1 all_diff in
	  (res_form, CP.merge_branches b1 b2, addrs1 @ addrs2)
  | HTrue -> (MCP.mkMTrue no_pos, [], [])
  | HFalse -> (MCP.mkMFalse no_pos, [], [])


(* xpure of consumed precondition *)
and xpure_consumed_pre (prog : prog_decl) (f0 : formula) : (CP.formula * (branch_label * CP.formula) list) = match f0 with
  | Or ({ formula_or_f1 = f1;
          formula_or_f2 = f2;
          formula_or_pos = pos}) ->
      let ipf1, pf1b = xpure_consumed_pre prog f1 in
      let ipf2, pf2b = xpure_consumed_pre prog f2 in
      let branches = Util.remove_dups (fst (List.split pf1b) @ (fst (List.split pf2b))) in
      let map_fun branch =
        try 
          let l1 = List.assoc branch pf1b in
          try
            let l2 = List.assoc branch pf2b in
		    CP.mkOr l1 l2 None pos
          with Not_found -> CP.mkTrue no_pos
        with Not_found -> CP.mkTrue no_pos
      in
      let map_fun b = (b, map_fun b) in
	  (CP.mkOr ipf1 ipf2 None pos), (List.map map_fun branches)
  | Base ({formula_base_heap = h; formula_base_pos = pos;}) ->
      let (ph, phb) = xpure_consumed_pre_heap prog h in
	   (ph, (List.map (fun (l, x) -> (l, CP.mkAnd x ph pos)) phb))
  | Exists ({formula_exists_qvars = qvars;
            formula_exists_heap = qh;
            formula_exists_pure = qp;
            formula_exists_pos = pos}) ->
      let (pqh, pqhb) = xpure_consumed_pre_heap prog qh in
      let res_form = CP.mkExists qvars pqh None pos in
	  (pqh, (List.map (fun (l, x) -> (l, CP.mkAnd x res_form pos)) pqhb))

and xpure_consumed_pre_heap (prog : prog_decl) (h0 : h_formula) : (CP.formula * (branch_label * CP.formula) list) = match h0 with
  | DataNode ({h_formula_data_node = p;
               h_formula_data_pos = pos}) -> (CP.mkTrue pos, [])
  | ViewNode ({ h_formula_view_node = p;
                h_formula_view_name = c;
                h_formula_view_arguments = vs;
                h_formula_view_pos = pos}) ->
    let vdef = look_up_view_def pos prog.prog_view_decls c in
    let vinv, vinv_b = vdef.view_user_inv in (* views have been ordered such that this dependency is respected *)
    let vinv = MCP.fold_mem_lst (CP.mkTrue no_pos) false true vinv in
    let from_svs = CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed) :: vdef.view_vars in
    let to_svs = p :: vs in
    let tmp1 = CP.subst_avoid_capture from_svs to_svs vinv in
    let tmp1b = List.map (fun (l,f) -> (l, CP.subst_avoid_capture from_svs to_svs f)) vinv_b in
    tmp1, tmp1b
  | Star ({ h_formula_star_h1 = h1;
            h_formula_star_h2 = h2;
            h_formula_star_pos = pos}) ->
      let (ph1, ph1b) = xpure_consumed_pre_heap prog h1 in
      let (ph2, ph2b) = xpure_consumed_pre_heap prog h2 in
      let tmp1 = (CP.mkAnd ph1 ph2 pos, CP.merge_branches ph1b ph2b) in
	  tmp1
  | HTrue -> (P.mkTrue no_pos, [])
  | HFalse -> (P.mkFalse no_pos, [])

and pairwise_diff (svars10: P.spec_var list ) (svars20:P.spec_var list) pos =
  let rec diff_one sv svars = match svars with
    | sv2 :: rest ->
	    let tmp1 = diff_one sv rest in
	    let tmp2 = CP.mkNeqVar sv sv2 pos in
	    let res = CP.mkAnd tmp1 tmp2 pos in
	    res
    | [] -> CP.mkTrue pos
  in
  if U.empty svars20 then
    CP.mkTrue pos
  else
    match svars10 with
	  | sv :: rest ->
	      let tmp1 = pairwise_diff rest svars20 pos in
	      let tmp2 = diff_one sv svars20 in
	      let res = CP.mkAnd tmp1 tmp2 pos in
	      res
	  | [] -> CP.mkTrue pos
 
 
 
and prune_ctx prog ctx = match ctx with
  | OCtx (c1,c2)-> OCtx (prune_ctx prog c1,prune_ctx prog c2)
  | Ctx es -> Ctx {es with es_formula =prune_preds prog es.es_formula}
  
and prune_branch_ctx prog (pt,bctx) = (pt,prune_ctx prog bctx)    
and prune_ctx_list prog ctx = List.map (fun (c1,c2)->(c1,List.map (prune_branch_ctx prog) c2)) ctx
    
and prune_pred_struc prog f = 
  let rec helper f =match f with
    | ECase c -> ECase {c with formula_case_branches = List.map (fun (c1,c2)-> (c1,prune_pred_struc prog c2)) c.formula_case_branches;}
    | EBase b -> EBase {b with formula_ext_base = prune_preds prog b.formula_ext_base;
                               formula_ext_continuation = prune_pred_struc prog b.formula_ext_continuation}
    | EAssume (v,f,l) -> EAssume (v,prune_preds prog f,l) in    
(*let _ = print_string ("prunning: "^(Cprinter.string_of_struc_formula f)^"\n") in*)
List.map helper f
   
and prune_preds prog (f:formula):formula =     
    let rec helper_formulas f = match f with
    | Or o -> 
      let f1 = helper_formulas o.formula_or_f1 in
      let f2 = helper_formulas o.formula_or_f2 in
      Or {o with formula_or_f1 = f1; formula_or_f2 = f2;}
    | Exists e ->    
      let rec fct i e = if (i== !Globals.prune_cnt_limit) then e
        else
          let nh, mem, changed = heap_prune_preds prog e.formula_exists_heap e.formula_exists_pure in 
          if changed then fct (i+1) {e with formula_exists_heap = nh; formula_exists_pure = mem;}
          else {e with formula_exists_pure = List.map (fun c-> {c with MCP.memo_group_changed = false}) e.formula_exists_pure} in
      Exists (fct 0 e)
    | Base b ->
      let rec fct i b = if (i== !Globals.prune_cnt_limit) then b
          else
            let nh, mem, changed = heap_prune_preds prog b.formula_base_heap b.formula_base_pure in
            (*let _ = print_string (" nf: "^(Cprinter.string_of_h_formula nh)^" --> "^(string_of_bool changed)^"\n") in*)
            if changed then 
              fct (i+1) {b with formula_base_heap = nh; formula_base_pure = mem}
            else {b with formula_base_pure = List.map (fun c-> {c with MCP.memo_group_changed = false}) b.formula_base_pure} in
      Base (fct 0 b) in
  if (not !Globals.allow_pruning) then f
  else 
     (
      Util.push_time "prune_preds_filter";
      let f1 = filter_formula_memo f in
      Util.pop_time "prune_preds_filter";
      Util.push_time "prune_preds";
      let nf = helper_formulas f1 in
      Util.pop_time "prune_preds";
      nf)
   
and heap_prune_preds prog (hp:h_formula) (old_mem:MCP.memo_pure): (h_formula*MCP.memo_pure*bool)= 
  match hp with
    | Star s ->
        let h1, mem1, changed1  = heap_prune_preds prog s.h_formula_star_h1 old_mem in
        let h2, mem2, changed2  = heap_prune_preds prog s.h_formula_star_h2 mem1 in
        (Star {  
          h_formula_star_h1 = h1;
          h_formula_star_h2 = h2;
          h_formula_star_pos = s.h_formula_star_pos }, mem2, (changed1 or changed2) )
    | HTrue 
    | HFalse -> (hp, old_mem, false) 
    | DataNode d ->       
      (match d.h_formula_data_remaining_branches with
        | Some l -> (hp, old_mem, false)
        | None -> 
          let not_null_form = CP.BForm (CP.Neq (CP.Var (d.h_formula_data_node,no_pos),CP.Null no_pos,no_pos), None) in
          let null_form = CP.Eq (CP.Var (d.h_formula_data_node,no_pos),CP.Null no_pos,no_pos) in
          let br_lbl = [(1,"")] in
          let new_hp = DataNode{d with 
            h_formula_data_remaining_branches = Some br_lbl;
            h_formula_data_pruning_conditions = [ (null_form,br_lbl)];} in
          let new_mem = MCP.memoise_add_pure old_mem  not_null_form in
         (new_hp, new_mem, true))           
    | ViewNode v ->   
      let v_def = look_up_view_def v.h_formula_view_pos prog.prog_view_decls v.h_formula_view_name in
      let fr_vars = (CP.SpecVar (CP.OType v_def.view_data_name, self, Unprimed)):: v_def.view_vars in
      let to_vars = v.h_formula_view_node :: v.h_formula_view_arguments in
      let zip = List.combine fr_vars to_vars in
      let (rem_br, prun_cond,first_prune) =  
          match v.h_formula_view_remaining_branches with
            | Some l -> (l, v.h_formula_view_pruning_conditions,false)
            | None ->                    
                let new_cond = List.map (fun (c1,c2)-> (CP.b_subst zip c1,c2)) v_def.view_prune_conditions in         
                 (v_def.view_prune_branches,new_cond ,true) in                   
      if (List.length rem_br)<=1 then 
        (ViewNode{v with h_formula_view_remaining_branches = Some rem_br; h_formula_view_pruning_conditions = [];}, old_mem,first_prune)
      else
      (*decide which prunes can be activated and drop the onese that are implied while keeping the old unknowns*)
      let l_prune,l_no_prune, new_mem2 = List.fold_left 
        (fun (yes_prune, no_prune, new_mem) (p_cond, pr_branches)->            
          if (Util.subset rem_br pr_branches) then (yes_prune, no_prune,new_mem)
          else
            if ((List.length (Util.intersect pr_branches rem_br))=0) then (yes_prune, no_prune,new_mem)
            else try
                let fv = CP.bfv p_cond in
                let corr = MCP.memo_find_relevant_slice fv new_mem in
                if not (MCP.memo_changed corr) then (yes_prune,(p_cond, pr_branches)::no_prune,new_mem)
                else 
                    let y_p = (Util.inc_counter "counter_memo_count";
                      MCP.memo_check_syn_prun(*_debug*) (p_cond, pr_branches) rem_br corr) in
                    match y_p with
                      | Some y_p ->
                       (Util.inc_counter "counter_memo_hit";
                          (*let _ = print_string ("found contra: "^(String.concat " ; "(List.map (fun (c,_) -> string_of_int c) y_p))^"-\n") in*)
                       (y_p@yes_prune, no_prune,new_mem))
                      | None -> 
                          (*decide if i ^ a = false*)
                         (* let _ = print_string ("memo miss: "^(Cprinter.string_of_b_formula p_cond)^"\n") in
                          let _ = print_string (" memo formula: "^(Cprinter.string_of_memoised_list [corr])^"\n") in                    
                          let _ = print_string ("init mem: "^(Cprinter.string_of_memoised_list [corr])^"\n") in
                          let _ = print_string ("and_is: "^(Cprinter.string_of_pure_formula and_is)^"\n") in
                          let _ = print_string ("pcond: "^(Cprinter.string_of_b_formula p_cond)^"\n") in
                         *) 
                          let and_is = MCP.fold_mem_lst_cons (CP.BConst (true,no_pos)) [corr] false true false  in
                          let sat,_,_ = TP.imply_msg_no_no and_is (CP.Not ((CP.BForm (p_cond,None)),None,no_pos)) (ref 1) "prune_imply" true in
                          let sat = not sat in
                          (*let and_is = MCP.fold_mem_lst_cons p_cond [corr] false true false  in
                          let sat = TP.is_sat_msg_no_no "prune_sat" and_is true in*)
                          if not sat then (*there was a contradiction*)
                            let nyp = pr_branches@yes_prune in
                            let mem_w_fail = MCP.memoise_add_failed_memo new_mem (MCP.memo_cons_wrap_fail p_cond) in
                            (nyp,no_prune,mem_w_fail)
                          else (yes_prune,(p_cond, pr_branches)::no_prune,new_mem)
              with | Not_found -> (yes_prune, (p_cond, pr_branches)::no_prune, new_mem)
        ) ([],[], old_mem) prun_cond in
       (*l_prune : branches that will be dropped*)
        (*l_no_prune: constraints that overlap with the implied set or are part of the unknown, remaining prune conditions *)
       (*rem_br : formula_label list  -> remaining branches *)         
      (*let _ = print_string ("pruned cond active: "^(string_of_int (List.length l_prune))^"\n") in*)
      let (r_hp, r_memo, r_b) = if ((List.length l_prune)>0) then  
          let posib_dismised = Util.remove_dups l_prune in
          let rem_br_lst = List.filter (fun c -> not (List.mem c posib_dismised)) rem_br in
          let l_no_prune = List.filter (fun (_,c)-> (List.length(Util.intersect c rem_br_lst))>0) l_no_prune in
          let new_hp = ViewNode {v with 
              h_formula_view_remaining_branches = Some rem_br_lst;
              h_formula_view_pruning_conditions = l_no_prune;} in
          let dism_invs = if first_prune then [] else List.map (CP.b_apply_subs zip) (lookup_view_invs rem_br v_def) in
          let added_invs = List.map (CP.b_apply_subs zip) (lookup_view_invs rem_br_lst v_def) in
          let new_add_invs = Util.difference_f CP.eq_b_formula_no_aset added_invs dism_invs in
          let old_dism_invs = Util.difference_f CP.eq_b_formula_no_aset dism_invs added_invs in
          let ni = MCP.create_memo_group_wrapper new_add_invs true in
          (*let _ = print_string ("adding: "^(Cprinter.string_of_memoised_list ni)^"\n") in*)
          let mem_o_inv = MCP.memo_change_status old_dism_invs new_mem2 in 
          ( Util.inc_counter "prune_cnt"; Util.add_to_counter "dropped_branches" (List.length l_prune);
          (new_hp, MCP.merge_mems mem_o_inv ni true, true)          )
      else 
        if not first_prune then 
          (ViewNode{v with h_formula_view_pruning_conditions = l_no_prune;},new_mem2, false)
        else 
          let ai = List.map (CP.b_apply_subs zip) (lookup_view_invs rem_br v_def) in
          let gr_ai = MCP.create_memo_group_wrapper ai true in     
          let l_no_prune = List.filter (fun (_,c)-> (List.length(Util.intersect c rem_br))>0) l_no_prune in
          let new_hp = ViewNode {v with  h_formula_view_remaining_branches = Some rem_br;h_formula_view_pruning_conditions = l_no_prune;} in
        (new_hp, MCP.merge_mems new_mem2 gr_ai true, true) in
      (r_hp,r_memo,r_b)
        
    
(* split conseq to a node to be checked at the next step and *)
(* a the remaining part to be checked recursively            *)
and split_linear_node (h : h_formula) : (h_formula * h_formula) = match h with
  | HTrue -> (HTrue, HTrue)
  | HFalse -> (HFalse, HFalse)
  | DataNode _ | ViewNode _ -> (h, HTrue)
  | Star ({h_formula_star_h1 = h1;
	h_formula_star_h2 = h2;
	h_formula_star_pos = pos}) -> begin
      match h1 with
	    | HTrue -> print_string ("\n\n!!!This shouldn't happen!!!\n\n"); split_linear_node h2 (* this shouldn't happen anyway *)
	    | _ ->
	        let ln1, r1 = split_linear_node h1 in
	        (ln1, mkStarH r1 h2 pos)
    end
      

and split_linear_node_guided (vars : CP.spec_var list) (h : h_formula) : (h_formula * h_formula) = 
  (*let _ = print_string ("starting split with : "^(String.concat ";" (List.map Cprinter.string_of_spec_var vars))^"} \n") in*)
  match h with
    | HTrue -> (HTrue, HTrue)
    | HFalse -> (HFalse, HFalse)
    | DataNode {h_formula_data_node = root} | ViewNode {h_formula_view_node = root} ->
	    if (List.exists (CP.eq_spec_var root) vars) then (h, HTrue)
	    else (HTrue,h)
    | Star ({h_formula_star_h1 = h1;
	  h_formula_star_h2 = h2;
	  h_formula_star_pos = pos}) -> begin
        match h1 with
          | HTrue -> print_string ("\n\n!!!This shouldn't happen!!!\n\n"); split_linear_node_guided vars h2 (* this shouldn't happen anyway *)
          | _ ->
              let ln1, r1 = split_linear_node_guided vars h1 in
		      match ln1 with
                | HTrue -> let ln2, r2 = split_linear_node_guided vars h2 in
                  (ln2, mkStarH h1 r2 pos)
                | _     ->  (ln1, mkStarH r1 h2 pos)
      end
	    

	    

(* find a node from the left hand side *)
and find_node prog lhs_h (lhs_p : MCP.memo_pure) (ps : CP.spec_var list) pos : find_node_result =
  let rec merge_results rs1 rs2 = match rs1 with
    | Failed -> rs2
    | NoMatch -> begin
	    match rs2 with
	      | Failed -> rs1
	      | _ -> rs2
      end
    | Match l1 -> begin
	    match rs2 with
	      | Failed -> rs1
	      | NoMatch -> rs1
	      | Match  l2 -> rs1 (*TODO: fix it Match (l1 @ l2) *)
      end in
  let tmp1 = List.map (fun p -> find_node_one prog lhs_h lhs_p p pos) ps in
  let tmp2 = List.fold_left merge_results Failed tmp1 in
  tmp2

(*
(* return a list of nodes from heap f that appears in *)
(* alias set aset. The flag associated with each node *)
(* lets us know if the match is at the root pointer,  *)
(* or at materialized args,...                        *)
*)

and find_node_one prog lhs_h (lhs_p:MCP.memo_pure) (p : CP.spec_var) pos : find_node_result =
  let matches = Context.context_old prog lhs_h lhs_p p pos in
  if U.empty matches then NoMatch	(* can't find an aliased node, but p is mentioned in LHS *)
  else Match (matches)

and h_mvars prog (h : h_formula) : CP.spec_var list = match h with
  | Star ({h_formula_star_h1 = h1;
	h_formula_star_h2 = h2;
	h_formula_star_pos = pos}) -> Util.remove_dups (h_fv h1 @ h_fv h2)
  | DataNode ({h_formula_data_node = v}) -> [v]
  | ViewNode ({h_formula_view_node = v;
	h_formula_view_arguments = vargs;
	h_formula_view_name = c}) -> begin
      let vdef = look_up_view_def_raw prog.prog_view_decls c in
      let mvs = CP.subst_var_list_avoid_capture vdef.view_vars vargs vdef.view_materialized_vars in
      let mvars = if CP.mem v mvs then mvs else v :: mvs in
	  mvars
    end
  | HTrue | HFalse -> []
      
      
(*assume that f does not contain any disjunctions and quantifiers*)
(*and get_equations_sets (f : CP.formula) (interest_vars:Cpure.spec_var list): (CP.b_formula list) = match f with
  | CP.And (f1, f2, pos) -> 
      let l1 = get_equations_sets f1 interest_vars in
      let l2 = get_equations_sets f2 interest_vars in
	  l1@l2
  | CP.BForm (bf,_,_) -> begin
      match bf with
	    | Cpure.BVar (v,l)-> [bf]
	    | Cpure.Lt (e1,e2,l)-> 
	        if (Cpure.of_interest e1 e2 interest_vars) then [Cpure.Lt(e1,e2,l)]
	        else []
	    | Cpure.Lte (e1,e2,l) -> 
	        if (Cpure.of_interest e1 e2 interest_vars)  then [Cpure.Lte(e1,e2,l)]
	        else []
	    | Cpure.Gt (e1,e2,l) -> 
	        if (Cpure.of_interest e1 e2 interest_vars)  then [Cpure.Lt(e2,e1,l)]
	        else []
	    | Cpure.Gte(e1,e2,l)-> 
	        if (Cpure.of_interest e1 e2 interest_vars)  then [Cpure.Lte(e2,e1,l)]
	        else []
	    | Cpure.Eq (e1,e2,l) -> 
	        if (Cpure.of_interest e1 e2 interest_vars)  then [Cpure.Eq(e1,e2,l)]
	        else []
	    | Cpure.Neq (e1,e2,l)-> 
	        if (Cpure.of_interest e1 e2 interest_vars)  then [Cpure.Neq(e1,e2,l)]
	        else []
	    | _ -> []
    end	
  | CP.Not (f1,_,_) -> List.map (fun c-> match c with
	  | Cpure.BVar (v,l)-> c
	  | Cpure.Lt (e1,e2,l)-> Cpure.Lt (e2,e1,l)
	  | Cpure.Lte (e1,e2,l) -> Cpure.Lte (e2,e1,l)
	  | Cpure.Eq (e1,e2,l) -> Cpure.Neq (e1,e2,l) 
	  | Cpure.Neq (e1,e2,l)-> Cpure.Eq (e1,e2,l)
	  |_ ->Error.report_error { 
		   Error.error_loc = no_pos; 
		   Error.error_text ="malfunction:get_equations_sets must return only bvars, inequalities and equalities"}
	) (get_equations_sets f1 interest_vars)
  | _ ->Error.report_error { 
      Error.error_loc = no_pos; 
      Error.error_text ="malfunction:get_equations_sets can be called only with conjuncts and without quantifiers"}
      *)
and combine_es_and prog (f : MCP.memo_pure) (reset_flag:bool) (es : entail_state) : context = 
  let r1,r2 = combine_and es.es_formula f in
  (*the cache id list is monotonicly extended *)
  let es = es_cache_extend es in   
  if (reset_flag) then if r2 then (Ctx {es with es_formula = r1;es_unsat_flag =false;})
  else Ctx {es with es_formula = r1;}
  else Ctx {es with es_formula = r1;}
    

and combine_list_context_and_unsat_now prog (ctx : list_context) (f : MCP.memo_pure) : list_context = 
  let r = transform_list_context ((combine_es_and prog f true),(fun c->c)) ctx in
  let r = transform_list_context ((elim_unsat_es prog (ref 1)),(fun c->c)) r in
  TP.incr_sat_no () ; r


and combine_list_partial_context_and_unsat_now prog (ctx : list_partial_context) (f : MCP.memo_pure) : list_partial_context = 
  let r = transform_list_partial_context ((combine_es_and prog f true),(fun c->c)) ctx in
  let r = transform_list_partial_context ((elim_unsat_es prog (ref 1)),(fun c->c)) r in
  TP.incr_sat_no () ; r



and combine_context_and_unsat_now prog (ctx : context) (f : MCP.memo_pure) : context = 
  let r = transform_context (combine_es_and prog f true) ctx in
  let r = transform_context (elim_unsat_es prog (ref 1)) r in
  TP.incr_sat_no () ; r
    
(* expand all predicates in a definition *)

and expand_all_preds prog f0 do_unsat: formula = 
  match f0 with
    | Or (({formula_or_f1 = f1;
            formula_or_f2 = f2}) as or_f) -> begin
	    let ef1 = expand_all_preds prog f1 do_unsat in
	    let ef2 = expand_all_preds prog f2 do_unsat in
	    Or ({or_f with formula_or_f1 = ef1; formula_or_f2 = ef2})
      end
    | Base ({formula_base_heap = h;
              formula_base_pure = p;
              formula_base_pos =pos}) -> begin
	    let proots = find_pred_roots_heap h in 
	    let ef0 = List.fold_left (fun f -> fun v -> unfold (Prog prog) f v do_unsat pos ) f0 proots in
	    ef0
      end
    | Exists ({ formula_exists_qvars = qvars;
                formula_exists_heap = qh;
                formula_exists_pure = qp;
                formula_exists_flow = fl;
                formula_exists_label = lbl;
                formula_exists_pos = pos}) -> begin
	    let proots = find_pred_roots_heap qh in
	    let f = Base ({formula_base_heap = qh;
                      formula_base_pure = qp;
                      formula_base_type = TypeTrue;
                      formula_base_flow = fl;
                      formula_base_branches = [];
                      formula_base_label = lbl;
                      formula_base_pos = pos}) in
	    let ef = List.fold_left (fun f -> fun v -> unfold (Prog prog) f v do_unsat pos  ) f proots in
	    let ef0 = push_exists qvars ef in
	    ef0
      end

and find_pred_roots f0 = match f0 with
  | Or ({formula_or_f1 = f1;
          formula_or_f2 = f2}) -> begin
      let pr1 = find_pred_roots f1 in
      let pr2 = find_pred_roots f2 in
      let tmp = Util.remove_dups_f (pr1 @ pr2) CP.eq_spec_var in
	  tmp
    end
  | Base ({formula_base_heap = h;
            formula_base_pure = p;
            formula_base_pos =pos}) -> find_pred_roots_heap h
  | Exists ({formula_exists_qvars = qvars;
              formula_exists_heap = qh;
              formula_exists_pure = qp;
              formula_exists_pos = pos}) -> begin
      let tmp1 = find_pred_roots_heap qh in
      let tmp2 = Util.difference_f CP.eq_spec_var tmp1 qvars in
	  tmp2
    end

and find_pred_roots_heap h0 = 
  match h0 with
    | Star ({h_formula_star_h1 = h1;
              h_formula_star_h2 = h2;
              h_formula_star_pos = pos}) -> begin
	    let pr1 = find_pred_roots_heap h1 in
	    let pr2 = find_pred_roots_heap h2 in
	    let tmp = Util.remove_dups_f (pr1 @ pr2) CP.eq_spec_var in
	    tmp
      end
    | ViewNode ({h_formula_view_node = p}) -> [p]
    | DataNode _ | HTrue | HFalse -> []

(* unfolding *)
and unfold_context (prog:prog_or_branches) (ctx : list_context) (v : CP.spec_var) (do_unsat:bool)(pos : loc) : list_context =
  let fct es = 
    let unfolded_f = unfold prog es.es_formula v do_unsat pos in
    let res = build_context (Ctx es) unfolded_f pos in
    if do_unsat then set_unsat_flag res true
    else res in 
  transform_list_context (fct,(fun c->c)) ctx 

and unfold_partial_context (prog:prog_or_branches) (ctx : list_partial_context) (v : CP.spec_var) (do_unsat:bool)(pos : loc) : list_partial_context =
  let fct es = 
    let unfolded_f = unfold prog es.es_formula v do_unsat pos in
    let res = build_context (Ctx es) unfolded_f pos in
    if do_unsat then set_unsat_flag res true
    else res in 
  transform_list_partial_context (fct,(fun c->c)) ctx 
    
    
and unfold (prog:prog_or_branches) (f : formula) (v : CP.spec_var) (do_unsat:bool) (pos : loc) : formula = match f with
  | Base ({ formula_base_heap = h;
            formula_base_pure = p;
            formula_base_branches = b;
            formula_base_flow = fl;
            formula_base_pos = pos}) -> 
      (*let _ = print_string ("\n memo before unfold: "^(Cprinter.string_of_memoised_list mem)^"\n")in*)
      unfold_baref prog h p fl v pos b [] do_unsat 
  | Exists _ -> (*report_error pos ("malfunction: trying to unfold in an existentially quantified formula!!!")*)
      let rf = rename_bound_vars f in
      let qvars, baref = split_quantifiers rf in
      let h, p, fl, b, t = split_components baref in
      (*let _ = print_string ("\n memo before unfold: "^(Cprinter.string_of_memoised_list mem)^"\n")in*)
      let uf = unfold_baref prog h p fl v pos b qvars do_unsat in
	  uf
  | Or ({formula_or_f1 = f1;
          formula_or_f2 = f2;
          formula_or_pos = pos}) ->
      let uf1 = unfold prog f1 v do_unsat pos in
      let uf2 = unfold prog f2 v do_unsat pos in
      let resform = mkOr uf1 uf2 pos in
	  resform

and unfold_baref prog (h : h_formula) (p : MCP.memo_pure) (fl:flow_formula) (v : CP.spec_var) pos b qvars do_unsat : formula =
  let asets = Context.alias (MCP.ptr_equations p) in
  let aset' = Context.get_aset asets v in
  let aset = if CP.mem v aset' then aset' else v :: aset' in
  let unfolded_h = unfold_heap prog h aset v fl pos in
  let pure_f = mkBase HTrue p TypeTrue (mkTrueFlow ()) b pos in
  let tmp_form_norm = normalize_combine unfolded_h pure_f pos in
  let tmp_form = Cformula.set_flow_in_formula_override fl tmp_form_norm in
  let resform = if (List.length qvars) >0 then push_exists qvars tmp_form else tmp_form in
  
  (*let res_form = elim_unsat prog resform in*)
  if do_unsat then match prog with | Prog prog -> 
    (Util.push_time "unfold_unsat";
    let r = elim_unsat_for_unfold prog resform in
    Util.pop_time "unfold_unsat";r)    | _ -> resform
  else resform
    

and unfold_heap prog (f : h_formula) (aset : CP.spec_var list) (v : CP.spec_var) fl pos : formula = match f with
  | ViewNode ({h_formula_view_node = p;
                h_formula_view_name = c;
                h_formula_view_origins = origs;
                h_formula_view_label = v_lbl;
                h_formula_view_remaining_branches = brs;
                h_formula_view_arguments = vs}) ->(*!!Attention: there might be several nodes pointed to by the same pointer as long as they are empty*)
      if CP.mem p aset then
	    match prog with
	      | Prog prog ->
	          let vdef = Cast.look_up_view_def pos prog.prog_view_decls c in
            (*let _ = print_string "\n y\n" in*)
            let forms = match brs with 
                | None -> vdef.view_un_struc_formula 
                | Some s -> struc_to_formula (filter_branches brs vdef.view_formula) in
	          let renamed_view_formula = rename_bound_vars forms in
	          let fr_vars = (CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed))
		        :: vdef.view_vars in
	          let to_vars = v :: vs in
		      (* let tmp_form = normalize renamed_view_formula
		         (formula_of_pure vdef.Cast.view_x_formula pos) pos in
		         let res_form = subst_avoid_capture fr_vars to_vars tmp_form in *)
	          let res_form = subst_avoid_capture fr_vars to_vars renamed_view_formula in
	          let res_form = add_origins res_form origs in
		      (*let res_form = struc_to_formula res_form in*)
		      CF.replace_formula_label v_lbl res_form
	      | Branches (base , br, to_vars) -> 
           (* let _ = print_string "\n x\n" in*)
	          if (List.fold_left2 (fun a c1 c2-> a&&(c1=c2)) true to_vars vs) 
	          then  CF.replace_formula_label v_lbl  (CF.formula_of_memo_pure_with_branches_fl base br fl no_pos)
	          else formula_of_heap f pos
      else
	    formula_of_heap_fl f fl pos
  | Star ({h_formula_star_h1 = f1;
	h_formula_star_h2 = f2}) ->
      let uf1 = unfold_heap prog f1 aset v fl pos in
      let uf2 = unfold_heap prog f2 aset v fl pos in
	  normalize_combine uf1 uf2 pos
  | _ -> formula_of_heap_fl f fl pos

(*
  vvars: variables of interest
  evars: those involving this will be on the rhs
  otherwise move to the lhs
*)
and split_universal ((f0 : CP.formula), f0b) (evars : CP.spec_var list) (expl_inst_vars : CP.spec_var list)(vvars : CP.spec_var list) (pos : loc) 
    : ((CP.formula * (branch_label * CP.formula) list) * (CP.formula * (branch_label * CP.formula) list) * (CP.spec_var list)) =
  let rec split f = match f with
    | CP.And (f1, f2, _) ->
	    let app1, cpp1 = split f1 in
	    let app2, cpp2 = split f2 in
	    (CP.mkAnd app1 app2 pos, CP.mkAnd cpp1 cpp2 pos)
    | _ ->
	    let fvars = CP.fv f in
	    if CP.disjoint fvars vvars then
	      (CP.mkTrue pos, CP.mkTrue pos) (* just ignore the formula in this case as
					                        it is disjoint
					                        from the set of variables of interest *)
	    else
	      (*
	        - 23.05.2008 -
	        Current actions are:
	        (i) discard E2(g) which has already been proven
	        (ii) move E1(f.g) to LHS for implicit instantiation
	        (iii) leave E3(e,f,g) to RHS for linking existential var e

	        What we added here: -->Step (iii) can be also improved by additionally moving (exists e : E3(e,f,g)) to the LHS.
	      *)
	      if not (CP.disjoint (evars@expl_inst_vars) fvars) then (* to conseq *)
	        (CP.mkTrue pos, f)
	      else (* to ante *)
	        (f, CP.mkTrue pos)
  in
  (* -- added on 21.05.2008 *)
  (* try to obtain as much as a CNF form as possible so that the splitting of bindings between antecedent and consequent is more accurate *)
  let f = (normalize_to_CNF f0 pos) in
  let fb = (List.map (fun (l,f) -> (l, normalize_to_CNF f pos)) f0b) in
  (* added on 21.05.2008 -- *)
  (*
    let _ = (print_string ("\n[solver.ml, split_universal]: Pure formula: " ^ (Cprinter.string_of_pure_formula f0) ^ "\n")) in
    let _ = (print_string ("[solver.ml, split_universal]: Pure formula in simplified cnf: " ^ (Cprinter.string_of_pure_formula f) ^ "\n")) in
  *)
  let to_ante, to_conseq = split f in
  let tmp_l = List.map (fun (l, f) -> (l, split f)) fb in
  let labels, pairs = List.split tmp_l in
  let to_ante_f, to_conseq_f = List.split pairs in
  let to_ante_b, to_conseq_b = (List.combine labels to_ante_f), (List.combine labels to_conseq_f) in

  let conseq_fv = CP.fv to_conseq in
  let conseq_fv_b = (List.map (fun (l,f) -> CP.fv f) to_conseq_b) in
  let instantiate = List.filter (fun v -> List.mem v (evars@expl_inst_vars)) conseq_fv in
  let instantiate_b = List.map (fun fv_list -> List.filter (fun v -> List.mem v (evars@expl_inst_vars)) fv_list) conseq_fv_b in
  let wrapped_to_conseq = List.fold_left (fun f v -> CP.Exists (v, f,None, pos)) to_conseq instantiate in
  let wrapped_to_conseq_b = List.map2 (fun to_conseq instantiate -> List.fold_left (fun f v -> CP.Exists (v, f, None, pos)) to_conseq instantiate) to_conseq_f instantiate_b in
  let to_ante =
    if CP.fv wrapped_to_conseq <> [] then CP.And (to_ante, wrapped_to_conseq, no_pos) else to_ante
  in
  let to_ante_f = List.map2 (fun to_ante wrapped_to_conseq ->
	if CP.fv wrapped_to_conseq <> [] then CP.And (to_ante, wrapped_to_conseq, no_pos) else to_ante
  ) to_ante_f wrapped_to_conseq_b in
  let to_ante_b = List.combine labels to_ante_f in
  (*t evars = explicitly_quantified @ evars in*)
  Debug.devel_pprint ("split_universal: evars: "
  ^ (String.concat ", "
	(List.map Cprinter.string_of_spec_var evars))) pos;
  Debug.devel_pprint ("split_universal: expl_inst_vars: "
  ^ (String.concat ", "
	(List.map Cprinter.string_of_spec_var expl_inst_vars))) pos;
  
  Debug.devel_pprint ("split_universal: vvars: "
  ^ (String.concat ", "
	(List.map Cprinter.string_of_spec_var vvars))) pos;
  Debug.devel_pprint ("split_universal: to_ante: "
  ^ (Cprinter.string_of_pure_formula_branches (to_ante, to_ante_b))) pos;
  Debug.devel_pprint ("split_universal: to_conseq: "
  ^ (Cprinter.string_of_pure_formula_branches (to_conseq, to_conseq_b))) pos;
  let fvars = CP.fv f in

  (* 27.05.2008 *)
  if !Globals.move_exist_to_LHS & (not(Util.empty (Util.difference_f CP.eq_spec_var fvars evars)) & not(Util.empty evars))	then
	(* there still are free vars whose bondings were not moved to the LHS --> existentially quantify the whole formula and move it to the LHS *)
	(* Ex.:  ex e. f1<e & e<=g or ex e. (f=1 & e=2 \/ f=2 & e=3) *)
	(*let _ = print_string("\n[solver.ml, split_universal]: No FV in  " ^ (Cprinter.string_of_pure_formula f) ^ "\n") in*)
	(* Branches not handled here yet *)
	let new_f = discard_uninteresting_constraint f vvars in
	(((CP.mkAnd to_ante (CP.mkExists evars new_f None pos) pos), []), (to_conseq, to_conseq_b), evars)
  else ((to_ante, to_ante_b), (to_conseq, to_conseq_b), evars)


(**************************************************************)
(**************************************************************)
(**************************************************************)
(*
  We do a simplified translation towards CNF where we only take out the common
  conjuncts from all the disjuncts:

  Ex:
  (a=1 & b=1) \/ (a=2 & b=2) - nothing common between the two disjuncts
  (a=1 & b=1 & c=3) \/ (a=2 & b=2 & c=3) ->  c=3 & ((a=1 & b=1) \/ (a=2 & b=2))
*)

(*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)
(*17.04.2009*)
and memo_normalize_to_CNF_new (f:MCP.memo_pure) pos : MCP.memo_pure = 
  List.map (fun c-> {c with MCP.memo_group_slice = List.map (fun c-> normalize_to_CNF_new c pos) c.MCP.memo_group_slice}) f

and normalize_to_CNF_new (f : CP.formula) pos : CP.formula = 
  let disj_list = (CP.list_of_disjs) f in
  let dc_list = List.map CP.list_of_conjs disj_list in
  match dc_list with
    | conj_list :: rest -> 
	    let first_disj, res_conj, res_disj_list = (filter_common_conj conj_list rest pos) in
	    let res_disj = List.map (fun c -> (CP.conj_of_list c pos)) res_disj_list in
	    (CP.mkAnd (CP.conj_of_list res_conj pos) (CP.mkOr (CP.conj_of_list first_disj pos) (CP.disj_of_list res_disj pos) None pos) pos)
    | [] -> (print_string("[solver.ml, normalize_to_CNF]: should not be here!!"); (CP.mkTrue pos)) 

and filter_common_conj (conj_list : CP.formula list) (dc_list : (CP.formula list) list) pos : (CP.formula list *  CP.formula list * (CP.formula list list)) = 
  match conj_list with
    | h :: rest -> 
	    let b, new_dc_list = remove_conj_list dc_list h pos in
	    if b then 
	      let first_disj, conj, new_dc_list2 = filter_common_conj rest new_dc_list pos in
	      (first_disj, h::conj, new_dc_list2)
	    else
	      let first_disj, conj, new_dc_list2 = filter_common_conj rest dc_list pos in
	      (h::first_disj, conj, new_dc_list2)
    | [] -> ([], [], dc_list)	

and remove_conj_list (f : (CP.formula list) list) (conj : CP.formula) pos : (bool * (CP.formula list list)) = match f with
  | h :: rest ->
      let b1, l1 = remove_conj_new h conj pos in
      let b2, l2 = remove_conj_list rest conj pos in
	  (b1 & b2, l1::l2)
  | [] -> (true, [])		
      
and remove_conj_new (f : CP.formula list) (conj : CP.formula) pos : (bool * CP.formula list) = match f with
  | h :: rest -> 
      if (CP.eq_pure_formula h conj) then (true, rest)
      else
	    let b1, l1 = remove_conj_new rest conj pos in (b1, h::l1)
  | [] -> (false, [])			
      
(*17.04.2009*)	
(*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)

and normalize_to_CNF (f : CP.formula) pos : CP.formula = match f with
  | CP.Or (f1, f2, lbl, p) ->
      let conj, disj1, disj2 = (find_common_conjs f1 f2 p) in
	  (*
	    let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: f1: " ^ (Cprinter.string_of_pure_formula f1) ^ "\n")) in
	    let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: f2: " ^ (Cprinter.string_of_pure_formula f2) ^ "\n")) in
	    let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: Conj: " ^ (Cprinter.string_of_pure_formula conj) ^ "\n")) in
	    let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: disj1: " ^ (Cprinter.string_of_pure_formula disj1) ^ "\n")) in
	    let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: disj2: " ^ (Cprinter.string_of_pure_formula disj2) ^ "\n")) in
	  *)
	  (CP.mkAnd conj (CP.mkOr disj1 disj2 lbl p) p)
  | CP.And (f1, f2, p) -> CP.And(normalize_to_CNF f1 p, normalize_to_CNF f2 p, p)
  | CP.Not (f1, lbl, p) -> CP.Not(normalize_to_CNF f1 p, lbl ,p)
  | CP.Forall (sp, f1, lbl, p) -> CP.Forall(sp, normalize_to_CNF f1 p, lbl ,p)
  | CP.Exists (sp, f1, lbl, p) -> CP.Exists(sp, normalize_to_CNF f1 p, lbl ,p)
  | _ -> f

(* take two formulas f1 and f2 and returns:
   - the formula containing the commom conjuncts
   - the formula representing what's left of f1
   - the formula representing what's left of f2
*)

and find_common_conjs (f1 : CP.formula) (f2 : CP.formula) pos : (CP.formula * CP.formula * CP.formula) = match f1 with
  | CP.BForm(b,_) ->
      if (List.exists (fun c -> (CP.eq_pure_formula c f1)) (CP.list_of_conjs f2)) then
	    begin
	      (f1, (CP.mkTrue pos), (remove_conj f2 f1 pos))
	    end
      else
	    (*
	      let _ = (print_string ("\n[cpure.ml, find_common_conjs]: no common conj between: \n")) in
	      let _ = (print_string ("\t\t " ^ (Cprinter.string_of_pure_formula f1) ^ "\n")) in
	      let _ = (print_string ("\t\t " ^ (Cprinter.string_of_pure_formula f2) ^ "\n")) in
	      let _ = (print_string ("\n[cpure.ml, find_common_conjs]: list of conj for f2: " ^ (Cprinter.string_of_pure_formula_list (CP.list_of_conjs f2)) ^ "\n")) in
	    *)
	    ((CP.mkTrue pos), f1, f2)
  | CP.And(f11, f12, p) ->
      let outer_conj, new_f1, new_f2 = (find_common_conjs f11 f2 p) in
      let outer_conj_prim, new_f1_prim, new_f2_prim  = (find_common_conjs f12 new_f2 p) in
	  ((CP.mkAnd outer_conj outer_conj_prim p), (CP.mkAnd new_f1 new_f1_prim p), new_f2_prim)
  | CP.Or(f11, f12, lbl ,p) ->
      let new_f11 = (normalize_to_CNF f11 p) in
      let new_f12 = (normalize_to_CNF f12 p) in
	  (CP.mkTrue pos),(CP.mkOr new_f11 new_f12 lbl p),f2
  | _ -> ((CP.mkTrue pos), f1, f2)

and remove_conj (f : CP.formula) (conj : CP.formula) pos : CP.formula = match f with
  | CP.BForm(b1,_) ->
      begin
	    match conj with
	      |CP.BForm(b2,_) ->
	         if (CP.eq_b_formula_no_aset b1 b2) then
	           (CP.mkTrue pos)
	         else f
	      | _ -> f
      end
  | CP.And(f1, f2, p) ->
      (CP.mkAnd (remove_conj f1 conj p) (remove_conj f2 conj p) p)
  | CP.Not(f1, lbl, p) -> CP.Not((remove_conj f1 conj p), lbl, p)
  | _ -> f

(**************************************************************)
(**************************************************************)
(**************************************************************)

(* 21.05.2008 *)
(*
  Say we have three kinds of vars
  f - free, g - global (from the view definition), e - existential
  Assume, we have expression at the end of folding:
  E1(f,g) & E2(g) & E3(e,f,g)

  First action is to discard E2(g) which has already been proven

  (discard_uninteresting_constraint f vvars) only maintains those vars containing vvars, which are vars of interest
*)

and discard_uninteresting_constraint (f : CP.formula) (vvars: CP.spec_var list) : CP.formula = match f with
  | CP.BForm _ ->
      if CP.disjoint (CP.fv f) vvars then (CP.mkTrue no_pos)
      else f
  | CP.And(f1, f2, l) -> CP.And(discard_uninteresting_constraint f1 vvars, discard_uninteresting_constraint f2 vvars, l)
  | CP.Or(f1, f2, lbl, l) -> CP.Or(discard_uninteresting_constraint f1 vvars, discard_uninteresting_constraint f2 vvars, lbl, l)
  | CP.Not(f1, lbl, l) -> CP.Not(discard_uninteresting_constraint f1 vvars, lbl, l)
  | _ -> f


(**************************************************************)
(**************************************************************)
(**************************************************************)

(* fold some constraints in f1 to view v under pure pointer *)
(* constraint pp and Presburger constraint pres             *)
and fold prog (ctx : context) (view : h_formula) (pure : CP.formula) use_case (pos : loc): (list_context * proof) = match view with
  | ViewNode ({h_formula_view_node = p;
                h_formula_view_name = c;
                h_formula_view_label = pid;
                h_formula_view_remaining_branches = r_brs;
                h_formula_view_arguments = vs}) -> begin
      try
	    let vdef = look_up_view_def_raw prog.Cast.prog_view_decls c in
      let brs = filter_branches r_brs vdef.Cast.view_formula in
      let form = if use_case then brs else Cformula.case_to_disjunct brs in
	    let renamed_view_formula = rename_struc_bound_vars form in
	    (*(if use_base_case then match vdef.Cast.view_base_case with 
	      | None -> vdef.Cast.view_formula
	      | Some s -> s
	      else vdef.Cast.view_formula) in*)						
	    let fr_vars = (CP.SpecVar (CP.OType vdef.Cast.view_data_name, self, Unprimed)):: vdef.view_vars in
	    let to_vars = p :: vs in
	    let view_form = subst_struc_avoid_capture fr_vars to_vars renamed_view_formula in
	    let view_form = add_struc_origins view_form (get_view_origins view) in
	    let view_form = CF.replace_struc_formula_label pid view_form in
	    Debug.devel_pprint ("fold: view_form:\n" ^ (Cprinter.string_of_struc_formula view_form)) pos;
	    let estate = estate_of_context ctx pos in
	    let new_es = {estate with es_evars = vs (*Util.remove_dups (vs @ estate.es_evars)*)} in
	    let new_ctx = Ctx new_es in
	    (*let new_ctx = set_es_evars ctx vs in*)
	    let rs0, fold_prf = heap_entail_one_context_struc prog true false false new_ctx view_form pos None in
      (*let _ = print_string ("before fold: " ^ (Cprinter.string_of_context new_ctx)) in
      let _ = print_string ("after fold: " ^ (Cprinter.string_of_list_context rs0)) in*)
	    let tmp_vars = p :: (estate.es_evars @ vs) in
	    (**************************************)
	    (*        process_one 								*)
	    (**************************************)
	    let rec process_one (ss:CF.steps) rs1  =
	      Debug.devel_pprint ("fold: rs1:\n"^ (Cprinter.string_of_context rs1)) pos;
	      match rs1 with
	        | OCtx (c1, c2) ->
		        (*
		          It is no longer safe to assume that rs will be conjunctive.
		          The recursive folding entailment call (via case splitting
		          for example) can turn ctx to a disjunctive one, hence making
		          rs disjunctive.
		        *)
		        let tmp1 = process_one (CF.add_to_steps ss "left OR 3 on ante") c1 in
		        let tmp2 = process_one (CF.add_to_steps ss "right OR 3 on ante") c2 in
		        let tmp3 = (mkOCtx tmp1 tmp2 pos) in
		        tmp3
	        | Ctx es ->
		        (* let es = estate_of_context rs pos in *)
                let es = CF.overwrite_estate_with_steps es ss in
		        let w = Util.difference_f CP.eq_spec_var  es.es_evars tmp_vars in
		        let tmp_pure = elim_exists_pure w es.es_pure pos in
		        let res_rs = Ctx {es with es_evars = estate.es_evars;
                  es_pure = tmp_pure; es_prior_steps = (ss @ es.es_prior_steps);} in
		        Debug.devel_pprint ("fold: context at beginning of fold: "
				^ (Cprinter.string_of_spec_var p) ^ "\n"
				^ (Cprinter.string_of_context ctx)) pos;
		        Debug.devel_pprint ("fold: context at end of fold: "
				^ (Cprinter.string_of_spec_var p) ^ "\n"
				^ (Cprinter.string_of_context res_rs)) pos;
		        Debug.devel_pprint ("fold: es.es_pure: "
				^ (Cprinter.string_of_memo_pure_formula_branches es.es_pure)) pos;
		        res_rs in
	    let res = match rs0 with
          | FailCtx _ -> rs0
          | SuccCtx l -> SuccCtx (List.map (process_one []) l) in
	    (res, fold_prf)
      with
	    | Not_found -> report_error no_pos ("fold: view def not found:"^c^"\n") 
    end
  | _ ->
      Debug.devel_pprint ("fold: second parameter is not a view: "
	  ^ (Cprinter.string_of_h_formula view)) pos;
      report_error no_pos ("fold: second parameter is not a view\n") 
	    (*([], Failure)*)

and process_fold_result prog is_folding estate (fold_rs0:list_context) p2 vs2 base2 pos : (list_context * proof list) =
  let pure2 = base2.formula_base_pure in
  let resth2 = base2.formula_base_heap in
  let type2 = base2.formula_base_type in
  let branches2 = base2.formula_base_branches in
  let flow2 = base2.formula_base_flow in
  let rec process_one (ss:CF.steps) fold_rs1 = match fold_rs1 with
    | OCtx (c1, c2) ->
	    let tmp1, prf1 = process_one (add_to_steps ss "left OR 4 in ante") c1 in
	    let tmp2, prf2 = process_one  (add_to_steps ss "right OR 4 in ante") c2 in
	    let tmp3 = or_list_context tmp1 tmp2 in
	    let prf3 = Prooftracer.mkOrLeft fold_rs1 (Base base2) [prf1; prf2] in 
	    (tmp3, prf3)
    | Ctx fold_es ->
	    (*	let fold_es = estate_of_context fold_rs pos in *)
	    (* remove the constraints involving only global variabls *)
	    (* 20.05.2008 *)
	    (*let _ = print_string ("[solver.ml, process_fold_result]: Context: " ^ Cprinter.string_of_context fold_rs1 ^ "\n") in
	      let _ = (print_string ("\n[solver.ml, process_fold_result]: Pure formula: " ^ (Cprinter.string_of_pure_formula fold_es.es_pure) ^ "\n")) in
	      let new_pure = discard_redundant_constraint fold_es.es_pure vs2 in
	      let _ = (print_string ("[solver.ml, process_fold_result]: Global vars: " ^ (Cprinter.string_of_spec_var_list vs2) ^ "\n")) in
	      let _ = (print_string ("[solver.ml, process_fold_result]: Pure formula after discarding globals: " ^ (Cprinter.string_of_pure_formula new_pure) ^ "\n")) in*)
	    (* 20.05.2008 *)
        let fold_es = CF.overwrite_estate_with_steps fold_es ss in
      let e_pure = MCP.fold_mem_lst (CP.mkTrue pos) true true (fst fold_es.es_pure) in
	    let (to_ante, to_ante_br), (to_conseq, to_conseq_br), new_evars = split_universal (e_pure, snd fold_es.es_pure) fold_es.es_evars fold_es.es_gen_expl_vars vs2 pos in
	    let tmp_conseq = mkBase resth2 pure2 type2 flow2 branches2 pos in
	    let new_conseq = normalize tmp_conseq (CF.replace_branches to_conseq_br (formula_of_pure to_conseq pos)) pos in
	    let new_ante = normalize fold_es.es_formula (CF.replace_branches to_ante_br (formula_of_pure to_ante pos)) pos in
      let new_ante = filter_formula_memo new_ante in
	    let new_consumed = fold_es.es_heap in
	    let new_es = {(es_cache_extend estate) with es_heap = new_consumed;
                                es_formula = new_ante;
                                es_evars = new_evars;
                                es_unsat_flag =false; } in
	    let new_ctx = (Ctx new_es) in
	    Debug.devel_pprint ("process_fold_result: new_ctx after folding: "
		^ (Cprinter.string_of_spec_var p2) ^ "\n"
		^ (Cprinter.string_of_context new_ctx)) pos;
	    Debug.devel_pprint ("process_fold_result: vs2: "
		^ (String.concat ", "
		  (List.map Cprinter.string_of_spec_var vs2))) pos;
	    Debug.devel_pprint ("process_fold_result: to_ante: "
		^ (Cprinter.string_of_pure_formula to_ante)) pos;
	    Debug.devel_pprint ("process_fold_result: to_conseq: "
		^ (Cprinter.string_of_pure_formula to_conseq)) pos;
	    Debug.devel_pprint ("process_fold_result: new_conseq:\n"
		^ (Cprinter.string_of_formula new_conseq)) pos;
	    let rest_rs, prf = heap_entail_one_context prog is_folding false
	      new_ctx new_conseq pos
	    in
	    Debug.devel_pprint ("process_fold_result: context at end fold: "
		^ (Cprinter.string_of_spec_var p2) ^ "\n"
		^ (Cprinter.string_of_list_context rest_rs)) pos;
	    (rest_rs, prf) in
  match fold_rs0 with
    | FailCtx _ -> report_error no_pos ("process_fold_result: FailCtx encountered solver.ml\n")
    | SuccCtx fold_rs0 -> 
	    let t1,p1 = List.split (List.map (process_one []) fold_rs0) in
	    let t1 = fold_context_left t1 in
	    (t1,p1)       

(*added 09-05-2008 , by Cristian, checks that after the RHS existential elimination the newly introduced variables will no appear in the residue*)
and redundant_existential_check (svs : CP.spec_var list) (ctx0 : context) =
  match ctx0 with
    | Ctx es -> let free_var_list = (fv es.es_formula) in
	  begin if (not ( CP.disjoint svs free_var_list)) then
	    Debug.devel_pprint ("Some variable introduced by existential elimination where found in the residue") no_pos end
    | OCtx (c1, c2) ->
	    let _ = redundant_existential_check svs c1 in
	    (redundant_existential_check svs c2)

and elim_exists_pure w (f, b) pos =
  (elim_exists_memo_pure w f pos, List.map (fun (l, f) -> (l, elim_exists_pure_branch w f pos)) b)
  
and elim_exists_memo_pure (w : CP.spec_var list) (f0 : MCP.memo_pure) pos =
  let helper c =
    if (List.length (Util.intersect_fct CP.eq_spec_var w c.MCP.memo_group_fv)=0) then [c] 
    else 
      let r,drp1 = List.partition 
            (fun c-> (List.length (Util.intersect_fct CP.eq_spec_var (CP.bfv c.MCP.memo_formula) w))>0) 
            c.MCP.memo_group_cons in
      let ns,drp2 = List.partition 
            (fun c-> (List.length (Util.intersect_fct CP.eq_spec_var (CP.fv c) w))>0) 
            c.MCP.memo_group_slice in
      let nas, drp3 = List.partition (fun (c1,c2)-> 
        (List.exists (CP.eq_spec_var c1) w) or (List.exists (CP.eq_spec_var c2) w)) 
        (Util.get_equiv_eq c.MCP.memo_group_aset) in
      let aset = List.fold_left  ( fun a (c1,c2) -> Util.add_equiv_eq a c1 c2) MCP.empty_var_aset drp3 in 
      let fand1 = List.fold_left (fun a c-> match c.MCP.memo_status with
        | MCP.Implied _
        | MCP.Implied_dupl -> CP.mkAnd a (CP.BForm (c.MCP.memo_formula, None)) pos
        | _ -> a) (CP.mkTrue pos) r in
      let fand2 = List.fold_left (fun a c-> CP.mkAnd a c pos) fand1 ns in
      let fand3 = List.fold_left (fun a (c1,c2)-> 
                    CP.mkAnd a (CP.BForm (CP.Eq(CP.Var(c1,no_pos),CP.Var(c2,no_pos),no_pos),None)) no_pos)
                    fand2 nas in
      let fand4 = elim_exists_pure_branch w fand3  pos in
      let r = 
       {MCP.memo_group_fv = Util.difference c.MCP.memo_group_fv w;
        MCP.memo_group_changed = true;
        MCP.memo_group_cons = drp1;
        MCP.memo_group_slice = drp2;
        MCP.memo_group_aset = aset;} in
      MCP.memoise_add_pure [r] fand4 in
  List.concat (List.map helper f0)  
  
and elim_exists_pure_branch (w : CP.spec_var list) (f0 : CP.formula) pos =
  let f = CP.mkExists w f0 None pos in
  let simplified_f = TP.simplify f in
  simplified_f

(* --- added 11.05.2008 *)
and entail_state_elim_exists es = 
  let f_prim = elim_exists es.es_formula in
  (* 05.06.08 *)
  (* we also try to eliminate exist vars for which a find a substitution of the form v = exp from the pure part *)
  (*let _ = print_string("[solver.ml, elim_exists_ctx]: Formula before exp exist elim: " ^ Cprinter.string_of_formula f_prim ^ "\n") in*)
  let f = elim_exists_exp f_prim in
  let qvar, base = CF.split_quantifiers f in
  let h, p, fl, b, t = CF.split_components base in
  
  let simpl_p =	
      if !Globals.simplify_pure then 
        MCP.simpl_memo_pure_formula simpl_b_formula simpl_pure_formula p TP.simplify
      else p in
  let simpl_fl = fl (*flows have nothing to simplify to*)in
  let simpl_f = CF.mkExists qvar h simpl_p t simpl_fl b no_pos in
  Ctx{es with es_formula = simpl_f}   (*assuming no change in cache formula*)
    
and elim_exists_ctx_list (ctx0 : list_context) = 
  transform_list_context (entail_state_elim_exists, (fun c-> c)) ctx0

and elim_exists_partial_ctx_list (ctx0 : list_partial_context) = 
  transform_list_partial_context (entail_state_elim_exists, (fun c-> c)) ctx0

    
and elim_exists_ctx (ctx0:context) =
  transform_context entail_state_elim_exists ctx0
    
    
and elim_ante_evars (es:entail_state) : context = 
  let f = push_exists es.es_ante_evars es.es_formula in
  let ef = elim_exists f in
  Ctx {es with es_formula = ef } (*!! maybe unsound unless new clean cache id*)

and unsat_base prog (sat_subno:  int ref) f  : bool= 
  match f with
    | Or _ -> report_error no_pos ("unsat_xpure : encountered a disjunctive formula \n")
    | Base ({ formula_base_heap = h;
            formula_base_pure = p;
            formula_base_branches = br;
            formula_base_pos = pos}) ->
      let (ph, phb) = xpure_heap prog h 1 in
      let phb = CP.merge_branches phb br in  
      if phb = [] then 
        let npf = MCP.merge_mems p ph true in
        TP.is_sat_memo_sub_no npf sat_subno true true
      else
        let npf = MCP.fold_mem_lst (MCP.fold_mem_lst (CP.mkTrue no_pos) false true ph) false true p in
        let r = List.fold_left (fun is_ok (_,pf1b)->  if not is_ok then false else 
            TP.is_sat_sub_no (CP.mkAnd npf pf1b no_pos) sat_subno ) true phb in
        (not r)
  | Exists ({ formula_exists_qvars = qvars;
              formula_exists_heap = qh;
              formula_exists_pure = qp;
              formula_exists_branches = br;
              formula_exists_pos = pos}) ->
      let wrap_exists f = List.fold_left (fun f -> fun qv -> CP.Exists (qv, f, None, pos)) f qvars in
      let (ph, phb) = xpure_heap prog qh 1 in
      let phb = CP.merge_branches phb br in    
      if phb = [] then 
        let npf = MCP.merge_mems qp ph true in
        let f_lst = MCP.fold_mem_lst_to_lst npf false true true in
        List.fold_left (fun a c-> if a then a else not (TP.is_sat_sub_no (wrap_exists c) sat_subno)) false f_lst 
      else
        let npf = MCP.fold_mem_lst (MCP.fold_mem_lst (CP.mkTrue no_pos) false true ph) false true qp in
        let r = List.fold_left (fun is_ok (_,pf1b)->  
                    if not is_ok then false 
                    else TP.is_sat_sub_no (wrap_exists (CP.mkAnd npf pf1b no_pos)) sat_subno) true phb in
        (not r)
              
and elim_unsat_es (prog : prog_decl) (sat_subno:  int ref) (es : entail_state) : context =
  if (es.es_unsat_flag) then Ctx es
  else 
    let f = es.es_formula in
    let _ = reset_int2 () in
(*    let _ = print_string ("f before unsat: "^(Cprinter.string_of_formula f)^"\n") in*)
    let b = unsat_base prog sat_subno f in
    if not b then Ctx{es with es_unsat_flag = true } else 
    false_ctx (flow_formula_of_formula es.es_formula) no_pos
    	    
and elim_unsat_for_unfold (prog : prog_decl) (f : formula) : formula= match f with
  | Or _ -> elim_unsat_all prog f 
  | _ -> f

 (*used for finding the unsat in the original pred defs formulas*)
and find_unsat (prog : prog_decl) (f : formula):formula list*formula list =  
  let sat_subno = ref 1 in 
  match f with
    | Base _ | Exists _ ->
	    let _ = reset_int2 () in
	    let pf, pfb = xpure prog f in
	    let is_ok =        
	      if pfb = [] then 
          let f_lst = MCP.fold_mem_lst_to_lst pf false true true in
          List.fold_left (fun a c-> if not a then a else TP.is_sat_sub_no c sat_subno) true f_lst 
	      else
          let npf = MCP.fold_mem_lst (CP.mkTrue no_pos) false true pf in
          List.fold_left (fun is_ok (label, pf1b) ->
            if not is_ok then false 
            else TP.is_sat_sub_no (CP.And (npf, pf1b, no_pos)) sat_subno ) true pfb in	  
	    if is_ok then ([f],[]) else ([],[f])
    | Or ({formula_or_f1 = f1;
	  formula_or_f2 = f2;
	  formula_or_pos = pos}) ->
	    let nf1,nf1n = find_unsat prog f1 in
	    let nf2,nf2n = find_unsat prog f2 in
	    (nf1@nf2,nf1n@nf2n)

	      
and elim_unsat_all prog (f : formula): formula = match f with
  | Base _ | Exists _ ->
      let sat_subno = ref 1 in	
      let _ = reset_int2 () in
	  (*      print_endline (Cprinter.string_of_formula f);*)
      let pf, pfb = xpure prog f in
      let is_ok =
        if pfb = [] then 
          let f_lst = MCP.fold_mem_lst_to_lst pf false true true in
          List.fold_left (fun a c-> if not a then a else TP.is_sat_sub_no c sat_subno) true f_lst 
	      else
          let npf = MCP.fold_mem_lst (CP.mkTrue no_pos) false true pf in
	        List.fold_left (fun is_ok (label, pf1b) ->
            if not is_ok then false 
            else TP.is_sat_sub_no (CP.And (npf, pf1b, no_pos)) sat_subno ) true pfb in
	  TP.incr_sat_no ();
	  (*      if is_ok then print_endline "elim_unsat_all: true" else print_endline "elim_unsat_all: false";*)
	  if is_ok then f else mkFalse (flow_formula_of_formula f) (pos_of_formula f)
  | Or ({ formula_or_f1 = f1;
          formula_or_f2 = f2;
          formula_or_pos = pos}) ->
      let nf1 = elim_unsat_all prog f1 in
      let nf2 = elim_unsat_all prog f2 in
	  mkOr nf1 nf2 pos

(* extracts those involve free vars from a set of equations  - here free means that it is not existential and it is not meant for explicit instantiation *)
(*NOTE: should (fr,t) be added for (CP.mem fr expl_inst)*)
and get_eqns_free (st : ((CP.spec_var * CP.spec_var) * branch_label) list) (evars : CP.spec_var list) (expl_inst : CP.spec_var list) 
    (struc_expl_inst : CP.spec_var list) pos : (CP.formula * (branch_label * CP.formula) list)*(CP.formula * (branch_label * CP.formula) list)*
    (CP.spec_var * CP.spec_var) list = match st with
      | ((fr, t), br_label) :: rest ->
	      let ((rest_left_eqns, rest_left_eqns_br),(rest_right_eqns, rest_right_eqns_br),s_list) = get_eqns_free rest evars expl_inst struc_expl_inst pos in
	      if (CP.mem fr evars) || (CP.mem fr expl_inst)  (*TODO: should this be uncommented? || List.mem t evars *) then
	        ((rest_left_eqns, rest_left_eqns_br),(rest_right_eqns, rest_right_eqns_br),(fr, t)::s_list)
	      else if (CP.mem fr struc_expl_inst) then
	        let tmp = CP.mkEqVar fr t pos in
		    if br_label = "" then
		      let res = CP.mkAnd tmp rest_right_eqns pos in
		      ((rest_left_eqns, rest_left_eqns_br),(res, rest_right_eqns_br),s_list)
		    else
		      ((rest_left_eqns, rest_left_eqns_br),(rest_right_eqns, CP.add_to_branches br_label tmp rest_right_eqns_br),s_list)
	      else
	        let tmp = CP.mkEqVar fr t pos in
		    if br_label = "" then
		      let res = CP.mkAnd tmp rest_left_eqns pos in
		      ((res, rest_left_eqns_br),(rest_right_eqns, rest_right_eqns_br),s_list)
		    else
		      ((rest_left_eqns, CP.add_to_branches br_label tmp rest_left_eqns_br),(rest_right_eqns, rest_right_eqns_br),s_list)
      | [] -> ((CP.mkTrue pos, []),(CP.mkTrue pos, []),[])

(*
  - extract the equations for the variables that are to be explicitly instantiated
  - remove the variables already instantiated from ivars
  - expl_vars will contain the vars that are next to be explicitly instantiated: for each equation ivar = v, it adds v to the list of vars that will be explicitly instantiated later
*)
and get_eqns_expl_inst (st : (CP.spec_var * CP.spec_var) list) (ivars : CP.spec_var list) (*(expl_vars : CP.spec_var list) *)pos : (CP.formula list * CP.spec_var list * CP.spec_var list) = match st with
  | (fr, t) :: rest ->
      if (CP.mem fr ivars) then
	    let ivars' = (List.filter (fun x -> not(CP.eq_spec_var fr x)) ivars) in
	    let (rest_eqns, ivars_new, expl_vars_new) = get_eqns_expl_inst rest ivars' pos in
	    let tmp = CP.mkEqVar fr t pos in
	    let res = [tmp]@rest_eqns in
	    (*let _ = print_string ("expl_inst: " ^ (Cprinter.string_of_pure_formula tmp) ^ "\n") in*)
	    (res, ivars_new, t::expl_vars_new)
      else (
	    if (CP.mem t ivars) then
	      let ivars' = (List.filter (fun x -> not(CP.eq_spec_var t x)) ivars) in
	      let (rest_eqns, ivars_new, expl_vars_new) = get_eqns_expl_inst rest ivars' pos in
	      let tmp = CP.mkEqVar t fr pos in
	      let res = [tmp]@rest_eqns in
	      (*let _ = print_string ("expl_inst: " ^ (Cprinter.string_of_pure_formula tmp) ^ "\n") in*)
	      (res, ivars_new, fr::expl_vars_new)
	    else
	      (get_eqns_expl_inst rest ivars pos)
      )
  | [] -> ([], ivars, [])



(* removing existentail using ex x. (x=y & P(x)) <=> P(y) *)
and elim_exists (f0 : formula) : formula = match f0 with
  | Or ({ formula_or_f1 = f1;
          formula_or_f2 = f2;
          formula_or_pos = pos}) ->
      let ef1 = elim_exists f1 in
      let ef2 = elim_exists f2 in
	  mkOr ef1 ef2 pos
  | Base _ -> f0
  | Exists ({ formula_exists_qvars = qvar :: rest_qvars;
              formula_exists_heap = h;
              formula_exists_pure = p;
              formula_exists_type = t;
              formula_exists_flow = fl;
              formula_exists_branches = b;
              formula_exists_pos = pos}) ->
      let st, pp1 = MCP.get_subst_equation_memo_formula_vv p qvar in
	    let r = if List.length st = 1 then
      (*let _ = print_string ("exit ee: "^(Cprinter.string_of_memo_pure_formula pp1)^"\n") in*)
                let tmp = mkBase h pp1 t fl b pos in
                (*let f,t = List.hd st in
                let _ = print_string ("subst: "^(Cprinter.string_of_spec_var f)^" with : "^(Cprinter.string_of_spec_var t)^"\n") in*)
                let new_baref = subst st tmp in
                (*let _ = print_string ("ee1 : "^(Cprinter.string_of_formula new_baref)^"\n") in*)
                let tmp2 = add_quantifiers rest_qvars new_baref in
                (*let _ = print_string ("ee2 : "^(Cprinter.string_of_formula tmp2)^"\n") in*)
                let tmp3 = elim_exists tmp2 in
                (*let _ = print_string ("ee3 : "^(Cprinter.string_of_formula tmp3)^"\n") in*)
                tmp3
              else (* if qvar is not equated to any variables, try the next one *)
                let tmp1 = mkExists rest_qvars h p t fl b pos in
                let tmp2 = elim_exists tmp1 in
                let tmp3 = add_quantifiers [qvar] tmp2 in
                tmp3 in
      r
  | Exists _ -> failwith ("Solver.elim_exists: Exists with an empty list of quantified variables")

(**************************************************************)
(* heap entailment                                            *)
(**************************************************************)

and filter_set (cl : list_context) : list_context =
  if !Globals.use_set  then cl
  else match cl with 
    | FailCtx _ -> cl
    | SuccCtx l -> if U.empty l then cl else SuccCtx [(List.hd l)]
	    (* setup the labeling in conseq and the fail context in cl *)
	    
and heap_entail_prefix_init (prog : prog_decl) (is_folding : bool) (is_universal : bool) (has_post: bool)(cl : list_partial_context)
    (conseq : 'a) pos (pid:control_path_id) ((rename_f: 'a->'a), (to_string:'a->string),
	(f: prog_decl->bool->bool->bool->context->'a -> loc
    ->control_path_id->(list_context * proof))
	) : (list_partial_context * proof) = 
  if (List.length cl)<1 then report_error pos ("heap_entail_struc_list_partial_context_init : encountered an empty list_partial_context \n")
  else
    reset_formula_point_id();
  let rename_es es = {es with es_formula = rename_labels_formula_ante es.es_formula}in
  let conseq = rename_f conseq in
  let rec prepare_ctx es = {es with 
              es_success_pts  = ([]: (formula_label * formula_label)  list)  ;(* successful pt from conseq *)
              es_residue_pts  = residue_labels_in_formula es.es_formula ;(* residue pts from antecedent *)
              es_id      = (fst (fresh_formula_label ""))              ; (* unique +ve id *)
              es_orig_ante   = es.es_formula;
              (*es_orig_conseq = conseq ;*)}in	
  let cl_new = transform_list_partial_context ((fun es-> Ctx(prepare_ctx (rename_es es))),(fun c->c)) cl in
  heap_entail_struc_list_partial_context prog is_folding is_universal has_post cl_new conseq pos pid f to_string
    
and heap_entail_struc_list_partial_context (prog : prog_decl) (is_folding : bool) (is_universal : bool) (has_post: bool)(cl : list_partial_context)
    (conseq) pos (pid:control_path_id) f to_string : (list_partial_context * proof) =           
  (* print_string ("\ncalling struct_list_partial_context .."^string_of_int(List.length cl)); *)
  (* print_string (Cprinter.string_of_list_partial_context cl); *)
  Debug.devel_pprint ("heap_entail_struc_list_partial_context:"
  ^ "\nctx:\n" ^ (Cprinter.string_of_list_partial_context cl)
  ^ "\nconseq:\n" ^ (to_string conseq)) pos; 
  let l = List.map 
    (fun c-> heap_entail_struc_partial_context prog is_folding is_universal has_post c conseq pos pid f to_string) cl in
  let l_ctx , prf_l = List.split l in
  let result = List.fold_left list_partial_context_union (List.hd l_ctx) (List.tl l_ctx) in
  let proof = ContextList { 
    context_list_ante = [];
    context_list_conseq = struc_formula_of_formula (mkTrue (mkTrueFlow ()) pos) pos;
    context_list_proofs = prf_l; } in
  (result, proof)
    
and heap_entail_struc_partial_context (prog : prog_decl) (is_folding : bool) (is_universal : bool)
      (has_post: bool)(cl : partial_context) (conseq:'a) pos (pid:control_path_id) f to_string: (list_partial_context * proof) = 
  (* print_string "\ncalling struct_partial_context .."; *)
  Debug.devel_pprint ("heap_entail_struc_partial_context:"
  ^ "\nctx:\n" ^ (Cprinter.string_of_partial_context cl)
  ^ "\nconseq:\n" ^ (to_string conseq)) pos; 
  let fail_branches, succ_branches  = cl in
  let res = List.map (fun (lbl,c2)-> 
	(* print_string ("\nInput ==> :"^(Cprinter.string_of_context c2)); *)
	(* print_string ("\nConseq ==> :"^(to_string conseq)); *)
	let list_context_res,prf = f (*heap_entail_one_context_struc*) prog is_folding is_universal has_post c2 conseq pos pid in
	(* print_string ("\nOutcome ==> "^(Cprinter.string_of_list_context list_context_res)) ; *)
	let res = match list_context_res with
	  | FailCtx t -> [([(lbl,t)],[])]
	  | SuccCtx ls -> List.map ( fun c-> ([],[(lbl,c)])) ls in
	(res, prf)) succ_branches in
  let res_l,prf_l =List.split res in
  (* print_string ("\nCombining ==> :"^(Cprinter.string_of_list_list_partial_context res_l)); *)
  let res = List.fold_left list_partial_context_or [(fail_branches,[])] res_l in
  (* print_string ("\nResult of Combining ==> :"^(Cprinter.string_of_list_partial_context res)); *)
  let proof = ContextList { 
    context_list_ante = [];
    context_list_conseq = struc_formula_of_formula (mkTrue (mkTrueFlow ()) pos) pos;
    context_list_proofs = prf_l; } in
  (res, proof)
    
    
    
and heap_entail_struc_init (prog : prog_decl) (is_folding : bool) (is_universal : bool) (has_post: bool)(cl : list_context) (conseq : struc_formula) pos (pid:control_path_id): (list_context * proof) = 
  Debug.devel_pprint ("heap_entail_struc_init:"
  ^ "\nctx:\n" ^ (Cprinter.string_of_list_context cl)
  ^ "\nconseq:\n" ^ (Cprinter.string_of_struc_formula conseq)) pos; 
  match cl with
    | FailCtx fr ->(cl,Failure)
	    (*if (U.empty fcl) then (cl,Failure)
	      else begin
	      let _ = print_string ("heap_entail_struc_init: under failCtx branch \n")in 
	      push_fail_ctx (fr,fcl);
	      let r,prf = heap_entail_struc_init prog is_folding is_universal has_post (SuccCtx fcl) conseq pos pid in 
	      pop_fail_ctx ();
	      ((or_list_context_outer r (mkFailCtx_in fr)),prf)
	      end*)
    | SuccCtx _ ->
	    reset_formula_point_id();
	    let rename_es es = {es with es_formula = rename_labels_formula_ante es.es_formula}in
	    let conseq = rename_labels_struc conseq in
	    let rec prepare_ctx es = {es with 
		  es_success_pts  = ([]: (formula_label * formula_label)  list)  ;(* successful pt from conseq *)
		  es_residue_pts  = residue_labels_in_formula es.es_formula ;(* residue pts from antecedent *)
		  es_id      = (fst (fresh_formula_label ""))              ; (* unique +ve id *)
		  es_orig_ante   = es.es_formula;
		  es_orig_conseq = conseq ;}in	
	    let cl_new = transform_list_context ( (fun es1->         
        let es = {es1 with es_formula =prune_preds prog es1.es_formula} in
        Ctx(prepare_ctx (rename_es es))),(fun c->c)) cl in
	    let conseq_new = prune_pred_struc prog conseq in
	    heap_entail_struc prog is_folding is_universal has_post cl_new conseq_new pos pid

	      
	      
(* check entailment:                                          *)
(* each entailment should produce one proof, be it failure or *)
(* success. *)
and heap_entail_struc (prog : prog_decl) (is_folding : bool) (is_universal : bool) (has_post: bool)(cl : list_context) (conseq : struc_formula) pos pid: (list_context * proof) =
  match cl with 
    | FailCtx _ -> (cl,Failure)
    | SuccCtx cl ->
	    if !Globals.use_set || U.empty cl then
	      let tmp1 = List.map (fun c -> heap_entail_one_context_struc prog is_folding is_universal has_post c conseq pos pid) cl in
	      let tmp2, tmp_prfs = List.split tmp1 in
	      let prf = mkContextList cl conseq tmp_prfs in
          ((fold_context_left tmp2), prf)
	    else
	      (heap_entail_one_context_struc prog is_folding is_universal has_post (List.hd cl) conseq pos pid)

and heap_entail_one_context_struc (prog : prog_decl) (is_folding : bool) (is_universal : bool) has_post (ctx : context) (conseq : struc_formula) pos pid : (list_context * proof) =
  Debug.devel_pprint ("heap_entail_one_context_struc:"
  ^ "\nctx:\n" ^ (Cprinter.string_of_context ctx)
  ^ "\nconseq:\n" ^ (Cprinter.string_of_struc_formula conseq)) pos;
  if isAnyFalseCtx ctx then
    (* check this first so that false => false is true (with false residual) *)
    ((SuccCtx [ctx]), UnsatAnte)
  else(* if isConstFalse conseq then
	     (--[], UnsatConseq)
	     else *)if isConstETrue conseq then
    ((SuccCtx [ctx]), TrueConseq)
  else
    (*let ctx = (*if !Globals.elim_unsat then elim_unsat_ctx prog ctx else *) (*elim_unsat_ctx prog *)ctx in
      if isAnyFalseCtx ctx then
      ([false_ctx pos], UnsatAnte)
      else*)
    let result, prf = heap_entail_after_sat_struc prog is_folding
      is_universal has_post ctx conseq pos pid []  in
    (result, prf)


(* hello *)

and heap_entail_after_sat_struc prog is_folding is_universal has_post
    ctx conseq pos pid (ss:steps) : (list_context * proof) =     
match ctx with
  | OCtx (c1, c2) ->
      Debug.devel_pprint ("heap_entail_after_sat_struc:"
	  ^ "\nctx:\n" ^ (Cprinter.string_of_context ctx)
	  ^ "\nconseq:\n" ^ (Cprinter.string_of_struc_formula conseq)) pos;
      let rs1, prf1 = heap_entail_after_sat_struc prog is_folding
        is_universal has_post c1 conseq pos pid (CF.add_to_steps ss "left OR 5 on ante") in
      let rs2, prf2 = heap_entail_after_sat_struc prog is_folding is_universal has_post c2 conseq pos pid (CF.add_to_steps ss "right OR 5 on ante") in
	  ((or_list_context rs1 rs2),(mkOrStrucLeft ctx conseq [prf1;prf2]))
  | Ctx es -> begin
      Debug.devel_pprint ("heap_entail_after_sat_struc: invoking heap_entail_conjunct_lhs_struc"
	  ^ "\ncontext:\n" ^ (Cprinter.string_of_context ctx)
	  ^ "\nconseq:\n" ^ (Cprinter.string_of_struc_formula conseq)) pos;
      (*let es = {es with es_formula = prune_preds prog es.es_formula } in*)
      let es = (CF.add_to_estate_with_steps es ss) in
      let tmp, prf = heap_entail_conjunct_lhs_struc prog is_folding
        is_universal has_post (Ctx es) conseq pos pid in
	  (filter_set tmp, prf)
    end
      
and sem_imply_add prog is_folding is_universal ctx (p:CP.formula) only_syn:(context*bool) = match ctx with
  | OCtx _ -> report_error no_pos ("sem_imply_add: OCtx encountered \n")
  | Ctx c -> 
      if (CP.isConstTrue p) then (ctx,true)
      else
	    if (sintactic_search c.es_formula p) then (ctx,true)
	    else if only_syn then (ctx,false)
	    else
	      let b = (xpure_imply prog is_folding is_universal c p !Globals.imply_timeout) in
	      if b then 
        ((Ctx {c with 
          es_formula =(mkAnd_pure_and_branch 
                        c.es_formula 
                        (MCP.memoise_add_pure (MCP.mkMTrue no_pos) p) 
                        [] 
                        no_pos)}),true)
	      else (ctx,false)


and heap_entail_conjunct_lhs_struc 
    (prog : prog_decl) 
    (is_folding : bool) 
    (is_universal : bool) 
    (has_post:bool)
    (ctx : context) 
    (conseq : struc_formula) pos pid : (list_context * proof) =

  let rec syn_imply ctx p :bool = match ctx with
    | OCtx _ -> report_error no_pos ("syn_imply: OCtx encountered \n")
    | Ctx c -> 
	    if (sintactic_search c.es_formula p) then true
	    else false 
	      
  and inner_entailer (ctx : context) (conseq : struc_formula): list_context * proof = 
    let rec helper (ctx : context) (f:ext_formula) : list_context * proof = match f with
      | ECase b   -> 
	      (*let _ = print_string ("\nstart case:"^(Cprinter.string_of_ext_formula f)^"\n") in*)
          (* print_endline ("XXX helper of inner entailer"^Cprinter.string_of_prior_steps (CF.get_prior_steps ctx)); *)
          let ctx = add_to_context ctx "case rule" in
	      if (List.length b.formula_case_exists)>0 then 
	        let ws = CP.fresh_spec_vars b.formula_case_exists in
	        let st = List.combine b.formula_case_exists ws in
	        let new_struc = subst_struc st [(ECase {b with formula_case_exists = []})]in
	        let new_ctx = push_exists_context ws ctx in
	        let nc,np = inner_entailer new_ctx new_struc in 
	        (nc,(mkEexStep ctx [f] np))
	      else if (List.length b.formula_case_branches )=0 then ((SuccCtx [ctx]),TrueConseq)
	      else 
	        let rec helper l = match l with
	          | [] -> None
	          | (p,e)::t -> 
		          let tt = (syn_imply ctx p) in
		          (*print_string ("\n -------------:\n"^(Cprinter.string_of_context ctx)^"\n\n"^
		            (Cprinter.string_of_pure_formula p)^"\n\n"^(string_of_bool tt)^"\n") ;*)
		          if tt then Some (p,e) else helper t  in
	        let r = helper b.formula_case_branches in
	        
	        let r = match r with
	          | None -> begin
		          List.map (fun (c1,c2)-> 
			        let n_ctx = combine_context_and_unsat_now prog (ctx) (MCP.memoise_add_pure (MCP.mkMTrue pos) c1) in (*this unsat check is essential for completeness of result*)
				    if (isAnyFalseCtx n_ctx) then (SuccCtx[n_ctx],UnsatAnte)
				    else inner_entailer n_ctx c2 ) b.formula_case_branches 
		        end
	          | Some (p,e) -> begin [inner_entailer ctx e]end in
	        let rez1,rez2 = List.split r in
            let rez1 = List.fold_left (fun a c->or_list_context a c) (List.hd rez1) (List.tl rez1) in
	        (rez1,(mkCaseStep ctx [f] rez2))
      | EBase ({
		  formula_ext_explicit_inst =expl_inst;
		  formula_ext_implicit_inst = impl_inst;
		  formula_ext_exists = base_exists;
		  formula_ext_base = formula_base;
		  formula_ext_continuation = formula_cont;
		  formula_ext_pos = struc_pos;
	    } as b)  -> if (List.length base_exists)>0 then 
	      let ws = CP.fresh_spec_vars base_exists in
	      let st = List.combine base_exists ws in
	      let new_struc = subst_struc st [(EBase {b with formula_ext_exists = []})]in
	      let new_ctx = push_exists_context ws ctx in
	      let nc,np = inner_entailer new_ctx new_struc in 
	      (nc,(mkEexStep ctx [f] np))
	    else 
	      let n_ctx = (push_expl_impl_context expl_inst impl_inst ctx ) in
	      let n_ctx_list, prf = heap_entail_one_context prog (if (List.length formula_cont)>0 then true else is_folding)  is_universal n_ctx formula_base pos in
	      (*let _ = print_string ("pp: "^(Cprinter.string_of_spec_var_list b.formula_ext_explicit_inst)^"\n"^
	        (Cprinter.string_of_spec_var_list b.formula_ext_implicit_inst)^"\n"^
	        (Cprinter.string_of_context n_ctx)^"\n conseqqq: "^
	        (Cprinter.string_of_ext_formula f)^"\n"
	        ) in*)
	      (*let n_ctx_list = List.filter  (fun c -> not (isFalseCtx c)) n_ctx_list in*)
	      let n_ctx_list = pop_expl_impl_context expl_inst impl_inst n_ctx_list in
	      (*let _= print_string ("\n wrrap inst: "^(string_of_int (List.length formula_cont))^"\n"^
	        (Cprinter.string_of_spec_var_list (expl_inst@impl_inst))^"\n") in*)
          (match n_ctx_list with
	        | FailCtx _ -> (n_ctx_list, prf)
	        | SuccCtx sc ->
		        if (List.length formula_cont)>0 then
                  let res, n_rpf = List.split (List.map (fun c->inner_entailer c formula_cont) sc) in
                  let res = fold_context_left res in
                  let res = if !wrap_exists_implicit_explicit then  
		            push_exists_list_context (expl_inst@impl_inst) res 
		          else res in
		          (res, (mkBaseStep ctx [f] prf (mkCaseStep ctx [f] n_rpf)))
		        else	 
                  let res = if !wrap_exists_implicit_explicit then  
		            push_exists_list_context (expl_inst@impl_inst) n_ctx_list 
		          else n_ctx_list in
		          (*let _ = print_string ("\nresidue: "^(Cprinter.string_of_context_list res)^"\n  "^(string_of_bool (isFalseCtx (List.hd res)))^"\n") in*)
		          (res,prf)
          )
      | EAssume (ref_vars, post,(i,y)) -> if not has_post then report_error pos ("malfunction: this formula "^y^" can not have a post condition!")
	    else
	      let rs = clear_entailment_history ctx in
	      (*let _ =print_string ("before post:"^(Cprinter.string_of_context rs)^"\n") in*)
	      let rs1 = CF.compose_context_formula rs post ref_vars Flow_replace pos in
	      (*let _ =print_string ("\n after post:"^(Cprinter.string_of_context rs1)^"\n") in*)
	      let rs2 = CF.transform_context (elim_unsat_es prog (ref 1)) rs1 in
        (*let _ =print_string ("\n after post and unsat:"^(Cprinter.string_of_context rs2)^"\n") in*)
	      let rs3 = add_path_id rs2 (pid,i) in
        let rs4 = prune_ctx prog rs3 in
	      (*let _ = print_string (
	        "\n rs1:"^
	        (Cprinter.string_of_context rs1)
	        ^"\n rs2:"^
	        (Cprinter.string_of_context rs2)^"\n"
	        ) in*)
	      ((SuccCtx [rs4]),TrueConseq)
    in
    (*let _ = print_string ("\n inner entailer: "^(string_of_int (List.length conseq))^"\n") in
	  let _ = print_string ("\n thre conseq : "^(if ((List.length conseq)==3) then (Cprinter.string_of_struc_formula conseq) else "")^"\n") in*)
    if (List.length conseq)>0 then	
      let ctx = CF.add_to_context ctx "para OR on conseq" in
	  let r = List.map (helper ctx) conseq in
	  (*let _ = print_string ("\n r: "^(string_of_int (List.length r))^"\n") in*)
	  let l1,l2 = List.split r in
	  ((fold_context_left l1),(mkCaseStep ctx conseq l2))
    else 
	  ((SuccCtx [ctx]),TrueConseq)in
  let r = inner_entailer ctx conseq in
  r

and heap_entail_init (prog : prog_decl) (is_folding : bool) (is_universal : bool) (cl : list_context) (conseq : formula) pos : (list_context * proof) =
  match cl with
    | FailCtx fr -> (cl,Failure)
	    (*if (U.empty fcl) then (cl,Failure)
	      else begin
	      let _ = print_string ("heap_entail_init: under failCtx branch \n")in 
	      push_fail_ctx (fr,fcl);
	      let r,prf = heap_entail_init prog is_folding is_universal (SuccCtx fcl) conseq pos in 
	      pop_fail_ctx ();
	      ((or_list_context_outer r (mkFailCtx_in fr)),prf)
	      end*)
    | SuccCtx _ ->
	    reset_formula_point_id();
	    let conseq = rename_labels_formula conseq in
	    let rename_es es = {es with es_formula = rename_labels_formula_ante es.es_formula}in
	    let rec prepare_es es = {es with 
		  es_success_pts  = ([]: (formula_label * formula_label)  list)  ;(* successful pt from conseq *)
		  es_residue_pts  = residue_labels_in_formula es.es_formula   ;(* residue pts from antecedent *)
		  es_id      = (fst (fresh_formula_label ""))              ; (* unique +ve id *)
		  es_orig_ante   = es.es_formula;
		  es_orig_conseq = struc_formula_of_formula conseq pos;} in	
	    let cl_new = transform_list_context ((fun es-> Ctx(prepare_es(rename_es es))),(fun c->c)) cl in
	    let conseq_new = conseq in
	    heap_entail prog is_folding is_universal cl_new conseq_new pos
	      
	      
and heap_entail (prog : prog_decl) (is_folding : bool) (is_universal : bool) (cl : list_context) (conseq : formula) pos : (list_context * proof) =
  match cl with 
    | FailCtx _ -> (cl,Failure)
    | SuccCtx cl ->
	    if !Globals.use_set || U.empty cl then
          let tmp1 = List.map (fun c -> heap_entail_one_context prog is_folding is_universal c conseq pos) cl in
          let tmp2, tmp_prfs = List.split tmp1 in
          let prf = mkContextList cl (Cformula.formula_to_struc_formula conseq) tmp_prfs in
          ((fold_context_left tmp2), prf)
	    else
          (heap_entail_one_context prog is_folding is_universal (List.hd cl) conseq pos)

and heap_entail_one_context (prog : prog_decl) (is_folding : bool) (is_universal : bool) (ctx : context) (conseq : formula) pos : (list_context * proof) =
  Debug.devel_pprint ("heap_entail_one_context:"
  ^ "\nctx:\n" ^ (Cprinter.string_of_context ctx)
  ^ "\nconseq:\n" ^ (Cprinter.string_of_formula conseq)^"\n") pos;
  if isAnyFalseCtx ctx then
    (* check this first so that false => false is true (with false residual) *)
    (SuccCtx [ctx], UnsatAnte)
  else if isStrictConstTrue conseq then
    (SuccCtx [ctx], TrueConseq)
  else if isAnyFalseCtx ctx then
    (SuccCtx [ctx], UnsatAnte)
  else
    (heap_entail_after_sat prog is_folding is_universal ctx conseq pos
      ([]) ) 

and heap_entail_after_sat prog is_folding is_universal ctx conseq pos
    (ss:CF.steps) : (list_context * proof) = 
match ctx with
      | OCtx (c1, c2) ->
          Debug.devel_pprint ("heap_entail_after_sat:"
	      ^ "\nctx:\n" ^ (Cprinter.string_of_context ctx)
	      ^ "\nconseq:\n" ^ (Cprinter.string_of_formula conseq)) pos;
          let rs1, prf1 = heap_entail_after_sat prog is_folding
            is_universal c1 conseq pos (CF.add_to_steps ss "left OR 1 on ante") in  
          let rs2, prf2 = heap_entail_after_sat prog is_folding
            is_universal c2 conseq pos (CF.add_to_steps ss "right OR 1 on ante") in
	      (*let _ = print_string("\nheap_entail_after_sat fail o1: " ^(string_of_bool (isFailCtx rs1))) in
	        let _ = print_string("\nheap_entail_after_sat fail o2: " ^(string_of_bool (isFailCtx rs2))) in
	        let _ = print_string("\nheap_entail_after_sat fail r: " ^(string_of_bool (isFailCtx (or_list_context_inner rs1 rs2)))) in
	        let _ = if  (isFailCtx rs1) then print_string ("\npre: "^(Cprinter.string_of_context c1) ^"\n post: \n"^(Cprinter.string_of_formula conseq)^"\n") else () in
	        let _ = if  (isFailCtx rs2) then print_string ("\npre: "^(Cprinter.string_of_context c2) ^"\n post: \n"^(Cprinter.string_of_formula conseq)^"\n") else () in
	      *)
	      ((or_list_context rs1 rs2),(mkOrLeft ctx conseq [prf1;prf2]))
      | Ctx es -> begin
          Debug.devel_pprint ("heap_entail_after_sat: invoking heap_entail_conjunct_lhs"
	      ^ "\ncontext:\n" ^ (Cprinter.string_of_context ctx)
	      ^ "\nconseq:\n" ^ (Cprinter.string_of_formula conseq)) pos;
        (* print_string ("going: "^(Cprinter.string_of_formula es.es_formula)^"\n") ;*)
          (*let es = {es with es_formula = prune_preds prog es.es_formula} in
          let conseq = prune_preds prog conseq in*)
          let es = (CF.add_to_estate_with_steps es ss) in
          let tmp, prf = heap_entail_conjunct_lhs prog is_folding
            is_universal (Ctx es) conseq pos in  
	      (filter_set tmp, prf)
        end


(* check entailment when lhs is normal-form, rhs is a conjunct *)
and heap_entail_conjunct_lhs prog is_folding is_universal (ctx:context) conseq pos : (list_context * proof) = match conseq with
  | Or ({formula_or_f1 = f1;
	formula_or_f2 = f2;
	formula_or_pos = pos1}) ->
      Debug.devel_pprint ("heap_entail_conjunct_lhs: \nante:\n"
	  ^ (Cprinter.string_of_context ctx)
	  ^ "\nconseq:\n"
	  ^ (Cprinter.string_of_formula conseq)) pos;
      let ctx_L = CF.add_to_context ctx "left OR 2 on conseq" in
      let ctx_R = CF.add_to_context ctx "right OR 2 on conseq" in
      if !Globals.use_set then
	    let rs1, prf1 = heap_entail_conjunct_lhs prog is_folding is_universal ctx_L f1 pos in
	    let rs2, prf2 = heap_entail_conjunct_lhs prog is_folding is_universal ctx_R f2 pos in
	    ((fold_context_left [rs1;rs2]),( mkOrRight ctx conseq [prf1; prf2]))		  
      else
	    let rs1, prf1 = heap_entail_conjunct_lhs prog is_folding is_universal ctx_L f1 pos in
	    if (isFailCtx rs1) then
	      let rs2, prf2 = heap_entail_conjunct_lhs prog is_folding is_universal ctx_R f2 pos in
	      (filter_set rs2, prf2)
	    else
	      (filter_set rs1, prf1)
  | _ -> begin
      Debug.devel_pprint ("heap_entail_conjunct_lhs: invoking heap_entail_conjunct") pos;
      (heap_entail_conjunct prog is_folding is_universal ctx conseq pos)
    end

(* 23.10.2008 *)
(* for empty RHS heap:
   - move the explicit instantiations from the RHS to the LHS
   - remove the explicit instantiated vars from the existential vars of the conseq
   - add the existential vars from the conseq to the existential vars from the antecedent
   - f represents the consequent
*)
and move_lemma_expl_inst_ctx_list (ctx : list_context) (f : formula) : list_context =
  let fct es = 
    let new_es = (pop_exists_estate es.es_expl_vars es) in
    Ctx{(es_cache_extend new_es) with(* existential vars from conseq are made existential in the entecedent *)			
	  es_ante_evars = new_es.es_ante_evars @ new_es.es_evars;
	  es_formula = (CF.mkStar new_es.es_formula f Flow_combine no_pos);
	  es_unsat_flag = false;
	} in  
  transform_list_context ( fct,(fun c->c)) ctx


and move_expl_inst_ctx_list (ctx:list_context)(f:MCP.memo_pure):list_context = 
  let fct es = 
    let f1 = MCP.memo_pure_push_exists (es.es_gen_impl_vars@es.es_evars) f in
    let f1 = formula_of_memo_pure (MCP.memo_pure_elim_exists f1) no_pos in
    Ctx {(es_cache_extend es) with
	  es_gen_impl_vars = [];
	  es_ante_evars = es.es_ante_evars @ es.es_evars;
	  es_formula = (CF.mkStar es.es_formula f1 Flow_combine no_pos);
	  es_unsat_flag = false;
	} in
  transform_list_context (fct,(fun c->c)) ctx
    
(* from a list containing equaltions of the form vi = wi -> obtain two lists [vi]  and [wi] *)
and obtain_subst l =
  match l with
    | CP.BForm(CP.Eq(CP.Var(e1, _), CP.Var(e2, _), _),_)::r -> ((e1::(fst (obtain_subst r))), (e2::(snd (obtain_subst r))))
    | _::r -> ((fst (obtain_subst r)), (snd (obtain_subst r)))
    | [] -> ([],[])

(*************************************** 06.11.08 *******************************************************************)
(**********************************************************************************************************************)
(* check whether the target of a coercion is in the RHS of the entailment *)
(* coer: the coercion lemma to be applied *)
(* node: the node to which the coercion applies *)
(* lhs and rhs - the antecedent and consequent, respectively *)
and coer_target prog (coer : coercion_decl) node (rhs : CF.formula) (lhs : CF.formula) : bool =
  let coer_lhs = coer.coercion_head in
  let coer_rhs = coer.coercion_body in
  let coer_lhs_heap, coer_lhs_guard,coer_lhs_flow, coer_lhs_branches, _ = split_components coer_lhs in
  let rhs_heap, rhs_pure, rhs_flow, rhs_branches, _ = split_components rhs in
  let lhs_heap, lhs_pure, lhs_flow, lhs_branches, _ = split_components lhs in
  (*let _ = print_string("coer_lhs_heap = " ^ (Cprinter.string_of_h_formula coer_lhs_heap) ^ "\n") in
    let _ = print_string("node = " ^ (Cprinter.string_of_h_formula node) ^ "\n") in*)
  (* node - the node to which we want to apply the coercion rule *)
  (* need to find the substitution *)
  match node, coer_lhs_heap with
    | ViewNode ({ h_formula_view_node = p1;
                  h_formula_view_name = c1;
                  h_formula_view_origins = origs;
                  h_formula_view_arguments = ps1}),
	  ViewNode ({h_formula_view_node = p2;
              h_formula_view_name = c2;
              h_formula_view_arguments = ps2}) when c1=c2 ->
	    begin
	      (* apply the substitution *)
	      let coer_rhs_new = subst_avoid_capture (p2 :: ps2) (p1 :: ps1) coer_rhs in
	      let coer_lhs_new = subst_avoid_capture (p2 :: ps2) (p1 :: ps1) coer_lhs in
	      (*let _ = print_string("coer_rhs = " ^ (Cprinter.string_of_formula coer_rhs) ^ "\n") in*)
	      (*let _ = print_string("coer_rhs_new = " ^ (Cprinter.string_of_formula coer_rhs_new) ^ "\n") in *)
	      (* find the targets from the RHS of the coercion *)
	      let top_level_vars = (CF.f_top_level_vars coer_rhs_new) in
	      let target = (List.filter (fun x -> List.mem x top_level_vars) (CF.fv coer_rhs_new)) in
	      let target = (List.filter (fun x -> (List.mem x (CF.fv coer_lhs_new))) target) in
	      (*let _ = print_string ("Target:" ^ (Cprinter.string_of_spec_var_list target) ^ "\n") in*)
	      let coer_rhs_h, _,_, _, _ = split_components coer_rhs_new in
	      (* check for each target if it appears in the consequent *)
	      let all_targets = (List.map (fun x -> (check_one_target prog x lhs_pure rhs_pure rhs_heap coer_rhs_h)) target) in
	      let rec find_one_target all_targets = match all_targets with
	        | true :: r -> true
	        | false :: r -> (find_one_target r)
	        | [] -> false
	      in
	      (* need to find at least one target *)
	      (find_one_target all_targets)
	    end
    | _ -> Error.report_error {Error.error_loc = no_pos; Error.error_text = "malfunction coer_target recieved non views"}
	    (* given a spec var -> return the entire node *)
and get_node (sv : CP.spec_var) (f : CF.h_formula) : CF.h_formula =
  match f with
    | Star({ h_formula_star_h1 = f1; h_formula_star_h2 = f2}) ->
	    let res1 = (get_node sv f1) in
	    begin
	      match res1 with
	        | HFalse -> (get_node sv f2)
	        | _ -> res1
	    end
    | DataNode({h_formula_data_node = sv1; h_formula_data_name = name}) ->
	    if (CP.eq_spec_var sv sv1)
	    then f
	    else HFalse
    | ViewNode({h_formula_view_node = sv1; h_formula_view_name = name}) ->
	    if (CP.eq_spec_var sv sv1)
	    then f
	    else HFalse
    | _ -> HFalse

(* check whether target appears in rhs *)
(* we need lhs_pure to compute the alias set of target *)
and check_one_target prog (target : CP.spec_var) (lhs_pure : MCP.memo_pure) (rhs_p : MCP.memo_pure) (rhs_h : CF.h_formula) (coer_rhs_h : CF.h_formula): bool =
  (*let _ = print_string("check_one_target: target: " ^ (Cprinter.string_of_spec_var target) ^ "\n") in*)
  let lhs_eqns = MCP.ptr_equations lhs_pure in
  let lhs_asets = Context.alias lhs_eqns in
  let lhs_targetasets1 = Context.get_aset lhs_asets target in
  let lhs_targetasets =
    if CP.mem target lhs_targetasets1 then lhs_targetasets1
    else target :: lhs_targetasets1 in
  let fnode_results = (find_node prog rhs_h rhs_p lhs_targetasets no_pos) in
  begin
    match fnode_results with
	  | Failed -> (*let _ = print_string("[check_one_target]: failed\n") in*) false
	  | NoMatch -> (*let _ = print_string("[check_one_target]: no match\n") in*) false
	  | Match (matches) ->
	      begin
	        match matches with
		      | (anode, r_flag, _, resth1) :: rest ->
		          begin
		            let target_node = get_node target coer_rhs_h in
		            let _ = Debug.devel_pprint ("Target: " ^ (Cprinter.string_of_h_formula target_node) ^ "\n") no_pos in
		            let _ = Debug.devel_pprint ("Target match: " ^ (Cprinter.string_of_h_formula anode) ^ "\n") no_pos in
			        begin
			          match target_node, anode with
			            | ViewNode ({h_formula_view_node = p1;
					      h_formula_view_name = c1}),
			              ViewNode ({h_formula_view_node = p2;
					      h_formula_view_name = c2}) when c1=c2 ->
				            ((*print_string("[check_one_target]: target match found\n"); *)true)
			            | DataNode ({h_formula_data_node = p1;
					      h_formula_data_name = c1}),
				            DataNode ({h_formula_data_node = p2;
					        h_formula_data_name = c2}) when c1=c2 ->
				            ((*print_string("[check_one_target]: target match found\n");*) true)
			            | _ ->	false
			        end
		          end
		      | [] -> false
	      end
  end

(* checks whether a coercion is distributive *)
and is_distributive	(coer : coercion_decl) : bool =
  let coer_lhs = coer.coercion_head in
  let coer_rhs = coer.coercion_body in
  let coer_lhs_heap, _,_, _, _ = split_components coer_lhs in
  let coer_rhs_heap, _,_, _, _ = split_components coer_rhs in
  let top_level_lhs = top_level_vars coer_lhs_heap in
  let top_level_rhs = top_level_vars coer_rhs_heap in
  not(List.mem false (List.map (fun x -> check_one_node x top_level_rhs coer_lhs_heap coer_rhs_heap) top_level_lhs))

(*  checks whether sv is present on the lhs and points to the same view *)
and check_one_node (sv : CP.spec_var) (top_level_rhs : CP.spec_var list) (lhs_heap : CF.h_formula) (rhs_heap : CF.h_formula) : bool =
  match top_level_rhs with
    | h :: r ->
	    if (CP.eq_spec_var h sv) && (String.compare (CF.get_node_name (get_node sv lhs_heap)) (CF.get_node_name (get_node h rhs_heap))) == 0 then
	      true
	    else (check_one_node sv r lhs_heap rhs_heap)
    | [] -> false

(* returns the list of free vars from the rhs that do not appear in the lhs *)
and fv_rhs (lhs : CF.formula) (rhs : CF.formula) : CP.spec_var list =
  let lhs_fv = (CF.fv lhs) in
  let rhs_fv = (CF.fv rhs) in
  (List.filter (fun x -> not(List.mem x lhs_fv)) rhs_fv)

(* check the entailment of two conjuncts  *)
(* return value: if fst res = true, then  *)
(* snd res is the residual. Otherwise     *)
(* snd res is the constraint that causes  *)
(* the check to fail.                     *)
and heap_entail_conjunct (prog : prog_decl) (is_folding : bool) (is_universal : bool) (ctx0 : context) (conseq : formula) pos : (list_context * proof) =
  Debug.devel_pprint ("heap_entail_conjunct:"
  ^ "\ncontext:\n" ^ (Cprinter.string_of_context ctx0)
  ^ "\nconseq:\n" ^ (Cprinter.string_of_formula conseq)) pos;
  match ctx0 with
    | Ctx estate -> begin
	    let ante = estate.es_formula in
	    match ante with
	      | Exists ({ formula_exists_qvars = qvars;
                    formula_exists_heap = qh;
                    formula_exists_pure = qp;
                    formula_exists_type = qt;
                    formula_exists_flow = qfl;
                    formula_exists_branches = qb;
                    formula_exists_pos = pos}) ->
        (*print_string ("heap_entail_conjunct exist: mem lst: "^(Cprinter.string_of_memoised_list qmem )^"\n") ;*)
		      (* eliminating existential quantifiers from the LHS *)
		      (* ws are the newly generated fresh vars for the existentially quantified vars in the LHS *)
		      let ws = CP.fresh_spec_vars qvars in
		      (*--- 09.05.2008 *)
		      (*let _ = (print_string ("\n[solver.ml, line 1183]: fresh name = " ^ (Cprinter.string_of_spec_var_list ws) ^ "!!!!!!!!!!!\n")) in*)
		      (*09.05.2008 ---*)
		      let st = List.combine qvars ws in
		      let baref = mkBase qh qp qt qfl qb pos in
		      let new_baref = subst st baref in
		      (* new ctx is the new context after substituting the fresh vars for the exist quantified vars *)
		      let new_ctx = Ctx {estate with
                              es_formula = new_baref;
                              es_ante_evars = ws @ estate.es_ante_evars;
                              es_unsat_flag = false;} in
		      (* call the entailment procedure for the new context - with the existential vars substituted by fresh vars *)
		      let rs, prf1 = heap_entail_conjunct prog is_folding is_universal new_ctx conseq pos in
		      (* --- added 11.05.2008 *)
		      let new_rs =
		        if !Globals.wrap_exist then
		          (* the fresh vars - that have been used to substitute the existenaltially quantified vars - need to be existentially quantified after the entailment *)
		          (add_exist_vars_to_ctx_list rs ws)
		        else
		          rs
		      in
		      (* log the transformation for the proof tracere *)
		      let prf = mkExLeft ctx0 conseq qvars ws prf1 in
		      (new_rs, prf)
	      | _ -> begin
		      match conseq with
		        | Exists ({ formula_exists_qvars = qvars;
                        formula_exists_heap = qh;
                        formula_exists_pure = qp;
                        formula_exists_type = qt;
                        formula_exists_flow = qfl;
                        formula_exists_branches = qb;
                        formula_exists_pos = pos}) ->
		            (* quantifiers on the RHS. Keep them for later processing *)
		            let ws = CP.fresh_spec_vars qvars in
		            let st = List.combine qvars ws in
		            let baref = mkBase qh qp qt qfl qb pos in
		            let new_baref = subst st baref in
		            let new_ctx = Ctx {estate with es_evars = ws @ estate.es_evars} in
		            let tmp_rs, tmp_prf = heap_entail_conjunct prog is_folding is_universal new_ctx new_baref pos in
			        (match tmp_rs with
			          | FailCtx _ -> (tmp_rs, tmp_prf)
			          | SuccCtx sl ->
			              let prf = mkExRight ctx0 conseq qvars ws tmp_prf in
				          (*added 09-05-2008 , by Cristian, checks that after the RHS existential elimination the newly introduced variables will no appear in the residue hence no need to quantify*)
			              let _ = List.map (redundant_existential_check ws) sl in
			              let res_ctx =
				            if !Globals.elim_exists then List.map elim_exists_ctx sl
				            else sl in
				          (SuccCtx res_ctx, prf))
		        | _ ->
		            let h1, p1, fl1, br1, t1 = split_components ante in
                (*print_string ("heap_entail_conjunct base: mem lst: "^(Cprinter.string_of_memoised_list mem1 )^"\n") ;*)
		            let h2, p2, fl2, br2, t2 = split_components conseq in
			        (* let _ = print_string "pp 1\n" in*)
			        if (isAnyConstFalse ante)&&(CF.subsume_flow_ff fl2 fl1) then 
			          let _ = print_string ("got: "^(Cprinter.string_of_formula ante)^"|-"^(Cprinter.string_of_formula conseq)^"\n\n") in					  
			          (SuccCtx [false_ctx fl1 pos], UnsatAnte)
			        else					  
			          (*  let _ = print_string "pp 2\n" in*)
			          (* let _ = print_string ("bol : "^(string_of_bool ((CF.is_false_flow fl2.formula_flow_interval)))^"\n") in*)
			          if (not(CF.is_false_flow fl2.formula_flow_interval)) && not(CF.subsume_flow_ff fl2 fl1) then begin
			            Debug.devel_pprint ("heap_entail_conjunct: "
						^ "conseq has an incompatible flow type"
						^ "\ncontext:\n"
						^ (Cprinter.string_of_context ctx0)
						^ "\nconseq:\n"
						^ (Cprinter.string_of_formula conseq)) pos;
			            (CF.mkFailCtx_in (Basic_Reason ({ fc_message ="incompatible flow type"; 
                                                    fc_current_lhs = estate;
                                                    fc_orig_conseq = struc_formula_of_formula conseq pos;
                                                    fc_prior_steps = estate.es_prior_steps;
                                                    fc_failure_pts =[];})), UnsatConseq) 
			          end
			          else 
			            match h2 with
			              | HFalse (* -> (--[], UnsatConseq)  entailment fails *)
			              | HTrue -> begin
				              Debug.devel_pprint ("heap_entail_conjunct: "
						      ^ "conseq has an empty heap component"
						      ^ "\ncontext:\n"
						      ^ (Cprinter.string_of_context ctx0)
						      ^ "\nconseq:\n"
						      ^ (Cprinter.string_of_formula conseq)) pos;
				              let b1 = {  formula_base_heap = h1;
                                  formula_base_pure = p1;
                                  formula_base_type = t1;
                                  formula_base_flow = fl1;
                                  formula_base_branches = br1;
                                  formula_base_label = None;
                                  formula_base_pos = pos } in
				              (* 23.10.2008 *)
				              (*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)
				              (* at the end of an entailment due to the epplication of an universal lemma, we need to move the explicit instantiation to the antecedent  *)
				              (* Remark: for universal lemmas we use the explicit instantiation mechanism,  while, for the rest of the cases, we use implicit instantiation *)
				              (*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)
				              let ctx, proof = heap_entail_empty_rhs_heap prog is_folding is_universal estate b1 p2 br2 pos in
				              
				              let new_ctx =
				                if is_universal then ((*print_string ("YES Expl inst!!\n");*) move_lemma_expl_inst_ctx_list ctx conseq)
				                else ((*print_string ("NO Expl inst!!\n");*) ctx )
				              in
				              let new_ctx = move_expl_inst_ctx_list new_ctx p2 in
				              (new_ctx, proof)
				            end
			              | _ -> begin
				              Debug.devel_pprint ("heap_entail_conjunct: "
						      ^ "conseq has an non-empty heap component"
						      ^ "\ncontext:\n"
						      ^ (Cprinter.string_of_context ctx0)
						      ^ "\nconseq:\n"
						      ^ (Cprinter.string_of_formula conseq)) pos;
				              let b1 = {  formula_base_heap = h1;
                                  formula_base_pure = p1;
                                  formula_base_type = t1;
                                  formula_base_branches = br1;
                                  formula_base_label = None;
                                  formula_base_flow = fl1;
                                  formula_base_pos = pos } in
				              let b2 = {  formula_base_heap = h2;
                                  formula_base_pure = p2;
                                  formula_base_type = t2;
                                  formula_base_flow = fl2;
                                  formula_base_branches = br2;
                                  formula_base_label = None;
                                  formula_base_pos = pos } in
				              heap_entail_non_empty_rhs_heap prog is_folding is_universal ctx0 estate ante conseq b1 b2 pos
				            end
	        end
      end
    | _ -> report_error pos ("heap_entail_conjunct: context is disjunctive or fail!!!")

and heap_entail_build_memo_pure_check (evars : CP.spec_var list) (ante : MCP.memo_pure) (conseq : MCP.memo_pure) pos : (MCP.memo_pure * MCP.memo_pure) =
  let avars = MCP.mfv ante in
  let sevars = (* List.map CP.to_int_var *) evars in
  let outer_vars, inner_vars = List.partition (fun v -> CP.mem v avars) sevars in
  let tmp1 = MCP.memo_pure_push_exists inner_vars conseq in
  if U.empty outer_vars then
    (ante, tmp1)
  else
    let tmp2 = MCP.memo_pure_push_exists sevars conseq in
	(ante, tmp2)
  
and heap_entail_build_pure_check (evars : CP.spec_var list) (ante : CP.formula) (conseq : CP.formula) pos : (CP.formula * CP.formula) =
  let avars = CP.fv ante in
  let sevars = (* List.map CP.to_int_var *) evars in
  let outer_vars, inner_vars = List.partition (fun v -> CP.mem v avars) sevars in
  let tmp1 = CP.mkExists inner_vars conseq None pos in
  if U.empty outer_vars then
    (ante, tmp1)
  else
    let tmp2 = CP.mkExists sevars conseq None pos in
	(ante, tmp2)
 
and xpure_imply (prog : prog_decl) (is_folding : bool) (is_universal : bool) lhs (rhs_p:CP.formula) timeout : bool = 
  let imp_subno = ref 1 in
  let estate = lhs in
  let pos = no_pos in
  let r,c = match lhs.es_formula with
    | Or _ -> report_error no_pos ("xpure_imply: encountered Or formula on lhs")
    | Base b ->  (b,lhs)
    | Exists b ->  report_error no_pos ("xpure_imply: encountered Exists formula on lhs")in
  let lhs_h = r.formula_base_heap in  
  let lhs_p = r.formula_base_pure in
  let lhs_b = r.formula_base_branches in
  let _ = reset_int2 () in
  let xpure_lhs_h, xpure_lhs_h_b = xpure_heap prog (mkStarH lhs_h estate.es_heap pos) 1 in
  let tmp1 = MCP.merge_mems lhs_p xpure_lhs_h true in
  let new_ante, new_conseq = heap_entail_build_memo_pure_check (estate.es_evars@estate.es_gen_expl_vars) tmp1 
    (MCP.memoise_add_pure (MCP.mkMTrue pos) rhs_p) pos in
  let res,_,_ =  TP.memo_imply_timeout new_ante new_conseq ((string_of_int !imp_no) ^ "." ^ (string_of_int !imp_subno)) timeout in
  Debug.devel_pprint ("IMP #" ^ (string_of_int !imp_no) ^ "." ^ (string_of_int !imp_subno)) no_pos;				
  imp_subno := !imp_subno+1;  
  if res = false then
    let branches = Util.remove_dups (List.map (fun (bid, _) -> bid) (xpure_lhs_h_b @ lhs_b)) in
    let fold_fun2 is_ok branch_id_added =
      if is_ok then true else
        let tmp1 = MCP.merge_mems 
            (MCP.combine_memo_branch branch_id_added (lhs_p, lhs_b))
            (MCP.combine_memo_branch branch_id_added (xpure_lhs_h, xpure_lhs_h_b)) true in
        let new_ante, new_conseq = heap_entail_build_memo_pure_check (estate.es_evars@estate.es_gen_expl_vars) tmp1 
          (MCP.memoise_add_pure (MCP.mkMTrue pos) rhs_p) pos in
        let res,_,_ = TP.memo_imply_timeout new_ante new_conseq ((string_of_int !imp_no) ^ "." ^ (string_of_int !imp_subno)) timeout in
        (Debug.devel_pprint ("IMP #" ^ (string_of_int !imp_no) ^ "." ^ (string_of_int !imp_subno)) no_pos;				
        imp_subno := !imp_subno+1; 
        res)in
    List.fold_left fold_fun2 false branches
  else res 

and heap_entail_empty_rhs_heap (prog : prog_decl) (is_folding : bool) (is_universal : bool) estate lhs rhs_p rhs_p_br pos : (list_context * proof) =
  (*print_endline ("RHS: " ^ Cprinter.string_of_pure_formula_branches (rhs_p, rhs_p_br));*)
  let imp_subno = ref 1 in
  let lhs_h = lhs.formula_base_heap in
  let lhs_p = lhs.formula_base_pure in
  let lhs_t = lhs.formula_base_type in
  let lhs_fl = lhs.formula_base_flow in
  let lhs_b = lhs.formula_base_branches in
  let _ = reset_int2 () in
  let xpure_lhs_h, xpure_lhs_h_b = xpure_heap prog (mkStarH lhs_h estate.es_heap pos) 1 in
  (*  print_endline ("XPURE1: " ^ Cprinter.string_of_pure_formula_branches (xpure_lhs_h, xpure_lhs_h_b));*)
  let xpure_lhs_h0, xpure_lhs_h0_b = xpure_heap prog (mkStarH lhs_h estate.es_heap pos) 0 in
  (*print_endline ("consumed: "^(Cprinter.string_of_context (Cformula.Ctx estate)));
    print_endline ("XPURE0: " ^ Cprinter.string_of_pure_formula_branches (xpure_lhs_h0, xpure_lhs_h0_b));*)
  let fold_fun (is_ok,succs,fails) (branch_id, rhs_p) =
    if (is_ok = false) then (is_ok,succs,fails) else 
      let m_lhs = MCP.combine_memo_branch branch_id (lhs_p, lhs_b) in
      let tmp1 = MCP.merge_mems m_lhs (MCP.combine_memo_branch branch_id (xpure_lhs_h, xpure_lhs_h_b)) true in
      let new_ante, new_conseq = heap_entail_build_memo_pure_check (estate.es_evars@estate.es_gen_expl_vars) tmp1 rhs_p pos in
      let tmp2 = MCP.merge_mems m_lhs (MCP.combine_memo_branch branch_id (xpure_lhs_h0, xpure_lhs_h0_b)) true in
      let new_ante0, new_conseq0 = heap_entail_build_memo_pure_check (estate.es_evars@estate.es_gen_expl_vars) tmp2 rhs_p pos in
	  (* 26.03.2009 simplify the pure part *) 		 
	  (*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)				
	  (* TODO: if xpure 1 is needed, then perform the same simplifications as for xpure 0 *)
	  (*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)				
      let new_ante0 =
        if !Globals.omega_simpl && not(TP.is_memo_bag_constraint new_ante0)&& not(TP.is_memo_list_constraint new_ante0)  then 
          let simp_ante = new_ante0 in
            (*(Debug.devel_pprint ("simplify the antecedent with omega") no_pos;	
              
            let r = CP.memo_arith_simplify (simpl_memo_pure_formula new_ante0) in(* todo: remove the comment from omega.simplify after solving the problem in omega.ml with the collection of the error output *)
            Debug.devel_pprint ("res: "^(Cprinter.string_of_pure_formula r)^"\n") no_pos; r)*)
          (* check wheather Omega raised any error; if it did then use the ante before simplification *)
          if !Globals.omega_err = false then simp_ante else (Globals.omega_err := false; new_ante0)	(* reset the error flag *)
        else new_ante0 in
      let new_conseq0 = 
	    if !Globals.omega_simpl && not(TP.is_memo_bag_constraint new_conseq0)&& not(TP.is_memo_list_constraint new_conseq0)  then 
	      let simp_conseq = (Debug.devel_pprint ("simplify the consequent with omega") no_pos;	(*simpl_memo_pure_formula*) new_conseq0) in
	      let simp_conseq1 =  if !Globals.omega_err = false then simp_conseq else (Globals.omega_err := false; new_conseq0)	in 
        (* use the previous conseq , reset the error flag *)
        memo_normalize_to_CNF_new (MCP.memo_arith_simplify simp_conseq1) pos 
	    else new_conseq0
      in
	  (*
	    BEFORE:
	    TP.imply new_ante0 new_conseq0 ((string_of_int !imp_no) ^ "." ^ (string_of_int !imp_subno))) || (* first try XPure0 *)
	    (((new_ante <> new_ante0) || (new_conseq <> new_conseq0)) && 
	    (imp_subno := !imp_subno+1; Debug.devel_pprint ("IMP #" ^ (string_of_int !imp_no) ^ "." ^ (string_of_int !imp_subno) ^ " with XPure1") no_pos;
	    TP.imply new_ante new_conseq ((string_of_int !imp_no) ^ "." ^ (string_of_int !imp_subno)))) 	(* if XPure0  fails, then try XPure1 *)
	    in
	  *)    
      let _ = Debug.devel_pprint ("IMP #" ^ (string_of_int !imp_no) (*^ "." ^ (string_of_int !imp_subno) ^ " with XPure0"*)) no_pos in
      let split_conseq = (*Tpdispatcher.split_conjunctions*) new_conseq0 in
      let split_ante0 = (*Tpdispatcher.split_disjunctions*) new_ante0 in
      let split_ante1 = (*Tpdispatcher.split_disjunctions*) new_ante in
	  (* first try for xpure 0 and see what conjuncts can be discharged *)
      let res1,res2,res3 = if (MCP.isConstMTrue rhs_p) then (true,[],None) else (imply_memo split_ante0 split_ante1 split_conseq) in	
	  (* added by cezary  for branches *)
    (*if common fails to prove common it might be due to missing info, for example:
        x::avl<s,h,S> & ["s": s>0] |-  x::avl<s,h,S> & x!=null
      *)
      (*let _ = if res1 then () else 
        (print_string ("\n failed ante"^branch_id^" : ");
         print_string ("conseq_0 : "^(Cprinter.string_of_memo_pure_formula new_conseq0)^"\n");
         print_string ("xpure_0 : "^(Cprinter.string_of_memo_pure_formula new_ante0)^"\n");
         print_string ("xpure_1 : "^(Cprinter.string_of_memo_pure_formula new_ante)^"\n")) in   *)
      let res1,res2,re3 = 
        if res1 = false && branch_id = "" then
	      let branches = Util.remove_dups (List.map (fun (bid, _) -> bid) (xpure_lhs_h_b @ lhs_b)) in
          let fold_fun2 (is_ok,a2,a3) branch_id_added =
            if is_ok then (is_ok,a2,a3) else
              let m_lhs = MCP.combine_memo_branch branch_id_added (lhs_p, lhs_b) in
              let tmp1 = MCP.merge_mems m_lhs (MCP.combine_memo_branch branch_id_added (xpure_lhs_h, xpure_lhs_h_b)) true in
              let new_ante, new_conseq = heap_entail_build_memo_pure_check estate.es_evars tmp1 rhs_p pos in
              imp_subno := !imp_subno+1; 
              Debug.devel_pprint ("IMP #" ^ (string_of_int !imp_no) ^ "." ^ (string_of_int !imp_subno)) no_pos;
              (*let  _ = print_string ("imply ante: "^(Cprinter.string_of_memo_pure_formula new_ante)) in*)
		      TP.memo_imply new_ante new_conseq ((string_of_int !imp_no) ^ "." ^ (string_of_int !imp_subno))
          in
          List.fold_left fold_fun2 (false,[],None) branches
        else (res1,res2,res3)
      in
	  (*print_endline branch_id;
	    print_endline ("RHS_P: " ^ Cprinter.string_of_pure_formula rhs_p);
	    print_endline ("ANTE: " ^ Cprinter.string_of_pure_formula new_ante);
	    print_endline ("CONSEQ: " ^ Cprinter.string_of_pure_formula new_conseq);
	    if res then print_endline "ok" else print_endline "notok";*)
	  (imp_no := !imp_no+1;
	  (res1,res2@succs,res3))  in
    
  let prf = mkPure estate (CP.mkTrue no_pos) (CP.mkTrue no_pos) true None in
  let memo_r_br = List.map (fun (c1,c2)-> (c1,MCP.memoise_add_pure (MCP.mkMTrue pos) c2)) rhs_p_br in
  let (r_rez,r_succ_match, r_fail_match) = List.fold_left fold_fun  (true,[],None) (("", rhs_p) :: memo_r_br) in
  if r_rez then begin
    let res_delta = mkBase lhs_h lhs_p lhs_t lhs_fl lhs_b no_pos in
	if is_folding then begin
	  let res_es = {(es_cache_extend estate) with es_formula = res_delta; 
		es_pure = ((MCP.merge_mems rhs_p (fst estate.es_pure) true),(Cpure.merge_branches (snd estate.es_pure) rhs_p_br));
		es_success_pts = (List.fold_left (fun a (c1,c2)-> match (c1,c2) with
		  | Some s1,Some s2 -> (s1,s2)::a
		  | _ -> a) [] r_succ_match)@estate.es_success_pts;
		es_unsat_flag = false;} in
	  let res_ctx = Ctx (CF.add_to_estate res_es "folding performed") in
	  Debug.devel_pprint ("heap_entail_empty_heap: folding: formula is valid") pos;
	  Debug.devel_pprint ("heap_entail_empty_heap: folding: res_ctx:\n" ^ (Cprinter.string_of_context res_ctx)) pos;
	  (SuccCtx[res_ctx], prf)
	end else begin
	  let res_ctx = Ctx {(es_cache_extend estate) with es_formula = res_delta;
		es_success_pts = (List.fold_left (fun a (c1,c2)-> match (c1,c2) with
		  | Some s1,Some s2 -> (s1,s2)::a
		  | _ -> a) [] r_succ_match)@estate.es_success_pts;} in
	  Debug.devel_pprint ("heap_entail_empty_heap: formula is valid") pos;
	  Debug.devel_pprint ("heap_entail_empty_heap: res_ctx:\n" ^ (Cprinter.string_of_context res_ctx)) pos;
	  (SuccCtx[res_ctx], prf)
	end
  end else begin
    Debug.devel_pprint ("heap_entail_conjunct: formula is not valid\n") pos;
     (CF.mkFailCtx_in (Basic_Reason ({
	  fc_message = "failed in entailing pure formula(s) in conseq";
	  fc_current_lhs  = estate;
      fc_prior_steps = estate.es_prior_steps;
	  fc_orig_conseq  = struc_formula_of_formula (formula_of_memo_pure_with_branches rhs_p rhs_p_br pos) pos;
	  fc_failure_pts = match r_fail_match with | Some s -> [s]| None-> [];})), prf)
  end
    (****************************************************************)  
    (* 20.04.2009 *)
    (* utilities for splitting the disjunctions in the antecedent and the conjunctions in the consequent *)
    (****************************************************************)  
    
and imply_memo ante_memo0 ante_memo1 conseq_memo = 
  match conseq_memo with
    | h :: rest -> 
      let r = MCP.fold_mem_lst_to_lst [h] false false true in
	    let (r1,r2,r3)=(imply_conj ante_memo0 ante_memo1 r) in
	    if r1 then 
	      let r1,r22,r23 = (imply_memo ante_memo0 ante_memo1 rest) in
	      (r1,r2@r22,r23)
	    else (r1,r2,r3)
    | [] -> (true,[],None)
    
    
    
and imply_conj ante_memo0 ante_memo1 conseq_conj = 
  match conseq_conj with
    | h :: rest -> 
	    let (r1,r2,r3)=(imply_one_conj ante_memo0 ante_memo1 h) in
	    if r1 then 
	      let r1,r22,r23 = (imply_conj ante_memo0 ante_memo1 rest) in
	      (r1,r2@r22,r23)
	    else 
      (*let _ = print_string ("\n failed ante: "^(Cprinter.string_of_pure_formula  
        (CP.fold_mem_lst (CP.mkTrue no_pos ) false ante_memo0))^"\t |- \t"^(Cprinter.string_of_pure_formula h)^"\n") in      *)
      (r1,r2,r3)
    | [] -> (true,[],None)
    
and imply_one_conj ante_memo0 ante_memo1 conseq  = 
  (*let _ = print_string ("\nSplitting the antecedent for xpure0:\n") in*)
  let xp01,xp02,xp03 = imply_process_ante ante_memo0 conseq ("IMP #" ^ (string_of_int !imp_no) ^ "." ^ (string_of_int 1(*!imp_subno*)) ^ " with XPure0") in  
  (*let _ = print_string ("\nDone splitting the antecedent for xpure0:\n") in*)
  if (not(xp01) (*&& (ante_memo0 <> ante_memo1)*)) then
    let _ = Debug.devel_pprint ("\nSplitting the antecedent for xpure1:\n") in
    let xp1 = imply_process_ante ante_memo1 conseq ("IMP #" ^ (string_of_int !imp_no) ^ "." ^ (string_of_int 2(*!imp_subno*)) ^ " with XPure1") in
    let _ = Debug.devel_pprint ("\nDone splitting the antecedent for xpure1:\n") in
	xp1
  else (xp01,xp02,xp03)	
    
and imply_process_ante ante_disj conseq str =
  let fv = CP.fv conseq in
  let n_ante = List.filter(fun c-> (List.length (Util.intersect_fct CP.eq_spec_var fv c.MCP.memo_group_fv))>0) ante_disj in 
  let r = MCP.fold_mem_lst (CP.mkTrue no_pos) false true n_ante in
  let _ = Debug.devel_pprint str no_pos in
  (TP.imply r conseq (string_of_int !imp_no) false)

   
and do_base_case_unfold prog ante conseq estate c1 c2 v1 v2 p1 p2 ln2 is_folding is_universal pid pos fold_f =
  if (is_data ln2) then (None,None)
  else
    let _ = Util.push_time "empty_predicate_testing" in
		let vd = (look_up_view_def_raw prog.prog_view_decls c1) in
		let fold_ctx = Ctx {(empty_es (mkTrueFlow ()) pos) with es_formula = ante;
                          es_heap = estate.es_heap;
                          es_evars = estate.es_evars;
                          es_gen_expl_vars = estate.es_gen_expl_vars; 
                          es_gen_impl_vars = estate.es_gen_impl_vars; 
                          es_ante_evars = estate.es_ante_evars;
                          es_unsat_flag = false;
                          es_prior_steps = estate.es_prior_steps;
                          es_path_label = estate.es_path_label;
                          es_cache_no_list = estate.es_cache_no_list} in
    let na,prf = match vd.view_base_case with
			| None ->  (CF.mkFailCtx_in(Basic_Reason ( { 
                                      fc_message ="failure 1 ?? when checking for aliased node";
                                      fc_current_lhs = estate;
                                      fc_prior_steps = estate.es_prior_steps;
                                      fc_orig_conseq = struc_formula_of_formula conseq pos; (* estate.es_orig_conseq; *)
                                      fc_failure_pts = match pid with | Some s-> [s] | _ -> [];})), UnsatConseq)
      | Some (bc1,(base1,branches1)) -> 
		    begin
          (*let _ = print_string ("ante: "^(Cprinter.string_of_formula ante)^"\n conseq "^(Cprinter.string_of_formula conseq)^"\n") in*)
          let fr_vars = (CP.SpecVar (CP.OType vd.Cast.view_data_name, self, Unprimed)) :: vd.view_vars in			
          let to_vars = p1 :: v1 in
          (*let _ = print_string ("from "^(Cprinter.string_of_spec_var_list fr_vars)^"\n to "^(Cprinter.string_of_spec_var_list to_vars)^"\n") in*)
          let base = MCP.subst_avoid_capture_memo fr_vars to_vars base1 in
          let branches = List.map (fun (c1,c2)-> (c1,Cpure.subst_avoid_capture fr_vars to_vars c2)) branches1 in
          let bc1 = Cpure.subst_avoid_capture fr_vars to_vars bc1 in
          let (nctx,b) = sem_imply_add prog is_folding is_universal fold_ctx bc1 !Globals.enable_syn_base_case in
          if b then 
					  let ctx = unfold_context (Branches (base,branches, v1)) (SuccCtx[nctx]) p1 true pos in
            (ctx,TrueConseq)
          else  (CF.mkFailCtx_in(Basic_Reason  ( { 
                                      fc_message ="failure 2 ?? when checking for aliased node";
                                      fc_current_lhs = estate;
                                      fc_prior_steps = estate.es_prior_steps;
                                      fc_orig_conseq = struc_formula_of_formula conseq pos; (* estate.es_orig_conseq; *)
                                      fc_failure_pts = match pid with | Some s-> [s] | _ -> [];})),TrueConseq)
        end in
    let _ = Util.pop_time "empty_predicate_testing" in
    if (isFailCtx na) then (None,None)
    else 
      let cx = match na with | SuccCtx l -> List.hd l |_ -> report_error pos("heap_entail_conjunct: something wrong has happened with the context") in
      let _ = Util.push_time "fold_after_base_case" in
			let do_fold_result,prf = fold_f cx p2 in
      let _ = Util.pop_time "fold_after_base_case" in
      if not(isFailCtx do_fold_result) then (Some(do_fold_result,prf),None)
      else                         
			  match cx with
			    | OCtx (c1,c2) ->  (None,None)
					| Ctx c -> (None,Some c)
	    
and do_match prog estate l_args r_args l_node_name r_node_name l_node r_node rhs is_folding is_universal r_var pos : 
    list_context *proof =
  Debug.devel_pprint ("do_match: using " ^
    (Cprinter.string_of_h_formula l_node)	^ " to prove " ^
    (Cprinter.string_of_h_formula r_node)) pos;
  let l_h,l_p,l_fl,l_b,l_t = split_components estate.es_formula in
  let r_h,r_p,r_fl,r_b,r_t = split_components rhs in
  let label_list = try 
    let vdef = Cast.look_up_view_def_raw prog.prog_view_decls l_node_name in
    vdef.Cast.view_labels
  with Not_found -> List.map (fun _ -> "") l_args in
  let rho = List.combine r_args l_args in
  let (expl_inst, ivars', expl_vars') = (get_eqns_expl_inst rho estate.es_ivars pos) in
  (* to_lhs only contains bindings for free vars that are not to be explicitly instantiated *)
  let rho = List.combine rho label_list in
  let (to_lhs, to_lhs_br),(to_rhs,to_rhs_br),ext_subst = get_eqns_free rho estate.es_evars (estate.es_expl_vars@expl_vars') estate.es_gen_expl_vars pos in
  (*********************************************************************)
  (* handle both explicit and implicit instantiation *)
  (* for the universal vars from universal lemmas, we use the explicit instantiation mechanism,  while, for the rest of the cases, we use implicit instantiation *)
  (* explicit instantiation is like delaying the movement of the bindings for the free vars from the RHS to the LHS *)
  (********************************************************************)
  let new_ante_p = (MCP.memoise_add_pure l_p to_lhs) in
  let new_conseq_p = (MCP.memoise_add_pure r_p to_rhs) in
  let new_ante = mkBase l_h new_ante_p l_t l_fl (CP.merge_branches l_b to_lhs_br) pos in
  let tmp_conseq = mkBase r_h new_conseq_p r_t r_fl (CP.merge_branches r_b to_rhs_br) pos  in
  (* apply the new bindings to the consequent *)
  let r_subs, l_sub = List.split ext_subst in
  (*IMPORTANT TODO: global existential not took into consideration*)
  let tmp_conseq' = subst_avoid_capture r_subs l_sub tmp_conseq in
  let tmp_h2, tmp_p2, tmp_fl2, tmp_b2,_  = split_components tmp_conseq' in
  let new_conseq = mkBase tmp_h2 tmp_p2 r_t r_fl tmp_b2 pos in
  let new_consumed = mkStarH l_node estate.es_heap pos in
  let n_es_res,n_es_succ = match ((get_node_label l_node),(get_node_label r_node)) with
    |Some s1, Some s2 -> ((Util.remove_elem s1 estate.es_residue_pts),((s1,s2)::estate.es_success_pts))
    |None, Some s2 -> (estate.es_residue_pts,estate.es_success_pts)
    |Some s1, None -> ((Util.remove_elem s1 estate.es_residue_pts),estate.es_success_pts)
    | None, None -> (estate.es_residue_pts, estate.es_success_pts)in 
  let new_es = {(es_cache_extend estate) with es_formula = new_ante;
	(* add the new vars to be explicitly instantiated *)
	es_expl_vars = estate.es_expl_vars@expl_vars';
	(* update ivars - basically, those univ vars for which binsings have been found will be removed:
	   for each new binding uvar = x, uvar will be removed from es_ivars and x will be added to the es_expl_vars *)
	es_ivars = ivars';
	es_heap = new_consumed;
	es_residue_pts = n_es_res;
	es_success_pts = n_es_succ; } in
  let new_subst = (obtain_subst expl_inst) in
  (* apply the explicit instantiations to the consequent *)
  let new_conseq = subst_avoid_capture (fst new_subst) (snd new_subst) new_conseq in
  (* for each expl inst vi = wi: make wi existential + remove vi from the exist vars *)
  let new_es' = {new_es with es_evars = new_es.es_evars @ (snd new_subst); es_must_match = false} in
  let new_es = pop_exists_estate (fst new_subst) new_es' in
  let new_ctx = Ctx (CF.add_to_estate new_es "matching of view/node") in
  Debug.devel_pprint ("do_match: "^ "new_ctx after matching: "
  ^ (Cprinter.string_of_spec_var r_var) ^ "\n"^ (Cprinter.string_of_context new_ctx)) pos;
  Debug.devel_pprint ("do_match: "^ "new_conseq after matching:\n"
  ^ (Cprinter.string_of_formula new_conseq)) pos;
  let res_es1, prf1 = heap_entail_conjunct prog is_folding is_universal new_ctx new_conseq pos in
  (res_es1,prf1)
	
and heap_entail_non_empty_rhs_heap prog is_folding is_universal ctx0 estate ante conseq lhs_b rhs_b pos : (list_context * proof) =
  let lhs_h = lhs_b.formula_base_heap in
  let lhs_p = lhs_b.formula_base_pure in
  let lhs_t = lhs_b.formula_base_type in
  let lhs_fl = lhs_b.formula_base_flow in
  let lhs_br = lhs_b.formula_base_branches in
  let rhs_h = rhs_b.formula_base_heap in
  let rhs_p = rhs_b.formula_base_pure in
  let rhs_t = rhs_b.formula_base_type in
  let rhs_br = rhs_b.formula_base_branches in
  let rhs_fl = rhs_b.formula_base_flow in
  (*let ln2, resth2 = split_linear_node rhs_h in*)
  let ln2, resth2 = split_linear_node_guided ( Util.remove_dups (h_fv lhs_h @ MCP.mfv lhs_p)) rhs_h in
  let ln2,resth2 = if (Cformula.is_complex_heap ln2) then (ln2,resth2)
  else split_linear_node rhs_h in
  (*let estate_steps = estate.es_prior_steps in *)
  match ln2 with
    | DataNode ({ h_formula_data_node = p2;
                  h_formula_data_name = c2;
                  h_formula_data_arguments = v2;
                  h_formula_data_label = pid;
                  h_formula_data_remaining_branches =r_rem_brs;
                  h_formula_data_pruning_conditions = r_p_cond;
                  h_formula_data_pos = pos2})
    | ViewNode ({ h_formula_view_node = p2;
                  h_formula_view_name = c2;
                  h_formula_view_arguments = v2;
                  h_formula_view_label = pid;
                  h_formula_view_remaining_branches = r_rem_brs;
                  h_formula_view_pruning_conditions = r_p_cond;
                  h_formula_view_pos = pos2}) -> begin
	    Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: trying to prove "
		^ (Cprinter.string_of_h_formula ln2)) pos;
	    (************************************)
	    (* the folding process *)
	    (* process folding. var_to_fold is the variable from the LHS to fold to *)
	    (************************************)
	    (****************************************************************************************************************************************************************************)
	    (* do_fold *)
	    (****************************************************************************************************************************************************************************)
	    let do_fold_w_ctx fold_ctx var_to_fold = 
	      let estate = estate_of_context fold_ctx pos2 in
          (*let estate_steps = estate.es_prior_steps in*)
	      (*************************** existential_eliminator_helper *************************************************)
	      let existential_eliminator_helper = 
	        let comparator v1 v2 = (String.compare (Cpure.name_of_spec_var v1) (Cpure.name_of_spec_var v2))==0 in
	        let pure = rhs_p in
	        let ptr_eq = MCP.ptr_equations pure in
	        let ptr_eq = (List.map (fun c->(c,c)) v2) @ ptr_eq in
	        let asets = Context.alias ptr_eq in
		    try
		      let vdef = look_up_view_def_raw prog.Cast.prog_view_decls c2 in
		      let subs_vars = List.combine vdef.view_vars v2 in
		      let sf = (CP.SpecVar (CP.OType vdef.Cast.view_data_name, self, Unprimed)) in
		      let subs_vars = (sf,var_to_fold)::subs_vars in
		      ((List.map (fun (c1,c2)-> 
				if (List.exists (comparator c1) vdef.view_case_vars) then
				  if (List.exists (comparator c2) estate.es_evars) then
				    let paset = Context.get_aset asets c2 in
					List.find (fun c -> not (List.exists (comparator c) estate.es_evars )) paset 
				  else c2
				else c2					
			  ) subs_vars),true)
		    with | Not_found -> (var_to_fold::v2,false) in
	      (*************************** end existential_eliminator_helper *************************************************)	
	      let (new_v2,use_case) = existential_eliminator_helper in
	      let view_to_fold = ViewNode ({  h_formula_view_node = List.hd new_v2 (*var_to_fold*);
                                        h_formula_view_name = c2;
                                        h_formula_view_arguments = List.tl new_v2;
                                        h_formula_view_modes = get_view_modes ln2;
                                        h_formula_view_coercible = true;
                                        h_formula_view_origins = get_view_origins ln2;
                                        h_formula_view_label = pid;           (*TODO: the other alternative is to use none*)
                                        h_formula_view_remaining_branches = r_rem_brs;
                                        h_formula_view_pruning_conditions = r_p_cond;
                                        h_formula_view_pos = pos2}) in

	      let fold_rs, fold_prf = fold prog fold_ctx view_to_fold (P.mkTrue pos) use_case pos in
	      if not (CF.isFailCtx fold_rs) then
		    let b = { formula_base_heap = resth2;
                  formula_base_pure = rhs_p;
                  formula_base_type = rhs_t;
                  formula_base_branches = rhs_br;
                  formula_base_flow = rhs_fl;		
                  formula_base_label = None;   
                  formula_base_pos = pos } in
		    let tmp, tmp_prf = process_fold_result prog is_folding estate fold_rs p2 v2 b pos in
		    let prf = mkFold ctx0 conseq p2 fold_prf tmp_prf in
		    (tmp, prf)
	      else begin
		    Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: unable to fold:\n"
          ^ (Cprinter.string_of_context ctx0) ^ "\n"
          ^ "to:ln2: "
          ^ (Cprinter.string_of_h_formula ln2)
          ^ "\nrhs_p: "
          ^ (Cprinter.string_of_memo_pure_formula rhs_p)) pos;
        (fold_rs, fold_prf)
	      end in
	    let do_fold (var_to_fold : CP.spec_var) =
	      let fold_ctx = Ctx {(empty_es (mkTrueFlow () ) pos) with 
            es_formula = ante;
            es_heap = estate.es_heap;
            es_evars = estate.es_evars;
            es_gen_expl_vars = estate.es_gen_expl_vars; 
            es_gen_impl_vars = estate.es_gen_impl_vars; 
            es_ante_evars = estate.es_ante_evars;
            es_pure = estate.es_pure;
            es_unsat_flag  = false;
            es_success_pts = estate.es_success_pts;
            es_residue_pts = estate.es_residue_pts;
            es_id  = estate.es_id;
            es_orig_ante  = estate.es_orig_ante;
            es_orig_conseq = estate.es_orig_conseq;
            es_prior_steps = estate.es_prior_steps;
            es_path_label = estate.es_path_label;
            es_cache_no_list = estate.es_cache_no_list} in
	      do_fold_w_ctx fold_ctx var_to_fold  in
	    
	    
	    (****************************************************************************************************************************************************************************)
	    (* end do_fold *)
	    (****************************************************************************************************************************************************************************)
	    (*
	      find nodes from LHS matching p2. Matching can occur at root
	      or at an argument.

	      The search is quite aggressive for now. It not only looks for
	      nodes (from LHS) aliased to p2, but also nodes that are aliased
	      (using lhs_p) to variables aliased (using rhs_p) to p2.

	      TODO: show that this is ok.
	    *)
	    let fnode_results = find_node_one prog lhs_h lhs_p p2  pos in
	    (************************* match_all_nodes ******************)
	    match fnode_results with 
	      | Failed -> (CF.mkFailCtx_in (Basic_Reason ( {
            fc_message = "failed 1 ?? to find a match";
            fc_current_lhs = estate;
                  fc_prior_steps = estate.es_prior_steps;
            fc_orig_conseq = struc_formula_of_formula conseq pos; (* estate.es_orig_conseq; *)
            fc_failure_pts = match pid with | Some s-> [s] | _ -> [];})), NoAlias) (* p2 is not mentioned in LHS, failure *)
	      | NoMatch -> begin (* p2 is mentioned in LHS, but no matching
				                node/predicate is found *)
            if is_data ln2 then begin (* fail *)
              Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
            ^ "no aliased node for data node "
            ^ (Cprinter.string_of_h_formula ln2)
            ^ " is found in LHS\n") pos;
              (CF.mkFailCtx_in (Basic_Reason ( {
            fc_message = "failed to find a match in conseq for "^Cprinter.string_of_h_formula(ln2);
            fc_current_lhs = estate;
                    fc_prior_steps = estate.es_prior_steps;
            fc_orig_conseq = struc_formula_of_formula conseq pos; (* estate.es_orig_conseq; *)
            fc_failure_pts = match pid with | Some s-> [s] | _ -> [];})), NoAlias) 
            end
            else begin (* attempting to fold against the base case *)
              Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
          ^ "folding with no node on lhs: " ^ (Cprinter.string_of_spec_var p2)
          ^ "\ncontext:\n" ^ (Cprinter.string_of_context ctx0) 
          ^ "\nln2:\n" ^ (Cprinter.string_of_h_formula ln2)
          ^ "\nrhs_p:\n" ^ (Cprinter.string_of_memo_pure_formula rhs_p)) pos;
              do_fold p2 (* p2 is mentioned in LHS, p2 can be fold target *)
                (* var_to_fold *)
            end (* end of emty anodes case *)
          end
	      | Match (matches) -> begin
		      (* let _ = print_string("check the aliases") in	*)
		      (* one or more aliased nodes are found, try all of them one by one. *)
		      (* When trying a node, add the remaining back to resth1. *)
		      (*******************************************************************************************************************************************************************************************)
		      (* start of check_aliased_node *)
		      (*******************************************************************************************************************************************************************************************)
		      (* *)
		      let check_aliased_node (anode, r_flag) resth1 =
		        match anode with
		          | ViewNode ({ h_formula_view_node = p1;
                            h_formula_view_name = c1;
                            h_formula_view_arguments = v1;
                            h_formula_view_remaining_branches = l_rem_brs;
                            h_formula_view_pos = pos1})
		          | DataNode ({ h_formula_data_node = p1;
                            h_formula_data_name = c1;
                            h_formula_data_arguments = v1;
                            h_formula_data_remaining_branches = l_rem_brs;
                            h_formula_data_pos = pos1}) ->
			          if r_flag = Context.Root then begin (* matching occurs at root *)
			            if (c1 = c2) then 
                    (* try and make sure the branches match, if not and if some conditions involving only 
                      univ vars can be used to prune the necesary branch then add those conditions to the right
                      and do the prune*)
                    let subsumes, to_be_proven = prune_branches_subsume prog estate.es_ivars anode ln2 in
                    if not subsumes then 
                        (CF.mkFailCtx_in (Basic_Reason ({
                                fc_message = "there is a mismatch in branches ";
                                fc_current_lhs = estate;
                                fc_prior_steps = estate.es_prior_steps;
                                fc_orig_conseq = estate.es_orig_conseq;
                                fc_failure_pts =match pid with | Some s-> [s] | _ -> [];})), NoAlias)
                    else
                      (match to_be_proven with
                        | Some l ->
                          (*let _ = print_string ("can strenghten: with: "^(Cprinter.string_of_pure_formula l)^"\n") in*)
                          let f_l = formula_of_pure l pos   in
                          let new_es_f = normalize estate.es_formula f_l pos in
                          let new_es = {estate with es_formula = prune_preds prog new_es_f } in 
                          let new_ctx = Ctx new_es in
                          let new_conseq = normalize conseq f_l pos in
                          heap_entail_conjunct prog is_folding is_universal new_ctx new_conseq pos 
                        | None ->
                          let ans = do_base_case_unfold prog ante conseq estate c1 c2 v1 v2 p1 p2 ln2 is_folding 
                                    is_universal pid pos do_fold_w_ctx in
                          match ans with 
                            | Some x, _ -> x
                            | None, y->  
                              let new_estate = match y with 
                                  | Some x-> x 
                                  | None -> {estate with es_formula = (mkBase resth1 lhs_p lhs_t lhs_fl lhs_br pos)} in
                              let res_es1, prf1 = do_match prog new_estate v1 v2 c1 c2 anode ln2 
                                                          (mkBase resth2 rhs_p rhs_t rhs_fl rhs_br pos) 
                                                          is_folding is_universal p2 pos in
                                  let copy_enable_distribution = !enable_distribution in
                                (*******************************************************************************************************************************************************************************************)
                                (* call to do_coercion *)
                                (* try coercion as well *)
                                (*******************************************************************************************************************************************************************************************)
                                  let ans =	
                                  if is_view anode then
                                    (Debug.devel_pprint ("do_coercion for " ^ (Cprinter.string_of_h_formula anode) ^ "\n") pos;
                                    Some (do_coercion c1 c2 prog estate conseq ctx0 resth1 resth2 anode lhs_p lhs_t lhs_fl lhs_br rhs_p rhs_t rhs_fl lhs_b rhs_b ln2 is_folding pos pid))
                                      (* else (CF.SuccCtx [], []) in - this does not work! *)
                                  else None in
                                match ans with
                                  | None -> (res_es1, prf1)
                                  | Some (res_es2,prf2) -> begin
                                      enable_distribution := copy_enable_distribution;
                                      let prf1 = mkMatch ctx0 conseq ln2 [prf1] in
                                      let prf = mkMatch ctx0 conseq ln2 (prf1 :: prf2) in
                                      let res = (fold_context_left
                                    [res_es1;res_es2]) in (* this is a union *)
                                      (*let _ = print_string ("\nmatch "^(string_of_bool(isFailCtx res_es1))^
                                        "\n coerc: "^(string_of_bool(isFailCtx res_es2))^"\n result :"^
                                        (string_of_bool(isFailCtx res_es1))^"\n") in*)
                                      let prf = match isFailCtx res_es1, isFailCtx res_es2 with
                                        | true,true -> prf
                                        | true,false ->  mkCoercion2 ctx0 conseq prf2
                                        | false ,true -> enable_distribution := true; prf1
                                        | false , false -> prf in
                                      (res,prf)
                                    end
                      )
			            else (* c1 not equal c2*)
			              begin
				            if is_view ln2 && is_data anode then 
				              begin (* fold *)
				                Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: folding: " ^ (Cprinter.string_of_spec_var p2)
                            ^ "\nante:\n" ^ (Cprinter.string_of_formula ante)
                            ^ "\nln2:\n" ^ (Cprinter.string_of_h_formula ln2)
                            ^ "\nrhs_p:\n" ^ (Cprinter.string_of_memo_pure_formula rhs_p)) pos;
				                do_fold p2
				              end else if is_data ln2 && is_view anode then 
				                begin (* unfold *)
				                  let delta1 = unfold (Prog prog) ante p1 true pos in
				                  let ctx1 = build_context ctx0 delta1 pos in
				                  let ctx1 = set_unsat_flag ctx1 true in
				                  let res_rs, prf1 = heap_entail_one_context prog
					                is_folding is_universal ctx1 conseq pos in
				                  let prf = mkUnfold ctx0 conseq anode prf1 in
					              (res_rs, prf)
				                end else 
                        (* two different predicates match, try coercion *)
                          (*try base case unfolding *)
                          let ans = do_base_case_unfold prog ante conseq estate c1 c2 v1 v2 p1 p2 ln2 is_folding is_universal pid pos do_fold_w_ctx in
                          match ans with 
                            | Some x, _ -> x
                            | None, _->                              
                              if !Globals.use_coercion then 
                              begin
                                Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: " ^ "trying coercion") pos;
                                let res, prfs = do_coercion c1 c2 prog estate conseq ctx0 resth1 resth2 anode lhs_p lhs_t lhs_fl lhs_br rhs_p rhs_t rhs_fl lhs_b rhs_b ln2 is_folding pos pid in
                                let prf = mkCoercion2 ctx0 conseq prfs in
                                (res, prf)
                              end else 
                                begin
                                  Debug.devel_pprint ("heap_entail_conjunct: " ^ "can't reduce, fold, unfold") pos;
                                  (CF.mkFailCtx_in (Basic_Reason ( {
                                                      fc_message = "can't reduce, fold, unfold";
                                                      fc_current_lhs = estate;
                                                      fc_prior_steps = estate.es_prior_steps;
                                                      fc_orig_conseq = estate.es_orig_conseq;
                                                      fc_failure_pts =match pid with | Some s-> [s] | _ -> []; 
                                                    })), Failure)
                              end
			              end (*end for c1 not equal c2*)
			          end (*end of match at root*)
			          else if !Globals.use_coercion then (* there is a match at some node, but not at root *)
			            
			            (*if is_data ln2 && r_flag = Arg then begin
			              Debug.devel_pprint ("heap_entail_conjunct: matching of data node"
			              ^ " with non-materialized argument") pos;
			              (--[], NoAlias) (* there no hope an alias at
			              non-materialized arg would expose an object *)
			              end else*)
			            begin
			              Debug.devel_pprint ("heap_entail_conjunct: there is a match at some node, but not at root\n") pos;
			              let res, prfs = do_coercion c1 c2 prog estate conseq ctx0 resth1 resth2 anode lhs_p lhs_t lhs_fl lhs_br rhs_p rhs_t rhs_fl lhs_b rhs_b ln2 is_folding pos pid in
			              let prf = mkCoercion2 ctx0 conseq prfs in
				          (res, prf)
			            end
			          else
			            (CF.mkFailCtx_in (Basic_Reason ({
						  fc_message = "there is a match at some node, not at root";
						  fc_current_lhs = estate;
                          fc_prior_steps = estate.es_prior_steps;
						  fc_orig_conseq = estate.es_orig_conseq;
						  fc_failure_pts =match pid with | Some s-> [s] | _ -> [];})), NoAlias)
		          | _ -> report_error pos
			          ("heap_entail_conjunct: something wrong has happened with the context") in
		      (*******************************************************************************************************************************************************************************************)
		      (* end of check_aliased_node *)
		      (*******************************************************************************************************************************************************************************************)				  
		      (*******************************************************************************************************************************************************************************************)
		      (* check_node_helper *)
		      (*******************************************************************************************************************************************************************************************)
		      (* check one match *)
		      let rec check_node_helper (all_nodes : Context.context list) : (list_context * proof list) = match all_nodes with
		        | (anode, r_flag, _, rest_heap) :: rest ->
			        (*let _ = print_string("check alias for " ^ (Cprinter.string_of_h_formula anode) ^ "and rest_heap = " ^ (Cprinter.string_of_h_formula rest_heap) ^ "\n") in*)
			        let rs1, prf1 = check_aliased_node (anode, r_flag) rest_heap in
			        (*						let _ = print_string("result of check alias: " ^ (Cprinter.string_of_context_list rs1) ^ "\n") in*)
	                if rest=[] then (rs1,[prf1])
			        else  
			          if !Globals.use_set then (* use_set denotes set of state
							                      searching *)
                        let rs2,prfs2 = check_node_helper rest in
				        (fold_context_left [rs1;rs2],prf1 :: prfs2)               
			          else (rs1,[prf1])
			            (* let rs2,prfs = if !Globals.use_set then check_node_helper rest  *)
			            (*   else (CF.mkFailCtx_in(Basic_Reason ( {  *)
			            (* 					fc_message ="failure  4 ?? under node helper when checking for aliased node"; *)
			            (* 					fc_current_lhs = estate; *)
			            (* 					fc_orig_conseq = struc_formula_of_formula conseq pos;  *)
			            (* 					fc_failure_pts = match pid with | Some s-> [s] | _ -> [];})), []) *)
			            (* in *)
			            (*   ((fold_context_left [rs1;rs2]), prf1 :: prfs2) *)
		        | [] -> (CF.mkFailCtx_in(Trivial_Reason "impossible here : end of check_node_helper"),[]) in
		      (* (Some {  *)
		      (* 								fc_message ="failure  5 ?? under node helper when checking for aliased node"; *)
		      (* 								fc_current_lhs = estate; *)
		      (* 								fc_orig_conseq = struc_formula_of_formula conseq pos;  *)
		      (* 								fc_failure_pts = match pid with | Some s-> [s] | _ -> [];})), []) in	 *)					
		      
		      (* finally, check all matches  *)
		      let rs, prfs = check_node_helper matches in
		      let prf =
		        if U.empty (List.tl prfs) then List.hd prfs
		        else (*let _ = print_string("can do match\n") in*) mkMMatch ctx0 conseq ln2 prfs
		      in
		      (*	let _ = print_string("result of check node: " ^ (Cprinter.string_of_context_list rs) ^ "\n") in*)
		      (rs, prf)
		    end
	  end
    | HFalse | HTrue | Star _ -> failwith ("heap_entail_conjunct: "
	  ^ "something bad has happened to split_linear_node")



(*******************************************************************************************************************************************************************************************)
(*
  Summary of the coercion helper methods:
  - check the guard in do_universal and rewrite_coercion
  -  rewrite_coercion called in apply_left_coercion and apply_right_coercion
  - apply_left_coercion called in do_coercion
  - apply_right_coercion called in do_coercion
  - do_coercion called in heap_entail_non_empty_rhs_heap --------- the main coercion helper
  - do_universal called in apply_universal
  - apply_universal called in do_coercion

*)

(* helper functions for coercion *)

(*
  Applying universally-quantified lemmas. Here are the steps:
  - Compute the set of universal variables. If the set is
  empty, then just do normal rewriting. (this has been done by apply_universal).
  - Split the guard out. Change it to existential to check
  for satisfiability.
  - Do the rewriting.
  - Perform entailment with rewritten formula
  - Filter subformulas from the pure part of the consequent
  that are related to the guard. This provides us with the instantiation.

  Now it only works when applying to the antecedent.
*)
(* new version:
   - forall v*. H /\ G -> B
   - match H and the node/predicate to be coerced and obtain the substitution \rho
*)					
(*******************************************************************************************************************************************************************************************)
(* do_universal *)
(*******************************************************************************************************************************************************************************************)

and do_universal prog estate node f coer anode lhs_b rhs_b conseq is_folding pos pid: (list_context * proof) =
  begin
    (* rename the bound vars *)
    let f_univ_vars = CP.fresh_spec_vars coer.coercion_univ_vars in
    (*
	  let _ = print_string ("univ_vars: "   ^ (String.concat ", "   (List.map CP.name_of_spec_var  coer.coercion_univ_vars)) ^ "\n") in
    *)
    (*let _ = print_string ("[do_univ]: rename the univ boudn vars: " ^ (String.concat ", " (List.map CP.name_of_spec_var f_univ_vars)) ^ "\n") in	*)
    let tmp_rho = List.combine coer.coercion_univ_vars f_univ_vars in
    let coer_lhs = CF.subst tmp_rho coer.coercion_head in
    let coer_rhs = CF.subst tmp_rho coer.coercion_body in
    (************************************************************************)
    (* also rename the free vars from the rhs that do not appear in the lhs *)
    let lhs_fv = (fv_rhs coer_lhs coer_rhs) in
    let fresh_lhs_fv = CP.fresh_spec_vars lhs_fv in
    let tmp_rho = List.combine lhs_fv fresh_lhs_fv in
    let coer_lhs = CF.subst tmp_rho coer_lhs in
    let coer_rhs = CF.subst tmp_rho coer_rhs in
    let lhs_heap, lhs_guard,lhs_fl, lhs_branches, _  = split_components coer_lhs in
    let lhs_guard = MCP.fold_mem_lst (CP.mkTrue no_pos) true true lhs_guard in
    let br_match br1 br2 = match br1,br2 with
    | None,None -> true
    | Some br1,Some br2 ->(Util.list_equal br1 br2)
    (*if (Util.list_equal br1 br2) then true 
      else (print_string("miss: "^(String.concat ","(List.map (fun (c,_)-> (string_of_int c)) br1))^" then "^
            (String.concat ","(List.map (fun (c,_)-> (string_of_int c)) br2))^"\n");false)*)
    | _ -> let _ = print_string ("mal: "^(Cprinter.string_of_coerc_decl true coer)^"\n lhs: "^(Cprinter.string_of_formula (CF.formula_of_base lhs_b))^
                            " rhs: "^(Cprinter.string_of_formula (CF.formula_of_base rhs_b))^"\n") in
      Err.report_error { Err.error_loc = no_pos; Err.error_text ="malfunction: specialization mismatch in lemma application"}   in    
    match node, lhs_heap with
	  | ViewNode ({ h_formula_view_node = p1;
                  h_formula_view_name = c1;
                  h_formula_view_origins = origs;
                  h_formula_view_remaining_branches = br1;
                  h_formula_view_arguments = ps1}),
      ViewNode ({ h_formula_view_node = p2;
                  h_formula_view_name = c2;
                  h_formula_view_remaining_branches = br2;
                  h_formula_view_arguments = ps2}) when c1=c2 && (br_match br1 br2)-> begin
	      (* the lemma application heuristic:
	         - if the flag 	lemma_heuristic in true then we use both coerce& match - each lemma application must be followed by a match  - and history
	         - if the flag is false, we only use coerce&distribute&match
	      *)
	      let apply_coer = (coer_target prog coer anode (CF.formula_of_base rhs_b) (CF.formula_of_base lhs_b)) in
	      if (!Globals.lemma_heuristic && 		(* use coerce&match together with the history mechanism *)
		    (not(apply_coer) 					(* the target is not present *)
		    or (get_estate_must_match estate))  (* must match *)
		  && (List.mem coer.coercion_body_view origs
		  or List.mem coer.coercion_head_view origs))  (* there is a cycle *)
		    or 	(not(!Globals.lemma_heuristic) &&   (* use coerce&distribute&match*)
			  (not(apply_coer) or 				(* the target is not present *)
			    ((get_estate_must_match estate) 	(* must match *)
			    && (not(!enable_distribution) 		(* distributive coercion is not allowed *)
				or not(is_distributive coer))))) 	(* coercion is not distributive *)
	      then
		    (Debug.devel_pprint("[do_universal]: Coercion cannot be applied!") pos; 
		    (CF.mkFailCtx_in(Basic_Reason( { 
			  fc_message ="failed coercion application";
			  fc_current_lhs = estate;
              fc_prior_steps = estate.es_prior_steps;
			  fc_orig_conseq = estate.es_orig_conseq;
			  fc_failure_pts = match pid with | Some s-> [s] | _ -> [];})), Failure))
	      else	(* we can apply coercion *)
		    begin
		      if (not(!Globals.lemma_heuristic) && get_estate_must_match estate) then
		        ((*print_string("disable distribution\n");*) enable_distribution := false);
		      (* the \rho substitution \rho (B) and  \rho(G) is performed *)
		      let lhs_guard_new = CP.subst_avoid_capture (p2 :: ps2) (p1 :: ps1) lhs_guard in
		      let lhs_branches_new = List.map (fun (s, f) -> (s, (CP.subst_avoid_capture (p2 :: ps2) (p1 :: ps1) f))) lhs_branches in
		      let coer_rhs_new1 = subst_avoid_capture (p2 :: ps2) (p1 :: ps1) coer_rhs in
		      let coer_rhs_new = add_origins coer_rhs_new1 (coer.coercion_head_view :: origs) in
		      let _ = reset_int2 () in
		      (*let xpure_lhs = xpure prog f in*)
		      (*************************************************************************************************************************************************************************)
		      (* delay the guard check *)
		      (* for now, just add it to the consequent *)
		      (*************************************************************************************************************************************************************************)
		      (*let guard_to_check = CP.mkExists f_univ_vars lhs_guard_new pos in*)
		      (*let _ = print_string("xpure_lhs: " ^ (Cprinter.string_of_pure_formula xpure_lhs) ^ "\n") in
		        let _ = print_string("guard: " ^ (Cprinter.string_of_pure_formula guard_to_check) ^ "\n") in*)
		      let new_f = normalize coer_rhs_new f pos in
		      (* add the guard to the consequent  - however, the guard check is delayed *)
		      let formula = replace_branches lhs_branches_new (formula_of_pure lhs_guard_new pos) in
		      let new_conseq = normalize conseq formula pos in
		      let new_estate = {estate with
                            es_evars = f_univ_vars @ estate.es_evars;
                            (* the new universal vars to be instantiated *)
                            es_ivars = f_univ_vars @ estate.es_ivars;
                            es_formula = new_f;
                            es_must_match = true} in
		      let new_ctx = Ctx new_estate in
		      let res, prf = heap_entail prog is_folding true (SuccCtx [new_ctx]) new_conseq pos in
		      (res, prf)
		    end
	    end
	  | _ -> (CF.mkFailCtx_in(Basic_Reason ( { 
		  fc_message ="failed coercion application, found data expected view";
		  fc_current_lhs = estate;
          fc_prior_steps = estate.es_prior_steps;
		  fc_orig_conseq = estate.es_orig_conseq;
		  fc_failure_pts = [];})), Failure)
  end
    (*
      Rewrites f by matching node with coer_lhs to obtain a substitution.
      The substitution is then applied to coer_rhs, which is then *-joined
      with f and then normalized.

      If the first component of the returned value is true, the rewrite
      is successful and the coercion performed. Otherwise, the rewrite is
      not performed (due to the guard).
    *)
    (*******************************************************************************************************************************************************************************************)
    (* rewrite_coercion *)
    (*******************************************************************************************************************************************************************************************)
and rewrite_coercion prog estate node f coer lhs_b rhs_b weaken pos : (bool * formula) =
  (* This function also needs to add the name and the origin list
     of the source view to the origin list of the target view. It
     needs to check if the target view in coer_rhs belongs to the
     list of origins of node. If so, don't apply the coercion *)
  (******************** here it was the test for coerce&match *************************)
  let coer_lhs = coer.coercion_head in
  let coer_rhs = coer.coercion_body in
  let lhs_heap, lhs_guard, lhs_flow, lhs_branches, _ = split_components coer_lhs in
  let lhs_guard = MCP.fold_mem_lst (CP.mkTrue no_pos) true true lhs_guard in
  let br_match br1 br2 = match br1,br2 with
    | None,None -> true
    | Some br1,Some br2 -> (Util.list_equal br1 br2)
      (*if (Util.list_equal br1 br2) then true (*(weaken&&(Util.subset br1 br2))||(not weaken && (Util.subset br2 br1))*)
      else (print_string("miss: "^(String.concat ","(List.map (fun (c,_)-> (string_of_int c)) br1))^" then "^
            (String.concat ","(List.map (fun (c,_)-> (string_of_int c)) br2))^"\n");false)*)
    | _ -> 
      let _ = print_string ("mal: "^(Cprinter.string_of_coerc_decl weaken coer)^"\n lhs: "^(Cprinter.string_of_formula (CF.formula_of_base lhs_b))^
                            " rhs: "^(Cprinter.string_of_formula (CF.formula_of_base rhs_b))^"\n") in
      Err.report_error { Err.error_loc = no_pos; Err.error_text ="malfunction: specialization mismatch in lemma application"}   in
  match node, lhs_heap with
    | ViewNode ({ h_formula_view_node = p1;
                  h_formula_view_name = c1;
                  h_formula_view_origins = origs;
                  h_formula_view_remaining_branches = br1;
                  h_formula_view_arguments = ps1}),
      ViewNode ({ h_formula_view_node = p2;
                  h_formula_view_name = c2;
                  h_formula_view_remaining_branches = br2;
                  h_formula_view_arguments = ps2}) 
                  when (c1=c2 && (br_match br1 br2))-> begin
	    (*
	      let _ = print_string ("body_view: " ^ coer.coercion_body_view ^ "\n") in
	      let _ = print_string ("head_view: " ^ coer.coercion_head_view ^ "\n") in
	      let _ = print_string ("origs: " ^ (String.concat ", " origs) ^ "\n") in
	    *)
	    (*************************************************************)
	    (* replace with the coerce&match mechanism *)
	    (*************************************************************)
	    let apply_coer = (coer_target prog coer node (CF.formula_of_base rhs_b) (CF.formula_of_base lhs_b)) in
	    (* the lemma application heuristic:
	       - if the flag 	lemma_heuristic in true then we use both coerce& match and history
	       - if the flag is false, we only use coerce&distribute&match
	    *)
	    if (!Globals.lemma_heuristic && 
          (not(apply_coer) (* coerce&match+history *) or (get_estate_must_match estate)) && 
          (List.mem coer.coercion_body_view origs or List.mem coer.coercion_head_view origs))
	    or (not(!Globals.lemma_heuristic) && (* coerce&distribute&match *)
			(not(apply_coer) or 	(* the target is not present *)
      ((get_estate_must_match estate) (* must match *) && (not(!enable_distribution) (* distributive coercion is not allowed *)
			  or not(is_distributive coer))))) (* coercion is not distributive *)
	    then

	      (Debug.devel_pprint("[do_universal]: Coercion cannot be applied!") pos; (false, mkTrue (mkTrueFlow ())no_pos))
	    else
	      (* we can apply coercion *)
	      begin
		    (* apply \rho (G)	and \rho(B) *)
		    let lhs_guard_new = CP.subst_avoid_capture (p2 :: ps2) (p1 :: ps1) lhs_guard in
		    (*let lhs_branches_new = List.map (fun (s, f) -> (s, (CP.subst_avoid_capture (p2 :: ps2) (p1 :: ps1) f))) lhs_branches in*)
		    let coer_rhs_new1 = subst_avoid_capture (p2 :: ps2) (p1 :: ps1) coer_rhs in
		    let coer_rhs_new = add_origins coer_rhs_new1 (coer.coercion_head_view :: origs) in
		    let _ = reset_int2 () in
		    let xpure_lhs, xpure_lhs_b = xpure prog f in
		    (*******************************************************************************************************************************************************************************************)
		    (* test the guard again in rewrite_coercion
		       - for now we only revise the universal lemmas handled by apply_universal --> the check stays here as it is *)
		    (*******************************************************************************************************************************************************************************************)
		    (* is it necessary to xpure (node * f) instead ? *)
		    Debug.devel_pprint ("IMP #" ^ (string_of_int !imp_no) ^ "\n") no_pos;
		    imp_no := !imp_no+1;
		    if ((fun (c1,_,_)-> c1) (TP.imply (MCP.fold_mem_lst (CP.mkTrue no_pos) true true xpure_lhs) lhs_guard_new (string_of_int !imp_no) false)) then
		      let new_f = normalize coer_rhs_new f pos in
		      (if (not(!Globals.lemma_heuristic) && get_estate_must_match estate) then
			    ((*print_string("disable distribution\n"); *)enable_distribution := false);
		      (true, new_f))
		    else if !Globals.case_split then begin
		      (*
		        Doing case splitting based on the guard.
		      *)
		      Debug.devel_pprint("rewrite_coercion: guard is not satisfied, " ^ "splitting.\n") pos;
		      let neg_guard = CP.mkNot lhs_guard_new None pos in
		      let f0 = normalize f (formula_of_heap node pos) pos in
		      let f1 = normalize f0 (formula_of_pure neg_guard pos) pos in
		      (* unfold the case with the negation of the guard. *)
		      let f1 = unfold (Prog prog) f1 p1 true pos in
		      let f2 = normalize f0 (formula_of_pure lhs_guard_new pos) pos in
		      (* f2 need no unfolding, since next time
			     coercion is reapplied,
			     the guard is guaranteed to be satisified *)
		      let new_f = mkOr f1 f2 pos in
		      if (not(!Globals.lemma_heuristic) && (get_estate_must_match estate)) then
			    ((*print_string("disable distribution\n"); *)enable_distribution := false);
		      (true, new_f)
		    end else begin
		      Debug.devel_pprint
		        ("rewrite_coercion: guard is not satisfied, "
		        ^ "no splitting.\n") pos;
		      (false, mkTrue (mkTrueFlow ()) no_pos)
		    end
	      end
	  end
    | _ -> (false, mkTrue (mkTrueFlow ()) no_pos)
	    (*end	*)
	    
(*******************************************************************************************************************************************************************************************)
and apply_universal prog estate coer resth1 anode lhs_p lhs_t lhs_fl lhs_br lhs_b rhs_b c1 c2 conseq is_folding pos pid =
  (*******************************************************************************************************************************************************************************************)
  flush stdout;
  if Util.empty coer.coercion_univ_vars then (CF.mkFailCtx_in ( Basic_Reason (  {
                                                                          fc_message = "failed apply_universal";
                                                                          fc_current_lhs = estate;
                                                                          fc_prior_steps = estate.es_prior_steps;
                                                                          fc_orig_conseq = estate.es_orig_conseq;
                                                                          fc_failure_pts = match pid with | Some s-> [s] | _ -> [];
                                                                        })), Failure)
  else begin
    let f = mkBase resth1 lhs_p lhs_t lhs_fl lhs_br pos in(* Assume coercions have no branches *)
    let _ = Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: apply_universal: "	^ "c1 = " ^ c1 ^ ", c2 = " ^ c2 ^ "\n") pos in
    (*do_universal anode f coer*)
    do_universal prog estate anode f coer anode lhs_b rhs_b conseq is_folding pos pid
  end
    
(*******************************************************************************************************************************************************************************************)
(* do_coercion *)
(*******************************************************************************************************************************************************************************************)
and do_coercion c1 c2 prog estate conseq ctx0 resth1 resth2 anode lhs_p lhs_t lhs_fl lhs_br rhs_p rhs_t rhs_fl lhs_b rhs_b ln2 is_folding pos pid : (CF.list_context * proof list) =
  Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: do_coercion: " ^ "c1 = " ^ c1 ^ ", c2 = " ^ c2 ^ "\n") pos;
  let coers1 = look_up_coercion_def_raw prog.prog_left_coercions c1 in
  let coers1, univ_coers = List.partition (fun c -> Util.empty c.coercion_univ_vars) coers1 in
  (* universal coercions *)
  (*let _ = print_string("[do_coercion]: number of univ coer " ^ (string_of_int (List.length univ_coers)) ^ "--> call apply universal \n") in*)
  let univ_r = if (List.length univ_coers)>0 then
    let univ_res_tmp = List.map (fun coer -> apply_universal prog estate coer resth1 anode lhs_p lhs_t lhs_fl lhs_br lhs_b rhs_b c1 c2 conseq is_folding pos pid) univ_coers in
    let univ_res, univ_prf = List.split univ_res_tmp in
    Some (univ_res, univ_prf)
  else None in
  (*let univ_prf = List.concat univ_prf in*)
  (* left coercions *)
  (*let _ = print_string("[do_coercion]: number of univ coer " ^ (string_of_int (List.length coers1)) ^ "--> call apply_left_coercion\n") in  *)
  let left_r = if (List.length coers1)>0 then
    let tmp1 = List.map  (fun coer -> apply_left_coercion estate coer prog conseq ctx0 resth1 anode lhs_p lhs_t lhs_fl lhs_br lhs_b rhs_b c1 is_folding pos pid) coers1 in
    let left_res, left_prf = List.split tmp1 in
    let left_prf = List.concat left_prf in
    Some (left_res,left_prf)
  else None in
  (* a quick hack *)
  (* right coercions *)
  let coers2 = look_up_coercion_def_raw prog.prog_right_coercions c2 in
  let right_r = if (List.length coers2)>0 then
    let tmp2 = List.map (fun coer -> apply_right_coercion estate coer prog conseq ctx0 resth2 ln2 rhs_p rhs_t rhs_fl lhs_b rhs_b c2 is_folding pos pid) coers2 in
    let right_res, right_prf = List.split tmp2 in
    let right_prf = List.concat right_prf in
    Some (right_res,right_prf)
  else None in
  match univ_r,left_r,right_r with
	  (* | None,None,None -> (CF.mkFailCtx_in(Basic_Reason None), []) *)
    | None,None,None -> (CF.mkFailCtx_in(Trivial_Reason "cannot find matching node in antecedent (do coercion)"), [])
	    (* (CF.mkFailCtx_in(Basic_Reason ( { *)
	    (* fc_message ="cannot find matching node in antecedent (do coercion) "; *)
	    (* fc_current_lhs = estate; *)
	    (* fc_orig_conseq = struc_formula_of_formula conseq pos; *)
	    (* fc_failure_pts = match pid with | Some s-> [s] | _ -> [];})), []) *)
    | Some (c1,c2), None, None 
    | None, Some (c1,c2), None  
    | None, None, Some (c1,c2) -> ((fold_context_left c1),c2)
    | Some (c1,c2),Some(d1,d2),None
    | Some (c1,c2),None,Some(d1,d2)
    | None,Some (c1,c2),Some(d1,d2) -> 
        let c1 = (fold_context_left c1) in
        let d1 = (fold_context_left d1) in
        let r = (fold_context_left [c1;d1]) in
        let prf = (if (isFailCtx r)==(isFailCtx c1) then c2 else [])@
          (if (isFailCtx r)==(isFailCtx d1) then d2 else [])in
        (r,prf)
    | Some (c1,c2),Some(d1,d2),Some (e1,e2) ->
        let c1 = (fold_context_left c1) in
        let d1 = (fold_context_left d1) in
        let e1 = (fold_context_left e1) in
        let r = (fold_context_left [c1;d1;e1]) in
        let prf = (if (isFailCtx r)==(isFailCtx c1) then c2 else [])@
          (if (isFailCtx r)==(isFailCtx d1) then d2 else [])@
          (if (isFailCtx r)==(isFailCtx e1) then e2 else [])in
        (r,prf)
	      (*******************************************************************************************************************************************************************************************)
	      (* apply_left_coercion *)
	      (*******************************************************************************************************************************************************************************************)
and apply_left_coercion estate coer prog conseq ctx0 resth1 anode lhs_p lhs_t lhs_fl lhs_br lhs_b rhs_b c1 is_folding pos pid=
  (*let _ = print_string("left coercion\n") in*)
  let f = mkBase resth1 lhs_p lhs_t lhs_fl lhs_br pos in
  let _ = Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
  ^ "left_coercion: c1 = "
  ^ c1 ^ "\n") pos in
  let ok, new_lhs = rewrite_coercion prog estate anode f coer lhs_b rhs_b true pos in
  if ok then begin
    let new_ctx1 = build_context ctx0 new_lhs pos in
	(* let new_ctx = set_context_formula ctx0 new_lhs in *)
    let new_ctx = SuccCtx[(set_context_must_match new_ctx1)] in
    let res, tmp_prf = heap_entail prog is_folding false new_ctx conseq pos in
    let prf = mkCoercionLeft ctx0 conseq coer.coercion_head
	  coer.coercion_body tmp_prf coer.coercion_name
    in
	(res, [prf])
  end else (CF.mkFailCtx_in( Basic_Reason ( { 
              fc_message ="failed coercion application";
              fc_current_lhs = estate;
              fc_prior_steps = estate.es_prior_steps;
              fc_orig_conseq = estate.es_orig_conseq;
              fc_failure_pts = match pid with | Some s-> [s] | _ -> [];})), [])
    (*******************************************************************************************************************************************************************************************)
    (* apply_right_coercion *)
    (*******************************************************************************************************************************************************************************************)
and apply_right_coercion estate coer prog conseq ctx0 resth2 ln2 rhs_p rhs_t rhs_fl lhs_b rhs_b c2 is_folding pos pid =
  (*let _ = print_string("right coercion\n") in*)
  let f = mkBase resth2 rhs_p rhs_t rhs_fl [] pos in
  let _ = Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
  ^ "right_coercion: c2 = "
  ^ c2 ^ "\n") pos in
  if is_coercible ln2 then
    let ok, new_rhs = rewrite_coercion prog estate ln2 f coer lhs_b rhs_b false pos in
	if ok then begin
	  let new_ctx = SuccCtx [(set_context_must_match ctx0)] in
	  let res, tmp_prf = heap_entail prog is_folding false new_ctx new_rhs pos in
	  let prf = mkCoercionRight ctx0 conseq coer.coercion_head
	    coer.coercion_body tmp_prf  coer.coercion_name
	  in
	  (res, [prf])
	end else (CF.mkFailCtx_in(Basic_Reason ( {fc_message ="failed right coercion application";
	fc_current_lhs = estate;
    fc_prior_steps = estate.es_prior_steps;
	fc_orig_conseq = estate.es_orig_conseq;
	fc_failure_pts = match pid with | Some s-> [s] | _ -> [];})), [])
  else (CF.mkFailCtx_in(Basic_Reason ({fc_message ="failed right coercion application";
  fc_current_lhs = estate;
  fc_prior_steps = estate.es_prior_steps;
  fc_orig_conseq = estate.es_orig_conseq;
  fc_failure_pts = match pid with | Some s-> [s] | _ -> [];})), []) 
    
(*************************************************************************************************************************
															                                                              05.06.2008:
															                                                              Utilities for existential quantifier elimination:
															                                                              - before we were only searching for substitutions of the form v1 = v2 and then substitute ex v1. P(v1) --> P(v2)
															                                                              - now, we want to be more aggressive and search for substitutions of the form v1 = exp2; however, we can only apply these substitutions to the pure part
															                                                              (due to the way shape predicates are recorded --> root pointer and args are suppose to be spec vars)
															                                                              - also check that v1 is not contained in FV(exp2)
*************************************************************************************************************************)

(* apply elim_exist_exp_loop until no change *)
and elim_exists_exp (f0 : formula) : (formula) =
  let f, flag = elim_exists_exp_loop f0 in
  if flag then (elim_exists_exp f)
  else begin
    (*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_formula f ^ "\n") in
	  let qvar, base = CF.split_quantifiers f in
	  let h, p, t = CF.split_components base in
	  let simpl_p = elim_exists_pure qvar p no_pos in
	  let simpl_f = CF.mkExists qvar h simpl_p t no_pos in
	  let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_formula simpl_f ^ "\n") in
	  simpl_f *) f
  end

(* removing existentail using ex x. (x=e & P(x)) <=> P(e) *)
and elim_exists_exp_loop (f0 : formula) : (formula * bool) = match f0 with
  | Or ({formula_or_f1 = f1;
	formula_or_f2 = f2;
	formula_or_pos = pos}) ->
      let ef1, flag1 = elim_exists_exp_loop f1 in
      let ef2, flag2 = elim_exists_exp_loop f2 in
	  (mkOr ef1 ef2 pos, flag1 & flag2)
  | Base _ -> (f0, false)
  | Exists ({ formula_exists_qvars = qvar :: rest_qvars;
              formula_exists_heap = h;
              formula_exists_pure = p;
              formula_exists_type = t;
              formula_exists_branches = b;
              formula_exists_flow = fl;
              formula_exists_pos = pos}) ->
      let fvh = h_fv h in
	  (*let _ = print_string("Try to eliminate " ^ Cprinter.string_of_spec_var qvar ^ "\n") in*)
	  if  not(List.exists (fun sv -> CP.eq_spec_var sv qvar) fvh) then
	    (*List.mem qvar fvh)	then*) (* if it does not appear in the heap part --> we try to eliminate *)
	    (*let _ = print_string("fv(h) = " ^ Cprinter.string_of_spec_var_list fvh ^ "\n") in*)
	    let st, pp1 = MCP.get_subst_equation_memo_formula p qvar false in
	    if List.length st > 0 then (* if there exists one substitution  - actually we only take the first one -> therefore, the list should only have one elem *)
	      (* basically we only apply one substitution *)
	      let one_subst = List.hd st in
		  (*let _ = print_string ("\nLength = " ^ string_of_int (List.length st) ^ "\n") in
		    let _ =  print_string("\n Using the subst var: " ^ Cprinter.string_of_spec_var (fst one_subst) ^ "\texp: " ^ Cprinter.string_of_formula_exp (snd one_subst) ^ "\n") in*)
	      let tmp = mkBase h pp1 t fl b pos in
		  (*let _ = (print_string (" Base formula: " ^ (Cprinter.string_of_formula tmp) ^ "\n")) in*)
	      let new_baref = subst_exp [one_subst] tmp in
 		  (*let _ = (print_string (" new_baref: " ^ (Cprinter.string_of_formula new_baref) ^ "\n")) in*)
	      let tmp2 = add_quantifiers rest_qvars new_baref in
	      let tmp3, _ = elim_exists_exp_loop tmp2 in
		  (tmp3, true)
	    else (* if qvar is not equated to any variables, try the next one *)
	      let tmp1 = mkExists rest_qvars h p t fl b pos in
	      let tmp2, flag = elim_exists_exp_loop tmp1 in
	      let tmp3 = add_quantifiers [qvar] tmp2 in
		  (tmp3, flag)
	  else (* anyway it's going to stay in the heap part so we can't eliminate --> try eliminate the rest of them, and then add it back to the exist quantified vars *)
	    let tmp1 = mkExists rest_qvars h p t fl b pos in
	    let tmp2, flag = elim_exists_exp_loop tmp1 in
	    let tmp3 = add_quantifiers [qvar] tmp2 in
	    ((push_exists [qvar] tmp3), flag)

  | Exists _ -> failwith ("Solver.elim_exists: Exists with an empty list of quantified variables")


(******************************************************************************************************************
														                                                           10.06.2008
														                                                           Utilities for simplifications:
														                                                           - whenever the pure part contains some arithmetic formula that can be further simplified --> call the theorem prover to perform the simplification
														                                                           Ex. x = 1 + 0 --> simplify to x = 1
******************************************************************************************************************)

and simpl_pure_formula (f : CP.formula) : CP.formula = match f with
  | CP.And (f1, f2, pos) -> CP.mkAnd (simpl_pure_formula f1) (simpl_pure_formula f2) pos
  | CP.Or (f1, f2, lbl, pos) -> CP.mkOr (simpl_pure_formula f1) (simpl_pure_formula f2) lbl pos
  | CP.Not (f1, lbl, pos) -> CP.mkNot (simpl_pure_formula f1) lbl pos
  | CP.Forall (sv, f1, lbl, pos) -> CP.mkForall [sv] (simpl_pure_formula f1) lbl pos
  | CP.Exists (sv, f1, lbl, pos) -> CP.mkExists [sv] (simpl_pure_formula f1) lbl pos
  | CP.BForm (f1,lbl) ->
      let simpl_f = CP.BForm(simpl_b_formula f1, lbl) in
	  (*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_pure_formula f ^ "\n") in
	    let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_pure_formula simpl_f ^ "\n") in*)
	  simpl_f

and simpl_b_formula (f : CP.b_formula): CP.b_formula =  match f with
  | CP.Lt (e1, e2, pos)
  | CP.Lte (e1, e2, pos)
  | CP.Gt (e1, e2, pos)
  | CP.Gte (e1, e2, pos)
  | CP.Eq (e1, e2, pos)
  | CP.Neq (e1, e2, pos)
  | CP.BagSub (e1, e2, pos) ->
      if ((count_iconst e1) > 1) or ((count_iconst e2) > 1) then
	    (*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_b_formula f ^ "\n") in*)
	    let simpl_f = TP.simplify (CP.BForm(f,None)) in
  	    begin
  	      match simpl_f with
  	        | CP.BForm(simpl_f1,_) ->
  		        (*let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_b_formula simpl_f1 ^ "\n") in*)
  		        simpl_f1
  	        | _ -> f
  	    end
      else f
  | CP.EqMax (e1, e2, e3, pos)
  | CP.EqMin (e1, e2, e3, pos) ->
      if ((count_iconst e1) > 1) or ((count_iconst e2) > 1) or ((count_iconst e3) > 1) then
	    (*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_b_formula f ^ "\n") in*)
	    let simpl_f = TP.simplify (CP.BForm(f,None)) in
  	    begin
  	      match simpl_f with
  	        | CP.BForm(simpl_f1,_) ->
  		        (*let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_b_formula simpl_f1 ^ "\n") in*)
  		        simpl_f1
  	        | _ -> f
  	    end
      else f
  | CP.BagIn (sv, e1, pos)
  | CP.BagNotIn (sv, e1, pos) ->
      if ((count_iconst e1) > 1) then
	    (*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_b_formula f ^ "\n") in*)
	    let simpl_f = TP.simplify (CP.BForm(f,None)) in
  	    begin
  	      match simpl_f with
  	        | CP.BForm(simpl_f1,_) ->
  		        (*let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_b_formula simpl_f1 ^ "\n") in*)
  		        simpl_f1
  	        | _ -> f
  	    end
      else f
  | CP.ListIn (e1, e2, pos)
  | CP.ListNotIn (e1, e2, pos)
  | CP.ListAllN (e1, e2, pos)
  | CP.ListPerm (e1, e2, pos) ->
		if ((count_iconst e1) > 1) or ((count_iconst e2) > 1) then
			(*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_b_formula f ^ "\n") in*)
			let simpl_f = TP.simplify (CP.BForm(f,None)) in
  		begin
  		match simpl_f with
  		| CP.BForm(simpl_f1,_) ->
  			(*let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_b_formula simpl_f1 ^ "\n") in*)
  			simpl_f1
  		| _ -> f
  		end
  	else f
 	| _ -> f

(*
  - count how many int constants are contained in one expression
  - if there are more than 1 --> means that we can simplify further (by performing the operation)
*)
and count_iconst (f : CP.exp) = match f with
  | CP.Subtract (e1, e2, _)
  | CP.Add (e1, e2, _) -> ((count_iconst e1) + (count_iconst e2))
  | CP.Mult (e1, e2, _)
  | CP.Div (e1, e2, _) -> ((count_iconst e1) + (count_iconst e2))
  | CP.IConst _ -> 1
  | _ -> 0

and combine_struc (f1:struc_formula)(f2:struc_formula) :struc_formula = 
  let sat_subno = ref 0 in
  let rec combine_ext_struc (f1:ext_formula)(f2:ext_formula):ext_formula = match f1 with
    | ECase b -> let r = match f2 with
	    | ECase d ->
	        let comb = (List.fold_left (fun a1 (c11,c12)-> a1@(List.map (fun (c21,c22)-> 
			  ((Cpure.mkAnd c11 c21 d.formula_case_pos),c12,c22)) b.formula_case_branches) ) [] d.formula_case_branches) in
	        let comb = List.fold_left (fun a (c1,c2,c3)-> 
			  let sat = Tpdispatcher.is_sat_sub_no c1 sat_subno in
			  if sat then a
			  else (c1,(combine_struc c2 c3))::a)[] comb in
	        ECase {b with 
		      formula_case_exists = b.formula_case_exists@d.formula_case_exists;
		      formula_case_branches = comb}
	    | EBase d ->
	        ECase {b with formula_case_branches =  (List.map (fun (c1,c2)-> (c1,(combine_struc [f2] c2))) b.formula_case_branches)}
	    | EAssume _ -> ECase ({b with formula_case_branches = List.map (fun (c1,c2)-> (c1,(combine_struc c2 [f2])))
			  b.formula_case_branches}) in r	
    | EBase b -> let r = match f2 with
	    | ECase d ->
	        ECase {d with 	 formula_case_branches =  (List.map (fun (c1,c2)-> (c1,(combine_struc [f1] c2))) d.formula_case_branches)}
	    | EBase d -> EBase 
	        {
	          formula_ext_explicit_inst = b.formula_ext_explicit_inst @ d.formula_ext_explicit_inst;
	          formula_ext_implicit_inst = b.formula_ext_implicit_inst @ d.formula_ext_implicit_inst;
	          formula_ext_exists = b.formula_ext_exists @ d.formula_ext_exists;
	          formula_ext_base = normalize_combine b.formula_ext_base d.formula_ext_base b.formula_ext_pos ;
	          formula_ext_continuation = combine_struc b.formula_ext_continuation d.formula_ext_continuation;
	          formula_ext_pos = b.formula_ext_pos
	        }
	    | EAssume _ -> EBase ({b with formula_ext_continuation = combine_struc b.formula_ext_continuation [f2]}) in r
    | EAssume (x1,b, (y1',y2') )-> let r = match f2 with
	    | ECase d -> combine_ext_struc f2 f1
	    | EBase d -> combine_ext_struc f2 f1 
	    | EAssume (x2,d,(y1,y2)) -> EAssume ((x1@x2),(normalize_combine b d (Cformula.pos_of_formula d)),(y1,(y2^y2'))) in r in
  List.fold_left (fun b c1->b@(List.map (fun c2->(combine_ext_struc c1 c2)) f2)) [] f1


and compose_struc_formula (delta : struc_formula) (phi : struc_formula) (x : CP.spec_var list) (pos : loc) =
  let rs = CP.fresh_spec_vars x in
  (*--- 09.05.2000 *)
  (*let _ = (print_string ("\n[cformula.ml, line 533]: fresh name = " ^ (string_of_spec_var_list rs) ^ "!!!!!!!!!!!\n")) in*)
  (*09.05.2000 ---*)
  let rho1 = List.combine (List.map CP.to_unprimed x) rs in
  let rho2 = List.combine (List.map CP.to_primed x) rs in
  let new_delta = subst_struc rho2 delta in
  let new_phi = subst_struc rho1 phi in
  let new_f = combine_struc new_delta new_phi in
  let resform = push_struc_exists rs new_f in
  resform	
    
and transform_null (eqs) :(CP.b_formula list) = List.map (fun c-> match c with
  | Cpure.BVar _ 
  | Cpure.Lt _
  | Cpure.Lte _ -> c
  | Cpure.Eq (e1,e2,l) -> 
	  if (Cpure.exp_is_object_var e1)&&(Cpure.is_num e2) then
		if (Cpure.is_zero e2) then Cpure.Eq (e1,(Cpure.Null l),l)
		else Cpure.Neq (e1,(Cpure.Null l),l)
	  else if (Cpure.exp_is_object_var e2)&&(Cpure.is_num e1) then
		if (Cpure.is_zero e1) then Cpure.Eq (e2,(Cpure.Null l),l)
		else Cpure.Neq (e2,(Cpure.Null l),l)
	  else c
  | Cpure.Neq (e1,e2,l)-> 
	  if (Cpure.exp_is_object_var e1)&&(Cpure.is_num e2) then
		if (Cpure.is_zero e2) then Cpure.Neq (e1,(Cpure.Null l),l)
		else c
	  else if (Cpure.exp_is_object_var e2)&&(Cpure.is_num e1) then
		if (Cpure.is_zero e1) then Cpure.Neq (e2,(Cpure.Null l),l)
		else c
	  else c
  | _ -> c
) eqs
	
(*returns true if exists one unsat branch*)(*
and check_unsat_struc prog (cf:struc_formula):bool = 
		let rec inner (f:formula) (cf:struc_formula):bool =
			let rec helper (f:formula) (cf:ext_formula):bool = match cf with
				| EAssume b -> 
					 let pf, pfb = xpure prog f in
					(not(Tpdispatcher.is_sat pf false)) || (List.exists (fun (_,c2) -> not(Tpdispatcher.is_sat (Cpure.And (pf,c2,no_pos)) false)) pfb)
				| EBase b -> inner (normalize f b.formula_ext_base no_pos) b.formula_ext_continuation 
				| ECase b -> List.exists (fun (c1,c2)-> inner (normalize (formula_of_pure c1 no_pos) f no_pos) c2 ) b.formula_case_branches in	
		if (List.length cf)==0 then
			let pf, pfb = xpure prog f in
					(not(Tpdispatcher.is_sat pf false)) || (List.exists (fun (_,c2) -> not(Tpdispatcher.is_sat (Cpure.And (pf,c2,no_pos)) false)) pfb)
		else List.exists (helper f) cf in
	(*inner (mkTrue no_pos) cf*) false*)

let heap_entail_one_context_new (prog : prog_decl) (is_folding : bool)
    (is_universal : bool)   (b1:bool)  (ctx : context) 
    (conseq : formula) pos (b2:control_path_id): (list_context * proof) =
      heap_entail_one_context prog is_folding is_universal ctx conseq pos
  
let heap_entail_struc_list_partial_context_init (prog : prog_decl) (is_folding : bool) (is_universal : bool) (has_post: bool)(cl : list_partial_context)
        (conseq:struc_formula) pos (pid:control_path_id) : (list_partial_context * proof) = 
  Debug.devel_pprint ("heap_entail_struc_list_partial_context_init:"
         ^ "\nctx:\n" ^ (Cprinter.string_of_list_partial_context cl)
          ^ "\nconseq:"^ (Cprinter.string_of_struc_formula conseq) ^"\n") pos; 
  Util.push_time "entail_prune";
  let cl = prune_ctx_list prog cl in
  let conseq = prune_pred_struc prog conseq in
  Util.pop_time "entail_prune";
  heap_entail_prefix_init prog is_folding is_universal has_post cl conseq pos pid (rename_labels_struc,Cprinter.string_of_struc_formula,heap_entail_one_context_struc)
  
let heap_entail_list_partial_context_init (prog : prog_decl) (is_folding : bool) (is_universal : bool) (cl : list_partial_context)
        (conseq:formula) pos (pid:control_path_id) : (list_partial_context * proof) = 
  Debug.devel_pprint ("heap_entail_list_partial_context_init:"
         ^ "\nctx:\n" ^ (Cprinter.string_of_list_partial_context cl)
          ^ "\nconseq:"^ (Cprinter.string_of_formula conseq) ^"\n") pos; 
  Util.push_time "entail_prune";  
  let cl_after_prune = prune_ctx_list prog cl in
  let conseq = prune_preds prog conseq in
  (*let _ = print_string ("Context before prune ctx: "^(Cprinter.string_of_list_partial_context cl)^"\n") in
  let _ = print_string ("Context after prune ctx: "^(Cprinter.string_of_list_partial_context cl_after_prune)^"\n") in*)
  Util.pop_time "entail_prune";
  heap_entail_prefix_init prog is_folding is_universal false cl_after_prune conseq pos pid (rename_labels_formula ,Cprinter.string_of_formula,heap_entail_one_context_new)  
  
  