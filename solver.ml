(*
26.11.2008
todo: disable the default logging for omega
*)

open Globals
open Cast
open Cformula
open Prooftracer

module CP = Cpure
module Err = Error
module TP = Tpdispatcher

let enable_distribution = ref true

type find_node_result =
  | Failed (* p2 (of p2::c2<V2> coming from the RHS) is not in FV(LHS) *)
  | NoMatch (* p2 \in FV(LHS), but no aliased node is found *)
  | Match of ((h_formula * match_type) list * h_formula) (* found p1::c1<V1> such that p1=p2 *)
	  (* first component: list of matching nodes. The flags tell if a match happens
		 at the root pointer or at a materialized argument, such as the
		 tail pointer of a list with tail pointer.
		 second component: the remaining of the heap after all the matching nodes are
		 taken away. *)

and match_type =
  | Root
  | MaterializedArg
  | Arg

let no_diff = ref false (* if true, then xpure_symbolic will drop the disequality generated by * *)

let no_check_outer_vars = ref false (*  *)

(*
   Find the type (class name) of a variable
   Result is (cbot, ctop, exact).

   When exact is true, t = ctop and cbot = "".
   When exact is false, cbot < t <: ctop
*)

(* satisfiability check *)
(* and is_satisfiable (f : constr) : bool = *)

(*
  compute_inv:
  if false then use view_x_formula for invariant
  if true then use view_invariant (user-supplied invariant) to compute view_x_formula
*)

(*
let rec geq_null = function
  | CP.And (a,b,x) -> CP.And (geq_null a, geq_null b, x)
  | CP.Or (a,b,x) -> CP.Or (geq_null a, geq_null b, x)
  | CP.Not (a,x) -> CP.Not (geq_null a, x)
  | CP.Forall (z,a,x) -> CP.Forall (z, geq_null a, x)
  | CP.Exists (z,a,x) -> CP.Exists (z, geq_null a, x)
  | CP.BForm b -> begin match b with
    | CP.Neq (a, CP.Null nl, l) -> CP.BForm (CP.Gt (a, CP.Null nl, l))
(*    | CP.Neq (a, CP.Null nl, l) -> CP.BForm (CP.Neq (a, CP.Null nl, l))*)
    | x -> CP.BForm x
  end
;;
*)

let rec xpure (prog : prog_decl) (f0 : formula) : CP.formula = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let pf1 = xpure prog f1 in
	  let pf2 = xpure prog f2 in
	  let res_form = CP.mkOr pf1 pf2 pos in
		res_form
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
		   formula_base_pos = pos}) ->
	  let ph = pointers_nonnegative prog h in
	  let res_form = CP.mkAnd ph p pos in
		res_form
  | Exists ({formula_exists_qvars = qvars;
			 formula_exists_heap = qh;
			 formula_exists_pure = qp;
			 formula_exists_pos = pos}) ->
	  let pqh = pointers_nonnegative prog qh in
	  let sqvars = (* List.map CP.to_int_var *) qvars in
	  let tmp1 = CP.mkAnd pqh qp pos in
	  let res_form = List.fold_left
		(fun f -> fun qv -> CP.Exists (qv, f, pos)) tmp1 sqvars
	  in
		res_form

and pointers_nonnegative prog h =
  let pf = xpure_heap prog h 1 in
  let rec aux_exp = function
    | CP.Var (v, _) -> [v]
    | CP.Add (l, r, _)
    | CP.Subtract (l, r, _)
    | CP.Max (l, r, _)
    | CP.Min (l, r, _) -> (aux_exp l) @ (aux_exp r)
    | CP.Mult (_, r, _) -> (aux_exp r)
    | _ -> []
  in
  let rec aux = function
    | CP.Not (f, _) -> aux f
    | CP.Forall (v, f, _)
    | CP.Exists (v, f, _) -> List.filter (fun e -> e <> v) (aux f)
    | CP.And (f, g, _) -> (aux f) @ (aux g)
    | CP.Or (f, g, _) -> (aux f) @ (aux g)
    | CP.BForm bf -> match bf with
      | CP.BVar (v, _) -> [v]
      | CP.Gt (l, r, _)
      | CP.Gte (l, r, _)
      | CP.Lte (l, r, _)
      | CP.Eq (l, r, _)
      | CP.Neq (l, r, _)
      | CP.Lt (l, r, _) -> (aux_exp l) @ (aux_exp r)
      | CP.EqMax (l, r, t, _)
      | CP.EqMin (l, r, t, _) -> (aux_exp l) @ (aux_exp r) @ (aux_exp t)
      | _ -> []
  in
(*  let fvariables = Util.remove_dups (aux pf) in
  let pointers = List.filter (fun x -> match x with CP.SpecVar(CP.OType _, _, _) -> true | _ -> false) fvariables in
  let inequalties = List.map (fun x -> CP.BForm (CP.Gte (CP.Var (x, no_pos), CP.IConst (0, no_pos), no_pos))) pointers in
  let formula = List.fold_left (fun f ineq -> CP.And (f, ineq, no_pos)) pf inequalties in*)
  let formula = pf in
(*  print_endline (String.concat "," (List.map string_of_spec_var (pointers))); flush stdout;*)
  formula

and xpure_heap (prog : prog_decl) (h0 : h_formula) (use_xpure0 :int) : CP.formula = match h0 with
  | DataNode ({h_formula_data_node = p;
			   h_formula_data_pos = pos}) ->
	  let i = fresh_int2 () in
	  let non_null = CP.mkEqVarInt p i pos in
		non_null
  | ViewNode ({h_formula_view_node = p;
			   h_formula_view_name = c;
			   h_formula_view_arguments = vs;
			   h_formula_view_pos = pos}) ->
	  let vdef = look_up_view_def pos prog.prog_view_decls c in
	  let rec helper addrs =
		match addrs with
		  | a :: rest ->
			  let i = fresh_int () in
			  let non_null = CP.mkEqVarInt a i pos in
			  let rest_f = helper rest in
			  let res_form = CP.mkAnd non_null rest_f pos in
				res_form
		  | [] -> CP.mkTrue pos in
	  (*let vaddrs = CP.fresh_spec_vars vdef.view_addr_vars in*)
	  (*--- 09.05.2008 *)
		(*let _ = (print_string ("\n[solver.ml, line 152]: fresh name = " ^ (Cprinter.string_of_spec_var_list vaddrs) ^ "!!!!!!!!!!!\n")) in*)
		(*09.05.2008 ---*)
	  (*let non_null = helper vaddrs in*)
	  let vinv = 
        match use_xpure0 with
        | -1 -> CP.mkTrue no_pos
        | 0 -> vdef.view_user_inv
        | _ -> vdef.view_x_formula
      in
	  let from_svs = CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed) :: vdef.view_vars in
	  let to_svs = p :: vs in
	  let tmp1 = CP.subst_avoid_capture from_svs to_svs vinv in
	  (*let tmp2 = CP.mkAnd non_null tmp1 pos in*)
	  (* let tmp3 = CP.mkExists vaddrs tmp2 pos in *)
		(* tmp3 *)
		tmp1
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) ->
	  let ph1 = xpure_heap prog h1 use_xpure0 in
	  let ph2 = xpure_heap prog h2 use_xpure0 in
	  let res_form = CP.mkAnd ph1 ph2 pos in
		res_form
  | HTrue -> CP.mkTrue no_pos
  | HFalse -> CP.mkFalse no_pos

and xpure_symbolic (prog : prog_decl) (f0 : formula) : (CP.formula * CP.spec_var list) = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let ipf1, avars1 = xpure_symbolic prog f1 in
	  let ipf2, avars2 = xpure_symbolic prog f2 in
	  let res_f = CP.mkOr ipf1 ipf2 pos in
		(res_f, avars1 @ avars2)
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
		   formula_base_pos = pos}) ->
	  let ph, addrs = xpure_heap_symbolic prog h in
	  let res_form = CP.mkAnd ph p pos in
		(res_form, addrs)
  | Exists ({formula_exists_qvars = qvars;
			 formula_exists_heap = qh;
			 formula_exists_pure = qp;
			 formula_exists_pos = pos}) ->
	  let pqh, addrs = xpure_heap_symbolic prog qh in
	  let sqvars = (* List.map CP.to_int_var *) qvars in
	  let tmp1 = CP.mkAnd pqh qp pos in
	  let res_form = List.fold_left (fun f -> fun qv -> CP.Exists (qv, f, pos)) tmp1 sqvars in
		(res_form, addrs)

and xpure_heap_symbolic (prog : prog_decl) (h0 : h_formula) : (CP.formula * CP.spec_var list) = match h0 with
  | DataNode ({h_formula_data_node = p;
			   h_formula_data_pos = pos}) ->
	  let i = fresh_name () in
	  (*--- 09.05.2008 *)
	  (*let _ = (print_string ("\n[solver.ml, line 199]: fresh name = " ^ i ^ "!!!!!!!!!!!\n")) in*)
		(*09.05.2008 ---*)
	  let vi = CP.SpecVar (CP.type_of_spec_var p, i, Unprimed) in
	  let non_zero = CP.BForm (CP.Neq (CP.Var (vi, pos), CP.Null pos, pos)) in
(*
	  let vi = CP.SpecVar (int_type, i, Unprimed) in
	  let non_zero = CP.BForm (CP.Gt (CP.Var (vi, pos), CP.IConst (0, pos), pos)) in
*)
	  let tmp1 = CP.mkEqVar p vi pos in
	  let tmp2 = CP.mkAnd tmp1 non_zero pos in
		(tmp2, [vi])
  | ViewNode ({h_formula_view_node = p;
			   h_formula_view_name = c;
			   h_formula_view_arguments = vs;
			   h_formula_view_pos = pos}) ->
	  let vdef = look_up_view_def pos prog.prog_view_decls c in
	  let vinv = vdef.view_x_formula in (* views have been ordered such that this dependency is respected *)
	  let from_svs = CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed) :: vdef.view_vars in
	  let to_svs = p :: vs in
	  let tmp1 = CP.subst_avoid_capture from_svs to_svs vinv in
	  let from_addrs = vdef.view_addr_vars in
	  let to_addrs = CP.fresh_spec_vars from_addrs in
	  (*--- 09.05.2008 *)
		(*let _ = (print_string ("\n[solver.ml, line 225]: fresh name = " ^ (Cprinter.string_of_spec_var_list to_addrs) ^ "!!!!!!!!!!!\n")) in*)
		(*09.05.2008 ---*)
	  let tmp2 = CP.subst (List.combine from_addrs to_addrs) tmp1 in (* no capture can happen *)
		(tmp2, to_addrs)
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) ->
	  let ph1, addrs1 = xpure_heap_symbolic prog h1 in
	  let ph2, addrs2 = xpure_heap_symbolic prog h2 in
	  let all_diff =
		if !no_diff then P.mkTrue no_pos
		else pairwise_diff addrs1 addrs2 pos in
	  let tmp1 = CP.mkAnd ph1 ph2 pos in
	  let res_form = CP.mkAnd tmp1 all_diff pos in
		(res_form, addrs1 @ addrs2)
  | HTrue -> (P.mkTrue no_pos, [])
  | HFalse -> (P.mkFalse no_pos, [])

and xpure_symbolic_no_exists (prog : prog_decl) (f0 : formula) : (CP.formula * CP.spec_var list) = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let ipf1, avars1 = xpure_symbolic_no_exists prog f1 in
	  let ipf2, avars2 = xpure_symbolic_no_exists prog f2 in
	  let res_f = CP.mkOr ipf1 ipf2 pos in
		(res_f, avars1 @ avars2)
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
		   formula_base_pos = pos}) ->
	  let ph, addrs = xpure_heap_symbolic_no_exists prog h in
	  let res_form = CP.mkAnd ph p pos in
		(res_form, addrs)
  | Exists ({formula_exists_qvars = qvars;
			 formula_exists_heap = qh;
			 formula_exists_pure = qp;
			 formula_exists_pos = pos}) ->
	  let pqh, addrs' = xpure_heap_symbolic_no_exists prog qh in
	  let sqvars = (* List.map CP.to_int_var *) qvars in
	  let tmp1 = CP.mkAnd pqh qp pos in
	  let addrs = CP.difference addrs' sqvars in
	  let res_form = List.fold_left (fun f -> fun qv -> CP.Exists (qv, f, pos)) tmp1 sqvars in
		(res_form, addrs)

and xpure_heap_symbolic_no_exists (prog : prog_decl) (h0 : h_formula) : (CP.formula * CP.spec_var list) = match h0 with
  | DataNode ({h_formula_data_node = p;
			   h_formula_data_pos = pos}) ->
(*
	  let non_zero = CP.BForm (CP.Gt (CP.Var (p, pos), CP.IConst (0, pos), pos)) in
*)
	  let non_zero = CP.BForm (CP.Neq (CP.Var (p, pos), CP.Null pos, pos)) in
		(non_zero, [p])
  | ViewNode ({h_formula_view_node = p;
			   h_formula_view_name = c;
			   h_formula_view_arguments = vs;
			   h_formula_view_pos = pos}) ->
	  let vdef = look_up_view_def pos prog.prog_view_decls c in
	  let vinv = vdef.view_x_formula in (* views have been ordered such that this dependency is respected *)
	  let from_svs = CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed) :: vdef.view_vars in
	  let to_svs = p :: vs in
	  let tmp1 = CP.subst_avoid_capture from_svs to_svs vinv in
	  let from_addrs = vdef.view_addr_vars in
	  let to_addrs = CP.fresh_spec_vars from_addrs in
	  (*--- 09.05.2008 *)
		(*let _ = (print_string ("\n[solver.ml, line 288]: fresh name = " ^ (Cprinter.string_of_spec_var_list to_addrs) ^ "!!!!!!!!!!!\n")) in*)
		(*09.05.2008 ---*)
	  let tmp2 = CP.subst (List.combine from_addrs to_addrs) tmp1 in (* no capture can happen *)
		(tmp2, to_addrs)
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) ->
	  let ph1, addrs1 = xpure_heap_symbolic_no_exists prog h1 in
	  let ph2, addrs2 = xpure_heap_symbolic_no_exists prog h2 in
	  let all_diff =
		if !no_diff then P.mkTrue no_pos
		else pairwise_diff addrs1 addrs2 pos in
	  let tmp1 = CP.mkAnd ph1 ph2 pos in
	  let res_form = CP.mkAnd tmp1 all_diff pos in
		(res_form, addrs1 @ addrs2)
  | HTrue -> (P.mkTrue no_pos, [])
  | HFalse -> (P.mkFalse no_pos, [])


(* xpure of consumed precondition *)
and xpure_consumed_pre (prog : prog_decl) (f0 : formula) : CP.formula = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let ipf1 = xpure_consumed_pre prog f1 in
	  let ipf2 = xpure_consumed_pre prog f2 in
	  let res_f = CP.mkOr ipf1 ipf2 pos in
		res_f
  | Base ({formula_base_heap = h;
		   formula_base_pos = pos}) ->
	  let ph = xpure_consumed_pre_heap prog h in
		ph
  | Exists ({formula_exists_qvars = qvars;
			 formula_exists_heap = qh;
			 formula_exists_pure = qp;
			 formula_exists_pos = pos}) ->
	  let pqh = xpure_consumed_pre_heap prog qh in
	  let res_form = CP.mkExists qvars pqh pos in
		res_form

and xpure_consumed_pre_heap (prog : prog_decl) (h0 : h_formula) : CP.formula = match h0 with
  | DataNode ({h_formula_data_node = p;
			   h_formula_data_pos = pos}) -> CP.mkTrue pos
  | ViewNode ({h_formula_view_node = p;
			   h_formula_view_name = c;
			   h_formula_view_arguments = vs;
			   h_formula_view_pos = pos}) ->
	  let vdef = look_up_view_def pos prog.prog_view_decls c in
	  let vinv = vdef.view_user_inv in (* views have been ordered such that this dependency is respected *)
	  let from_svs = CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed) :: vdef.view_vars in
	  let to_svs = p :: vs in
	  let tmp1 = CP.subst_avoid_capture from_svs to_svs vinv in
		tmp1
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) ->
	  let ph1 = xpure_consumed_pre_heap prog h1 in
	  let ph2 = xpure_consumed_pre_heap prog h2 in
	  let tmp1 = CP.mkAnd ph1 ph2 pos in
		tmp1
  | HTrue -> P.mkTrue no_pos
  | HFalse -> P.mkFalse no_pos

(*
and xpure_combine (f1 : CP.formula) (f2 : CP.formula) pos =
  let new_f1 = CP.rename_top_level_bound_vars f1 in
  let new_f2 = CP.rename_top_level_bound_vars f2 in
  let qvars1, bare_1 = CP.split_ex_quantifiers new_f1 in
  let qvars2, bare_2 = CP.split_ex_quantifiers new_f2 in
  let all_diff = pairwise_diff qvars1 qvars2 pos in
  let tmp1 = CP.mkAnd bare_1 bare_2 pos in
  let tmp2 = CP.mkAnd tmp1 all_diff pos in
  let res_f = CP.mkExists (qvars1 @ qvars2) tmp2 pos in
	res_f
*)

and pairwise_diff svars10 svars20 pos =
  let rec diff_one sv svars = match svars with
	| sv2 :: rest ->
		let tmp1 = diff_one sv rest in
		let tmp2 = CP.mkNeqVar sv sv2 pos in
		let res = CP.mkAnd tmp1 tmp2 pos in
		  res
	| [] -> CP.mkTrue pos
  in
	if U.empty svars20 then
	  CP.mkTrue pos
	else
	  match svars10 with
		| sv :: rest ->
			let tmp1 = pairwise_diff rest svars20 pos in
			let tmp2 = diff_one sv svars20 in
			let res = CP.mkAnd tmp1 tmp2 pos in
			  res
		| [] -> CP.mkTrue pos


(* split conseq to a node to be checked at the next step and *)
(* a the remaining part to be checked recursively            *)
and split_linear_node (h : h_formula) : (h_formula * h_formula) = match h with
  | HTrue -> (HTrue, HTrue)
  | HFalse -> (HFalse, HFalse)
  | DataNode _ | ViewNode _ -> (h, HTrue)
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) -> begin
	  match h1 with
		| HTrue -> print_string ("\n\n!!!This shouldn't happen!!!\n\n"); split_linear_node h2 (* this shouldn't happen anyway *)
		| _ ->
			let ln1, r1 = split_linear_node h1 in
			  (ln1, mkStarH r1 h2 pos)
	end

(* find a node from the left hand side *)
and find_node prog lhs_h lhs_p (ps : CP.spec_var list) pos : find_node_result =
  let rec merge_results rs1 rs2 = match rs1 with
	| Failed -> rs2
	| NoMatch -> begin
		match rs2 with
		  | Failed -> rs1
		  | _ -> rs2
	  end
	| Match l1 -> begin
		match rs2 with
		  | Failed -> rs1
		  | NoMatch -> rs1
		  | Match l2 -> rs1 (*TODO: fix it Match (l1 @ l2) *)
	  end in
  let tmp1 = List.map (fun p -> find_node_one prog lhs_h lhs_p p pos) ps in
  let tmp2 = List.fold_left merge_results Failed tmp1 in
	tmp2

and find_node_one prog lhs_h lhs_p (p : CP.spec_var) pos : find_node_result =
  let lhs_fv = (h_fv lhs_h) @ (CP.fv lhs_p) in
	if CP.mem p lhs_fv then
	  let eqns' = ptr_equations lhs_p in
	  let eqns = (p, p) :: eqns' in
	  let asets = alias eqns in
	  let paset = get_aset asets p in (* find the alias set containing p *)
		if U.empty paset then begin (* can this case happen *)
		  failwith ("Error in getting aliases for "
					^ (Cprinter.string_of_spec_var p))
		end else
		  let anodes, resth1 = get_aliased_node prog lhs_h paset in
			if U.empty anodes || CP.mem CP.null_var paset then
			  NoMatch (* can't find an aliased node, but p is mentioned in LHS *)
			else
			  Match (anodes, resth1)
	else begin
(*
	  Debug.devel_pprint ("find_node: no aliased node for "
						  ^ (Cprinter.string_of_spec_var p)
						  ^ " is found in lhs\n\n") pos;
	  Failed (* if p doesn't appear in LHS, entailment surely fails *)
*)
	  Debug.devel_pprint ("find_node: " ^ (Cprinter.string_of_spec_var p) ^ " is not mentioned in lhs\n\n") pos;
	  NoMatch
	end

and h_mvars prog (h : h_formula) : CP.spec_var list = match h with
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) -> Util.remove_dups (h_fv h1 @ h_fv h2)
  | DataNode ({h_formula_data_node = v}) -> [v]
  | ViewNode ({h_formula_view_node = v;
			   h_formula_view_arguments = vargs;
			   h_formula_view_name = c}) -> begin
	  let vdef = look_up_view_def_raw prog.prog_view_decls c in
	  let mvs = CP.subst_var_list_avoid_capture vdef.view_vars vargs vdef.view_materialized_vars in
	  let mvars = if CP.mem v mvs then mvs else v :: mvs in
		mvars
	end
  | HTrue | HFalse -> []


(* assume that f is a satisfiable conjunct *)
and ptr_equations (f : CP.formula) : (CP.spec_var * CP.spec_var) list = match f with
  | CP.And (f1, f2, pos) -> (ptr_equations f1) @ (ptr_equations f2)
  | CP.BForm bf -> begin
	  match bf with
		| CP.Eq (e1, e2, _) ->
			if CP.can_be_aliased e1 && CP.can_be_aliased e2 then
			  let sv1 = CP.get_alias e1 in
			  let sv2 = CP.get_alias e2 in
				[(sv1, sv2)]
				  (* (CP.Var (sv1, _), CP.Var (sv2, _), _) -> [(sv1, sv2)]
					 will put this back when modifying the simplification of pure formula to
					 preserve types of variables
					 if CP.is_object_var sv1 then [(sv1, sv2)]
					 else []
				  *)
			else []
		| _ -> []
	end
  | _ -> []

(* computes must-alias sets from equalities, maintains the invariant *)
(* that these sets form a partition. *)
and alias (ptr_eqs : (CP.spec_var * CP.spec_var) list) : CP.spec_var list list = match ptr_eqs with
  | (v1, v2) :: rest -> begin
	  let rest_sets = alias rest in
	  let search (v : CP.spec_var) (asets : CP.spec_var list list) =
		List.partition (fun aset -> CP.mem v aset) asets in
	  let av1, rest1 = search v1 rest_sets in
	  let av2, rest2 = search v2 rest1 in
	  let v1v2_set = U.remove_dups (List.concat ([v1; v2] :: (av1 @ av2))) in
		v1v2_set :: rest2
	end
  | [] -> []

and get_aset (aset : CP.spec_var list list) (v : CP.spec_var) : CP.spec_var list =
  let tmp = List.filter (fun a -> CP.mem v a) aset in
	match tmp with
	  | [] -> []
	  | [s] -> s
	  | _ -> failwith ((Cprinter.string_of_spec_var v) ^ " appears in more than one alias sets")

(* return a list of nodes from heap f that appears in *)
(* alias set aset. The flag associated with each node *)
(* lets us know if the match is at the root pointer,  *)
(* or at materialized args,...                        *)
and get_aliased_node prog (f0 : h_formula) (aset : CP.spec_var list) : ((h_formula * match_type) list * h_formula) =
  let rec alias_helper f = match f with
	| HTrue | HFalse -> ([], f)
	| DataNode ({h_formula_data_node = p1}) ->
		if CP.mem p1 aset then ([(f, Root)], HTrue)
		else ([], f)
	| ViewNode ({h_formula_view_node = p1;
				 h_formula_view_arguments = vs1;
				 h_formula_view_name = c}) ->
		if CP.mem p1 aset then
		  ([(f, Root)], HTrue)
		else
		  let vdef = look_up_view_def_raw prog.prog_view_decls c in
		  let mvs = CP.subst_var_list_avoid_capture vdef.view_vars vs1
			vdef.view_materialized_vars
		  in
			if List.exists (fun v -> CP.mem v aset) mvs then
			  ([(f, MaterializedArg)], HTrue)
			else if List.exists (fun v -> CP.mem v aset) vs1 then
			  ([(f, Arg)], HTrue)
			else
			  ([], f)
	| Star ({h_formula_star_h1 = f1;
			 h_formula_star_h2 = f2;
			 h_formula_star_pos = pos}) ->
		let n1, r1 = alias_helper f1 in
		let n2, r2 = alias_helper f2 in
		  (n1 @ n2, mkStarH r1 r2 pos)
  in
	alias_helper f0


(* expand all predicates in a definition *)

and expand_all_preds prog f0 : formula = match f0 with
  | Or (({formula_or_f1 = f1;
		  formula_or_f2 = f2}) as or_f) -> begin
	  let ef1 = expand_all_preds prog f1 in
	  let ef2 = expand_all_preds prog f2 in
		Or ({or_f with formula_or_f1 = ef1; formula_or_f2 = ef2})
	end
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
		   formula_base_pos =pos}) -> begin
	  let proots = find_pred_roots_heap h in
	  let ef0 = List.fold_left (fun f -> fun v -> unfold prog f v pos) f0 proots in
		ef0
	end
  | Exists ({formula_exists_qvars = qvars;
			 formula_exists_heap = qh;
			 formula_exists_pure = qp;
			 formula_exists_pos = pos}) -> begin
	  let proots = find_pred_roots_heap qh in
	  let f = Base ({formula_base_heap = qh;
					 formula_base_pure = qp;
					 formula_base_type = TypeTrue;
					 formula_base_pos = pos}) in
	  let ef = List.fold_left (fun f -> fun v -> unfold prog f v pos) f proots in
	  let ef0 = push_exists qvars ef in
		ef0
	end

and find_pred_roots f0 = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2}) -> begin
	  let pr1 = find_pred_roots f1 in
	  let pr2 = find_pred_roots f2 in
	  let tmp = CP.remove_dups (pr1 @ pr2) in
		tmp
	end
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
		   formula_base_pos =pos}) -> find_pred_roots_heap h
  | Exists ({formula_exists_qvars = qvars;
			 formula_exists_heap = qh;
			 formula_exists_pure = qp;
			 formula_exists_pos = pos}) -> begin
	  let tmp1 = find_pred_roots_heap qh in
	  let tmp2 = CP.difference tmp1 qvars in
		tmp2
	end

and find_pred_roots_heap h0 = match h0 with
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) -> begin
	  let pr1 = find_pred_roots_heap h1 in
	  let pr2 = find_pred_roots_heap h2 in
	  let tmp = CP.remove_dups (pr1 @ pr2) in
		tmp
	end
  | ViewNode ({h_formula_view_node = p}) -> [p]
  | DataNode _ | HTrue | HFalse -> []

(* unfolding *)
and unfold_context prog (ctx : context) (v : CP.spec_var) (pos : loc) : context = match ctx with
  | OCtx (c1, c2) ->
	  let new_c1 = unfold_context prog c1 v pos in
	  let new_c2 = unfold_context prog c2 v pos in
		or_context new_c1 new_c2
  | Ctx es ->
	  let unfolded_f = unfold prog es.es_formula v pos in
	  let res = build_context ctx unfolded_f pos in
		res

and unfold prog (f : formula) (v : CP.spec_var) (pos : loc) : formula = match f with
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
		   formula_base_pos =pos}) -> unfold_baref prog h p v pos
  | Exists _ ->
	  let rf = rename_bound_vars f in
	  let qvars, baref = split_quantifiers rf in
	  let h, p, t = split_components baref in
	  let uf = unfold_baref prog h p v pos in
	  let resform = push_exists qvars uf in
		resform
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let uf1 = unfold prog f1 v pos in
	  let uf2 = unfold prog f2 v pos in
	  let resform = mkOr uf1 uf2 pos in
		resform

and unfold_baref prog (h : h_formula) (p : CP.formula) (v : CP.spec_var) pos : formula =
  let asets = alias (ptr_equations p) in
  let aset' = get_aset asets v in
  let aset = if CP.mem v aset' then aset' else v :: aset' in
  let unfolded_h = unfold_heap prog h aset v pos in
  let tmp_form = normalize unfolded_h (formula_of_pure p pos) pos in
  let res_form = elim_unsat prog tmp_form in
	(*
	  print_string ("\nunfolded_h:\n" ^ (Cprinter.string_of_formula unfolded_h) ^ "\n");
	  print_string ("\ntmp_form:\n" ^ (Cprinter.string_of_formula tmp_form) ^ "\n");
	  print_string ("\nres_form:\n" ^ (Cprinter.string_of_formula res_form) ^ "\n");
	*)
	res_form

and unfold_heap prog (f : h_formula) (aset : CP.spec_var list) (v : CP.spec_var) pos : formula = match f with
  | ViewNode ({h_formula_view_node = p;
			   h_formula_view_name = c;
			   h_formula_view_origins = origs;
			   h_formula_view_arguments = vs}) ->
	  if CP.mem p aset then
		let vdef = Cast.look_up_view_def pos prog.prog_view_decls c in
		let renamed_view_formula = rename_bound_vars vdef.view_formula in
		let fr_vars = (CP.SpecVar (CP.OType vdef.view_data_name, self, Unprimed))
		  :: vdef.view_vars in
		let to_vars = v :: vs in
		(* let tmp_form = normalize renamed_view_formula
		   (formula_of_pure vdef.Cast.view_x_formula pos) pos in
		   let res_form = subst_avoid_capture fr_vars to_vars tmp_form in *)
		let res_form = subst_avoid_capture fr_vars to_vars renamed_view_formula in
		let res_form = add_origins res_form origs in
		  res_form
	  else
		formula_of_heap f pos
  | Star ({h_formula_star_h1 = f1;
		   h_formula_star_h2 = f2}) ->
	  let uf1 = unfold_heap prog f1 aset v pos in
	  let uf2 = unfold_heap prog f2 aset v pos in
		normalize uf1 uf2 pos
  | _ -> formula_of_heap f pos

(*
  vvars: variables of interest
  evars: those involving this will be on the rhs
  otherwise move to the lhs
*)
and split_universal (f0 : CP.formula) (evars : CP.spec_var list) (vvars : CP.spec_var list) (pos : loc) : (CP.formula * CP.formula) =
  let rec split f = match f with
	| CP.And (f1, f2, _) ->
		let app1, cpp1 = split f1 in
		let app2, cpp2 = split f2 in
		  (CP.mkAnd app1 app2 pos, CP.mkAnd cpp1 cpp2 pos)
	| _ ->
		let fvars = CP.fv f in
		  if CP.disjoint fvars vvars then
			(CP.mkTrue pos, CP.mkTrue pos) (* just ignore the formula in this case as
											  it is disjoint
											  from the set of variables of interest *)
		  else
		  (*
		  	- 23.05.2008 -
				Current actions are:
		    (i) discard E2(g) which has already been proven
		    (ii) move E1(f.g) to LHS for implicit instantiation
		   (iii) leave E3(e,f,g) to RHS for linking existential var e

		 What we added here: -->Step (iii) can be also improved by additionally moving (exists e : E3(e,f,g)) to the LHS.
		  *)
		  if not (CP.disjoint evars fvars) then (* to conseq *)
		  	(CP.mkTrue pos, f)
		  else (* to ante *)
				(f, CP.mkTrue pos)
	in
	(* -- added on 21.05.2008 *)
	(* try to obtain as much as a CNF form as possible so that the splitting of bindings between antecedent and consequent is more accurate *)
	let f = (normalize_to_CNF f0 pos) in
	(* added on 21.05.2008 -- *)
	(*
	let _ = (print_string ("\n[solver.ml, split_universal]: Pure formula: " ^ (Cprinter.string_of_pure_formula f0) ^ "\n")) in
  let _ = (print_string ("[solver.ml, split_universal]: Pure formula in simplified cnf: " ^ (Cprinter.string_of_pure_formula f) ^ "\n")) in
  *)
  let to_ante, to_conseq = split f in
  Debug.devel_pprint ("split_universal: evars: "
						^ (String.concat ", "
							 (List.map Cprinter.string_of_spec_var evars))) pos;
	Debug.devel_pprint ("split_universal: vvars: "
						^ (String.concat ", "
							 (List.map Cprinter.string_of_spec_var vvars))) pos;
	Debug.devel_pprint ("split_universal: to_ante: "
						^ (Cprinter.string_of_pure_formula to_ante)) pos;
	Debug.devel_pprint ("split_universal: to_conseq: "
						^ (Cprinter.string_of_pure_formula to_conseq)) pos;
	let fvars = CP.fv f in

	(* 27.05.2008 *)
	if !Globals.move_exist_to_LHS & (not(Util.empty (CP.difference fvars evars)) & not(Util.empty evars))	then
		(* there still are free vars whose bondings were not moved to the LHS --> existentially quantify the whole formula and move it to the LHS *)
		(* Ex.:  ex e. f1<e & e<=g or ex e. (f=1 & e=2 \/ f=2 & e=3) *)
		(*let _ = print_string("\n[solver.ml, split_universal]: No FV in  " ^ (Cprinter.string_of_pure_formula f) ^ "\n") in*)
		let new_f = discard_uninteresting_constraint f vvars in
			((CP.mkAnd to_ante (CP.mkExists evars new_f pos) pos), to_conseq)
	else (to_ante, to_conseq)


(**************************************************************)
(**************************************************************)
(**************************************************************)
(*
	We do a simplified translation towards CNF where we only take out the common
 	conjuncts from all the disjuncts:

	Ex:
 (a=1 & b=1) \/ (a=2 & b=2) - nothing common between the two disjuncts
 (a=1 & b=1 & c=3) \/ (a=2 & b=2 & c=3) ->  c=3 & ((a=1 & b=1) \/ (a=2 & b=2))
*)

and normalize_to_CNF (f : CP.formula) pos : CP.formula = match f with
	| CP.Or (f1, f2, p) ->
		let conj, disj1, disj2 = (find_common_conjs f1 f2 p) in
			(*
			let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: f1: " ^ (Cprinter.string_of_pure_formula f1) ^ "\n")) in
			let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: f2: " ^ (Cprinter.string_of_pure_formula f2) ^ "\n")) in
			let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: Conj: " ^ (Cprinter.string_of_pure_formula conj) ^ "\n")) in
			let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: disj1: " ^ (Cprinter.string_of_pure_formula disj1) ^ "\n")) in
			let _ = (print_string ("\n[cpure.ml, normalize_to_CNF]: disj2: " ^ (Cprinter.string_of_pure_formula disj2) ^ "\n")) in
			*)
			(CP.mkAnd conj (CP.mkOr disj1 disj2 p) p)
  | CP.And (f1, f2, p) -> CP.And(normalize_to_CNF f1 p, normalize_to_CNF f2 p, p)
	| CP.Not (f1, p) -> CP.Not(normalize_to_CNF f1 p, p)
	| CP.Forall (sp, f1, p) -> CP.Forall(sp, normalize_to_CNF f1 p, p)
	| CP.Exists (sp, f1, p) -> CP.Exists(sp, normalize_to_CNF f1 p, p)
  | _ -> f

(* take two formulas f1 and f2 and returns:
	- the formula containing the commom conjuncts
	- the formula representing what's left of f1
	- the formula representing what's left of f2
*)

and find_common_conjs (f1 : CP.formula) (f2 : CP.formula) pos : (CP.formula * CP.formula * CP.formula) = match f1 with
	| CP.BForm(b) ->
		if (List.exists (fun c -> (CP.eq_pure_formula c f1)) (CP.list_of_conjs f2)) then
			begin
				(f1, (CP.mkTrue pos), (remove_conj f2 f1 pos))
			end
		else
			(*
			let _ = (print_string ("\n[cpure.ml, find_common_conjs]: no common conj between: \n")) in
			let _ = (print_string ("\t\t " ^ (Cprinter.string_of_pure_formula f1) ^ "\n")) in
			let _ = (print_string ("\t\t " ^ (Cprinter.string_of_pure_formula f2) ^ "\n")) in
			let _ = (print_string ("\n[cpure.ml, find_common_conjs]: list of conj for f2: " ^ (Cprinter.string_of_pure_formula_list (CP.list_of_conjs f2)) ^ "\n")) in
			*)
			((CP.mkTrue pos), f1, f2)
	| CP.And(f11, f12, p) ->
		let outer_conj, new_f1, new_f2 = (find_common_conjs f11 f2 p) in
		let outer_conj_prim, new_f1_prim, new_f2_prim  = (find_common_conjs f12 new_f2 p) in
		((CP.mkAnd outer_conj outer_conj_prim p), (CP.mkAnd new_f1 new_f1_prim p), new_f2_prim)
	| CP.Or(f11, f12, p) ->
		let new_f11 = (normalize_to_CNF f11 p) in
		let new_f12 = (normalize_to_CNF f12 p) in
        (CP.mkTrue pos),(CP.mkOr new_f11 new_f12 p),f2
	| _ -> ((CP.mkTrue pos), f1, f2)

and remove_conj (f : CP.formula) (conj : CP.formula) pos : CP.formula = match f with
	| CP.BForm(b1) ->
		begin
			match conj with
			|CP.BForm(b2) ->
				if (CP.eq_b_formula b1 b2) then
					(CP.mkTrue pos)
				else f
			| _ -> f
		end
	| CP.And(f1, f2, p) ->
		(CP.mkAnd (remove_conj f1 conj p) (remove_conj f2 conj p) p)
	| CP.Not(f1, p) -> CP.Not((remove_conj f1 conj p), p)
	| _ -> f

(**************************************************************)
(**************************************************************)
(**************************************************************)

(* 21.05.2008 *)
(*
	Say we have three kinds of vars
  f - free, g - global (from the view definition), e - existential
	Assume, we have expression at the end of folding:
  E1(f,g) & E2(g) & E3(e,f,g)

	First action is to discard E2(g) which has already been proven

 (discard_uninteresting_constraint f vvars) only maintains those vars containing vvars, which are vars of interest
*)

and discard_uninteresting_constraint (f : CP.formula) (vvars: CP.spec_var list) : CP.formula = match f with
	| CP.BForm _ ->
		if CP.disjoint (CP.fv f) vvars then (CP.mkTrue no_pos)
		else f
  | CP.And(f1, f2, l) -> CP.And(discard_uninteresting_constraint f1 vvars, discard_uninteresting_constraint f2 vvars, l)
  | CP.Or(f1, f2, l) -> CP.Or(discard_uninteresting_constraint f1 vvars, discard_uninteresting_constraint f2 vvars, l)
  | CP.Not(f1, l) -> CP.Not(discard_uninteresting_constraint f1 vvars, l)
  | _ -> f


(**************************************************************)
(**************************************************************)
(**************************************************************)

(* fold some constraints in f1 to view v under pure pointer *)
(* constraint pp and Presburger constraint pres             *)
and fold prog (ctx : context) (view : h_formula) (pure : CP.formula) (pos : loc) = match view with
  | ViewNode ({h_formula_view_node = p;
			   h_formula_view_name = c;
			   h_formula_view_arguments = vs}) -> begin
	  try
		let vdef = look_up_view_def_raw prog.Cast.prog_view_decls c in
		let renamed_view_formula = rename_bound_vars vdef.Cast.view_formula in
		let fr_vars = (CP.SpecVar (CP.OType vdef.Cast.view_data_name, self, Unprimed))
		  :: vdef.view_vars in
		let to_vars = p :: vs in
		let view_form = subst_avoid_capture fr_vars to_vars renamed_view_formula in
		let view_form = add_origins view_form (get_view_origins view) in
		  Debug.devel_pprint ("fold: view_form:\n"
							  ^ (Cprinter.string_of_formula view_form)) pos;
		  let estate = estate_of_context ctx pos in
		  let new_es = {estate with es_evars = vs (*Util.remove_dups (vs @ estate.es_evars)*)} in
		  let new_ctx = Ctx new_es in
		  let rs0, fold_prf = heap_entail_one_context prog true false new_ctx view_form pos in
		  let tmp_vars = p :: (estate.es_evars @ vs) in
		  (**************************************)
		  (*        process_one 								*)
		  (**************************************)
		  let rec process_one rs1 =
			Debug.devel_pprint ("fold: rs1:\n"
								^ (Cprinter.string_of_context rs1)) pos;
			match rs1 with
			  | OCtx (c1, c2) ->
				  (*
					It is no longer safe to assume that rs will be conjunctive.
					The recursive folding entailment call (via case splitting
					for example) can turn ctx to a disjunctive one, hence making
					rs disjunctive.
				  *)
				  let tmp1 = process_one c1 in
				  let tmp2 = process_one c2 in
				  let tmp3 = OCtx (tmp1, tmp2) in
					tmp3
			  | Ctx es ->
				  (* let es = estate_of_context rs pos in *)
				  let w = CP.difference es.es_evars tmp_vars in
				  let tmp_pure = elim_exists_pure w es.es_pure pos in
				  let res_rs = Ctx {es with es_evars = estate.es_evars; es_pure = tmp_pure} in
					Debug.devel_pprint ("fold: context at beginning of fold: "
										^ (Cprinter.string_of_spec_var p) ^ "\n"
										^ (Cprinter.string_of_context ctx)) pos;
					Debug.devel_pprint ("fold: context at end of fold: "
										^ (Cprinter.string_of_spec_var p) ^ "\n"
										^ (Cprinter.string_of_context res_rs)) pos;
					Debug.devel_pprint ("fold: es.es_pure: "
										^ (Cprinter.string_of_pure_formula es.es_pure)) pos;
					res_rs in
		  let res = List.map process_one rs0 in
			(res, fold_prf)
	  with
		| Not_found -> ([], Failure)
	end
  | _ ->
	  Debug.devel_pprint ("fold: second parameter is not a view: "
						  ^ (Cprinter.string_of_h_formula view)) pos;
	  ([], Failure)

and process_fold_result prog is_folding estate fold_rs0 p2 vs2 base2 pos : (context list * proof list) =
  let pure2 = base2.formula_base_pure in
  let resth2 = base2.formula_base_heap in
  let type2 = base2.formula_base_type in
  let rec process_one fold_rs1 = match fold_rs1 with
	| OCtx (c1, c2) ->
		let tmp1, prf1 = process_one c1 in
		let tmp2, prf2 = process_one c2 in
		let tmp3 = or_context_list tmp1 tmp2 in
		let prf3 = Prooftracer.mkOrLeft fold_rs1 (Base base2) [prf1; prf2] in
		  (tmp3, prf3)
	| Ctx fold_es ->
		(*	let fold_es = estate_of_context fold_rs pos in *)
		(* remove the constraints involving only global variabls *)
		(* 20.05.2008 *)
		(*let _ = print_string ("[solver.ml, process_fold_result]: Context: " ^ Cprinter.string_of_context fold_rs1 ^ "\n") in
		let _ = (print_string ("\n[solver.ml, process_fold_result]: Pure formula: " ^ (Cprinter.string_of_pure_formula fold_es.es_pure) ^ "\n")) in
		let new_pure = discard_redundant_constraint fold_es.es_pure vs2 in
		let _ = (print_string ("[solver.ml, process_fold_result]: Global vars: " ^ (Cprinter.string_of_spec_var_list vs2) ^ "\n")) in
		let _ = (print_string ("[solver.ml, process_fold_result]: Pure formula after discarding globals: " ^ (Cprinter.string_of_pure_formula new_pure) ^ "\n")) in*)
		(* 20.05.2008 *)
		let to_ante, to_conseq = split_universal fold_es.es_pure
		  fold_es.es_evars vs2 pos in
		let tmp_conseq = mkBase resth2 pure2 type2 pos in
		let new_conseq = normalize tmp_conseq
		  (formula_of_pure to_conseq pos) pos in
		let new_ante = normalize fold_es.es_formula
		  (formula_of_pure to_ante pos) pos in
		let new_consumed = fold_es.es_heap in
		let new_es = {estate with es_heap = new_consumed;
						es_formula = new_ante} in
		let new_ctx = Ctx new_es in
		  Debug.devel_pprint ("process_fold_result: new_ctx after folding: "
							  ^ (Cprinter.string_of_spec_var p2) ^ "\n"
							  ^ (Cprinter.string_of_context new_ctx)) pos;
		  Debug.devel_pprint ("process_fold_result: vs2: "
							  ^ (String.concat ", "
								   (List.map Cprinter.string_of_spec_var vs2))) pos;
		  Debug.devel_pprint ("process_fold_result: to_ante: "
							  ^ (Cprinter.string_of_pure_formula to_ante)) pos;
		  Debug.devel_pprint ("process_fold_result: to_conseq: "
							  ^ (Cprinter.string_of_pure_formula to_conseq)) pos;
		  Debug.devel_pprint ("process_fold_result: new_conseq:\n"
							  ^ (Cprinter.string_of_formula new_conseq)) pos;
		  let rest_rs, prf = heap_entail_one_context prog is_folding false
			new_ctx new_conseq pos
		  in
			Debug.devel_pprint ("process_fold_result: context at end fold: "
								^ (Cprinter.string_of_spec_var p2) ^ "\n"
								^ (Cprinter.string_of_context_list rest_rs)) pos;
			(rest_rs, prf) in
  let tmp1 = List.map process_one fold_rs0 in
  let tmp2, tmp_prfs1 = List.split tmp1 in
  let res = List.concat tmp2 in
	(res, tmp_prfs1)

(*
(* part of formula involving max/min/neq, part not *)
and pick_up_pres pres = match pres with
  | Presburger.BConstr (Presburger.EqMax _) -> (pres, Presburger.mkTrue)
  | Presburger.BConstr (Presburger.EqMin _) -> (pres, Presburger.mkTrue)
  | Presburger.BConstr (Presburger.ANeq _) -> (pres, Presburger.mkTrue)
  | Presburger.PAnd (p1, p2) ->
	  let mp1, nmp1 = pick_up_pres p1 in
	  let mp2, nmp2 = pick_up_pres p2 in
		(Presburger.mkAnd mp1 mp2, Presburger.mkAnd nmp1 nmp2)
  | _ -> (Presburger.mkTrue, pres)

(*TODO: still not completed yet *)
and elim_exists_pres (w : spec_var list) (f : Presburger.pConstr) =
  let tmp1 = Presburger.force_to_exists w f in
  let tmp2 = TP.pairwisecheck tmp1 in
	tmp2
	  (*
		and elim_exists_pres (w : spec_var list) (f0 : Presburger.pConstr) =
		let drop_exists (f : Presburger.pConstr) : Presburger.pConstr =
		f
		in
		let f1, f2 = pick_up_pres f0 in
		let tmp1 = Presburger.force_to_exists w f2 in
		let tmp2 = TP.pairwisecheck tmp1 in
		let tmp3 = Presburger.mkAnd f1 tmp2 in
		let tmp4 = Presburger.force_to_exists w tmp3 in
		tmp4
	  (* some more processing of tmp4 is needed *)
	  *)

and elim_exists_pp (w : spec_var list) (f0 : ppConstr) pos =
  let rec drop_exists (f : ppConstr) : ppConstr = match f with
	| PPAnd (f1, f2, _) ->
		let df1 = drop_exists f1 in
		let df2 = drop_exists f2 in
		let tmp = mkAndPP df1 df2 pos in
		  tmp
	| OEq (sv1, sv2, _) ->
		if List.mem sv1 w || List.mem sv2 w then
		  report_error pos ("elim_exists: " ^ (string_of_ppconstr f) ^ " should have been eliminated")
		else
		  f
	| _ ->
		let fvars = ppfv f in
		  if Util.disjoint fvars w then
			f
		  else
			PPTrue in
  let tmp1 = Constr (Presburger.mkTrue, f0, HTrue, pos) in
  let tmp2 = mkExists w tmp1 pos in
  let tmp3 = elim_exists tmp2 in
	match tmp3 with
	  | Or _ -> report_error pos ("elim_exists_pp: Or is generated from Constr!!!")
	  | Constr _ ->
		  let _, tmp_pp, _ = split_components tmp3 in
			tmp_pp
	  | Exists _ ->
		  let quants, baref = split_quantifiers tmp3 in
		  let _, tmp_pp, _ = split_components baref in
		  let tmp = drop_exists tmp_pp in
			tmp
*)
(*added 09-05-2008 , by Cristian, checks that after the RHS existential elimination the newly introduced variables will no appear in the residue*)
and redundant_existential_check (svs : CP.spec_var list) (ctx0 : context) =
   match ctx0 with
	| Ctx es -> let free_var_list = (fv es.es_formula) in
					begin if (not ( CP.disjoint svs free_var_list)) then
						Debug.devel_pprint ("Some variable introduced by existential elimination where found in the residue") no_pos end
	| OCtx (c1, c2) ->
	  let _ = redundant_existential_check svs c1 in
	  (redundant_existential_check svs c2)

and elim_exists_pure (w : CP.spec_var list) (f0 : CP.formula) pos =
  let f = CP.mkExists w f0 pos in
  let simplified_f = TP.simplify f in
	simplified_f

(* --- added 11.05.2008 *)
and elim_exists_ctx_list (ctx0 : context list) = match ctx0 with
  | [] -> []
  | h::rest -> (elim_exists_ctx h)::(elim_exists_ctx_list rest)
(* end added 11.05.2008 --- *)

and elim_exists_ctx (ctx0 : context) = match ctx0 with
  | Ctx es ->
	  let f_prim = elim_exists es.es_formula in
	  (* 05.06.08 *)
	  (* we also try to eliminate exist vars for which a find a substitution of the form v = exp from the pure part *)
	  (*let _ = print_string("[solver.ml, elim_exists_ctx]: Formula before exp exist elim: " ^ Cprinter.string_of_formula f_prim ^ "\n") in*)
	  let f = elim_exists_exp f_prim in

	  (*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_formula f ^ "\n") in*)

		let qvar, base = CF.split_quantifiers f in
		let h, p, t = CF.split_components base in
		let simpl_p =
			(* if the flag is enabled --> simplify the pure part *)
			if !Globals.simplify_pure then (simpl_pure_formula p)
			else p
		in
		let simpl_f = CF.mkExists qvar h simpl_p t no_pos in
		(*let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_formula simpl_f ^ "\n") in *)
	  Ctx {es with es_formula = simpl_f}
  | OCtx (c1, c2) ->
	  let sc1 = elim_exists_ctx c1 in
	  let sc2 = elim_exists_ctx c2 in
	  let result = or_context sc1 sc2 in
		result

and elim_ante_evars (ctx : context) : context = match ctx with
  | OCtx (c1, c2) ->
	  let ec1 = elim_ante_evars c1 in
	  let ec2 = elim_ante_evars c2 in
		or_context ec1 ec2
  | Ctx es ->
(*
	  let tmp = List.map CP.name_of_spec_var es.es_ante_evars in
	  let _ = print_string ("\nante_evars: " ^ (String.concat ", " tmp) ^ "\n") in
*)
	  let f = push_exists es.es_ante_evars es.es_formula in
	  let ef = elim_exists f in
		Ctx {es with es_formula = ef }

and elim_unsat_ctx_list (prog : prog_decl) (cl0 : context list) =
  let tmp = List.map (elim_unsat_ctx prog) cl0 in
  let res = List.filter (fun c -> not (isFalseCtx c)) tmp in
	res

and elim_unsat_ctx (prog : prog_decl) (ctx0 : context) =
  let rec unsat_helper ctx = match ctx with
	| Ctx es ->
		let f = es.es_formula in
		let _ = reset_int2 () in
		  if TP.is_sat (xpure prog f) then
			(true, ctx)
		  else
			(false, false_ctx no_pos)
	| OCtx (c1, c2) ->
		let b1, sc1 = unsat_helper c1 in
		let b2, sc2 = unsat_helper c2 in
		  if b1 then
			if b2 then
			  (true, or_context sc1 sc2)
			else
			  (true, sc1)
		  else
			if b2 then
			  (true, sc2)
			else
			  (false, false_ctx no_pos) in
  let b, sc = unsat_helper ctx0 in
	sc

and elim_unsat (prog : prog_decl) (f : formula) = match f with
  | Or _ -> elim_unsat_all prog f
  | _ -> f

and elim_unsat_all prog (f : formula) = match f with
  | Base _ | Exists _ ->
	  let _ = reset_int2 () in
	  let pure_f = xpure prog f in
(*
		Debug.devel_pprint ("elim_unsat: mappedf:\n"
							^ (Presburger.string_of_pConstr mappedf)) (get_constr_pos f);
*)
		if TP.is_sat pure_f then begin
		  (* Debug.devel_pprint ("elim_unsat: satisfiable") (get_constr_pos f); *)
		  f
		end else begin
		  (* Debug.devel_pprint ("elim_unsat: unsatisfiable") (get_constr_pos f); *)
		  mkFalse (pos_of_formula f)
		end
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let nf1 = elim_unsat_all prog f1 in
	  let nf2 = elim_unsat_all prog f2 in
		mkOr nf1 nf2 pos

(* extracts those involve free vars from a set of equations  - here free means that it is not existential and it is not meant for explicit instantiation *)
and get_eqns_free (st : (CP.spec_var * CP.spec_var) list) (evars : CP.spec_var list) (expl_inst : CP.spec_var list) pos : CP.formula = match st with
  | (fr, t) :: rest ->
	  let rest_eqns = get_eqns_free rest evars expl_inst pos in
		if (CP.mem fr evars) || (CP.mem fr expl_inst)  (*TODO: should this be uncommented? || List.mem t evars *) then
		  rest_eqns
		else
		  let tmp = CP.mkEqVar fr t pos in
		  let res = CP.mkAnd tmp rest_eqns pos in
			res
  | [] -> CP.mkTrue pos

(*
	- extract the equations for the variables that are to be explicitly instantiated
	- remove the variables already instantiated from ivars
	- expl_vars will contain the vars that are next to be explicitly instantiated: for each equation ivar = v, it adds v to the list of vars that will be explicitly instantiated later
*)
and get_eqns_expl_inst (st : (CP.spec_var * CP.spec_var) list) (ivars : CP.spec_var list) (*(expl_vars : CP.spec_var list) *)pos : (CP.formula list * CP.spec_var list * CP.spec_var list) = match st with
  | (fr, t) :: rest ->
		if (CP.mem fr ivars) then
		  let ivars' = (List.filter (fun x -> not(CP.eq_spec_var fr x)) ivars) in
		  let (rest_eqns, ivars_new, expl_vars_new) = get_eqns_expl_inst rest ivars' pos in
		  let tmp = CP.mkEqVar fr t pos in
		  let res = [tmp]@rest_eqns in
			(*let _ = print_string ("expl_inst: " ^ (Cprinter.string_of_pure_formula tmp) ^ "\n") in*)
			(res, ivars_new, t::expl_vars_new)
		else (
		if (CP.mem t ivars) then
		  let ivars' = (List.filter (fun x -> not(CP.eq_spec_var t x)) ivars) in
		  let (rest_eqns, ivars_new, expl_vars_new) = get_eqns_expl_inst rest ivars' pos in
		  let tmp = CP.mkEqVar t fr pos in
		  let res = [tmp]@rest_eqns in
			(*let _ = print_string ("expl_inst: " ^ (Cprinter.string_of_pure_formula tmp) ^ "\n") in*)
			(res, ivars_new, fr::expl_vars_new)
		else
			(get_eqns_expl_inst rest ivars pos)
		)
  | [] -> ([], ivars, [])

(*  extract the equations for the variables that are to be explicitly instantiated from the residue - a Cpure.formula *)
(* get the equation for the existential variable used in the
   following variable elimination ex x. (x=y & P(x)) <=> P(y).
   The function also returns the remainder of the formula after
   the equation is extracted. It stops searching upon seeing
   Or/Exists/Forall. The equations returned are only of form
   v1 = v2 so that they can be applied to heap nodes. *)
and get_subst_equation (f : CP.formula) (v : CP.spec_var) : ((CP.spec_var * CP.spec_var) list * CP.formula) = match f with
  | CP.And (f1, f2, pos) ->
	  let st1, rf1 = get_subst_equation f1 v in
		if List.length st1 > 0 then (* should never be more than 1 *)
		  (st1, CP.mkAnd rf1 f2 pos)
		else
		  let st2, rf2 = get_subst_equation f2 v in
			(st2, CP.mkAnd f1 rf2 pos)

  | CP.BForm bf -> get_subst_equation_b_formula bf v
  | _ -> ([], f)

and get_subst_equation_b_formula (f : CP.b_formula) (v : CP.spec_var) : ((CP.spec_var * CP.spec_var) list * CP.formula) = match f with
  | CP.Eq (e1, e2, pos) -> begin
	  match e1, e2 with
		| CP.Var (sv1, pos1), CP.Var (sv2, pos2) ->
			if CP.eq_spec_var sv1 v then ([(v, sv2)], CP.mkTrue no_pos)
			else if CP.eq_spec_var sv2 v then ([(v, sv1)], CP.mkTrue no_pos)
			else ([], CP.BForm f)
		| _ -> ([], CP.BForm f)
	end
  | _ -> ([], CP.BForm f)

(* removing existentail using ex x. (x=y & P(x)) <=> P(y) *)
and elim_exists (f0 : formula) : formula = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let ef1 = elim_exists f1 in
	  let ef2 = elim_exists f2 in
		mkOr ef1 ef2 pos
  | Base _ -> f0
  | Exists ({formula_exists_qvars = qvar :: rest_qvars;
			 formula_exists_heap = h;
			 formula_exists_pure = p;
			 formula_exists_type = t;
			 formula_exists_pos = pos}) ->
	  let st, pp1 = get_subst_equation p qvar in
		if List.length st = 1 then
		  let tmp = mkBase h pp1 t pos in
		  let new_baref = subst st tmp in
		  let tmp2 = add_quantifiers rest_qvars new_baref in
		  let tmp3 = elim_exists tmp2 in
			tmp3
		else (* if qvar is not equated to any variables, try the next one *)
		  let tmp1 = mkExists rest_qvars h p t pos in
		  let tmp2 = elim_exists tmp1 in
		  let tmp3 = add_quantifiers [qvar] tmp2 in
			tmp3
  | Exists _ -> failwith ("Solver.elim_exists: Exists with an empty list of quantified variables")

(**************************************************************)
(* heap entailment                                            *)
(**************************************************************)

and filter_set (cl : context list) : context list =
  if !Globals.use_set || U.empty cl then cl
  else [List.hd cl]

(* check entailment:                                          *)
(* each entailment should produce one proof, be it failure or *)
(* success. *)

and heap_entail (prog : prog_decl) (is_folding : bool) (is_universal : bool) (cl : context list) (conseq : formula) pos : (context list * proof) =
  if !Globals.use_set || U.empty cl then
	let tmp1 = List.map (fun c -> heap_entail_one_context prog is_folding is_universal c conseq pos) cl in
	let tmp2, tmp_prfs = List.split tmp1 in
	let prf = mkContextList cl conseq tmp_prfs in
	let tmp = List.concat tmp2 in
	  (tmp, prf)
  else
	let tmp1, tmp2 = heap_entail_one_context prog is_folding is_universal (List.hd cl) conseq pos in
	  (tmp1, tmp2)

and heap_entail_one_context (prog : prog_decl) (is_folding : bool) (is_universal : bool) (ctx : context) (conseq : formula) pos : (context list * proof) =
  Debug.devel_pprint ("heap_entail_one_context:"
					  ^ "\nctx:\n" ^ (Cprinter.string_of_context ctx)
					  ^ "\nconseq:\n" ^ (Cprinter.string_of_formula conseq)) pos;
  if isFalseCtx ctx then
	(* check this first so that false => false is true (with false residual) *)
	([false_ctx pos], UnsatAnte)
  else if isConstFalse conseq then
	([], UnsatConseq)
  else if isConstTrue conseq then
	([ctx], TrueConseq)
  else
	let ctx1 = (*if !Globals.elim_unsat then elim_unsat_ctx prog ctx else*) ctx in
	  if isFalseCtx ctx1 then
		([false_ctx pos], UnsatAnte)
	  else
		let result, prf = heap_entail_after_sat prog is_folding is_universal ctx1 conseq pos in
		  (result, prf)

and heap_entail_after_sat prog is_folding is_universal ctx conseq pos : (context list * proof) = match ctx with
  | OCtx (c1, c2) ->
	  Debug.devel_pprint ("heap_entail_after_sat:"
						  ^ "\nctx:\n" ^ (Cprinter.string_of_context ctx)
						  ^ "\nconseq:\n" ^ (Cprinter.string_of_formula conseq)) pos;
	  let rs1, prf1 = heap_entail_after_sat prog is_folding is_universal c1 conseq pos in
		if not (U.empty rs1) then
		  let rs2, prf2 = heap_entail_after_sat prog is_folding is_universal c2 conseq pos in
			if not (U.empty rs2) then
			  let rs = or_context_list rs1 rs2 in
				(* there's no need to do filtering here as rs1 and rs2
				   only contain one set each if the flag is set *)
			  let prf = mkOrLeft ctx conseq [prf1; prf2] in
				(rs, prf)
			else
			  ([], mkOrLeft ctx conseq [prf2]) (* failure is caused by second branch *)
		else
		  ([], mkOrLeft ctx conseq [prf1]) (* failure is caused by first branch *)
  | _ -> begin
	  Debug.devel_pprint ("heap_entail_after_sat: invoking heap_entail_conjunct_lhs"
						  ^ "\ncontext:\n" ^ (Cprinter.string_of_context ctx)
						  ^ "\nconseq:\n" ^ (Cprinter.string_of_formula conseq)) pos;
	  let tmp, prf = heap_entail_conjunct_lhs prog is_folding is_universal ctx conseq pos in
		(filter_set tmp, prf)
	end


(* check entailment when lhs is normal-form, rhs is a conjunct *)
and heap_entail_conjunct_lhs prog is_folding is_universal ctx conseq pos : (context list * proof) = match conseq with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos1}) ->
	  Debug.devel_pprint ("heap_entail_conjunct_lhs: \nante:\n"
						  ^ (Cprinter.string_of_context ctx)
						  ^ "\nconseq:\n"
						  ^ (Cprinter.string_of_formula conseq)) pos;
	  if !Globals.use_set then
		let rs1, prf1 = heap_entail_conjunct_lhs prog is_folding is_universal ctx f1 pos in
		let rs2, prf2 = heap_entail_conjunct_lhs prog is_folding is_universal ctx f2 pos in
		  if (U.empty rs1) & (U.empty rs2) then
			([], mkOrRight ctx conseq [prf1; prf2])
		  else if U.empty rs1 then
			(rs2, mkOrRight ctx conseq
			   (if !Globals.trace_all then [prf1; prf2] else [prf2]))
		  else if U.empty rs2 then
			(rs1, mkOrRight ctx conseq
			   (if !Globals.trace_all then [prf1; prf2] else [prf1]))
		  else
			(rs1 @ rs2, mkOrRight ctx conseq [prf1; prf2])
	  else
		let rs1, prf1 = heap_entail_conjunct_lhs prog is_folding is_universal ctx f1 pos in
		  if U.empty rs1 then
			let rs2, prf2 = heap_entail_conjunct_lhs prog is_folding is_universal ctx f2 pos in
			  (filter_set rs2, prf2)
		  else
			(filter_set rs1, prf1)
  | _ -> begin
	  Debug.devel_pprint ("heap_entail_conjunct_lhs: invoking heap_entail_conjunct") pos;
	  heap_entail_conjunct prog is_folding is_universal ctx conseq pos
	end

(* 23.10.2008 *)
(* for empty RHS heap:
	- move the explicit instantiations from the RHS to the LHS
	- remove the explicit instantiated vars from the existential vars of the conseq
	- add the existential vars from the conseq to the existential vars from the antecedent
- f represents the consequent
*)
and move_expl_inst_ctx_list (ctx : context list) (f : formula) : context list =
	List.map (fun x -> move_expl_inst_ctx x f) ctx

and move_expl_inst_ctx	(ctx : context) (f : formula) : context =
	match ctx with
		| CF.Ctx(es) ->
			(*let _ = print_string("[cformula.ml]: move expl_inst: " ^ (Cprinter.string_of_formula f)  ^ "\n") in	 *)
			(* the expl vars were made existential while they were kept in the consequent - therefore, now we remove them from es_evars *)
			let new_es = (pop_exists_estate es.es_expl_vars es) in
			let new_es' = {new_es with
				(* existential vars from conseq are made existential in the entecedent *)
				es_ante_evars = new_es.es_ante_evars @ new_es.es_evars;
				es_formula = (CF.mkStar new_es.es_formula f no_pos)
			}
			in CF.Ctx(new_es')
		| CF.OCtx(c1, c2) ->
			CF.OCtx((move_expl_inst_ctx c1 f), (move_expl_inst_ctx c2 f))

(* from a list containing equaltions of the form vi = wi -> obtain two lists [vi]  and [wi] *)
and obtain_subst l =
	match l with
		| CP.BForm(CP.Eq(CP.Var(e1, _), CP.Var(e2, _), _))::r -> ((e1::(fst (obtain_subst r))), (e2::(snd (obtain_subst r))))
		| _::r -> ((fst (obtain_subst r)), (snd (obtain_subst r)))
		| [] -> ([],[])

(*************************************** 06.11.08 *******************************************************************)
(**********************************************************************************************************************)
(* check whether the target of a coercion is in the RHS of the entailment *)
(* coer: the coercion lemma to be applied *)
(* node: the node to which the coercion applies *)
(* lhs and rhs - the antecedent and consequent, respectively *)
and coer_target prog (coer : coercion_decl) node (rhs : CF.formula) (lhs : CF.formula) : bool =
	let coer_lhs = coer.coercion_head in
	let coer_rhs = coer.coercion_body in
	let coer_lhs_heap, coer_lhs_guard, _ = split_components coer_lhs in
	let rhs_heap, rhs_pure, _ = split_components rhs in
	let lhs_heap, lhs_pure, _ = split_components lhs in
	(*let _ = print_string("coer_lhs_heap = " ^ (Cprinter.string_of_h_formula coer_lhs_heap) ^ "\n") in
	let _ = print_string("node = " ^ (Cprinter.string_of_h_formula node) ^ "\n") in*)
	(* node - the node to which we want to apply the coercion rule *)
	(* need to find the substitution *)
	match node, coer_lhs_heap with
		| ViewNode ({h_formula_view_node = p1;
					h_formula_view_name = c1;
					h_formula_view_origins = origs;
					h_formula_view_arguments = ps1}),
		ViewNode ({h_formula_view_node = p2;
					h_formula_view_name = c2;
					h_formula_view_arguments = ps2}) when c1=c2 ->
			begin
			(* apply the substitution *)
			let coer_rhs_new = subst_avoid_capture (p2 :: ps2) (p1 :: ps1) coer_rhs in
			let coer_lhs_new = subst_avoid_capture (p2 :: ps2) (p1 :: ps1) coer_lhs in
			(*let _ = print_string("coer_rhs = " ^ (Cprinter.string_of_formula coer_rhs) ^ "\n") in*)
			(*let _ = print_string("coer_rhs_new = " ^ (Cprinter.string_of_formula coer_rhs_new) ^ "\n") in *)
			(* find the targets from the RHS of the coercion *)
			let top_level_vars = (CF.f_top_level_vars coer_rhs_new) in
			let target = (List.filter (fun x -> List.mem x top_level_vars) (CF.fv coer_rhs_new)) in
			let target = (List.filter (fun x -> (List.mem x (CF.fv coer_lhs_new))) target) in
			(*let _ = print_string ("Target:" ^ (Cprinter.string_of_spec_var_list target) ^ "\n") in*)
			let coer_rhs_h, _, _ = (split_components coer_rhs_new) in
			(* check for each target if it appears in the consequent *)
			let all_targets = (List.map (fun x -> (check_one_target prog x lhs_pure rhs_pure rhs_heap coer_rhs_h)) target) in
				let rec find_one_target all_targets = match all_targets with
					| true :: r -> true
					| false :: r -> (find_one_target r)
					| [] -> false
				in
				(* need to find at least one target *)
				(find_one_target all_targets)
			end
(* given a spec var -> return the entire node *)
and get_node (sv : CP.spec_var) (f : CF.h_formula) : CF.h_formula =
	match f with
	| Star({ h_formula_star_h1 = f1; h_formula_star_h2 = f2}) ->
		let res1 = (get_node sv f1) in
			begin
			 match res1 with
			 | HFalse -> (get_node sv f2)
			 | _ -> res1
			end
	| DataNode({h_formula_data_node = sv1; h_formula_data_name = name}) ->
		if (CP.eq_spec_var sv sv1)
			then f
			else HFalse
	| ViewNode({h_formula_view_node = sv1; h_formula_view_name = name}) ->
		if (CP.eq_spec_var sv sv1)
			then f
			else HFalse
	| _ -> HFalse

(* check whether target appears in rhs *)
(* we need lhs_pure to compute the alias set of target *)
and check_one_target prog (target : CP.spec_var) (lhs_pure : CP.formula) (rhs_p : CP.formula) (rhs_h : CF.h_formula) (coer_rhs_h : CF.h_formula): bool =
	(*let _ = print_string("check_one_target: target: " ^ (Cprinter.string_of_spec_var target) ^ "\n") in*)
	let lhs_eqns = ptr_equations lhs_pure in
	let lhs_asets = alias lhs_eqns in
	let lhs_targetasets1 = get_aset lhs_asets target in
	let lhs_targetasets =
		if CP.mem target lhs_targetasets1 then lhs_targetasets1
		else target :: lhs_targetasets1 in
		let fnode_results = (find_node prog rhs_h rhs_p lhs_targetasets no_pos) in
		begin
		match fnode_results with
			| Failed -> (*let _ = print_string("[check_one_target]: failed\n") in*) false
			| NoMatch -> (*let _ = print_string("[check_one_target]: no match\n") in*) false
			| Match (matches, resth1) ->
				begin
				match matches with
					| (anode, r_flag) :: rest ->
						begin
							let target_node = get_node target coer_rhs_h in
							let _ = Debug.devel_pprint ("Target: " ^ (Cprinter.string_of_h_formula target_node) ^ "\n") no_pos in
							let _ = Debug.devel_pprint ("Target match: " ^ (Cprinter.string_of_h_formula anode) ^ "\n") no_pos in
							begin
							match target_node, anode with
								| ViewNode ({h_formula_view_node = p1;
											 h_formula_view_name = c1}),
								  ViewNode ({h_formula_view_node = p2;
											 h_formula_view_name = c2}) when c1=c2 ->
											((*print_string("[check_one_target]: target match found\n"); *)true)
								| DataNode ({h_formula_data_node = p1;
											 h_formula_data_name = c1}),
								  DataNode ({h_formula_data_node = p2;
											 h_formula_data_name = c2}) when c1=c2 ->
											((*print_string("[check_one_target]: target match found\n");*) true)
								| _ ->	false
							end
						end
					| [] -> false
				end
		end

(* checks whether a coercion is distributive *)
and is_distributive	(coer : coercion_decl) : bool =
	let coer_lhs = coer.coercion_head in
	let coer_rhs = coer.coercion_body in
	let coer_lhs_heap, _, _ = split_components coer_lhs in
	let coer_rhs_heap, _, _ = split_components coer_rhs in
	let top_level_lhs = top_level_vars coer_lhs_heap in
	let top_level_rhs = top_level_vars coer_rhs_heap in
	not(List.mem false (List.map (fun x -> check_one_node x top_level_rhs coer_lhs_heap coer_rhs_heap) top_level_lhs))

(*  checks whether sv is present on the lhs and points to the same view *)
and check_one_node (sv : CP.spec_var) (top_level_rhs : CP.spec_var list) (lhs_heap : CF.h_formula) (rhs_heap : CF.h_formula) : bool =
	match top_level_rhs with
	| h :: r ->
		if (CP.eq_spec_var h sv) && (String.compare (CF.get_node_name (get_node sv lhs_heap)) (CF.get_node_name (get_node h rhs_heap))) == 0 then
			true
		else (check_one_node sv r lhs_heap rhs_heap)
	| [] -> false

(* returns the list of free vars from the rhs that do not appear in the lhs *)
and fv_rhs (lhs : CF.formula) (rhs : CF.formula) : CP.spec_var list =
	let lhs_fv = (CF.fv lhs) in
	let rhs_fv = (CF.fv rhs) in
		(List.filter (fun x -> not(List.mem x lhs_fv)) rhs_fv)

(* check the entailment of two conjuncts  *)
(* return value: if fst res = true, then  *)
(* snd res is the residual. Otherwise     *)
(* snd res is the constraint that causes  *)
(* the check to fail.                     *)
and heap_entail_conjunct (prog : prog_decl) (is_folding : bool) (is_universal : bool) (ctx0 : context) (conseq : formula) pos : (context list * proof) =
  Debug.devel_pprint ("heap_entail_conjunct:"
					  ^ "\ncontext:\n" ^ (Cprinter.string_of_context ctx0)
					  ^ "\nconseq:\n" ^ (Cprinter.string_of_formula conseq)) pos;
  match ctx0 with
	| Ctx estate -> begin
		let ante = estate.es_formula in
		  match ante with
			| Exists ({formula_exists_qvars = qvars;
					   formula_exists_heap = qh;
					   formula_exists_pure = qp;
					   formula_exists_type = qt;
					   formula_exists_pos = pos}) ->
				(* eliminating existential quantifiers from the LHS *)
				(* ws are the newly generated fresh vars for the existentially quantified vars in the LHS *)
				let ws = CP.fresh_spec_vars qvars in
				(*--- 09.05.2008 *)
				(*let _ = (print_string ("\n[solver.ml, line 1183]: fresh name = " ^ (Cprinter.string_of_spec_var_list ws) ^ "!!!!!!!!!!!\n")) in*)
				(*09.05.2008 ---*)
				let st = List.combine qvars ws in
				let baref = mkBase qh qp qt pos in
				let new_baref = subst st baref in
				(* new ctx is the new context after substituting the fresh vars for the exist quantified vars *)
				let new_ctx = Ctx {estate with
									 es_formula = new_baref;
									 es_ante_evars = ws @ estate.es_ante_evars } in
				(* call the entailment procedure for the new context - with the existential vars substituted by fresh vars *)
				let rs, prf1 = heap_entail_conjunct prog is_folding is_universal new_ctx conseq pos in
				(* --- added 11.05.2008 *)
				let new_rs =
					if !Globals.wrap_exist then
						(* the fresh vars - that have been used to substitute the existenaltially quantified vars - need to be existentially quantified after the entailment *)
						(CF.add_exist_vars_to_ctx_list rs ws)
					else
						rs
				in
				(* log the transformation for the proof tracere *)
				let prf = mkExLeft ctx0 conseq qvars ws prf1 in
				  (new_rs, prf)
			| _ -> begin
				match conseq with
				  | Exists ({formula_exists_qvars = qvars;
							 formula_exists_heap = qh;
							 formula_exists_pure = qp;
							 formula_exists_type = qt;
							 formula_exists_pos = pos}) ->
					  (* quantifiers on the RHS. Keep them for later processing *)
					  let ws = CP.fresh_spec_vars qvars in
					  let st = List.combine qvars ws in
					  let baref = mkBase qh qp qt pos in
					  let new_baref = subst st baref in
					  let new_ctx = Ctx {estate with es_evars = ws @ estate.es_evars} in
					  let tmp_rs, tmp_prf = heap_entail_conjunct prog is_folding is_universal new_ctx new_baref pos in
					  if not (U.empty tmp_rs) then
						  let prf = mkExRight ctx0 conseq qvars ws tmp_prf in
						  (*added 09-05-2008 , by Cristian, checks that after the RHS existential elimination the newly introduced variables will no appear in the residue hence no need to quantify*)
						  let _ = List.map (redundant_existential_check ws) tmp_rs in
						  (*let res_ctx_prim = List.map (push_exists_context ws) tmp_rs in*)
						  let res_ctx_prim  = tmp_rs in
						  let res_ctx =
							if !Globals.elim_exists then List.map elim_exists_ctx res_ctx_prim
							else res_ctx_prim
						  in
							(res_ctx, prf)
						else ([], tmp_prf) (* entailment fails *)
				  | _ ->
					  let h1, p1, t1 = split_components ante in
					  let h2, p2, t2 = split_components conseq in
					  	match h2 with
						  | HFalse -> ([], UnsatConseq) (* entailment fails *)
						  | HTrue -> begin
							  Debug.devel_pprint ("heap_entail_conjunct: "
												  ^ "conseq has an empty heap component"
												  ^ "\ncontext:\n"
												  ^ (Cprinter.string_of_context ctx0)
												  ^ "\nconseq:\n"
												  ^ (Cprinter.string_of_formula conseq)) pos;
							  let b1 = { formula_base_heap = h1;
										 formula_base_pure = p1;
										 formula_base_type = t1;
										 formula_base_pos = pos } in
								(* 23.10.2008 *)
(*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)
(* at the end of an entailment due to the epplication of an universal lemma, we need to move the explicit instantiation to the antecedent  *)
(* Remark: for universal lemmas we use the explicit instantiation mechanism,  while, for the rest of the cases, we use implicit instantiation *)
(*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*)
								let ctx, proof = heap_entail_empty_rhs_heap prog is_folding is_universal estate b1 p2 pos in
								let new_ctx =
									if is_universal then ((*print_string ("YES Expl inst!!\n");*) move_expl_inst_ctx_list ctx conseq)
									else ((*print_string ("NO Expl inst!!\n");*) ctx )
								in
									(new_ctx, proof)
							end
						  | _ -> begin
							  Debug.devel_pprint ("heap_entail_conjunct: "
												  ^ "conseq has an non-empty heap component"
												  ^ "\ncontext:\n"
												  ^ (Cprinter.string_of_context ctx0)
												  ^ "\nconseq:\n"
												  ^ (Cprinter.string_of_formula conseq)) pos;
							  let b1 = { formula_base_heap = h1;
										 formula_base_pure = p1;
										 formula_base_type = t1;
										 formula_base_pos = pos } in
							  let b2 = { formula_base_heap = h2;
										 formula_base_pure = p2;
										 formula_base_type = t2;
										 formula_base_pos = pos } in
								heap_entail_non_empty_rhs_heap prog is_folding is_universal ctx0 estate ante conseq b1 b2 pos
							end
			  end
	  end
	| _ -> report_error pos ("heap_entail_conjunct: context is disjunctive!!!")

and heap_entail_build_pure_check (evars : CP.spec_var list) (ante : CP.formula) (conseq : CP.formula) pos : (CP.formula * CP.formula) =
  let avars = CP.fv ante in
  let sevars = (* List.map CP.to_int_var *) evars in
  let outer_vars, inner_vars = List.partition (fun v -> CP.mem v avars) sevars in
  let tmp1 = CP.mkExists inner_vars conseq no_pos in
	if U.empty outer_vars then
	  (ante, tmp1)
	else
(*TODO: fix this
*)
	  let tmp2 = CP.mkExists sevars conseq no_pos in
		(ante, tmp2)
(*
	  Error.report_error {
		Error.error_loc = pos;
		Error.error_text = ("heap_entail_build_pure_check: outer_vars: "
							^ (String.concat ", "
								 (List.map CP.name_of_spec_var outer_vars))) }
*)

and heap_entail_empty_rhs_heap (prog : prog_decl) (is_folding : bool) (is_universal : bool) estate lhs rhs_p pos : (context list * proof) =
  let lhs_h = lhs.formula_base_heap in
  let lhs_p = lhs.formula_base_pure in
  let lhs_t = lhs.formula_base_type in
  let _ = reset_int2 () in
  let xpure_lhs_h = xpure_heap prog (mkStarH lhs_h estate.es_heap pos) 1 in
  let tmp1 = CP.mkAnd xpure_lhs_h lhs_p pos in
  let new_ante, new_conseq = heap_entail_build_pure_check estate.es_evars tmp1 rhs_p pos in
  let xpure_lhs_h0 = xpure_heap prog (mkStarH lhs_h estate.es_heap pos) 0 in
  let tmp2 = CP.mkAnd xpure_lhs_h0 lhs_p pos in
  let new_ante0, new_conseq0 = heap_entail_build_pure_check estate.es_evars tmp2 rhs_p pos in
(*	let _ = print_string("old ante: " ^ (Cprinter.string_of_pure_formula tmp1) ^ "\n") in
	let _ = print_string("old conseq: " ^ (Cprinter.string_of_pure_formula rhs_p) ^ "\n") in*)
	Debug.devel_pprint ("heap_entail_empty_heap: checking implication:\n"
						^ "ante:\n"
						^ (Cprinter.string_of_pure_formula new_ante)
						^ "\nconseq:\n"
						^ (Cprinter.string_of_pure_formula new_conseq)) pos;
(*	let _ = print_string("ante: " ^ (Cprinter.string_of_pure_formula new_ante) ^ "\n") in
	let _ = print_string("conseq: " ^ (Cprinter.string_of_pure_formula new_conseq) ^ "\n") in*)
  if CP.isConstTrue rhs_p || TP.imply new_ante0 new_conseq0 || (((new_ante <> new_ante0) || (new_conseq <> new_conseq0)) && TP.imply new_ante new_conseq) then 
    begin
	    let res_delta = mkBase lhs_h lhs_p lhs_t pos in
		if is_folding then begin
		  let prf = mkPure estate new_ante new_conseq true None in
		  let res_es = {estate with es_formula = res_delta; es_pure = rhs_p} in
		  let res_ctx = Ctx res_es in
			Debug.devel_pprint ("heap_entail_empty_heap: folding: formula is valid") pos;
			Debug.devel_pprint ("heap_entail_empty_heap: folding: res_ctx:\n"
								^ (Cprinter.string_of_context res_ctx)) pos;
			([res_ctx], prf)
		end else begin
		  let prf = mkPure estate new_ante new_conseq true None in
		  let res_ctx = Ctx {estate with es_formula = res_delta} in
			Debug.devel_pprint ("heap_entail_empty_heap: formula is valid") pos;
			Debug.devel_pprint ("heap_entail_empty_heap: res_ctx:\n"
								^ (Cprinter.string_of_context res_ctx)) pos;
			([res_ctx], prf)
		end
	end else begin
	  Debug.devel_pprint ("heap_entail_conjunct: formula is not valid\n") pos;
	  let gformula =
		if !Globals.show_gist then Some (Omega.gist new_conseq new_ante)
		else None in
	  let prf = mkPure estate new_ante new_conseq false gformula in
		([], prf)
	end

and heap_entail_non_empty_rhs_heap prog is_folding is_universal ctx0 estate ante conseq lhs_b rhs_b pos : (context list * proof) =
  let lhs_h = lhs_b.formula_base_heap in
  let lhs_p = lhs_b.formula_base_pure in
  let lhs_t = lhs_b.formula_base_type in
  let rhs_h = rhs_b.formula_base_heap in
  let rhs_p = rhs_b.formula_base_pure in
  let rhs_t = rhs_b.formula_base_type in
  let ln2, resth2 = split_linear_node rhs_h in
	match ln2 with
	  | DataNode ({h_formula_data_node = p2;
				   h_formula_data_name = c2;
				   h_formula_data_arguments = v2;
				   h_formula_data_pos = pos2})
	  | ViewNode ({h_formula_view_node = p2;
				   h_formula_view_name = c2;
				   h_formula_view_arguments = v2;
				   h_formula_view_pos = pos2}) -> begin
		  Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: trying to prove "
							  ^ (Cprinter.string_of_h_formula ln2)) pos;
(************************************)
(* the folding process *)
(* process folding. var_to_fold is the variable from the LHS to fold to *)
(************************************)
(****************************************************************************************************************************************************************************)
(* do_fold *)
(****************************************************************************************************************************************************************************)
		  let do_fold (var_to_fold : CP.spec_var) =
			let fold_ctx = Ctx {(empty_es pos) with es_formula = ante;
								  es_heap = estate.es_heap;
								  es_evars = estate.es_evars;
								  es_ante_evars = estate.es_ante_evars} in
			let view_to_fold = ViewNode ({h_formula_view_node = var_to_fold;
										  h_formula_view_name = c2;
										  h_formula_view_arguments = v2;
										  h_formula_view_modes = get_view_modes ln2;
										  h_formula_view_coercible = true;
										  h_formula_view_origins = get_view_origins ln2;
										  h_formula_view_pos = pos2}) in
			let fold_rs, fold_prf = fold prog fold_ctx view_to_fold (P.mkTrue pos) pos in
			  if not (U.empty fold_rs) then
				let b = { formula_base_heap = resth2;
						  formula_base_pure = rhs_p;
						  formula_base_type = rhs_t;
						  formula_base_pos = pos } in
				let tmp, tmp_prf = process_fold_result prog is_folding
				  estate fold_rs p2 v2 b pos in
				let prf = mkFold ctx0 conseq p2 fold_prf tmp_prf in
				  (tmp, prf)
			  else begin
				Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: unable to fold:\n"
									^ (Cprinter.string_of_context ctx0) ^ "\n"
									^ "to:ln2: "
									^ (Cprinter.string_of_h_formula ln2)
									^ "\nrhs_p: "
									^ (Cprinter.string_of_pure_formula rhs_p)) pos;
				([], fold_prf)
			  end in
(****************************************************************************************************************************************************************************)
(* end do_fold *)
(****************************************************************************************************************************************************************************)
(****************************************************************************************************************************************************************************)
(* back into heap_entail_non_empty_rhs_heap *)
(****************************************************************************************************************************************************************************)
		  (*
			 find nodes from LHS matching p2. Matching can occur at root
			 or at an argument.

			 The search is quite aggressive for now. It not only looks for
			 nodes (from LHS) aliased to p2, but also nodes that are aliased
			 (using lhs_p) to variables aliased (using rhs_p) to p2.

			 TODO: show that this is ok.
		  *)
		  let rhs_eqns = ptr_equations rhs_p in
		  let rhs_asets = alias rhs_eqns in
		  let rhs_p2asets1 = get_aset rhs_asets p2 in
		  let rhs_p2asets =
			if CP.mem p2 rhs_p2asets1 then rhs_p2asets1
			else p2 :: rhs_p2asets1 in
		  let fnode_results = find_node prog lhs_h lhs_p rhs_p2asets pos in
			match fnode_results with
			  | Failed -> (*let _ = print_string("failed\n") in*) ([], NoAlias) (* p2 is not mentioned in LHS, failure *)
			  | NoMatch -> begin (* p2 is mentioned in LHS, but no matching
									node/predicate is found *)
				  (*let _ = print_string("no match\n") in*)
				  if is_data ln2 then begin (* fail *)
					Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
										^ "no aliased node for data node "
										^ (Cprinter.string_of_h_formula ln2)
										^ " is found in LHS\n") pos;
					([], NoAlias)
				  end
				  else begin (* attempting to fold against the base case *)
					Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
										^ "folding with no node on lhs: "
										^ (Cprinter.string_of_spec_var p2)
										^ "\ncontext:\n"
										^ (Cprinter.string_of_context ctx0)
										^ "\nln2:\n"
										^ (Cprinter.string_of_h_formula ln2)
										^ "\nrhs_p:\n"
										^ (Cprinter.string_of_pure_formula rhs_p)) pos;
					(* get a variable from the lhs that are aliased with p2 to use in the folding
					  let tmp_vars1 = CP.fv lhs_p in
					  let tmp_vars2 = List.filter (fun v -> CP.mem v p2aset) tmp_vars1 in
					  let var_to_fold = List.hd tmp_vars2 in (there must be at least one)
					*)
						do_fold p2 (* p2 is mentioned in LHS, p2 can be fold target *)
					  (* var_to_fold *)
				  end (* end of emty anodes case *)
				end
			  | Match (matches, resth1) -> begin
				  (* one or more aliased nodes are found, try all of them one by one. *)
				  (* When trying a node, add the remaining back to resth1. *)
				  let check_aliased_node (anode, r_flag) resth1 =
					(*let _ = print_string("match: " ^ (Cprinter.string_of_h_formula anode) ^ " for " ^ (Cprinter.string_of_h_formula ln2) ^ "\n") in
					let _ = print_string("conseq: " ^ (Cprinter.string_of_formula conseq) ^ "\n") in*)
					(* r_flag = true if the match happen at root pointer *)
					match anode with
					  | ViewNode ({h_formula_view_node = p1;
								   h_formula_view_name = c1;
								   h_formula_view_arguments = v1;
								   h_formula_view_pos = pos1})
					  | DataNode ({h_formula_data_node = p1;
								   h_formula_data_name = c1;
								   h_formula_data_arguments = v1;
								   h_formula_data_pos = pos1}) ->

						  (* helper functions for coercion *)

						  (*
							Applying universally-quantified lemmas. Here are the steps:
							- Compute the set of universal variables. If the set is
							empty, then just do normal rewriting. (this has been done by apply_universal).
							- Split the guard out. Change it to existential to check
							for satisfiability.
							- Do the rewriting.
							- Perform entailment with rewritten formula
							- Filter subformulas from the pure part of the consequent
							that are related to the guard. This provides us with the instantiation.

							Now it only works when applying to the antecedent.
						  *)
						(* new version:
							- forall v*. H /\ G -> B
							- match H and the node/predicate to be coerced and obtain the substitution \rho
						*)
(*******************************************************************************************************************************************************************************************)
(*
			Summary of the coercion helper methods:
			- check the guard in do_universal and rewrite_coercion
			-  rewrite_coercion called in apply_left_coercion and apply_right_coercion
			- apply_left_coercion called in do_coercion
			- apply_right_coercion called in do_coercion
			- do_coercion called in heap_entail_non_empty_rhs_heap --------- the main coercion helper
			- do_universal called in apply_universal
			- apply_universal called in do_coercion

*)
(*******************************************************************************************************************************************************************************************)
						(* do_universal *)
(*******************************************************************************************************************************************************************************************)

						let do_universal node f coer : (context list * proof) =
						begin
							(* rename the bound vars *)
							let f_univ_vars = CP.fresh_spec_vars coer.coercion_univ_vars in
(*
							let _ = print_string ("univ_vars: "   ^ (String.concat ", "   (List.map CP.name_of_spec_var  coer.coercion_univ_vars)) ^ "\n") in
*)
							(*let _ = print_string ("[do_univ]: rename the univ boudn vars: " ^ (String.concat ", " (List.map CP.name_of_spec_var f_univ_vars)) ^ "\n") in	*)
							let tmp_rho = List.combine coer.coercion_univ_vars f_univ_vars in
							let coer_lhs = CF.subst tmp_rho coer.coercion_head in
							let coer_rhs = CF.subst tmp_rho coer.coercion_body in
							(************************************************************************)
							(* also rename the free vars from the rhs that do not appear in the lhs *)
							let lhs_fv = (fv_rhs coer_lhs coer_rhs) in
							let fresh_lhs_fv = CP.fresh_spec_vars lhs_fv in
							let tmp_rho = List.combine lhs_fv fresh_lhs_fv in
							let coer_lhs = CF.subst tmp_rho coer_lhs in
							let coer_rhs = CF.subst tmp_rho coer_rhs in
							let lhs_heap, lhs_guard, _ = split_components coer_lhs in
							  match node, lhs_heap with
								| ViewNode ({h_formula_view_node = p1;
											 h_formula_view_name = c1;
											 h_formula_view_origins = origs;
											 h_formula_view_arguments = ps1}),
								  ViewNode ({h_formula_view_node = p2;
											 h_formula_view_name = c2;
											 h_formula_view_arguments = ps2}) when c1=c2 -> begin
									(* the lemma application heuristic:
									- if the flag 	lemma_heuristic in true then we use both coerce& match - each lemma application must be followed by a match  - and history
									- if the flag is false, we only use coerce&distribute&match
									*)
									let apply_coer = (coer_target prog coer anode (CF.formula_of_base rhs_b) (CF.formula_of_base lhs_b)) in
									if (!Globals.lemma_heuristic && 		(* use coerce&match together with the history mechanism *)
										(not(apply_coer) 					(* the target is not present *)
										or (get_estate_must_match estate))  (* must match *)
										&& (List.mem coer.coercion_body_view origs
										or List.mem coer.coercion_head_view origs))  (* there is a cycle *)
									or 	(not(!Globals.lemma_heuristic) &&   (* use coerce&distribute&match*)
										(not(apply_coer) or 				(* the target is not present *)
										((get_estate_must_match estate) 	(* must match *)
										&& (not(!enable_distribution) 		(* distributive coercion is not allowed *)
										or not(is_distributive coer))))) 	(* coercion is not distributive *)
									then
										(Debug.devel_pprint("[do_universal]: Coercion cannot be applied!") pos; ([], Failure))
									else	(* we can apply coercion *)
									begin
									  if (not(!Globals.lemma_heuristic) && get_estate_must_match estate) then
										((*print_string("disable distribution\n");*) enable_distribution := false);
									  (* the \rho substitution \rho (B) and  \rho(G) is performed *)
									  let lhs_guard_new = CP.subst_avoid_capture (p2 :: ps2) (p1 :: ps1) lhs_guard in
									  let coer_rhs_new1 = subst_avoid_capture (p2 :: ps2) (p1 :: ps1) coer_rhs in
									  let coer_rhs_new = add_origins coer_rhs_new1 (coer.coercion_head_view :: origs) in
									  let _ = reset_int2 () in
									  (*let xpure_lhs = xpure prog f in*)
(*************************************************************************************************************************************************************************)
(* delay the guard check *)
(* for now, just add it to the consequent *)
(*************************************************************************************************************************************************************************)
										(*let guard_to_check = CP.mkExists f_univ_vars lhs_guard_new pos in*)
										(*let _ = print_string("xpure_lhs: " ^ (Cprinter.string_of_pure_formula xpure_lhs) ^ "\n") in
										let _ = print_string("guard: " ^ (Cprinter.string_of_pure_formula guard_to_check) ^ "\n") in*)
										let new_f = normalize coer_rhs_new f pos in
										(* add the guard to the consequent  - however, the guard check is delayed *)
										let new_conseq = normalize conseq (formula_of_pure lhs_guard_new pos) pos in
										let new_estate = {estate with
															es_evars = f_univ_vars @ estate.es_evars;
															(* the new universal vars to be instantiated *)
															es_ivars = f_univ_vars @ estate.es_ivars;
															es_formula = new_f;
															es_must_match = true
														} in
										let new_ctx = Ctx new_estate in
										let res, prf = heap_entail prog is_folding true [new_ctx] new_conseq pos in
										(res, prf)
								  end
								end
								| _ -> ([], Failure)
						end
						in
						  (*
							Rewrites f by matching node with coer_lhs to obtain a substitution.
							The substitution is then applied to coer_rhs, which is then *-joined
							with f and then normalized.

							If the first component of the returned value is true, the rewrite
							is successful and the coercion performed. Otherwise, the rewrite is
							not performed (due to the guard).
						  *)
(*******************************************************************************************************************************************************************************************)
						(* rewrite_coercion *)
(*******************************************************************************************************************************************************************************************)
						let rewrite_coercion node f coer : (bool * formula) =
							(* This function also needs to add the name and the origin list
							   of the source view to the origin list of the target view. It
							   needs to check if the target view in coer_rhs belongs to the
							   list of origins of node. If so, don't apply the coercion *)
						(******************** here it was the test for coerce&match *************************)
							let coer_lhs = coer.coercion_head in
							let coer_rhs = coer.coercion_body in
							let lhs_heap, lhs_guard, _ = split_components coer_lhs in
							  match node, lhs_heap with
								| ViewNode ({h_formula_view_node = p1;
											 h_formula_view_name = c1;
											 h_formula_view_origins = origs;
											 h_formula_view_arguments = ps1}),
								  ViewNode ({h_formula_view_node = p2;
											 h_formula_view_name = c2;
											 h_formula_view_arguments = ps2}) when c1=c2 -> begin
(*
									let _ = print_string ("body_view: " ^ coer.coercion_body_view ^ "\n") in
									let _ = print_string ("head_view: " ^ coer.coercion_head_view ^ "\n") in
									let _ = print_string ("origs: " ^ (String.concat ", " origs) ^ "\n") in
*)
(*************************************************************)
(* replace with the coerce&match mechanism *)
(*************************************************************)
								let apply_coer = (coer_target prog coer node (CF.formula_of_base rhs_b) (CF.formula_of_base lhs_b)) in
								(* the lemma application heuristic:
								- if the flag 	lemma_heuristic in true then we use both coerce& match and history
								- if the flag is false, we only use coerce&distribute&match
								*)
								if (!Globals.lemma_heuristic
									&& (not(apply_coer) (* coerce&match+history *)
									or (get_estate_must_match estate))
									&& (List.mem coer.coercion_body_view origs
									or List.mem coer.coercion_head_view origs))
									or 	(not(!Globals.lemma_heuristic) && (* coerce&distribute&match *)
									(not(apply_coer) or 	(* the target is not present *)
									((get_estate_must_match estate) (* must match *)
									&& (not(!enable_distribution) (* distributive coercion is not allowed *)
									or not(is_distributive coer))))) (* coercion is not distributive *)
									then

									(Debug.devel_pprint("[do_universal]: Coercion cannot be applied!") pos; (false, mkTrue no_pos))
								else
								(* we can apply coercion *)
								begin
									(* apply \rho (G)	and \rho(B) *)
									let lhs_guard_new = CP.subst_avoid_capture (p2 :: ps2) (p1 :: ps1) lhs_guard in
									let coer_rhs_new1 = subst_avoid_capture (p2 :: ps2) (p1 :: ps1) coer_rhs in
									let coer_rhs_new = add_origins coer_rhs_new1 (coer.coercion_head_view :: origs) in
									let _ = reset_int2 () in
									let xpure_lhs = xpure prog f in
(*******************************************************************************************************************************************************************************************)
(* test the guard again in rewrite_coercion
- for now we only revise the universal lemmas handled by apply_universal --> the check stays here as it is *)
(*******************************************************************************************************************************************************************************************)
										(* is it necessary to xpure (node * f) instead ? *)
										if TP.imply xpure_lhs lhs_guard_new then
										  let new_f = normalize coer_rhs_new f pos in
											(if (not(!Globals.lemma_heuristic) && get_estate_must_match estate) then
											((*print_string("disable distribution\n"); *)enable_distribution := false);
											(true, new_f))
										else if !Globals.case_split then begin
										(*
											Doing case splitting based on the guard.
										*)
										  Debug.devel_pprint
											("rewrite_coercion: guard is not satisfied, " ^ "splitting.\n") pos;
										  let neg_guard = CP.mkNot lhs_guard_new pos in
										  let f0 = normalize f
											(formula_of_heap node pos) pos in
										  let f1 = normalize f0
											(formula_of_pure neg_guard pos) pos in
											(* unfold the case with the negation of the guard. *)
										  let f1 = unfold prog f1 p1 pos in
										  let f2 = normalize f0
											(formula_of_pure lhs_guard_new pos) pos in
											(* f2 need no unfolding, since next time
											   coercion is reapplied,
											   the guard is guaranteed to be satisified *)
										  let new_f = mkOr f1 f2 pos in
											if (not(!Globals.lemma_heuristic) && (get_estate_must_match estate)) then
											((*print_string("disable distribution\n"); *)enable_distribution := false);
											(true, new_f)
										end else begin
										  Debug.devel_pprint
											("rewrite_coercion: guard is not satisfied, "
											 ^ "no splitting.\n") pos;
										  (false, mkTrue no_pos)
										end
								  end
							end
								| _ -> (false, mkTrue no_pos)
							(*end	*)
							in
(*******************************************************************************************************************************************************************************************)
						  let apply_universal coer =
(*******************************************************************************************************************************************************************************************)
							flush stdout;
							if Util.empty coer.coercion_univ_vars then ([], Failure)
							else begin
							  let f = mkBase resth1 lhs_p lhs_t pos in
							  let _ = Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: apply_universal: "
														  ^ "c1 = " ^ c1 ^ ", c2 = " ^ c2 ^ "\n") pos in
								do_universal anode f coer
							end
						  in

(*******************************************************************************************************************************************************************************************)
(* apply_left_coercion *)
(*******************************************************************************************************************************************************************************************)
						let apply_left_coercion coer =
							(*let _ = print_string("left coercion\n") in*)
							let f = mkBase resth1 lhs_p lhs_t pos in
							let _ = Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
														^ "left_coercion: c1 = "
														^ c1 ^ "\n") pos in
								let ok, new_lhs = rewrite_coercion anode f coer in
								  if ok then begin
									let new_ctx1 = build_context ctx0 new_lhs pos in
									  (* let new_ctx = set_context_formula ctx0 new_lhs in *)
									let new_ctx = (set_context_must_match new_ctx1) in
									let res, tmp_prf = heap_entail prog is_folding false [new_ctx] conseq pos in
									let prf = mkCoercionLeft ctx0 conseq coer.coercion_head
									  coer.coercion_body tmp_prf coer.coercion_name
									in
									  (res, [prf])
								  end else ([], [])
						in

(*******************************************************************************************************************************************************************************************)
(* apply_right_coercion *)
(*******************************************************************************************************************************************************************************************)
						  let apply_right_coercion coer =
							(*let _ = print_string("right coercion\n") in*)
							let f = mkBase resth2 rhs_p rhs_t pos in
							let _ = Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
														^ "right_coercion: c2 = "
														^ c2 ^ "\n") pos in
							  if is_coercible ln2 then
									let ok, new_rhs = rewrite_coercion ln2 f coer in
									  if ok then begin
										let new_ctx = (set_context_must_match ctx0) in
										let res, tmp_prf = heap_entail prog is_folding false [new_ctx] new_rhs pos in
										let prf = mkCoercionRight ctx0 conseq coer.coercion_head
										  coer.coercion_body tmp_prf  coer.coercion_name
										in
										  (res, [prf])
									  end else ([], [])
							  else ([], []) in

(*******************************************************************************************************************************************************************************************)
					(* do_coercion *)
(*******************************************************************************************************************************************************************************************)
						  let do_coercion () =
							Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: do_coercion: " ^ "c1 = " ^ c1 ^ ", c2 = " ^ c2 ^ "\n") pos;
							let coers1 = look_up_coercion_def_raw prog.prog_left_coercions c1 in
							let coers1, univ_coers = List.partition (fun c -> Util.empty c.coercion_univ_vars) coers1 in
							  (* universal coercions *)
							(*let _ = print_string("[do_coercion]: number of univ coer " ^ (string_of_int (List.length univ_coers)) ^ "--> call apply universal \n") in*)
							let univ_res_tmp = List.map apply_universal univ_coers in
							let univ_res, _ = List.split univ_res_tmp in
							let univ_res = List.concat univ_res in
							  (* left coercions *)
							(*let _ = print_string("[do_coercion]: number of univ coer " ^ (string_of_int (List.length coers1)) ^ "--> call apply_left_coercion\n") in  *)
							let tmp1 = List.map apply_left_coercion coers1 in
							let tmp_res1, tmp_prf1 = List.split tmp1 in
							let tmp_res1 = List.concat tmp_res1 in
							let tmp_prf1 = List.concat tmp_prf1 in
							  (* a quick hack *)
							let tmp_res1 = univ_res @ tmp_res1 in
							  (* right coercions *)
							let coers2 = look_up_coercion_def_raw prog.prog_right_coercions c2 in
							let tmp2 = List.map apply_right_coercion coers2 in
							let tmp_res2, tmp_prf2 = List.split tmp2 in
							let tmp_res2 = List.concat tmp_res2 in
							let tmp_prf2 = List.concat tmp_prf2 in
							  if U.empty tmp_res1 & U.empty tmp_res2 then
							    (*let _ = print_string ("all failed\n") in*)
								([], tmp_prf1 @ tmp_prf2) (* report all failed proof in failure *)
							  else if U.empty tmp_res1 then
								(*let _ = print_string ("not all failed1\n") in*)
								(tmp_res2, tmp_prf2) (* only report the successful branch *)
							  else if U.empty tmp_res2 then
								(*let _ = print_string ("not all failed2\n") in*)
								(tmp_res1, tmp_prf1) (* only report the successful branch *)
							  else
								(*let _ = print_string ("not all failed3\n") in*)
								(tmp_res2 @ tmp_res1, tmp_prf1 @ tmp_prf2)
						  in
(*******************************************************************************************************************************************************************************************)
(*  back in heap_entail_non_empty_rhs_heap *)
(*******************************************************************************************************************************************************************************************)
						  (********************************)
						  (* start the main case analysis *)
						  (********************************)

							if r_flag = Root then begin (* matching occurs at root *)
							  if c1 = c2 then begin (* base case reduction *)
								Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: using " ^ (Cprinter.string_of_h_formula anode)	^ " to prove " ^ (Cprinter.string_of_h_formula ln2)) pos;
								(*let _ = print_string ("alias: " ^ (Cprinter.string_of_h_formula anode)	^ " for " ^ (Cprinter.string_of_h_formula ln2) ^ "\n") in*)
								let rho = List.combine v2 v1 in
								let (expl_inst, ivars', expl_vars') = (get_eqns_expl_inst rho estate.es_ivars pos) in
								(* to_lhs only contains bindings for free vars that are not to be explicitly instantiated *)
								let to_lhs = get_eqns_free rho estate.es_evars (estate.es_expl_vars@expl_vars') pos in
								(*let _ = print_string("to_lhs: " ^ (Cprinter.string_of_pure_formula to_lhs) ^ "\n") in*)
(*todo: the expl_vars i think whould be expl_vars - exist_vars: verify the any expl_inst is not in the expl_vars *)
								(*********************************************************************)
								(* handle both explicit and implicit instantiation *)
								(* for the universal vars from universal lemmas, we use the explicit instantiation mechanism,  while, for the rest of the cases, we use implicit instantiation *)
								(* explicit instantiation is like delaying the movement of the bindings for the free vars from the RHS to the LHS *)
								(********************************************************************)
								let new_ante = (mkBase resth1 (CP.mkAnd lhs_p to_lhs pos) lhs_t pos) in
								let tmp_conseq = mkBase resth2 rhs_p rhs_t pos in
								(* apply the new bindings to the consequent *)
								let tmp_conseq' = subst_avoid_capture v2 v1 tmp_conseq in
								let tmp_h2, tmp_p2, _ = split_components tmp_conseq' in
								let new_conseq = mkBase tmp_h2 tmp_p2 rhs_t pos in
								let new_consumed = mkStarH anode estate.es_heap pos in
								let new_es = {estate with es_formula = new_ante;
											(* add the new vars to be explicitly instantiated *)
											es_expl_vars = estate.es_expl_vars@expl_vars';
											(* update ivars - basically, those univ vars for which binsings have been found will be removed:
												for each new binding uvar = x, uvar will be removed from es_ivars and x will be added to the es_expl_vars *)
											es_ivars = ivars';
											es_heap = new_consumed} in
								let new_subst = (obtain_subst expl_inst) in
								(* apply the explicit instantiations to the consequent *)
								let new_conseq = subst_avoid_capture (fst new_subst) (snd new_subst) new_conseq in
								(* for each expl inst vi = wi: make wi existential + remove vi from the exist vars *)
								let new_es' = {new_es with es_evars = new_es.es_evars @ (snd new_subst); es_must_match = false} in
					            let new_es = pop_exists_estate (fst new_subst) new_es' in
								let new_ctx = Ctx new_es in
									Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
													  ^ "new_ctx after matching: "
													  ^ (Cprinter.string_of_spec_var p2) ^ "\n"
													  ^ (Cprinter.string_of_context new_ctx)) pos;
									Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: "
													  ^ "new_conseq after matching:\n"
													  ^ (Cprinter.string_of_formula new_conseq))
										pos;
								let res_es1, prf1 = heap_entail_conjunct prog is_folding is_universal
									new_ctx new_conseq pos in
								let copy_enable_distribution = !enable_distribution in
								let res_es2, prf2 =
(*******************************************************************************************************************************************************************************************)
(* call to do_coercion *)
(* try coercion as well *)
(*******************************************************************************************************************************************************************************************)
								if is_view anode then
									(Debug.devel_pprint ("do_coercion for " ^ (Cprinter.string_of_h_formula anode) ^ "\n") pos;
									do_coercion ())
								else ([], []) in
								  enable_distribution := copy_enable_distribution;
								  let prf1 = mkMatch ctx0 conseq ln2 [prf1] in
								  let prf = mkMatch ctx0 conseq ln2 (prf1 :: prf2) in
									(* prf is the combined proof of both matching and coercion *)
									if U.empty res_es1 & U.empty res_es2 then
									  (*let _ = print_string ("both fail\n") in	 *)
									  ([], prf) (* both fail *)
									else if U.empty res_es1 then
									   (*let _ = print_string ("first fails\n") in	*)
									  (res_es2, mkCoercion2 ctx0 conseq prf2)
									else if U.empty res_es2 then
										begin
											if (not(prf1 = Failure)) then
											enable_distribution := true;
											(*print_string("enable distribution\n");*)
											(res_es1, prf1)
										end
									else (* both ok *)
									  (res_es2 @ res_es1, prf)
							  end else if is_view ln2 && is_data anode then begin (* fold *)
								Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: folding: "
													^ (Cprinter.string_of_spec_var p2)
													^ "\nante:\n"
													^ (Cprinter.string_of_formula ante)
													^ "\nln2:\n"
													^ (Cprinter.string_of_h_formula ln2)
													^ "\nrhs_p:\n"
													^ (Cprinter.string_of_pure_formula rhs_p)) pos;
								do_fold p2
							  end else if is_data ln2 && is_view anode then begin (* unfold *)
								let delta1 = unfold prog ante p1 pos in
								let ctx1 = build_context ctx0 delta1 pos in
								let res_rs, prf1 = heap_entail_one_context prog
								  is_folding is_universal ctx1 conseq pos in
								let prf = mkUnfold ctx0 conseq anode prf1 in
								  (res_rs, prf)
							  end else if !Globals.use_coercion then begin
								(* two different predicates match, try coercion *)
								Debug.devel_pprint ("heap_entail_non_empty_rhs_heap: " ^ "trying coercion") pos;
								let res, prfs = do_coercion () in
								let prf = mkCoercion2 ctx0 conseq prfs in
								  (res, prf)
							  end else begin
								Debug.devel_pprint ("heap_entail_conjunct: " ^ "can't reduce, fold, unfold") pos;
								([], Failure)
							  end
							end else if !Globals.use_coercion then
							  (* there is a match at some node, but not at root *)
							  if is_data ln2 && r_flag = Arg then begin
								Debug.devel_pprint ("heap_entail_conjunct: matching of data node"
													^ " with non-materialized argument") pos;
								([], NoAlias) (* there no hope an alias at
												 non-materialized arg would expose an object *)
							  end else
								let res, prfs = do_coercion () in
								let prf = mkCoercion2 ctx0 conseq prfs in
								  (res, prf)
							else
							  ([], NoAlias)
					  | _ -> report_error pos
						  ("heap_entail_conjunct: something wrong has happened "
						   ^ "with get_aliased_node") in

				  (* check one match *)
				  let rec check_node_helper all_nodes remaining_nodes : (context list * proof list) = match all_nodes with
					| (anode, r_flag) :: rest ->
						let tmp_rest = List.map fst rest in
						let rest_heap = List.fold_left (fun h1 -> fun h2 -> mkStarH h1 h2 pos)
						  resth1 (remaining_nodes @ tmp_rest) in
						let rs1, prf1 = check_aliased_node (anode, r_flag) rest_heap in
						let rs2, prfs2 =
						  if !Globals.use_set then check_node_helper rest
							(anode :: remaining_nodes)
						  else ([], [])
						in
						  (rs1 @ rs2, prf1 :: prfs2)
					| [] -> ([], []) in

				  (* finally, check all matches  *)
				  let rs, prfs = check_node_helper matches [] in
(*
					if U.empty rs && is_view ln2 && is_complex_heap lhs_h then begin
					  (* ln2 may be an empty view, check that and if so,
                         restart entailment check without ln2 *)
					  let pure_lhs = formula_of_pure lhs_p pos in
					  let pure_ctx = set_context_formula ctx0 pure_lhs in
						(* let ln2_f = formula_of_heap ln2 pos in
						   let rs1 = heap_entail_conjunct prog is_folding pure_ctx ln2_f pos in *)
					  let rs1, fold_prf = fold prog pure_ctx ln2 (CP.mkTrue pos) pos in
						if U.empty rs1 then
						  let fold_prf = mkFold ctx0 conseq p2 fold_prf [] in
						  let prf = mkMMatch ctx0 conseq ln2 (fold_prf :: prfs) in
							([], prf)
						else begin
						  let lhs_hf = formula_of_heap lhs_h pos in
						  let new_rs1 = List.map
                            (fun c -> normalize_context_formula c lhs_hf pos) rs1 in
						  let b = { formula_base_heap = resth2;
									formula_base_pure = rhs_p;
									formula_base_type = rhs_t;
									formula_base_pos = pos } in
						  let tmp, tmp_prfs = process_fold_result prog
                            is_folding estate new_rs1 p2 v2 b pos in
						  let prf = mkFold ctx0 conseq p2 fold_prf tmp_prfs in
							(tmp, prf)
						end
					end else
*)
					  let prf =
						if U.empty (List.tl prfs) then List.hd prfs
						else mkMMatch ctx0 conseq ln2 prfs
					  in
						(rs, prf)
				end
		end
	  | HFalse | HTrue | Star _ -> failwith ("heap_entail_conjunct: "
											 ^ "something bad has happened to split_linear_node")

(*************************************************************************************************************************
	05.06.2008:
	Utilities for existential quantifier elimination:
	- before we were only searching for substitutions of the form v1 = v2 and then substitute ex v1. P(v1) --> P(v2)
	- now, we want to be more aggressive and search for substitutions of the form v1 = exp2; however, we can only apply these substitutions to the pure part
	(due to the way shape predicates are recorded --> root pointer and args are suppose to be spec vars)
	- also check that v1 is not contained in FV(exp2)
*************************************************************************************************************************)

(* apply elim_exist_exp_loop until no change *)
and elim_exists_exp (f0 : formula) : (formula) =
	let f, flag = elim_exists_exp_loop f0 in
		if flag then (elim_exists_exp f)
		else begin
			(*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_formula f ^ "\n") in
			let qvar, base = CF.split_quantifiers f in
			let h, p, t = CF.split_components base in
			let simpl_p = elim_exists_pure qvar p no_pos in
			let simpl_f = CF.mkExists qvar h simpl_p t no_pos in
			let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_formula simpl_f ^ "\n") in
				simpl_f *) f
		end

(* removing existentail using ex x. (x=e & P(x)) <=> P(e) *)
and elim_exists_exp_loop (f0 : formula) : (formula * bool) = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) ->
	  let ef1, flag1 = elim_exists_exp_loop f1 in
	  let ef2, flag2 = elim_exists_exp_loop f2 in
		(mkOr ef1 ef2 pos, flag1 & flag2)
  | Base _ -> (f0, false)
  | Exists ({formula_exists_qvars = qvar :: rest_qvars;
			 formula_exists_heap = h;
			 formula_exists_pure = p;
			 formula_exists_type = t;
			 formula_exists_pos = pos}) ->
		let fvh = h_fv h in
		(*let _ = print_string("Try to eliminate " ^ Cprinter.string_of_spec_var qvar ^ "\n") in*)
		if  not(List.exists (fun sv -> CP.eq_spec_var sv qvar) fvh) then
		(*List.mem qvar fvh)	then*) (* if it does not appear in the heap part --> we try to eliminate *)
		(*let _ = print_string("fv(h) = " ^ Cprinter.string_of_spec_var_list fvh ^ "\n") in*)
		  let st, pp1 = get_subst_equation_exp p qvar in
				if List.length st > 0 then (* if there exists one substitution  - actually we only take the first one -> therefore, the list should only have one elem *)
		  		(* basically we only apply one substitution *)
		  		let one_subst = List.hd st in
		  		(*let _ = print_string ("\nLength = " ^ string_of_int (List.length st) ^ "\n") in
		  		let _ =  print_string("\n Using the subst var: " ^ Cprinter.string_of_spec_var (fst one_subst) ^ "\texp: " ^ Cprinter.string_of_formula_exp (snd one_subst) ^ "\n") in*)
		  		let tmp = mkBase h pp1 t pos in
		  		(*let _ = (print_string (" Base formula: " ^ (Cprinter.string_of_formula tmp) ^ "\n")) in*)
				  let new_baref = subst_exp [one_subst] tmp in
 		  		(*let _ = (print_string (" new_baref: " ^ (Cprinter.string_of_formula new_baref) ^ "\n")) in*)
				  let tmp2 = add_quantifiers rest_qvars new_baref in
				  let tmp3, _ = elim_exists_exp_loop tmp2 in
					(tmp3, true)
				else (* if qvar is not equated to any variables, try the next one *)
				  let tmp1 = mkExists rest_qvars h p t pos in
				  let tmp2, flag = elim_exists_exp_loop tmp1 in
				  let tmp3 = add_quantifiers [qvar] tmp2 in
					(tmp3, flag)
		else (* anyway it's going to stay in the heap part so we can't eliminate --> try eliminate the rest of them, and then add it back to the exist quantified vars *)
			let tmp1 = mkExists rest_qvars h p t pos in
		  let tmp2, flag = elim_exists_exp_loop tmp1 in
		  let tmp3 = add_quantifiers [qvar] tmp2 in
				((push_exists [qvar] tmp3), flag)

  | Exists _ -> failwith ("Solver.elim_exists: Exists with an empty list of quantified variables")

and get_subst_equation_exp (f : CP.formula) (v : CP.spec_var) : ((CP.spec_var * CP.exp) list * CP.formula) = match f with
  | CP.And (f1, f2, pos) ->
	  let st1, rf1 = get_subst_equation_exp f1 v in
		if List.length st1 > 0 then (* should never be more than 1 *)
		  (st1, CP.mkAnd rf1 f2 pos)
		else
		  let st2, rf2 = get_subst_equation_exp f2 v in
			(st2, CP.mkAnd f1 rf2 pos)
  | CP.BForm bf -> get_subst_equation_b_formula_exp bf v
  | _ -> ([], f)

and get_subst_equation_b_formula_exp (f : CP.b_formula) (v : CP.spec_var) : ((CP.spec_var * CP.exp) list * CP.formula) = match f with
  | CP.Eq (e1, e2, pos) -> begin
	  match e1 with
		| CP.Var (sv1, pos1) ->
			(* check for equality and for circularity -> if v=e then v should not appear in FV(e) *)
			if (CP.eq_spec_var sv1 v) && (not (List.exists (fun sv -> CP.eq_spec_var sv v) (CP.afv e2)))
				(*(List.mem v (CP.afv e2))) *)
				then ([(v, e2)], CP.mkTrue no_pos)
			else
			begin
				match e2 with
				| CP.Var (sv2, pos2) ->
				if CP.eq_spec_var sv2 v && (not (List.exists (fun sv -> CP.eq_spec_var sv v) (CP.afv e1)))
					(*(not (List.mem v (CP.afv e1))) *)
					then ([(v, e1)], CP.mkTrue no_pos)
				else ([], CP.BForm f)
				| _ -> ([], CP.BForm f)
			end
		| _ ->
			begin
				match e2 with
				| CP.Var (sv2, pos2) ->
				if CP.eq_spec_var sv2 v && (not (List.exists (fun sv -> CP.eq_spec_var sv v) (CP.afv e1)))
					(*(not (List.mem v (CP.afv e1))) *)
					then ([(v, e1)], CP.mkTrue no_pos)
				else ([], CP.BForm f)
				| _ -> ([], CP.BForm f)
			end
	end
	| _ -> ([], CP.BForm f)

(******************************************************************************************************************
	10.06.2008
	Utilities for simplifications:
	- whenever the pure part contains some arithmetic formula that can be further simplified --> call the theorem prover to perform the simplification
	Ex. x = 1 + 0 --> simplify to x = 1
******************************************************************************************************************)
and simpl_pure_formula (f : CP.formula) : CP.formula = match f with
  | CP.And (f1, f2, pos) -> CP.mkAnd (simpl_pure_formula f1) (simpl_pure_formula f2) pos
  | CP.Or (f1, f2, pos) -> CP.mkOr (simpl_pure_formula f1) (simpl_pure_formula f2) pos
  | CP.Not (f1, pos) -> CP.mkNot (simpl_pure_formula f1) pos
  | CP.Forall (sv, f1, pos) -> CP.mkForall [sv] (simpl_pure_formula f1) pos
  | CP.Exists (sv, f1, pos) -> CP.mkExists [sv] (simpl_pure_formula f1) pos
  | CP.BForm (f1) ->
  		let simpl_f = CP.BForm(simpl_b_formula f1) in
    	(*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_pure_formula f ^ "\n") in
			let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_pure_formula simpl_f ^ "\n") in*)
			simpl_f

and simpl_b_formula (f : CP.b_formula) : CP.b_formula =  match f with
	| CP.Lt (e1, e2, pos)
	| CP.Lte (e1, e2, pos)
	| CP.Gt (e1, e2, pos)
	| CP.Gte (e1, e2, pos)
	| CP.Eq (e1, e2, pos)
	| CP.Neq (e1, e2, pos)
	| CP.BagSub (e1, e2, pos) ->
		if ((count_iconst e1) > 1) or ((count_iconst e2) > 1) then
			(*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_b_formula f ^ "\n") in*)
			let simpl_f = TP.simplify (CP.BForm(f)) in
  		begin
  		match simpl_f with
  		| CP.BForm(simpl_f1) ->
  			(*let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_b_formula simpl_f1 ^ "\n") in*)
  			simpl_f1
  		| _ -> f
  		end
  	else f
	| CP.EqMax (e1, e2, e3, pos)
	| CP.EqMin (e1, e2, e3, pos) ->
		if ((count_iconst e1) > 1) or ((count_iconst e2) > 1) or ((count_iconst e3) > 1) then
			(*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_b_formula f ^ "\n") in*)
			let simpl_f = TP.simplify (CP.BForm(f)) in
  		begin
  		match simpl_f with
  		| CP.BForm(simpl_f1) ->
  			(*let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_b_formula simpl_f1 ^ "\n") in*)
  			simpl_f1
  		| _ -> f
  		end
  	else f
  | CP.BagIn (sv, e1, pos)
  | CP.BagNotIn (sv, e1, pos) ->
  	if ((count_iconst e1) > 1) then
			(*let _ = print_string("\n[solver.ml]: Formula before simpl: " ^ Cprinter.string_of_b_formula f ^ "\n") in*)
			let simpl_f = TP.simplify (CP.BForm(f)) in
  		begin
  		match simpl_f with
  		| CP.BForm(simpl_f1) ->
  			(*let _ = print_string("\n[solver.ml]: Formula after simpl: " ^ Cprinter.string_of_b_formula simpl_f1 ^ "\n") in*)
  			simpl_f1
  		| _ -> f
  		end
  	else f
	| _ -> f

(*
	- count how many int constants are contained in one expression
	- if there are more than 1 --> means that we can simplify further (by performing the operation)
*)
and count_iconst (f : CP.exp) = match f with
  | CP.Subtract (e1, e2, _)
  | CP.Add (e1, e2, _) -> ((count_iconst e1) + (count_iconst e2))
  | CP.Mult (_, e2, _) -> (1 + (count_iconst e2))
	| CP.IConst _ -> 1
	| _ -> 0
