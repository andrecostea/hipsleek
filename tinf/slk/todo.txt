# termu-1c.ss

Why isn't @term entailment logged?

id: 1; caller: []; line: 10; classic: false; kind: POST; hec_num: 2; evars: []; infer_vars: []; c_heap: emp
============================================================
DONE # fact2b.ss

why give printing when no termination inference
or verification is requested?

*************************
* TERMINATION INFERENCE *
*************************
Temporal Assumptions:

>> FIXED
============================================================
# termu-1c3.ss

!!!Number of sleek log entries 7
!!!Logging logs/sleek_log_termu-1c3_ss.txt

Why only 1 logged entry printed?
============================================================
DONE # termu-1c4.ss

why are there 4 termination assumptions?

I was expecting just 3:

infer [@term] x>=0 & fpre(x) & x'=x-1 |- fpre(x').

infer [@term] x>=0 & fpre(x) & x'=x-1 & fpost(x') |- fpost(x).

infer [@term] x<0 & Term[] |- fpost(x).

>> Due to case spec, we need to prove postconditions of two
cases (x' >= 0 and x' < 0) when the input x >= 0.
============================================================
# termu-1c4.ss

UTPre@f fpre(int x).
UTPost@f fpost(int x).

Perhaps fpost need not carry any parameter; as
the purpose is to capture base versus recursive cases.

>> We need parameters for fpost to do exists elim (mostly for sleek).

I guess it is sufficient to declare:

UTPost@f fpost().

checkentail Term[] |- fpost@f().
// ok

checkentail Loop |- fpost@f().
// should check for false leh..


========================================================
infer [@term] x<0 & Term[] |- fpost().
print residue.
/*
# exp-u-1c4a.slk // 2

 inferred UTPost rel: [emp&x<0&
                        {FLOW,(21,22)=__norm}[]: [] -> TermR@f{0, true}()]
should use:
  x<0 & Term[] -> TermR@f{..}

*/

infer [] x<0 & Loop |- fpost().
print residue.
/*
# exp-u-1c4a.slk // 3

Got below but should fail!

Entail (3) : Valid. 
 <1>emp&Loop[] & x<0&{FLOW,(21,22)=__norm}[]
[[empty]]
*/

infer [@term] x<0 & Loop |- fpost().
print residue.
/*
# exp-u-1c4a.slk // 4

Got below but should attempt to infer false on conseq

 <1>emp&Loop[] & x<0&{FLOW,(21,22)=__norm}[]
 inferred UTPost rel: [emp&x<0&
                        {FLOW,(21,22)=__norm}[]: [] -> TermR@f{0, true}()]


========================================================
# fact.ss

non-linear cannot be handled. Can we at least remove or
transform them, so they can be partially handled.

Temporal Assumptions:
 termAssume 1<=v_int_16_922 & x'=v_int_16_919+1 & !(v_bool_15_880') & 
x'!=0 & !(v_bool_15_880') & x=x' & x'!=0 & v_int_16_879'=x'*v_int_16_922 & 
res=v_int_16_879' & fpost(v_int_16_877') --> fpost(x).

 termAssume x'=0 & x=x' & v_bool_15_880' & x'=x' & v_bool_15_880' & 
v_int_15_875'=1 & res=v_int_15_875' --> fpost(x).

 termAssume x'!=0 & x=x' & !(v_bool_15_880') & x'!=0 & !(v_bool_15_880') & 
x'=v_int_16_877'+1 & fpre(x) --> fpre(v_int_16_877').

Starting Omega...oc
Omega Error Exp:Globals.Illegal_Prover_Format("[omega.ml] Non-linear arithmetic is not supported by Omega.")
============================================================
DONE # fact2.ss

int fact(int x)
  infer [@term]
  requires true & fpre(x)
  ensures res>=1 & fpost(); //maybe just use TPost@f


 Derived x-1 as ranking function;maybe can have a simplification which
 returns x instead?


Termination Inference Result:
f:  case {
  1<=x -> requires emp & Term[-1+(1*x)]
 ensures emp & true; 
  x<=(0-1) -> requires emp & Loop[]
 ensures false & false; 
  x=0 -> requires emp & Term[]
 ensures emp & true; 
 
>> x-1 is the most correct ranking function for the case x >= 1

============================================================
DONE # fact2a.ss

Why continue with term inference after post-cond 
proving has failed?

Post condition cannot be derived:
  (may) cause:  res=v_int_13_948+1 |-  1<=res. LOCS:[13;8] (may-bug)

>> FIXED

============================================================
DONE # fact2c.ss

int fact(int x)
  infer [@term]
  case {
    x = 0 -> requires Term[] ensures res>=1 & fpost();
    x != 0 -> requires fpre(x) ensures res>=1 & fpost();
  }

{
  if (x==0) return 1;
  else return 1+fact(x - 1);
}

why did this fail  detect loop?

It also obtained a worse result than the
given partial spec.

>> We need fpost(x) to determine base case correctly.
>> FIXED: only collect temporal relations from methods in same scc

========================================================
DONE # exp-fact2c.slk

shouldn't this be a type error?

Entailment Problem (3) Failure("number of arguments for unknown temporal fpost does not match")

>> Due to fpost(x) in the third infer command
>> infer [@term] x!=0 & fpre(x) & x'=x-1 & fpost(x) |- fpost().
============================================================
# fact2c.ss

Two problems
(i) We seems to have lost the res>=1 post-state.
(ii) I think too many base cases here.

Fixing (i) is critical. Fixing (ii) is desirable.

For (i)0, why did we getfour (4)4 termination assumption.
If we had 3, we would obtain the right number of
cases, as follows:

# exp-fact2c1.slk

Temporal Assumptions:
 termAssume 1<=r & res=r+1 & x=x'+1 & x!=0 & fpost(x') --> fpost(x).

 termAssume res=1 & x=0 --> fpost(x).

 termAssume x=x'+1 & x!=0 & fpre(x) --> fpre(x').


Base/Rec Case Splitting:
[	f: [[2] 1<=x@R,[3] x<=(0-1)@R,[4] x=0@B]
]
Starting z3... 
Termination Inference Result:
f:  case {
  1<=x -> requires emp & Term[3,-1+(1*x)]
 ensures emp & true; 
  x<=(0-1) -> requires emp & Loop[]
 ensures false & false; 
  x=0 -> requires emp & Term[1]
 ensures emp & true; 
  }
============================================================
# exp-fact2c3.slk

 termAssume //x'!=0
    x=x'+1 & x!=0 & fpost(x') --> fpost(x).

 //termAssume x'=0 & x=x'+1 & x!=0 & fpost(x') --> fpost(x).

 termAssume x=0 --> fpost(x).

 termAssume x'=0 & x=x'+1 & x!=0 & fpre(x) --> fpre(x').

 termAssume x'!=0 & x=x'+1 & x!=0 & fpre(x) --> fpre(x').


If we merge the first 2 term assume of
rec post, we will end up with the desired result.

f:  case {
  1<=x -> requires emp & Term[7,-1+(1*x)]
 ensures emp & true; 
  x<=(0-1) -> requires emp & Loop[]
 ensures false & false; 
  x=0 -> requires emp & Term[5]
 ensures emp & true; 
  }

============================================================
============================================================
========================================================
============================================================
============================================================
============================================================
============================================================
========================================================
