# termu-1c.ss

Why isn't @term entailment logged?

id: 1; caller: []; line: 10; classic: false; kind: POST; hec_num: 2; evars: []; infer_vars: []; c_heap: emp
============================================================

============================================================
# termu-1c3.ss

!!!Number of sleek log entries 7
!!!Logging logs/sleek_log_termu-1c3_ss.txt

Why only 1 logged entry printed?
============================================================
# termu-1c4.ss

why are there 4 termination assumptions?

I was expecting just 3:

infer [@term] x>=0 & fpre(x) & x'=x-1 |- fpre(x').

infer [@term] x>=0 & fpre(x) & x'=x-1 & fpost(x') |- fpost(x).

infer [@term] x<0 & Term[] |- fpost(x).

>> Due to case spec, we need to prove postconditions of two
cases (x' >= 0 and x' < 0) when the input x >= 0.
============================================================
# termu-1c4.ss

UTPre@f fpre(int x).
UTPost@f fpost(int x).

Perhaps fpost need not carry any parameter; as
the purpose is to capture base versus recursive cases.
I guess it is sufficient to declare:

UTPost@f fpost().

checkentail Term[] |- fpost@f().
// ok

checkentail Loop |- fpost@f().
// should check for false leh..

>> We need parameters for fpost to do exists elim (mostly for sleek).

========================================================
infer [@term] x<0 & Term[] |- fpost().
print residue.
/*
# exp-u-1c4a.slk // 2

 inferred UTPost rel: [emp&x<0&
                        {FLOW,(21,22)=__norm}[]: [] -> TermR@f{0, true}()]
should use:
  x<0 & Term[] -> TermR@f{..}

*/

infer [] x<0 & Loop |- fpost().
print residue.
/*
# exp-u-1c4a.slk // 3

Got below but should fail!

Entail (3) : Valid. 
 <1>emp&Loop[] & x<0&{FLOW,(21,22)=__norm}[]
[[empty]]
*/

infer [@term] x<0 & Loop |- fpost().
print residue.
/*
# exp-u-1c4a.slk // 4

Got below but should attempt to infer false on conseq

 <1>emp&Loop[] & x<0&{FLOW,(21,22)=__norm}[]
 inferred UTPost rel: [emp&x<0&
                        {FLOW,(21,22)=__norm}[]: [] -> TermR@f{0, true}()]


========================================================
# fact.ss

non-linear cannot be handled. Can we at least remove or
transform them, so they can be partially handled.

Temporal Assumptions:
 termAssume 1<=v_int_16_922 & x'=v_int_16_919+1 & !(v_bool_15_880') & 
x'!=0 & !(v_bool_15_880') & x=x' & x'!=0 & v_int_16_879'=x'*v_int_16_922 & 
res=v_int_16_879' & fpost(v_int_16_877') --> fpost(x).

 termAssume x'=0 & x=x' & v_bool_15_880' & x'=x' & v_bool_15_880' & 
v_int_15_875'=1 & res=v_int_15_875' --> fpost(x).

 termAssume x'!=0 & x=x' & !(v_bool_15_880') & x'!=0 & !(v_bool_15_880') & 
x'=v_int_16_877'+1 & fpre(x) --> fpre(v_int_16_877').

Starting Omega...oc
Omega Error Exp:Globals.Illegal_Prover_Format("[omega.ml] Non-linear arithmetic is not supported by Omega.")
============================================================
# fact2.ss

int fact(int x)
  infer [@term]
  requires true & fpre(x)
  ensures res>=1 & fpost(); //maybe just use TPost@f


 Derived x-1 as ranking function;maybe can have a simplification which
 returns x instead?


Termination Inference Result:
f:  case {
  1<=x -> requires emp & Term[-1+(1*x)]
 ensures emp & true; 
  x<=(0-1) -> requires emp & Loop[]
 ensures false & false; 
  x=0 -> requires emp & Term[]
 ensures emp & true; 

============================================================
# fact2a.ss

Why continue with term inference after post-cond 
proving has failed?

Post condition cannot be derived:
  (may) cause:  res=v_int_13_948+1 |-  1<=res. LOCS:[13;8] (may-bug)

============================================================
# fact2c.ss

int fact(int x)
  infer [@term]
  case {
    x = 0 -> requires Term[] ensures res>=1 & fpost();
    x != 0 -> requires fpre(x) ensures res>=1 & fpost();
  }

{
  if (x==0) return 1;
  else return 1+fact(x - 1);
}

why did this fail  detect loop?

It also obtained a worse result than the
given partial spec.
============================================================
============================================================
============================================================
============================================================
========================================================
============================================================
============================================================
============================================================
============================================================
========================================================
