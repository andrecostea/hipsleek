# test/ls3.slk

checkentail x::lseg<p,n> & n>=0 |- x::lseg<q1,a>.
print residue.
/*
Two solutions when n>=0 added explicitly. 
Need a way to add this information implicitly.
# add invariant prior to lemma rewriting?

Entail 1: Valid. 

 <1>emp&0<=n & p=q1 & a=n&{FLOW,(21,22)=__norm}[]
[[ SEARCH ==>  COND ==>  Match ==> ]]
<2>q1::lseg<p,b_60>@M&0<=n & 0<=b_60 & b_60<=n & n=b_60+a & 0<=a & 0<=b_60&{FLOW,(21,22)=__norm}[]
[[ SEARCH ==>  (Lemma ==> lem_11) ==>  Match ==> ]]
====================================================================
# ls6b3.slk -dre ".*coercion_check"

lemma_test
  self::ns<p,n> <- self::lseg<p,n>.
// unsound

SOLUTION : Need to unfold RHS (inp2)

process_coercion_check inp1 : 
 emp&p=self_lem_12 & n=0&{FLOW,(21,22)=__norm}[]
 or (exists p_80,flted_7_81,q_82: self_lem_12::node<q_82>@M * 
    q_82::lseg<p_80,flted_7_81>@M&n=flted_7_81+1 & p=p_80&
    {FLOW,(21,22)=__norm})[]
 
process_coercion_check inp2 : EBase self_lem_12::ns<p,n>@M&{FLOW,(21,22)=__norm}[]
====================================================================
# ls6b4.slk --dis-lem-rhs-unfold

lemma_test
  self::ns<p,n> <-> self::lseg<p,n>.

why is this unsound for <-- ?

For folding lhs <- rhs
we convert to:
  unfold(rhs) --> lhs

However, this is unsound if rhs is actually
weaker. An issue is why is folding unsound
under such a scenario?
====================================================================
# ls7a.slk

Need to add case-analysis for RHS unfolding.

lemma_test
  self::lseg<p,n> & a>=0 & b>=0 & n=a+b
  <- self::lseg<q,a> * q::lseg<p,b>.

--en-lem-rhs-unfold causes incompleteness in the above due
to lack of case expression.  I think we need to convert to
case expression for the RHS-unfolded term, as shown below:

 |- case { 
     n=0 -> [] p=self_lem_11;
     n!=0 -> [] (exists q_82,p_88,flted_7_89:
        self_lem_11::node<q_82>@M * 
          q_82::lseg<p_88,flted_7_89>@M&n=flted_7_89+1 & p=p_88);
   }.

It needs to look for contradicting pure expression, such
as n=0, p=self_lem_11 and self_lem_11!=null, n>0 that
are unbound; and then pick a pair that is disjoint for
case-spec; as above
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
====================================================================
