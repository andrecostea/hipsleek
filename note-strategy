

  x::node<..> * R  |- x::node<..> * Q
    ===> mandatory match


  x::pred<..> * R  |- x::node<..> * Q
    ===> mandatory unfold

  y::ll_tail<.,x> * R  |- x::node<..> * Q
    ===>  x must materialised as a node,
         then mandatory unfold or left-lemma
     - materialised wrt defn
     - materialized wrt to a given lemma

  x::pred1<..> * R  |- x::pred2<..> * Q
    ===> mandatory base-case unfold on x, if applicable


  tx::node<..>  |- x::pred1<..,tx> * Q
    ===> mandatory right-lemma, if tx materialised wrt to lemma
         mandatory fold, if tx materialised by defn?

  y::pred1<..,tx>  |- x::pred2<..,tx> * Q
    ===> mandatory unfold of y::pred1, if tx is materalised by defn
    ===> mandatory lemma on y::pred1, if tx is materalised by lemma


===========================================

  x::node<...>   |-  x::pred<..>
   // full-fold
   // or right-distr lemma

  x::pred<...>   |-  x::pred<..>
   // match 
   // or base-case fold
   // or left-lemma (distr) with cycle detection & derived nodes
   // or right-lemma (distr)

  x::pred1<...>   |-  x::pred2<..>
   // or base-case fold
   // or left-lemma(s) with pred2 target
   // or right-lemma(s) with pred1 target


