I did a quick test and both versions (short2.c; short.ss) are verifying.
The only difference (which you can see in --pcp) is that the former uses
existential

 static  :EBase exists (Expl)[](Impl)[a](ex)[](exists deref_f_r_901:
                                                      ^^^^^^^^^^^^^
while the latter uses implicit:

static  :EBase exists (Expl)[](Impl)[r; a](ex)[]q::int__star__star<r>@M *
                                    ^^
        r::int__star<a>@M&@value[q]&{FLOW,(24,25)=__norm}[]


Checking procedure main$... 
( []) :short2.c:20: 8: bind: node  addr_34'::int_star<deref_20_910'@L>@L cannot be derived from context


==================================================

int foo(int** q)
/*@
 requires q::int^^<a>
 //ensures q::int^^<a> & res=0;
 ensures q::int__star__star<r>*r::int__star<a> & res=0;
*/
{
 return 0;
};

int foo$int__star__star(  int__star__star q)
static  :EBase exists (Expl)[](Impl)[a](ex)[](exists deref_f_r_901: 
                                                     ^^^^^^^
      q::int__star__star<deref_f_r_901>@M * 
      deref_f_r_901::int__star<a>@M&@value[q]&{FLOW,(24,25)=__norm})[]
          EBase emp&MayLoop[]&{FLOW,(1,27)=__flow}[]
                  EAssume 
                    (exists a_30,r: q::int__star__star<r>@M * 
                    r::int__star<a_30>@M&res=0 & a=a_30&
                    {FLOW,(24,25)=__norm})[]

========================================

int foo(int** q)
/*@
 requires q::int__star__star<r>*r::int__star<a>
 ensures q::int__star__star<r>*r::int__star<a> & res=0;
*/
{
 return 0;
};


int foo$int__star__star(  int__star__star q)
static  :EBase exists (Expl)[](Impl)[r; a](ex)[]q::int__star__star<r>@M * 
        r::int__star<a>@M&@value[q]&{FLOW,(24,25)=__norm}[]
          EBase emp&MayLoop[]&{FLOW,(1,27)=__flow}[]
                  EAssume 
                    (exists r_30,a_31: q::int__star__star<r_30>@M * 
                    r::int__star<a_31>@M&res=0 & r=r_30 & a=a_31&
                    {FLOW,(24,25)=__norm})[]

