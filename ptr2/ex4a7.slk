
// README:

//       Use @arr_ba for bi-abduction
//       Use @arr_en for classical entailment.
// 	 Use @arr_enfr for entailment with frame inference

//       In classical entailment, by default, it will just return TRUE or FALSE.
//       To generate pre-condition instead of just TRUE or FALSE, run with "--arr-pre".
//       For example, ../../sleek ex1.slk --arr-pre
//       To print all the intermediate steps, run with --verbose-arr
      

pred_prim Aseg<end> 
     inv_exact BG([(self,end)],true). //0<=self<=end). 
// 5::Aseg<5> -- empty
// 5::Aseg<6> -- 1 elem
// 5::Aseg<10> -- 5 elems


pred_prim AsegNE<end> 
     inv_exact BG([(self,end)],0<self<end).
// non-empty 

pred_prim ElemN<start:int> 
     inv_exact BG([self], true). // non-null
// x::ElemN<2>

//(8)
checkentail xxx::ElemN<_> * yyy::AsegNE<c> |- xxx!=yyy.

/*

Should be: xxx<yyy | yyy+c<=xxx

(==cvutil.ml#984==)
generate_constraint_from_baga_range_disj@25@23
generate_constraint_from_baga_range_disj inp1 :[[xxx],[(_,( yyy, c))]]
generate_constraint_from_baga_range_disj@25 EXIT:[[ ((_+yyy)>xxx | xxx>=(_+c))]]

Entail (1) : Fail.(may) cause: xxx!=_29 & yyy<c & yyy!=null & xxx!=null |-  xxx!=yyy. LOCS:[0;1;30] (may-bug)


(==cvutil.ml#1805==)
xpure_heap_symbolic_i@20@19
xpure_heap_symbolic_i inp1 :0
xpure_heap_symbolic_i inp2 : xxx::ElemN<Anon_13>@M * yyy::AsegNE<c>@M
xpure_heap_symbolic_i@20 EXIT:( xxx!=null & yyy!=null & yyy<c,[],false)

(==cvutil.ml#982==)
collect_baga_range@21@19
collect_baga_range inp1 : xxx::ElemN<Anon_13>@M * yyy::AsegNE<c>@M
collect_baga_range@21 EXIT:[[],[(_,( yyy, c))]]

(==cvutil.ml#984==)
generate_constraint_from_baga_range_disj@22@19
generate_constraint_from_baga_range_disj inp1 :[[],[(_,( yyy, c))]]
generate_constraint_from_baga_range_disj@22 EXIT:[]

(==sleekengine.ml#1269==)
xpure_heap_symbolic#999@19
xpure_heap_symbolic#999 inp1 :0
xpure_heap_symbolic#999 inp2 : xxx::ElemN<Anon_13>@M * yyy::AsegNE<c>@M
xpure_heap_symbolic#999 inp3 : true
xpure_heap_symbolic#999@19 EXIT: xxx!=null & yyy!=null & yyy<c#[]# [[xxx,_24]]true


(==cvutil.ml#982==)
collect_baga_range@24@23
collect_baga_range inp1 : xxx::ElemN<Anon_13>@M * yyy::AsegNE<c>@M
collect_baga_range@24 EXIT:[[],[(_,( yyy, c))]]

(==cvutil.ml#984==)
generate_constraint_from_baga_range_disj@25@23
generate_constraint_from_baga_range_disj inp1 :[[],[(_,( yyy, c))]]
generate_constraint_from_baga_range_disj@25 EXIT:[]

(==cvutil.ml#2035==)
xpure_heap_mem_enum#6@23
xpure_heap_mem_enum#6 inp1 : xxx::ElemN<Anon_13>@M * yyy::AsegNE<c>@M
xpure_heap_mem_enum#6 inp2 :lhs_pure: true
xpure_heap_mem_enum#6 inp3 :xpure_int:1
xpure_heap_mem_enum#6@23 EXIT: xxx!=null & yyy!=null & yyy<c #  [[xxx,_28]]

(==cvutil.ml#982==)
collect_baga_range@27@26
collect_baga_range inp1 : xxx::ElemN<Anon_13>@M * yyy::AsegNE<c>@M
collect_baga_range@27 EXIT:[[],[(_,( yyy, c))]]

(==cvutil.ml#984==)
generate_constraint_from_baga_range_disj@28@26
generate_constraint_from_baga_range_disj inp1 :[[],[(_,( yyy, c))]]
generate_constraint_from_baga_range_disj@28 EXIT:[]

(==cvutil.ml#2035==)
xpure_heap_mem_enum#6@26
xpure_heap_mem_enum#6 inp1 : xxx::ElemN<Anon_13>@M * yyy::AsegNE<c>@M
xpure_heap_mem_enum#6 inp2 :lhs_pure: true
xpure_heap_mem_enum#6 inp3 :xpure_int:1
xpure_heap_mem_enum#6@26 EXIT: xxx!=null & yyy!=null & yyy<c #  [[xxx,_29]]

*/