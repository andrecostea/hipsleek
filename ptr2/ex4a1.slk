
// README:

//       Use @arr_ba for bi-abduction
//       Use @arr_en for classical entailment.
// 	 Use @arr_enfr for entailment with frame inference

//       In classical entailment, by default, it will just return TRUE or FALSE.
//       To generate pre-condition instead of just TRUE or FALSE, run with "--arr-pre".
//       For example, ../../sleek ex1.slk --arr-pre
//       To print all the intermediate steps, run with --verbose-arr
      

pred_prim Aseg<end> 
     inv_exact BG([(self,end)],true). //0<=start<=end). // possibly empty

pred_prim AsegNE<end> 
     inv_exact BG([(self,end)],0<self<end). 

pred_prim ElemN<start:int> 
     inv_exact BG([self], true). // non-null

/*
pred_prim AsegNE<start:int, end:int> 
     inv_exact BG([(start,end)], 0<start<end). // definitely bounded
pred_prim Elem<start:int,value:int> 
     inv_exact BG([start], true). // non-null


//(1)
checkentail_exact x::Elem<s,1> & p=p |- x::Elem<p,_>.
expect Fail.
print residue.
// should not match by x, but by s+p
*/

//checkentail_exact x::Aseg<s,b> //& c=c  
 //                      |- x::Aseg<s,c>.
checkentail_exact x::Aseg<b> & s'=s' |- x::Aseg<c> .
expect Valid.
print residue.
checkentail_exact x::Aseg<b> & c=c |- x::Aseg<c> .
expect Fail.
print residue.
checkentail_exact x::ElemN<c> & s'=s' |- x::ElemN<_>.
expect Valid.
print residue.

checkentail_exact x::ElemN<c> & s'=s' |- x::ElemN<_> & x!=null.
expect Valid.
print residue.

checkentail_exact x::Aseg<b> & s'=s' |- x::Aseg<c> & x<=c.
expect Valid.
print residue.
// <1>emp&c=b&{FLOW,(4,5)=__norm#E}[]
// what about reside pure..

checkentail_exact x::Aseg<b> & s'=s' |- x::Aseg<c> & x!=null.
expect Fail.
print residue.


checkentail_exact x::Aseg<b> & s'=s' |- x::Aseg<c> & x<=c.
expect Valid.
print residue.
// <1>emp&c=b&{FLOW,(4,5)=__norm#E}[]
// what about reside pure..


checkentail_exact x::AsegNE<b> * x::AsegNE<c> |- x=null.
expect Valid.
print residue.
// <1>hfalse&false&{FLOW,(4,5)=__norm#E}[]

checkentail_exact x::AsegNE<b> * x::Aseg<c> |- x=c.
expect Valid.
print residue.
/* succeed with
<1>x::AsegNE<b>@M * x::Aseg<c>@M&{FLOW,(4,5)=__norm#E}[]

*/

checkentail_exact x::AsegNE<b> * x::Aseg<c> |- x=null.
expect Fail.
print residue.
/* should do we have !(_,_)..
Entail (9) : Fail.(must) cause: ((!(_=_) | x>=b | x>=c)) 
  & x<=c & x<b & x!=null |-  x=null. LOCS:[0;1;76] (must-bug)
*/

