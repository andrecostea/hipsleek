# ex4a.slk

//(1)
checkentail_exact x::Elem<s,1> |- x::Elem<p,_>.
expect Fail.
print residue.
// should not match by x, but by s=p

pred_prim Elem<start:int,value:int> inv_exact BG([start], 0<start). // non-null
direct match requires us to prove:
   s=p

UNSOUND .. Unexpected List: [1,2,3]
===================================================================
# ex4a1.slk

checkentail_exact x::Elem<s,1> |- x::Elem<p,_>.

// should fail. perhaps root_inst should be "s"

(==context.ml#3745==)
process_one_match@3@2@1
process_one_match inp1 :match_res:
 Type: Root
 LHS: x::Elem<s,flted_17_35>@M
 RHS: x::Elem<p,Anon_13>@M
 root_inst: None
 lhs_rest: emp
 rhs_rest: emp
 alias set: [x,x]rhs_inst: []rhs_infer: None
process_one_match inp2 :lhs_h: x::Elem<s,flted_17_35>@M
process_one_match inp3 :lhs_p: flted_17_35=1
process_one_match inp4 :rhs_node: x::Elem<p,Anon_13>@M
process_one_match inp5 :rhs_rest: emp
process_one_match inp6 :rhs_p: true
process_one_match inp7 :([],None)


(==solver.ml#11813==)
compute_actions@1
compute_actions inp1 :EQ ptr:[]
compute_actions inp2 :LHS heap: x::Elem<s,flted_17_35>@M
compute_actions inp3 :LHS pure: flted_17_35=1
compute_actions inp4 :RHS cand:[ x::Elem<p,Anon_13>@M]
compute_actions inp5 :RHS pure: true
compute_actions inp6 :right alias:[p,Anon_13]
compute_actions@1 EXIT: SEARCH =>[
  Prio:1
  Match =>
    Type: Root
    LHS: x::Elem<s,flted_17_35>@M
    RHS: x::Elem<p,Anon_13>@M
    root_inst: None
    lhs_rest: emp
    rhs_rest: emp
    alias set: [x,x]rhs_inst: []rhs_infer: None
  ]

===================================================================
/* # ex4a5.slk
should succeed ..

should be: 
  (x<b & y<c --> y>=b | x>=c)

instead of: 
  generate_constraint_from_baga_range_disj@48 EXIT:[[ (!(_=_) | y>=b | x>=c)]]

(==cvutil.ml#984==)
generate_constraint_from_baga_range_disj@48@46
generate_constraint_from_baga_range_disj inp1 :[[(_,( x, b))],[(_,( y, c))]]
generate_constraint_from_baga_range_disj@48 EXIT:[[ (!(_=_) | y>=b | x>=c)]]
===============================================================================
# ex4a6.slk (FIXED)
should fail ..

pred_prim Aseg<end> 
     inv_exact BG([(self,end)],true). //0<=start<=end). // possibly empty

pred_prim AsegNE<end> 
     inv_exact BG([(self,end)],0<self<end). 

The entailment below should fail:

checkentail_exact x::AsegNE<b> * y::Aseg<c> |- b<=y | c<=x.
expect Fail.
print residue.


   <x,b>    <y,c>
   <5,6>    <1,10>


You can fix it by changing:

instead of: 
  generate_constraint_from_baga_range_disj@48 EXIT:[[ (!(_=_) | y>=b | x>=c)]]

to using a weaker condition:

  (x<b & y<c --> y>=b | x>=c)

===============================================================================
# ex4a7.slk  (FIXED)

checkentail_exact x::AsegNE<bbb> * x::Aseg<c> |- x=null.
expect Fail.
print residue.
/* why is there .. !(_,_)..
Entail (9) : Fail.(must) cause: ((!(_=_) | x>=b | x>=c)) 
  & x<=c & x<b & x!=null |-  x=null. LOCS:[0;1;76] (must-bug)

(==sleekengine.ml#1269==)
xpure_heap_symbolic#999@7
xpure_heap_symbolic#999 inp1 :0
xpure_heap_symbolic#999 inp2 : x::AsegNE<b>@M * x::Aseg<c>@M
xpure_heap_symbolic#999 inp3 : true
xpure_heap_symbolic#999@7 EXIT: x!=null & x<b & x<=c & ((!(_=_) | x>=b | x>=c))#[]# [[_22]]true

@7! **cvutil.ml#994:baga_ranges:[[(_,( x, b))],[(_,( y, c))]]
@7! **cvutil.ml#995:baga_constraints:[[ (!(_=_) | y>=b | x>=c)]]

 (x<b & y<c) --> (y<=b |x>=c)
===================================================================
# ex4a7.slk (FIXED)

Fixed by changing:

(==cvutil.ml#982==)
collect_baga_range@21@19
collect_baga_range inp1 : xxx::ElemN<Anon_13>@M * yyy::AsegNE<c>@M
collect_baga_range@21 EXIT:[[],[(_,( yyy, c))]]

to:

(==cvutil.ml#982==)
collect_baga_range@24@23
collect_baga_range inp1 : xxx::ElemN<Anon_13>@M * yyy::AsegNE<c>@M
collect_baga_range@24 EXIT:[[xxx],[(_,( yyy, c))]]

===================================================================
ex4a7.slk  (FIXED)

Bug at:

(==cvutil.ml#984==)
generate_constraint_from_baga_range_disj@25@23
generate_constraint_from_baga_range_disj inp1 :[[xxx],[(_,( yyy, c))]]
generate_constraint_from_baga_range_disj@25 EXIT:[[ ((_+yyy)>xxx | xxx>=(_+c))]]

to change to : yyy>xxx | xxx>=c

(==cvutil.ml#984==)
generate_constraint_from_baga_range_disj@31@29
generate_constraint_from_baga_range_disj inp1 :[[xxx],[(_,( yyy, c))]]
generate_constraint_from_baga_range_disj@31 EXIT:[[ (yyy>xxx | xxx>=c)]]
===================================================================
# ex4a7.slk (FIXED)

xpure_heap_mem_enum#6@45
xpure_heap_mem_enum#6 inp1 : xxx::ElemN<Anon_13>@M * yyy::AsegNE<c>@M
xpure_heap_mem_enum#6 inp2 :lhs_pure: true
xpure_heap_mem_enum#6 inp3 :xpure_int:1
xpure_heap_mem_enum#6@45 EXIT: xxx!=null & yyy!=null & yyy<c & ((yyy>xxx | xxx>=c)) #  [[xxx,yyy]]

checkentail xxx::ElemN<_> * yyy::AsegNE<c> |- xxx!=yyy.

Instead of: [[xxx,_30]]
should be [[xxx,yyy]


@29! **cvutil.ml#1412:memset: [[xxx,_30]]

@50! **cast.ml#1868:c= :AsegNE
@50! **cast.ml#1881:look_up_view_baga: baga= :[([(_,( self, end))], 0<self & self<end)]
@50! **cast.ml#1882:baga ex vars= :[]
@50! **cast.ml#1886:from_svs:[self,end]
@50! **cast.ml#1887:to_svs:[yyy,c]
@50! **cast.ml#1896:baga (subst)= :[([(_,( yyy, c))], 0<yyy & yyy<c)]
@50! **cast.ml#1898:baga (filtered)= :[([_30], 0<yyy & yyy<c)]
@50! **cast.ml#1901:baga (hulled)= :[_30]

If yyy<c --> yyy

@49! **cast.ml#1868:c= :ElemN
@49! **cast.ml#1881:look_up_view_baga: baga= :[([self], true)]
@49! **cast.ml#1882:baga ex vars= :[]
@49! **cast.ml#1886:from_svs:[self,start]
@49! **cast.ml#1887:to_svs:[xxx,Anon_13]
@49! **cast.ml#1896:baga (subst)= :[([xxx], true)]
@49! **cast.ml#1898:baga (filtered)= :[([xxx], true)]
@49! **cast.ml#1901:baga (hulled)= :[xxx]

(==cvutil.ml#2035==)
xpure_heap_mem_enum#6@29
xpure_heap_mem_enum#6 inp1 : xxx::ElemN<Anon_13>@M * yyy::AsegNE<c>@M
xpure_heap_mem_enum#6 inp2 :lhs_pure: true
xpure_heap_mem_enum#6 inp3 :xpure_int:1
xpure_heap_mem_enum#6@29 EXIT: xxx!=null & yyy!=null & yyy<c & ((yyy>xxx | xxx>=c)) #  [[xxx,_30]]

===================================================================
# ex4a8.slk (FIXED)

  Error in debugging output; 2477 is wrong..

Problem solved by pinning cppo to 1.1.2.

2013  sudo opam pin add cppo 1.1.2 --root=/usr/.opam
 

!!! vbi:Some([([(_,( self, end))], true)])
!!! **astsimp.ml#2477:extracted start/end:[self,end]
!!! **astsimp.ml#2477:view_vars:[end]
!!! **astsimp.ml#2477:inter_vars:[end]
!!! vbi:Some([([(_,( self, end))], 0<self & self<end)])
!!! **astsimp.ml#2477:extracted start/end:[self,end]
!!! **astsimp.ml#2477:view_vars:[end]
!!! **astsimp.ml#2477:inter_vars:[end]
!!! vbi:Some([([self], true)])
!!! **astsimp.ml#2477:extracted start/end:[]
!!! **astsimp.ml#2477:view_vars:[start]
!!! **astsimp.ml#2477:inter_vars:[]
===================================================================
# ex4a8.slk (FIXED) 
 by looking at BAGA under_approx for prim_pred

//(2)
checkentail_exact x::ElemN<_> |- x!=null.
expect Fail.
print residue.
// must fail since there is a memory footprint


//(3)
checkentail_exact x::Aseg<_> |- true.
expect Fail.
print residue.
// may fail since there maybe a memory footprint

//(4)
checkentail_exact x::Aseg<y> & x=y |- true.
expect Valid.
print residue.

(==solver.ml#10157==)
is_classic_resourceless_h_formula@9@7
is_classic_resourceless_h_formula inp1 : x::ElemN<Anon_14>@M
is_classic_resourceless_h_formula@9 EXIT:true

# need to consider primitive predicates which 
have over-approx heap locations.
===================================================================
# ex4a8.slk

   Should consider may/must failure also?

//(4)
checkentail_exact x::Aseg<_> |- emp.
expect Fail.
print residue.
// may fail since there maybe a memory footprint
/*
# ex4a8.slk

most of these should be MayErr rather than MustErr

MustErr Context: 
   fe_kind: MUST
   fe_name: 
   fe_locs: {
     fc_message: classical separation logic
     fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
   }
 [[empty]]
 CEX:true
===================================================================
/* ex5a3.slk

small error: why is xxx undefined?

# Allow pred-prim inv view_data_name
     view_data_name: 
  

# is type inference correct?
   view AsegN<end:TVar[31]>= 
    EBase 
      exists (Impl)[Anon_13:int; 
      xxx:TVar[26]](* lbl: *){3}->(exists end_15:TVar[31]: (* lbl: *){3}->
      self:TVar[26]::ElemN<Anon_13:int>@M * 
      xxx:TVar[26]::Aseg<end_15:TVar[31]>@M&
      xxx:TVar[26]=1+self:TVar[26] & end_15:TVar[31]=end:TVar[31]&
      {FLOW,(1,26)=__flow#E}[])



WARNING: ex5a3.slk_20:5_20:15:compute_view_fw_bw: data name in view is empty

Last Proving Location: ex5a3.slk_14:10_14:26

ERROR: at ex5a3.slk_20:5_20:15
Message: compute_view_fw_bw: data not found: 

Last Proving Location: ex5a3.slk_14:10_14:26

ERROR: at _0:0_0:0
Message: xxx is undefined (7)
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================

   
