
// README:

//       Use @arr_ba for bi-abduction
//       Use @arr_en for classical entailment.
// 	 Use @arr_enfr for entailment with frame inference

//       In classical entailment, by default, it will just return TRUE or FALSE.
//       To generate pre-condition instead of just TRUE or FALSE, run with "--arr-pre".
//       For example, ../../sleek ex1.slk --arr-pre
//       To print all the intermediate steps, run with --verbose-arr


//lemma_unsafe self::Aseg<y> <- self::AsegN<y>.

pred_prim ElemN<start:int>
     inv_exact BG([self], true). // non-null

pred_prim AsegA<end>
     inv_exact BG([(self,end)],true). //0<=start<=end). // possibly empty

pred AsegNE<end> == exists xxx: self::ElemN<_> * xxx::Aseg<end> & xxx=self+1
     inv_exact BG([(self,end)],0<self<end).

pred AsegN<end> == self::ElemN<_> * xxx::Aseg<end> & xxx=self+1
     inv_exact BG([(self,end)],0<self<end).

pred Aseg<end> == self=end
     or self::AsegN<end> & self<end
     inv_exact BG([(self,end)],true). //0<=start<=end). // possibly empty

/*
(==solver.ml#13753==)
do_base_fold@29@27@26@25@24
do_base_fold inp1 :  emp&zzz=1+yyy & yyy<zzz & Anon_56=Anon_14 & Anon_56=Anon_14&
{FLOW,(4,5)=__norm#E}[]
 es_evars: [end_61; zzz_55]
 es_gen_impl_vars(E): [xxx_57]
 es_heap: yyy::ElemN<Anon_14>@M
 es_rhs_eqset: [zzz_55:zzz; end_61:zzz_55; end_61:zzz_55]
 es_subst (from,to): []:[]
 es_trace:  SEARCH ==>  Fold ==>  SEARCH ==>  Match(yyy,yyy) ==>  SEARCH ==>  COND ==>  BaseCaseFold
do_base_fold inp2 : xxx_57::Aseg<end_61>@M&xxx_57=1+yyy & end_61=zzz_55&{FLOW,(1,26)=__flow#E}[]
do_base_fold@29 EXIT: failctxfe_kind: MAY
        fe_name: logical bug
        fe_locs: {
    fc_message:  yyy!=null & yyy<(1+yyy) |-  xxx_57=yyy+1. LOCS:[1;32;22] (may-bug)
    fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}
  }
[[ SEARCH ==>  Fold ==>  SEARCH ==>  Match(yyy,yyy) ==>  SEARCH ==>  COND ==>  BaseCaseFold]]false


(==solver.ml#13753==)
do_base_fold@23
do_base_fold inp1 :  emp&Anon_56=Anon_14 & yyy<zzz & zzz=yyy+1&{FLOW,(4,5)=__norm#E}[]
 es_evars: [end_62; zzz_63]
 es_gen_impl_vars(E): [xxx_57]
 es_rhs_eqset: [end_62:zzz_63]
 es_subst (from,to): []:[]
 es_trace:  SEARCH ==>  COND ==>  BaseCaseFold
do_base_fold inp2 : xxx_57::Aseg<end_62>@M&xxx_57=yyy+1 & end_62=zzz_63&{FLOW,(4,5)=__norm#E}[]
do_base_fold@23 EXIT: failctxfe_kind: MAY
        fe_name: logical bug
        fe_locs: {
    fc_message:  yyy<(yyy+1) |-  xxx_57=1+yyy. LOCS:[69;70] (may-bug)
    fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}
  }
[[ SEARCH ==>  COND ==>  BaseCaseFold]]false

*/

/*
es_evars : CP.spec_var list; (* existential variables on RHS *)
es_gen_expl_vars: CP.spec_var list; (* explicit instantiation var *)
es_gen_impl_vars: CP.spec_var list; (* implicit instantiation var *)

(* for IMMUTABILITY *)
(* INPUT : this is an alias set for the RHS conseq *)
(* to be used by matching strategy for imm *)
es_rhs_eqset : (CP.spec_var * CP.spec_var) list;


EXISTS:
(==solver.ml#13753==)
do_base_fold@1
do_base_fold inp1 :  emp&zzz=1+yyy & yyy<zzz & Anon_71=Anon_15 & Anon_71=Anon_15&
{FLOW,(4,5)=__norm#E}[]
 es_evars: [end_76; xxx_77; zzz_70]
 es_gen_impl_vars(E): []
 es_heap: yyy::ElemN<Anon_15>@M
 es_rhs_eqset: [zzz_70:zzz; end_76:zzz_70; end_76:zzz_70]
 es_subst (from,to): []:[]
 es_trace:  SEARCH ==>  Fold ==>  SEARCH ==>  Match(yyy,yyy) ==>  SEARCH ==>  COND ==>  BaseCaseFold
do_base_fold inp2 : xxx_77::Aseg<end_76>@M&xxx_77=1+yyy & end_76=zzz_70&{FLOW,(1,26)=__flow#E}[]
do_base_fold@1 EXIT: 1[
    emp&zzz=1+yyy & yyy<zzz & Anon_71=Anon_15&{FLOW,(4,5)=__norm#E}[]
   es_evars: [end_76; xxx_77; zzz_70]
   es_gen_impl_vars(E): []
   ]
[[ SEARCH ==>  Fold ==>  SEARCH ==>  Match(yyy,yyy) ==>  SEARCH ==>  COND ==>  BaseCaseFold]]

existential_eliminator_helper@4@3@1
existential_eliminator_helper inp1 :  emp&zzz=1+yyy & yyy<zzz & Anon_71=Anon_15 & Anon_71=Anon_15&
{FLOW,(4,5)=__norm#E}[]
 es_evars: [end_76; xxx_77; zzz_70]
 es_gen_impl_vars(E): []
 es_heap: yyy::ElemN<Anon_15>@M
 es_rhs_eqset: [zzz_70:zzz; end_76:zzz_70; end_76:zzz_70]
 es_subst (from,to): []:[]
 es_trace:  SEARCH ==>  Fold ==>  SEARCH ==>  Match(yyy,yyy) ==>  SEARCH ==>  COND ==>  BaseCaseFold
 es_unsat_flag: false
existential_eliminator_helper inp2 :Var2Fold::xxx_77
existential_eliminator_helper inp3 :Pred::Aseg
existential_eliminator_helper inp4 :SVL::[end_76]
existential_eliminator_helper inp5 :RHS pure:: xxx_77=1+yyy & end_76=zzz_70
existential_eliminator_helper@4 EXIT:([xxx_77,end_76],Some( true))

________________________________________________________________________________

NOT EXISTS:
(==solver.ml#13753==)
do_base_fold@1
do_base_fold inp1 :  emp&zzz=1+yyy & yyy<zzz & Anon_71=Anon_15 & Anon_71=Anon_15&
{FLOW,(4,5)=__norm#E}[]
 es_evars: [end_76; zzz_70]
 es_gen_impl_vars(E): [xxx_72]
 es_heap: yyy::ElemN<Anon_15>@M
 es_rhs_eqset: [zzz_70:zzz; end_76:zzz_70; end_76:zzz_70]
 es_subst (from,to): []:[]
 es_trace:  SEARCH ==>  Fold ==>  SEARCH ==>  Match(yyy,yyy) ==>  SEARCH ==>  COND ==>  BaseCaseFold
do_base_fold inp2 : xxx_72::Aseg<end_76>@M&xxx_72=1+yyy & end_76=zzz_70&{FLOW,(1,26)=__flow#E}[]
do_base_fold@1 EXIT: failctxfe_kind: MAY
        fe_name: logical bug
        fe_locs: {
    fc_message:  yyy!=null & yyy<(1+yyy) |-  xxx_72=yyy+1. LOCS:[1;98;25] (may-bug)
    fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}
  }
[[ SEARCH ==>  Fold ==>  SEARCH ==>  Match(yyy,yyy) ==>  SEARCH ==>  COND ==>  BaseCaseFold]]false
*/

checkentail_exact
       yyy::ElemN<_>  //& xxx=zzz
         & zzz=yyy+1 & yyy<zzz
       |- yyy::AsegN<zzz>.
expect Valid.
print residue.

/*
// BaseCaseFold that should always fail
checkentail_exact
       yyy::ElemN<_>
          & zzz=yyy-1
       |- yyy::AsegN<zzz>.
expect Fail.
print residue.

// BaseCaseFold that should always fail
checkentail_exact
       yyy::ElemN<_>
          & zzz=yyy
       |- yyy::AsegN<zzz>.
expect Fail.
print residue.

*/
