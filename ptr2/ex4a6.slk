
// README:

//       Use @arr_ba for bi-abduction
//       Use @arr_en for classical entailment.
// 	 Use @arr_enfr for entailment with frame inference

//       In classical entailment, by default, it will just return TRUE or FALSE.
//       To generate pre-condition instead of just TRUE or FALSE, run with "--arr-pre".
//       For example, ../../sleek ex1.slk --arr-pre
//       To print all the intermediate steps, run with --verbose-arr
      

pred_prim Aseg<end> 
     inv_exact BG([(self,end)],true). //0<=start<=end). // possibly empty

pred_prim AsegNE<end> 
     inv_exact BG([(self,end)],0<self<end). 


pred_prim ElemN<start:int> 
     inv_exact BG([self], true). // non-null

//(1)
checkentail xxx::ElemN<_> * yyy::Aseg<c> |- xxx!=yyy.
expect Fail.

//(2)
checkentail xxx::ElemN<_> * yyy::Aseg<c> & yyy<c |- xxx!=yyy.
expect Valid.

/*
# xxx is lost..

generate_constraint_from_baga_range_disj@18
generate_constraint_from_baga_range_disj inp1 :[[],[(_,( yyy, c))]]
generate_constraint_from_baga_range_disj@18 EXIT:[]
*/

//(3)
checkentail xxx::ElemN<_> * yyy::ElemN<_> |- xxx!=yyy.
// both xxx and yyy are lost..

//(4)
checkentail x::AsegNE<b> * y::Aseg<c> |- y=c.
print residue.
expect Fail.
/* should succeed, 
<1>x::AsegNE<b>@M * x::Aseg<c>@M&{FLOW,(4,5)=__norm#E}[]

*/

//(5)
checkentail x::AsegNE<b> * y::Aseg<c> |- false.
expect Fail.
print residue.

//(6)
checkentail x::AsegNE<b> * x::Aseg<c> |- x=c.
expect Valid.
print residue.

//(7)
checkentail x::AsegNE<b> * x::Aseg<c> |- false.
expect Fail.
print residue.

//(8)
checkentail_exact x::AsegNE<bbb> * x::Aseg<c> |- x=null.
expect Fail.
print residue.

//(9)
checkentail x::AsegNE<bbb> * x::Aseg<c> |- x!=null.
expect Valid.
print residue.

/* why is there .. !(_,_)..
Entail (9) : Fail.(must) cause: ((!(_=_) | x>=b | x>=c)) 
  & x<=c & x<b & x!=null |-  x=null. LOCS:[0;1;76] (must-bug)

(==sleekengine.ml#1269==)
xpure_heap_symbolic#999@7
xpure_heap_symbolic#999 inp1 :0
xpure_heap_symbolic#999 inp2 : x::AsegNE<b>@M * x::Aseg<c>@M
xpure_heap_symbolic#999 inp3 : true
xpure_heap_symbolic#999@7 EXIT: x!=null & x<b & x<=c & ((!(_=_) | x>=b | x>=c))#[]# [[_22]]true


*/

//(10)
checkentail_exact x::AsegNE<bbb> * x::AsegNE<c> |- false. //x=null.
expect Valid.
print residue.

//(11)
checkentail_exact x::AsegNE<bbb> * y::AsegNE<c> |- x!=y.
expect Valid.
print residue.

//(12)
checkentail_exact x::AsegNE<bbb> * y::AsegNE<c> |- false.
expect Fail.
print residue.

//(13)
checkentail x::AsegNE<b> * y::Aseg<c> |- // !(y<c) | 
    b<=y | c<=x.
expect Fail.
print residue.

//(14)
checkentail x::AsegNE<b> * y::Aseg<c> |- !(y<c) | b<=y | c<=x.
expect Valid.
print residue.

//(15)
checkentail x::AsegNE<b> * y::ElemN<_> |- x!=y.
expect Valid.

//(16) // should fail as this is supposed to be classic
checkentail_exact x::AsegNE<b> * y::ElemN<_> |- x!=y.
expect Fail.
print residue.


//(17) // should fail as this is supposed to be classic
infer [@classic] x::AsegNE<b> * y::ElemN<_> |- x!=y.
expect Fail.
print residue.

data cell {
 int v;
}.


checkentail x::cell<_> |- x!=null.
expect Valid.
print residue.

checkentail_exact x::cell<_> |- x!=null.
expect Fail.
print residue.

checkentail_exact x::ElemN<_> |- x!=null.
expect Fail.
print residue.

checkentail x::ElemN<_> |- x!=null.
expect Valid.
print residue.
