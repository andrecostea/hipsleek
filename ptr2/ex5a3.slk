
// README:

//       Use @arr_ba for bi-abduction
//       Use @arr_en for classical entailment.
// 	 Use @arr_enfr for entailment with frame inference

//       In classical entailment, by default, it will just return TRUE or FALSE.
//       To generate pre-condition instead of just TRUE or FALSE, run with "--arr-pre".
//       For example, ../../sleek ex1.slk --arr-pre
//       To print all the intermediate steps, run with --verbose-arr


pred_prim ElemN<start:int> 
     inv_exact BG([self], true). // non-null

pred_prim AsegA<end> 
     inv_exact BG([(self,end)],true). //0<=start<=end). // possibly empty

pred Aseg<end> == self=end
     or self::AsegN<end> & self<end 
     inv_exact BG([(self,end)],true). //0<=start<=end). // possibly empty

pred AsegN<end> == self::ElemN<_> * xxx::Aseg<end> & xxx=self+1
     inv_exact BG([(self,end)],0<self<end). 


//(1) unfolding
checkentail_exact xxx::AsegN<yyy> & zzz=xxx+1 |- xxx::ElemN<_>*zzz::Aseg<yyy>.
expect Valid.
print residue.


//(2) require existential handling
checkentail_exact xxx::AsegN<yyy> //& zzz=xxx+1
       |- xxx::ElemN<_>*zzz::Aseg<yyy>.
expect Valid.
print residue.

//(3) lhs maybe empty
checkentail_exact xxx::Aseg<yyy> & zzz=xxx+1
       |- xxx::ElemN<_>*zzz::Aseg<yyy>.
expect Fail.
print residue.

//(4) lhs is non-empty
checkentail_exact xxx::Aseg<yyy> & zzz=xxx+1 & xxx<yyy
       |- xxx::ElemN<_>*zzz::Aseg<yyy>.
expect Valid.
print residue.


checkentail_exact
       xxx::ElemN<_>*zzz::Aseg<yyy> & zzz=xxx+1
       |- xxx::AsegN<yyy>.
expect Valid.
print residue.

checkentail_exact
       xxx::ElemN<_>*zzz::Aseg<yyy> & zzz=xxx+1
       |- xxx::AsegN<kkk>.
expect Valid.
print residue.

/* ex5a3.slk

small error: why is xxx undefined?

WARNING: ex5a3.slk_20:5_20:15:compute_view_fw_bw: data name in view is empty

Last Proving Location: ex5a3.slk_14:10_14:26

ERROR: at ex5a3.slk_20:5_20:15
Message: compute_view_fw_bw: data not found: 

Last Proving Location: ex5a3.slk_14:10_14:26

ERROR: at _0:0_0:0
Message: xxx is undefined (7)


(==iast.ml#2420==)
update_fixpt@2
update_fixpt inp1 :[(Aseg:@,[],[]),(ElemN:@,[],[]),(AsegN:@,[],[ElemN])]
update_fixpt res1 :[(Aseg:Aseg@,[],[]),(ElemN:ElemN@,[],[]),(AsegN:AsegN@,[],[ElemN])]
update_fixpt@2 EXIT:()



*/
