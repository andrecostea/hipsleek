/*
@M - mutable   (0)
@I - immutable (1)
@L - lending   (2)
@A - no access (3)
*/

//data cell {int val;}.

data node {
	int val; 
	node next;	
}.

pred ll<v1> == self = null 
	or (exists qq: self::node<a@v1, qq> * 
    qq::ll<v1>)
  inv true      .



checkentail x::node<p,q> * q::ll<ann1> & ann2=@A |- x::ll<ann2> .
print residue.
expect Valid.

checkentail x::node<p,q> * q::ll<@A> & ann2=@A |- x::ll<ann2> .
print residue.
expect Valid.

checkentail x::node<p,q> * q::ll<@M> & ann2=@M |- x::ll<ann2> .
print residue.
expect_infer Valid R{emp}. // classic proving needed

checkentail x::node<p,q> * q::ll<@A> & ann2=@M |- x::ll<ann2> .
print residue.
expect Fail.

/*


  x::ll<@A> |- x::ll<@A> --> emp // x::ll

  x::ll<@M> |- x::ll<@M> --> emp // should be empty

  x::ll<@M> |- x::ll<@A> --> emp // May Failure ..

  x::ll<@A> |- x::ll<@M> --> emp // May Failure ..

 --

Residue:
 <1>(exists ann2_35: q::ll<ann1>@M * x::node<p@M,q_40@A>@M&ann2_35=@A & a_36=p & @M<:ann2_35 & ann2=@A&{FLOW,(20,21)=__norm#E}[]
[[ Fold ==>  SEARCH ==>  Match(x,x) ==>  COND ==>  Match(q,q)]]


(====)
subs_imm_par@41@40
subs_imm_par inp1 :[(ann2_30,ann2_34)]
subs_imm_par inp2 :@M
subs_imm_par@41 EXIT:@M

(==solver.ml#7220==)
subst@40
subst inp1 :[(ann2_30,ann2_34)]
subst inp2 : x::ll{}<ann2_30>@M&ann2_30=ann2&{FLOW,(20,21)=__norm#E}[]
subst@40 EXIT: x::ll{}<ann2_30>@M&ann2_34=ann2&{FLOW,(20,21)=__norm#E}[]


*/