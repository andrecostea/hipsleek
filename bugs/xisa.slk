data node {
	int val; 
	node prev;	
	node next;	
}.

pred dll1<> == self::dll_r1<null>
  inv true.

pred dll_r1<p> == self=null
  or self::node<_,p,r> * r::dll_r1<self>   
  inv true.

/*
Example below cannot be captured since there
isn't a way to split the fields in our system.

pred dll2<> == self=null
  or self.prev::null * self::dll_r2<>
  inv true.
pred dll_r2<> == self.next::n *
  (n=null or n.prev::self * n::dll_r2<>)
  inv true.


pred dll2<> == self=null
  or self::node<_,null,p> * p::dll_r2<self>
  inv true.
pred dll_r2<p> == self=null
  or self::node<_,p,n> * n::dll_r2<self>
  inv true.
*/

pred dll3<t> == self=null & t=null
  or self::dll_r3<null,t,null>
  inv true.

pred dll_r3<p,t,a> == 
  self::node<_,p,a> & self=t
  or self::node<_,p,n> * n::dll_r3<self,t,a> & self!=t
  inv true.


pred dll4<h> == self=h & h=null
  or self::dll_r4<null,h,null>
  inv true.

pred dll_r4<b,h,n> ==
  self::node<_,b,n> & self=h
  or self::node<_,p,n> * p::dll_r4<b,h,self> & self!=h
  inv true.


////lemma "ht2tail" self::ll_ht<n, h, t> <-> self::ll_tail<n+1,t>.

//lemma "dll3todll4" self::dll3<t> <-> t::dll4<self>.

//lemma "dll_r3_to_dll_r4" self::dll_r3<p,t,a> -> t::dll_r4<p,self,a>.

lemma "dll_r4_to_dll_r3" self::dll_r4<b,h,n> -> h::dll_r3<b,self,n>.

/*

//(1)
checkentail x::node<_,null,null> |- x::dll1<> .
print residue.

//(2)
checkentail x::node<_,null,null> |- x::dll3<r> .
print residue.

//(3)
checkentail x::node<_,null,null> |- x::dll4<r> .
print residue.

//(4)
checkentail x::node<_,null,n> * n::node<_,x, n1> * n1::node<_,n,null> |- x::dll1<>.
print residue.

//(5)
checkentail x::node<_,null,n> * n::node<_,x, n1> * n1::node<_,n,null> |- x::dll3<n1>.
print residue.

//(6)
checkentail x::node<_,null,n> * n::node<_,x, n1> * n1::node<_,n,null> |- n1::dll4<x>.
print residue.

//(7)
checkentail x::node<_,p,n> * n::node<_,x, n1> * n1::node<_,n,a> |- x::dll_r3<p,n1,a>.
print residue.

//(8)
checkentail x::node<_,p,n> * n::node<_,x, n1> * n1::node<_,n,a> |- n1::dll_r4<p,x,a>.
print residue.

//(9)
checkentail n::node<_,x, n1> * n1::node<_,n,null> |- n::dll_r3<x,n1,null>.
print residue.

//(10) segment
checkentail x::node<_,p,n> * n::dll_r3<x,n1,a> & x!=n1 |- x::dll_r3<p,n1,a>.
print residue.

//(11) dll
checkentail x::node<_,null,n> * n::dll_r3<x,n1,null> & x!=n1 |- x::dll3<n1>.
print residue.

*/


/*
??? BUGs

// SUMMARY

//
checkentail n1::dll_r4<null,n,null> |- n::dll_r3<null,n1,null>.
print residue.
// w/ lemma "dll_r4_to_dll_r3" applied to the LHS first => succeed
// no lemma => loop forever
// w/  lemma "dll_r3_to_dll_r4" applied to the RHS => loop forever
// ??? Is it because of unbounded unfolding of predicates

//
checkentail x::node<_,null,n> * n1::dll_r4<x,n,null> & x!=n1 |- x::dll3<n1>.
print residue. // similar to the above



checkentail x::node<_,p,n> * n::dll_r3<x,n1,a> & x!=n1 |- n1::dll_r4<p,x,a>.
print residue. 
// w/ lemma "dll_r3_to_dll_r4" applied to the RHS => fail
// w/ lemma "dll_r4_to_dll_r3" applied to the LHS first => loop forever
// w/o lemmas => loop forever
// ??? unfounded unfolding of predicates

checkentail x::node<_,null,n> * n::dll_r3<x,n1,null> & x!=n1 |- n1::dll4<x>.
print residue. // similar to the above

*/


checkentail n1::dll_r4<null,n,null> |- n::dll_r3<null,n1,null>.
// bugs ??? it does not perform lemma coercion on the RHS
// but loop forever instead
