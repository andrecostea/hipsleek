data node {
  int val;
  node next;
}.

pred p<v> == self::node<v,_>
  inv self!=null.

// (1)
checkentail y::node<_,r>@M |- y::node<a,b>@v & v<:@M.
/*
PROBLEM : @M<:v instantiated instead of v=@M;
   implicit should be instantiated with the latter

 @M=0; @I=1; @L=2
   0<=v |- v<=0

 y::node<Anon_11,r>@M[Orig]&true&{FLOW,(17,18)=__norm}[] [] |-  EBase exists (Expl)(Impl)[v; a; b](ex)y::node<a,b>@v[Orig]&v<:@M&
       {FLOW,(17,18)=__norm}[]
Entail (1) : Fail.(may) cause: @M<:v |-  v<:@M. LOCS:[0;7] (may-bug)
*/

//(2) should valid
checkentail y::node<_,r>@M |- y::node<a,b>@v & v<:@I.

//(3) right instantiated as @I<:v
checkentail y::node<_,_>@I |- [v] y::node<_,_>@v & v<:@M.

//(4) left instantiated as v=@I
checkentail y::node<_,_>@I |- y::node<_,_>@v & v<:@M.

//(5) fail
checkentail y::node<_,_>@I |- y::node<_,_>@M.



// (2)
checkentail y::node<_,r>@M * x::node<_,_>@L 
              |- y::node<_,b>@v * x::node<_,b>@v.
/*
PROBLEM : there should be only one implicit v

 y::node<Anon_13,r>@M[Orig] * x::node<Anon_14,Anon_15>@L[Orig]&true&
{FLOW,(17,18)=__norm}[] [] |-  EBase exists (Expl)(Impl)[Anon_16; v; Anon_17; 
       b](ex)EXISTS(b_49: y::node<Anon_16,b>@v[Orig] * 
       x::node<Anon_17,b_49>@v[Orig]&b_49=b&{FLOW,(17,18)=__norm})[]
*/


checkentail y::node<_,r>@M & v=@I & a=3 |- y::node<a,b>@v & v<:@M.
/*
PROBLEM : expecting @v to be existentially quantified.
          normalization need to be fixed.
run_infer:
 y::node<Anon_12,r>@M[Orig]&v=@I & a=3&{FLOW,(17,18)=__norm}[] [] |-  EBase exists (Expl)(Impl)[b](ex)EXISTS(a_28: y::node<a_28,b>@v[Orig]&
       v<:@M & a_28=a&{FLOW,(17,18)=__norm})[]

*/

//checkentail y::p<2>@M |- y::p<b>@v & b>1.
//print residue.

checkentail y::node<_,_>@M |- y::node<_,_>@v .
print residue.

checkentail y::node<_,_>@M |- (exists v: y::node<_,_>@v & v=@M) .
print residue.

checkentail y::node<_,_>@M |- [v] y::node<a,b>@v & v<:@M.
print residue.

// (14) valid
//infer [] y::node<_,_>@I |- y::node<a,b>@v & v<:@I.

