
!!! **tpdispatcher.ml#492:init_tp by default: 
!!! **tpdispatcher.ml#391:set_tp z3Starting z3... 
H1 is defined.

Starting Omega.../usr/local/bin/oc

!!! **WARNING****cpure.ml#5961:is_eq_baga may be unsound
!!! **WARNING****cpure.ml#5961:is_eq_baga may be unsound
!!! **WARNING****cpure.ml#5961:is_eq_baga may be unsound
!!! **WARNING****cpure.ml#5961:is_eq_baga may be unsound
!!! **WARNING****context.ml#825:pushing to infer
!!! **WARNING****context.ml#825:pushing to infer
!!! **context.ml#3239:process_matches (steps) :
 ### LHS : x::node<zzz>@M * H1(y)
 ### RHS : y::node<flted_14_49>@M
 ### matches :
[ Type: Root
 LHS: H1(y)
 RHS: y::node<flted_14_49>@M
 root_inst: None
 lhs_rest: x::node<zzz>@M
 rhs_rest: x::lseg<zzz_48>@M
 alias set: [y]rhs_inst: []rhs_infer: None]

!!! **context.ml#3239:process_matches (steps) :
 ### LHS : x::node<zzz>@M * H1(y)
 ### RHS : x::lseg<zzz_48>@M
 ### matches :
[ Type: Root
 LHS: x::node<zzz>@M
 RHS: x::lseg<zzz_48>@M
 root_inst: None
 lhs_rest: H1(y)
 rhs_rest: y::node<flted_14_49>@M
 alias set: [x]rhs_inst: []rhs_infer: None]

!!! **context.ml#3620:compute_action (steps) :
 ### RHS Cand :[ y::node<flted_14_49>@M, x::lseg<zzz_48>@M]
 ### action :
 Fold =>
   LHS: x::node<zzz>@M
   RHS: x::lseg<zzz_48>@M

!!! **solver.ml#12665:process_action (steps) :
 ### action :
 Fold =>
   Type: Root
   LHS: x::node<zzz>@M
   RHS: x::lseg<zzz_48>@M
   root_inst: None
   lhs_rest: H1(y)
   rhs_rest: y::node<flted_14_49>@M
   alias set: [x]rhs_inst: []rhs_infer: None
 ### estate : ex_formula : x::node<zzz>@M * H1(y)&{FLOW,(20,21)=__norm#E}[]
 es_heap:emp
 es_infer_vars: [zzz]
 ### conseq : y::node<flted_14_49>@M * x::lseg<zzz_48>@M&flted_14_49=null & zzz_48=zzz&
{FLOW,(20,21)=__norm#E}[]

!!! **WARNING****context.ml#825:pushing to infer
!!! **WARNING****context.ml#825:pushing to infer
!!! **WARNING****context.ml#825:pushing to infer
!!! **context.ml#3239:process_matches (steps) :
 ### LHS : x::node<zzz>@M * H1(y)
 ### RHS : x::node<q_50>@M
 ### matches :
[ Type: Root
 LHS: x::node<zzz>@M
 RHS: x::node<q_50>@M
 root_inst: None
 lhs_rest: H1(y)
 rhs_rest: q_50::lseg<p_54>@M
 alias set: [x]rhs_inst: []rhs_infer: None]

!!! **context.ml#3620:compute_action (steps) :
 ### RHS Cand :[ x::node<q_50>@M, q_50::lseg<p_54>@M]
 ### action :
 Match =>
   LHS: x::node<zzz>@M
   RHS: x::node<q_50>@M

!!! **solver.ml#12665:process_action (steps) :
 ### action :
 Match =>
   Type: Root
   LHS: x::node<zzz>@M
   RHS: x::node<q_50>@M
   root_inst: None
   lhs_rest: H1(y)
   rhs_rest: q_50::lseg<p_54>@M
   alias set: [x]rhs_inst: []rhs_infer: None
 ### estate : ex_formula : x::node<zzz>@M * H1(y)&{FLOW,(20,21)=__norm#E}[]
 es_heap:emp
 es_infer_vars: [zzz]
 ### conseq : x::node<q_50>@M * q_50::lseg<p_54>@M&x!=zzz_48 & p_54=zzz_48&
{FLOW,(1,26)=__flow#E}[]

!!! **WARNING****context.ml#825:pushing to infer
!!! **context.ml#3239:process_matches (steps) :
 ### LHS : H1(y)
 ### RHS : q_50::lseg<p_54>@M
 ### matches :[]

!!! **context.ml#3620:compute_action (steps) :
 ### RHS Cand :[ q_50::lseg<p_54>@M]
 ### action :
 COND =>[
  Prio:2
  BaseCaseFold =>
    LHS: emp
    RHS: q_50::lseg<p_54>@M;
  Prio:5
  UnmatchedRHSData =>  q_50::lseg<p_54>@M
  ]

!!! **solver.ml#12665:process_action (steps) :
 ### action :
 BaseCaseFold =>
   Type: Root
   LHS: emp
   RHS: q_50::lseg<p_54>@M
   root_inst: None
   lhs_rest: H1(y)
   rhs_rest: emp
   alias set: []rhs_inst: []rhs_infer: None
 ### estate : ex_formula : H1(y)&q_50=zzz & q_50=zzz&{FLOW,(20,21)=__norm#E}[]
 es_heap:x::node<zzz>@M
 es_infer_vars: [zzz]
 ### conseq : q_50::lseg<p_54>@M&x!=zzz_48 & p_54=zzz_48&{FLOW,(1,26)=__flow#E}[]

(==solver.ml#11761==)
do_fold_w_ctx@2@1
do_fold_w_ctx inp1 :  H1(y)&q_50=zzz & q_50=zzz&{FLOW,(20,21)=__norm#E}[]
 es_evars: [p_54; zzz_48; flted_14_49]
 es_gen_impl_vars(E): []
 es_heap: x::node<zzz>@M
 es_rhs_eqset: [zzz_48:zzz; p_54:zzz_48; p_54:zzz_48]
 es_trace:  Fold ==>  Match(x,x) ==>  COND ==>  BaseCaseFold
 es_infer_vars: [zzz]
 es_infer_vars_hp_rel: [H1]
 es_unsat_flag: false
do_fold_w_ctx inp2 :
 conseq =  q_50::lseg<p_54>@M&x!=zzz_48 & p_54=zzz_48&{FLOW,(1,26)=__flow#E}[]
 rhs_node =  q_50::lseg<p_54>@M
 vd =  EBase 
   (* lbl: *){1}->emp&self=p&{FLOW,(1,26)=__flow#E}[]
 rhs_rest =  emp
 rhs_b =  q_50::lseg<p_54>@M&x!=zzz_48 & p_54=zzz_48&{FLOW,(1,26)=__flow#E}[]
do_fold_w_ctx inp3 :true
do_fold_w_ctx@2 EXIT: [ H1(y)&q_50=zzz & zzz=null&{FLOW,(20,21)=__norm#E}[]
  es_evars: [p_54; zzz_48; flted_14_49]
  es_gen_impl_vars(E): []
  es_pure: q_50=p_54 & p_54=zzz_48 & x!=zzz_48
  es_heap: x::node<zzz>@M
  es_ante_evars: [p_54; zzz_48; flted_14_49]
  es_rhs_eqset: [zzz_48:zzz; p_54:zzz_48; p_54:zzz_48; p_54:zzz_48; 
                 q_50:p_54]
  es_aux_conseq: q_50=p_54
  es_trace:  Fold ==>  Match(x,x) ==>  COND ==>  BaseCaseFold
  es_infer_vars: [zzz]
  es_infer_vars_hp_rel: [H1]
  es_infer_pure: [zzz=null]]

!!! **WARNING****context.ml#825:pushing to infer
!!! **context.ml#3239:process_matches (steps) :
 ### LHS : x::node<zzz>@M * H1(y)
 ### RHS : y::node<flted_14_49>@M
 ### matches :
[ Type: Root
 LHS: H1(y)
 RHS: y::node<flted_14_49>@M
 root_inst: None
 lhs_rest: x::node<zzz>@M
 rhs_rest: emp
 alias set: [y]rhs_inst: []rhs_infer: None]

!!! **context.ml#3620:compute_action (steps) :
 ### RHS Cand :[ y::node<flted_14_49>@M]
 ### action :
 InferUnfold =>
   LHS: H1(y)
   RHS: y::node<flted_14_49>@M

!!! **solver.ml#12665:process_action (steps) :
 ### action :
 InferUnfold =>
   Type: Root
   LHS: H1(y)
   RHS: y::node<flted_14_49>@M
   root_inst: None
   lhs_rest: x::node<zzz>@M
   rhs_rest: emp
   alias set: [y]rhs_inst: []rhs_infer: None
 ### estate : ex_formula : x::node<zzz>@M * H1(y)&{FLOW,(20,21)=__norm#E}[]
 es_heap:emp
 es_infer_vars: [zzz]
 ### conseq : y::node<flted_14_49>@M&flted_14_49=null & zzz_48=zzz & x=zzz_48&
{FLOW,(20,21)=__norm#E}[]

!!! **cast.ml#1545:define: :
HeapPred HP_60(node flted_14_59, node@NI y).

!!! **solver.ml#12665:process_action (steps) :
 ### action :
 Match =>
   Type: Root
   LHS: y::node<flted_14_59>@M
   RHS: y::node<flted_14_49>@M
   root_inst: None
   lhs_rest: x::node<zzz>@M * HP_60(flted_14_59,y)
   rhs_rest: emp
   alias set: []rhs_inst: []rhs_infer: None
 ### estate : ex_formula : x::node<zzz>@M * HP_60(flted_14_59,y)&{FLOW,(20,21)=__norm#E}[]
 es_heap:emp
 es_infer_vars: [zzz]
 ### conseq : y::node<flted_14_49>@M&flted_14_49=null & zzz_48=zzz & x=zzz_48&
{FLOW,(20,21)=__norm#E}[]

!!! **context.ml#3239:process_matches (steps) :
 ### LHS : H1(y)
 ### RHS : y::node<flted_14_49>@M
 ### matches :
[ Type: Root
 LHS: H1(y)
 RHS: y::node<flted_14_49>@M
 root_inst: None
 lhs_rest: emp
 rhs_rest: emp
 alias set: [y]rhs_inst: []rhs_infer: None]

!!! **context.ml#3620:compute_action (steps) :
 ### RHS Cand :[ y::node<flted_14_49>@M]
 ### action :
 InferUnfold =>
   LHS: H1(y)
   RHS: y::node<flted_14_49>@M

!!! **solver.ml#12665:process_action (steps) :
 ### action :
 InferUnfold =>
   Type: Root
   LHS: H1(y)
   RHS: y::node<flted_14_49>@M
   root_inst: None
   lhs_rest: emp
   rhs_rest: emp
   alias set: [y]rhs_inst: []rhs_infer: None
 ### estate : ex_formula : H1(y)&x!=q_50 & zzz=null & q_50=zzz&{FLOW,(20,21)=__norm#E}[]
 es_heap:x::node<zzz>@M
 es_infer_vars: [zzz]
 es_infer_pure: [zzz=null]
 ### conseq :
 y::node<flted_14_49>@M&
flted_14_49=null & zzz_48=zzz & x!=zzz_48 & q_50=zzz_48&
{FLOW,(20,21)=__norm#E}[]

!!! **cast.ml#1545:define: :
HeapPred HP_65(node flted_14_64, node@NI y).

!!! **solver.ml#12665:process_action (steps) :
 ### action :
 Match =>
   Type: Root
   LHS: y::node<flted_14_64>@M
   RHS: y::node<flted_14_49>@M
   root_inst: None
   lhs_rest: HP_65(flted_14_64,y)
   rhs_rest: emp
   alias set: []rhs_inst: []rhs_infer: None
 ### estate : ex_formula : HP_65(flted_14_64,y)&x!=q_50 & zzz=null & q_50=zzz&{FLOW,(20,21)=__norm#E}[]
 es_heap:x::node<zzz>@M
 es_infer_vars: [zzz]
 es_infer_pure: [zzz=null]
 ### conseq :
 y::node<flted_14_49>@M&
flted_14_49=null & zzz_48=zzz & x!=zzz_48 & q_50=zzz_48&
{FLOW,(20,21)=__norm#E}[]

(==solver.ml#11761==)
do_fold_w_ctx@1
do_fold_w_ctx inp1 :  x::node<zzz>@M * H1(y)&{FLOW,(20,21)=__norm#E}[]
 es_evars: [zzz_48; flted_14_49]
 es_gen_impl_vars(E): []
 es_rhs_eqset: [zzz_48:zzz]
 es_trace:  Fold
 es_infer_vars: [zzz]
 es_infer_vars_hp_rel: [H1]
 es_unsat_flag: false
do_fold_w_ctx inp2 :
 conseq =  y::node<flted_14_49>@M * x::lseg<zzz_48>@M&flted_14_49=null & zzz_48=zzz&
{FLOW,(20,21)=__norm#E}[]
 rhs_node =  x::lseg<zzz_48>@M
 vd = None
 rhs_rest =  y::node<flted_14_49>@M
 rhs_b =  y::node<flted_14_49>@M * x::lseg<zzz_48>@M&flted_14_49=null & zzz_48=zzz&
{FLOW,(20,21)=__norm#E}[]
do_fold_w_ctx inp3 :false
do_fold_w_ctx@1 EXIT: MaybeErr Context: 
    fe_kind: MAY
    fe_name: logical bug
    fe_locs: {
        fc_message: AndR[ y!=null & x!=y & x!=null |-  x=zzz. LOCS:[0;14];  true |-  flted_14_59=null. LOCS:[0;14] (may-bug).]
        fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
      }
    [[ Fold ==>  InferUnfold  ==>  InferHeap ==>  Match(y,y)]]
   FAIL_UNION 
    fe_kind: MAY
    fe_name: logical bug
    fe_locs: {
        fc_message:  true |-  flted_14_64=null. LOCS:[0;14] (may-bug)
        fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
      }
    [[ Fold ==>  Match(x,x) ==>  COND ==>  BaseCaseFold ==>  InferUnfold  ==>  InferHeap ==>  Match(y,y)]]
   
 CEX:false

Entail (1) : Fail.(may) cause:UnionR[AndR[ y!=null & x!=y & x!=null |-  x=zzz. LOCS:[0;14];  true |-  flted_14_59=null. LOCS:[0;14] (may-bug).], true |-  flted_14_64=null. LOCS:[0;14] (may-bug)]

Residue:

 MaybeErr Context: 
    fe_kind: MAY
    fe_name: logical bug
    fe_locs: {
        fc_message: AndR[ y!=null & x!=y & x!=null |-  x=zzz. LOCS:[0;14];  true |-  flted_14_59=null. LOCS:[0;14] (may-bug).]
        fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
      }
    [[ Fold ==>  InferUnfold  ==>  InferHeap ==>  Match(y,y)]]
   FAIL_UNION 
    fe_kind: MAY
    fe_name: logical bug
    fe_locs: {
        fc_message:  true |-  flted_14_64=null. LOCS:[0;14] (may-bug)
        fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}
      }
    [[ Fold ==>  Match(x,x) ==>  COND ==>  BaseCaseFold ==>  InferUnfold  ==>  InferHeap ==>  Match(y,y)]]
   
 CEX:false
Validate 1: Expecting(3)Valid BUT got : Fail_May


Unexpected List: [1]

Stop z3... 71 invocations 
Stop Omega... 80 invocations 
SAT Count   : 102
SAT % Hit   : 58.82%
IMPLY Count : 71
IMPLY % Hit : 59.15%
Time(cache overhead) : 0.024785 (seconds)

0 false contexts at: ()

!!! log(small):(0.306198,260)
Total verification time: 0.191811 second(s)
	Time spent in main process: 0.14102 second(s)
	Time spent in child processes: 0.050791 second(s)

