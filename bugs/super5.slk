data node { int val ; node next }.

pred ls<p> == self = p 
	or self::node<next = r> * r::ls<p> & self!=p
	inv true.



checkentail a::node<_,b> |- 
        case {
          a=b -> [] a::node<_,b>;
          a!=b -> [] a::ls<b>;
        }.

checkentail a::node<_,b> & a!=b |- a::ls<b>.

checkentail a::node<_,b> & a=b |- a::ls<b>.

checkentail a::node<_,b>  |- case {
              a=b -> [] a::ls<b>;
             a!=b -> [] a::ls<b>;
            }.


lemma self::ls<p> -> self::ls<b>*b::ls<p>.

checkentail self=p 
 or self::node<next = r> * r::ls<p> & self!=p
    |- self::ls<b>*b::ls<p>.
//print residue.

// seems a bug handling lemma below!
lemma self::ls<z>  <- self::ls<y>*y::ls<z> & z=null . 

//lemma self::ls<z>  <- self::ls<y>*y::ls<z> & z=null.

//lemma self::ll<z>  <- self::ls<z> & z=nil.



// bug below!
//checkentail x::ls<y>*y::ls<z> |- x::ls<z>.

//checkentail x::ls<y>*y::ls<z> & z!=null |- x::ls<z>.

checkentail x::ls<y>*y::ls<null> |- x::ls<null>.

checkentail y::ls<null> & x=y
   or x::node<_,q>*q::ls<y> * y::ls<null> & x!=y |- x::ls<null>.


//pred ll<> == self::node<_,null> . 

//checkentail x::node<_,y> |- x::ll<>.

