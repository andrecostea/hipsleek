# test3.slk # DONE 

Inference has three basic problems in above file/

//(4).
infer[n] x::ll<n> |- x::node<_,null>.
print residue.
/*
This is WRONG! Previously, we got n=1 as inferred constraint.

Entail (4) : Fail.
*/

//(10).
infer[Q] x::node<_,y> * y::ll<n2> & 
Q(n1-1, n2, n3) & n1>0 |- x::ll<n3> & Q(n1,n2,n3).
print residue.
/*
The RELASS are wrong here. n3=n2+1 should have been instantiated
and n3=1 occurs when n2=0 presumably.

 <1>emp&Q(-1+n1,n2,n3) & 0<n1 & Anon_183=Anon_21 & r_184=y & n3=n2+1 & n3=1&{FLOW,(19,20)=__norm}[]
 inferred rel: [RELASS [Q]: ( Q(-1+n1,n2,n3)) -->  n3=n2+1; 
                RELASS [Q]: ( Q(-1+n1,n2,n3)) -->  n3=1; 
                RELDEFN Q: ( 1<=n1 & 0<=n2 & Q(-1+n1,n2,n3)) -->  Q(n1,n2,n3)]
*/



#



added memo_Pure re-patch;
      should do it more selectively

has assert been specialised?
  --> specialised on the fly

qsort
=====
 q is existential.. 
 prune baga conditions: (self,q)-163,(self)-162
 

use propagation and simplication for pruning conditions?

xform has redundancy (e.g. bugs/llrb5.slk)

A node with Derived became Original after lemma folding! which example?

view_unfold_num should be made into a verifier option

view_original should be changed from bool to integer
  0 -> original
  1,2,.. -> derived

Printing very indented:
                            [c<=1(IP)& 0<=c(IP)]  [true]  alias set:[@]
                          [d]:  [d<=2(IP)& 0<=d(IP)]  [true]  alias set:
                          [@])) &
                         {FLOW,(52,53)=__norm,}
                           ECase case {c=1 -> ECase case {d=0 -> EAssume 36:
                                                                   EXISTS(bh_123,
                                                                   flted_0_114,
                                                                   flted_0_115,
                                                                   flted_0_116: 

# graph2.txt: DONE

Why do two equivalent expression below give different result!

checkentail
x4::ls<x5>
* x3::node<x4>
* x4::ls<x7>
* x4::node<q>
* q::ls<x6> & x4!=x6
& x5!=x7
& x1=x2 & x2=x3
|- false.


checkentail
x3::node<x4>
* x4::ls<x5>
* x4::ls<x7>
* x4::node<q>
* q::ls<x6> & x4!=x6
& x5!=x7
& x1=x2 & x2=x3
|- false.

# test-5a.slk

How come explicit instantiation still have "exist" wrapper?

 checkentail x::sll<n> & n>2 |- [q] x::node<_,q>.

/*

Why is there an EXIST q wrapper for explicit instantiation?

 <1>EXISTS(q,flted_8_243: q::sll<flted_8_243>@M[0][Orig]&n=flted_8_243+1 & 2<n & q=q&{FLOW,(19,20)=__norm})[]


*/
@2! vheap: c'::node<Anon_12'@L,nn'@L>@L[Orig]&true&{FLOW,(1,25)=__flow}[]
@2! vheap 2: c'::node<Anon_12'@L,nn'@L>@L[Orig]&true&{FLOW,(1,25)=__flow}[]


dprint: bind2.ss:16: ctx:  List of Failesc Context: [FEC(0, 0, 1  )]

Successful States:
[
 Label: 
 State:c::node<Anon_11@M,p@M>@M[Orig]&c=c' & 0<=0 & Anon_11=Anon_33' & nn_34'=p&{FLOW,(22,23)=__norm}[]
       es_var_measures: MayLoop
       es_trace: empty

 ]

dprint: bind2.ss:20: ctx:  List of Failesc Context: [FEC(0, 0, 1  )]

Successful States:
[
 Label: 
 State:hfalse&false&{FLOW,(22,23)=__norm}[]

# bind2b1.ss (vs bind2b.ss)  TEMP FIXED fields-->@M

node paper_fix (node c)
  requires c::node<_,p>
  ensures res=p;
{
      node t;
      bind c to (vv,nn) in { t = nn; };
      dprint;
      return t;
}

/*

Why is this bind inferred as @M?
@7! >>>>>> bind type-checker <<<<<<
@7! node:c
@7! fields:[vv_32,nn_33]
@7! node ann:@M
@7! fields ann:[@L,@L]
@7! read-only:false

It should be @L; as in bind2b.ss with
@7! >>>>>> bind type-checker <<<<<<
@7! node:c
@7! fields:[val_15_762,next_15_763]
@7! node ann:@L
@7! fields ann:[@A,@L]
@7! read-only:true
@7!bind2b.ss:15: 10: bind: unfolded context:



*/


# bind2b2.ss   DONE

node paper_fix (node c)
  requires c::node<_,p>
  ensures res=p;
{
      node t;
      t = bind c to (vv,nn) in nn ;
      dprint;
      return t;
}

/*

Why is there a parsing error for bind in the RHS of assignment?

File "bind2b2.ss", line 15, characters 8-9
 --error: Stream.Error("[expression] expected after EQ (in [assignment_expression])")


*/

# bind2e.ss

 bind node lost during exception!

bind node not released by exception!
  1. restore
  2. use try-catch for bind?

dprint: bind2e.ss:17: ctx:  List of Failesc Context: [FEC(0, 1, 0 )]
Escaped States:
[
 
 Try-Block:0::
 [
  Path: 
  State:emp&c=c' & 0<=0 & Anon_11=Anon_36' & nn_37'=p & nn_37'=res&{FLOW,(16,17)=__Return}[]
        es_var_measures: MayLoop
        es_trace: empty

  ]
 ]


# bind2{e3,e4}.ss  DONE 
     (via CF.normalize_max_renaming_list_failesc_context_4_bind)

dprint: bind2e4.ss:18: ctx:  List of Failesc Context: [FEC(0, 1, 0 )]
!!! bind:tmp_res1:[ Escaped States:
 [
  
  Try-Block:62::
  [
   Path: 
   State:emp&c=c' & 0<=0 & Anon_11=Anon_36' & nn_37'=p & nn_37'=res&{FLOW,(16,17)=__Return}[]
         es_var_measures: MayLoop
         es_trace: empty

   ];
  
  ]]

bind2e3.ss

!!! bind:tmp_res1:[ 
 Successful States:
 [
  Label: 
  State:emp&c=c' & 0<=0 & Anon_11=Anon_36' & nn_37'=p & nn_37'=res&{FLOW,(16,17)=__Return}[]
        es_var_measures: MayLoop
        es_trace: empty

  ]]


# TODO how about field level access for bind2{e3,e4}.ss

Trung:

Could you try fix the type problem below 
at default branch? If possible, please also
support type annotation at the infer parameter
list by changing the parser, e.g:
  infer [(x:int)] x=3 & x=x' |-  x>4.

# bugs/cll-type.slk

// why "could not find coherent-type below" ?
// x & x' has the same int type
infer [x] x=3 & x=x'
 |-  x>4.

# cll-t2.slk  FIXED by Trung

infer [x] x::node<val_35_804,next_35_805> & y=null
 |-  y!=null.

/*
Got error which is not present in sa_logging branch.

ERROR: at _0:0_0:0 
Message: x is not found in both sides
 caught

It is not necessary for x to be on both sides;
just one side is sufficient.
*/

infer [x] x::node<val_35_804,next_35_805> & x=y
 |-  x!=null.

/*
Got error which is not present in sa_logging branch.

ERROR: at _0:0_0:0 
Message: x is not found in both sides
 caught

But x ia already on both sides!
*/
