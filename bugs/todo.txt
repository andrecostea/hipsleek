# test3.slk

Inference has three basic problems in above file/

//(4).
infer[n] x::ll<n> |- x::node<_,null>.
print residue.
/*
This is WRONG! Previously, we got n=1 as inferred constraint.

Entail (4) : Fail.
*/

//(10).
infer[Q] x::node<_,y> * y::ll<n2> & 
Q(n1-1, n2, n3) & n1>0 |- x::ll<n3> & Q(n1,n2,n3).
print residue.
/*
The RELASS are wrong here. n3=n2+1 should have been instantiated
and n3=1 occurs when n2=0 presumably.

 <1>emp&Q(-1+n1,n2,n3) & 0<n1 & Anon_183=Anon_21 & r_184=y & n3=n2+1 & n3=1&{FLOW,(19,20)=__norm}[]
 inferred rel: [RELASS [Q]: ( Q(-1+n1,n2,n3)) -->  n3=n2+1; 
                RELASS [Q]: ( Q(-1+n1,n2,n3)) -->  n3=1; 
                RELDEFN Q: ( 1<=n1 & 0<=n2 & Q(-1+n1,n2,n3)) -->  Q(n1,n2,n3)]
*/



#

added memo_Pure re-patch;
      should do it more selectively

has assert been specialised?
  --> specialised on the fly

qsort
=====
 q is existential.. 
 prune baga conditions: (self,q)-163,(self)-162
 

use propagation and simplication for pruning conditions?

xform has redundancy (e.g. bugs/llrb5.slk)

A node with Derived became Original after lemma folding! which example?

view_unfold_num should be made into a verifier option

view_original should be changed from bool to integer
  0 -> original
  1,2,.. -> derived

Printing very indented:
                            [c<=1(IP)& 0<=c(IP)]  [true]  alias set:[@]
                          [d]:  [d<=2(IP)& 0<=d(IP)]  [true]  alias set:
                          [@])) &
                         {FLOW,(52,53)=__norm,}
                           ECase case {c=1 -> ECase case {d=0 -> EAssume 36:
                                                                   EXISTS(bh_123,
                                                                   flted_0_114,
                                                                   flted_0_115,
                                                                   flted_0_116: 
