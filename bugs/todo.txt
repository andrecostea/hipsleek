# test3.slk # DONE 

Inference has three basic problems in above file/

//(4).
infer[n] x::ll<n> |- x::node<_,null>.
print residue.
/*
This is WRONG! Previously, we got n=1 as inferred constraint.

Entail (4) : Fail.
*/

//(10).
infer[Q] x::node<_,y> * y::ll<n2> & 
Q(n1-1, n2, n3) & n1>0 |- x::ll<n3> & Q(n1,n2,n3).
print residue.
/*
The RELASS are wrong here. n3=n2+1 should have been instantiated
and n3=1 occurs when n2=0 presumably.

 <1>emp&Q(-1+n1,n2,n3) & 0<n1 & Anon_183=Anon_21 & r_184=y & n3=n2+1 & n3=1&{FLOW,(19,20)=__norm}[]
 inferred rel: [RELASS [Q]: ( Q(-1+n1,n2,n3)) -->  n3=n2+1; 
                RELASS [Q]: ( Q(-1+n1,n2,n3)) -->  n3=1; 
                RELDEFN Q: ( 1<=n1 & 0<=n2 & Q(-1+n1,n2,n3)) -->  Q(n1,n2,n3)]
*/



#



added memo_Pure re-patch;
      should do it more selectively

has assert been specialised?
  --> specialised on the fly

qsort
=====
 q is existential.. 
 prune baga conditions: (self,q)-163,(self)-162
 

use propagation and simplication for pruning conditions?

xform has redundancy (e.g. bugs/llrb5.slk)

A node with Derived became Original after lemma folding! which example?

view_unfold_num should be made into a verifier option

view_original should be changed from bool to integer
  0 -> original
  1,2,.. -> derived

Printing very indented:
                            [c<=1(IP)& 0<=c(IP)]  [true]  alias set:[@]
                          [d]:  [d<=2(IP)& 0<=d(IP)]  [true]  alias set:
                          [@])) &
                         {FLOW,(52,53)=__norm,}
                           ECase case {c=1 -> ECase case {d=0 -> EAssume 36:
                                                                   EXISTS(bh_123,
                                                                   flted_0_114,
                                                                   flted_0_115,
                                                                   flted_0_116: 

# graph2.txt: DONE

Why do two equivalent expression below give different result!

checkentail
x4::ls<x5>
* x3::node<x4>
* x4::ls<x7>
* x4::node<q>
* q::ls<x6> & x4!=x6
& x5!=x7
& x1=x2 & x2=x3
|- false.


checkentail
x3::node<x4>
* x4::ls<x5>
* x4::ls<x7>
* x4::node<q>
* q::ls<x6> & x4!=x6
& x5!=x7
& x1=x2 & x2=x3
|- false.

# test-5a.slk

How come explicit instantiation still have "exist" wrapper?

 checkentail x::sll<n> & n>2 |- [q] x::node<_,q>.

/*

Why is there an EXIST q wrapper for explicit instantiation?

 <1>EXISTS(q,flted_8_243: q::sll<flted_8_243>@M[0][Orig]&n=flted_8_243+1 & 2<n & q=q&{FLOW,(19,20)=__norm})[]


*/
@2! vheap: c'::node<Anon_12'@L,nn'@L>@L[Orig]&true&{FLOW,(1,25)=__flow}[]
@2! vheap 2: c'::node<Anon_12'@L,nn'@L>@L[Orig]&true&{FLOW,(1,25)=__flow}[]


dprint: bind2.ss:16: ctx:  List of Failesc Context: [FEC(0, 0, 1  )]

Successful States:
[
 Label: 
 State:c::node<Anon_11@M,p@M>@M[Orig]&c=c' & 0<=0 & Anon_11=Anon_33' & nn_34'=p&{FLOW,(22,23)=__norm}[]
       es_var_measures: MayLoop
       es_trace: empty

 ]

dprint: bind2.ss:20: ctx:  List of Failesc Context: [FEC(0, 0, 1  )]

Successful States:
[
 Label: 
 State:hfalse&false&{FLOW,(22,23)=__norm}[]

# bind2b1.ss (vs bind2b.ss)  TEMP FIXED fields-->@M

node paper_fix (node c)
  requires c::node<_,p>
  ensures res=p;
{
      node t;
      bind c to (vv,nn) in { t = nn; };
      dprint;
      return t;
}

/*

Why is this bind inferred as @M?
@7! >>>>>> bind type-checker <<<<<<
@7! node:c
@7! fields:[vv_32,nn_33]
@7! node ann:@M
@7! fields ann:[@L,@L]
@7! read-only:false

It should be @L; as in bind2b.ss with
@7! >>>>>> bind type-checker <<<<<<
@7! node:c
@7! fields:[val_15_762,next_15_763]
@7! node ann:@L
@7! fields ann:[@A,@L]
@7! read-only:true
@7!bind2b.ss:15: 10: bind: unfolded context:



*/


# bind2b2.ss   DONE

node paper_fix (node c)
  requires c::node<_,p>
  ensures res=p;
{
      node t;
      t = bind c to (vv,nn) in nn ;
      dprint;
      return t;
}

/*

Why is there a parsing error for bind in the RHS of assignment?

File "bind2b2.ss", line 15, characters 8-9
 --error: Stream.Error("[expression] expected after EQ (in [assignment_expression])")


*/

# bind2e.ss

 bind node lost during exception!

bind node not released by exception!
  1. restore
  2. use try-catch for bind?

dprint: bind2e.ss:17: ctx:  List of Failesc Context: [FEC(0, 1, 0 )]
Escaped States:
[
 
 Try-Block:0::
 [
  Path: 
  State:emp&c=c' & 0<=0 & Anon_11=Anon_36' & nn_37'=p & nn_37'=res&{FLOW,(16,17)=__Return}[]
        es_var_measures: MayLoop
        es_trace: empty

  ]
 ]


# bind2{e3,e4}.ss  DONE 
     (via CF.normalize_max_renaming_list_failesc_context_4_bind)

dprint: bind2e4.ss:18: ctx:  List of Failesc Context: [FEC(0, 1, 0 )]
!!! bind:tmp_res1:[ Escaped States:
 [
  
  Try-Block:62::
  [
   Path: 
   State:emp&c=c' & 0<=0 & Anon_11=Anon_36' & nn_37'=p & nn_37'=res&{FLOW,(16,17)=__Return}[]
         es_var_measures: MayLoop
         es_trace: empty

   ];
  
  ]]

bind2e3.ss

!!! bind:tmp_res1:[ 
 Successful States:
 [
  Label: 
  State:emp&c=c' & 0<=0 & Anon_11=Anon_36' & nn_37'=p & nn_37'=res&{FLOW,(16,17)=__Return}[]
        es_var_measures: MayLoop
        es_trace: empty

  ]]


# TODO how about field level access for bind2{e3,e4}.ss

Trung:

Could you try fix the type problem below 
at default branch? If possible, please also
support type annotation at the infer parameter
list by changing the parser, e.g:
  infer [(x:int)] x=3 & x=x' |-  x>4.

# bugs/cll-type.slk

// why "could not find coherent-type below" ?
// x & x' has the same int type
infer [x] x=3 & x=x'
 |-  x>4.

# cll-t2.slk  FIXED by Trung

infer [x] x::node<val_35_804,next_35_805> & y=null
 |-  y!=null.

/*
Got error which is not present in sa_logging branch.

ERROR: at _0:0_0:0 
Message: x is not found in both sides
 caught

It is not necessary for x to be on both sides;
just one side is sufficient.
*/

infer [x] x::node<val_35_804,next_35_805> & x=y
 |-  x!=null.

/*
Got error which is not present in sa_logging branch.

ERROR: at _0:0_0:0 
Message: x is not found in both sides
 caught

But x ia already on both sides!
*/
==============================================
# bugs/app-2.slk  FIXED

checkentail x::ll_tail2<tx,nnn>@M 
 |-  tx::node<a,b>@L. 
// |-  tx::node<a,b>. 

-dd tracing

It seems that lemmas are not being triggered for@L.

With @L, I got

!!!:0: 0: do_base_case_unfold attempt for :  r_121::ll_tail2<tx_118,flted_12_119>@M[1][Orig]
!!!:0: 0: do_base_case_unfold attempt : unsuccessful for :  r_121::ll_tail2<tx_118,flted_12_119>@M[1][Orig]
!!!:0: 0: process_action :
 ### action =  LHSCaseAnalysis =>
                    Type: MaterializedArg (tx,partial,) view_defn_mater
                    LHS: x::ll_tail2<tx,nnn>@M[0][Orig][LHSCase]
                    RHS: tx::node<a,b>@L[Orig]
 lhs_rest: Hole[93]
 rhs_rest: emp
 ### estate =  x::ll_tail2<tx,nnn>@M[0][Orig][LHSCase]&true&{FLOW,(19,20)=__norm}[]
 ### conseq =  tx::node<a,b>@L[Orig]&true&{FLOW,(19,20)=__norm}[]


!!!:0: 0: do_lhs_case : unsuccessful for :  x::ll_tail2<tx,nnn>@M[0][Orig][LHSCase]
Entail (1) : Fail.


With @M, I got:

!!!:0: 0: process_action :
 ### action =  Lemma ==> ll_tail2 =>
                       Type: MaterializedArg (tx_116,partial,) coerc_defn_mater: ==> ll_tail2
                       LHS: r_119::ll_tail2<tx_116,flted_12_117>@M[1][Orig]
                       RHS: tx::node<a,b>@M[Orig]
 lhs_rest: x::node<Anon_118,r_119>@M[Orig]
 rhs_rest: emp
 ### estate =  x::node<Anon_118,r_119>@M[Orig] * r_119::ll_tail2<tx_116,flted_12_117>@M[1][Orig]&nnn=flted_12_117+1 & r_119!=null & tx=tx_116&{FLOW,(19,20)=__norm}[]
 ### conseq =  tx::node<a,b>@M[Orig]&true&{FLOW,(19,20)=__norm}[]


!!!:0: 0: do_coercion: estate : es_formula: 
  x::node<Anon_118,r_119>@M[Orig] * 
  r_119::ll_tail2<tx_116,flted_12_117>@M[1][Orig]&nnn=flted_12_117+1 & 
  r_119!=null & tx=tx_116&{FLOW,(19,20)=__norm}[]
 es_pure: true
 es_orig_ante: None

============================================================
# bug-base-case-2.slk  FIXED (lhs-case disabled by default)

performance bug

lhs-case-analysis seem to have triggered many alternatives:
Is there a way to apply lemma wo resorting to LHS case analysis,
so that (1) would work

Entail (2) : Valid. 

 <1>
    emp&q3=t & q=self & n!=self & q3=t & Anon_16=Anon_17 & q3!=self&
    {FLOW,(19,20)=__norm}[]
    or emp&n!=self & q3!=t & Anon_16=Anon_17 & self!=t&
       {FLOW,(19,20)=__norm}[]
    
<2>
   emp&q3=t & q=self & n!=self & q3=t & Anon_16=Anon_17&
   {FLOW,(19,20)=__norm}[]
   or emp&n!=self & q3!=t & Anon_16=Anon_17 & self!=t&{FLOW,(19,20)=__norm}[]
   
<3>emp&n!=self & Anon_16=Anon_17 & self!=t&{FLOW,(19,20)=__norm}[]
<4>
   emp&q3=t & q=self & n!=self & Anon_16=Anon_17 & q3=t & q3!=self&
   {FLOW,(19,20)=__norm}[]
   or emp&n!=self & Anon_16=Anon_17 & q3!=t & self!=t&{FLOW,(19,20)=__norm}[]
   
<5>
   emp&q3=t & q=self & n!=self & Anon_16=Anon_17 & q3=t & q3!=self&
   {FLOW,(19,20)=__norm}[]
   or emp&n!=self & Anon_16=Anon_17 & q3!=t & self!=t&{FLOW,(19,20)=__norm}[]

--dis-lhs-case

Entail (2) : Valid. 

 <1>emp&n!=self & Anon_16=Anon_17 & self!=t&{FLOW,(19,20)=__norm}[]

================================================================================================
# bug-lem-2.slk  FIXED

lemma "dll_r5_tail2" self::dll_r5<p,t,n>  
  <- self::dll_r5<p,q,t> * t::node<_,q,n> & self!=n.

/*

find_materialized_prop@1
find_materialized_prop inp1 :[self,p,t,n]
find_materialized_prop inp2 : {1}->EXISTS(p_13,t_14,q_15,n_16,q,Anon_11: 
 self::node<p_13,q,t_14>@M[Orig] * t::node<Anon_11,q_15,n_16>@M[Orig]
   &n!=self & p=p_13 & t=t_14 & q=q_15 & 
  n=n_16&{FLOW,(1,22)=__flow})[]

find_materialized_prop@1 EXIT out :[ (self,full,), (t,full,)]

find_materialized_prop@2
find_materialized_prop inp1 :[self,p,t,n]
find_materialized_prop inp2 : 
EXISTS(q_32,Anon_12,q: 
 self::dll_r5<p,q,t>@M#O[dll_r5_tail2][0][Derv][LHSCase] * 
 t::node<Anon_12,q_32,n>@M[Derv]&n!=self & q=q_32&{FLOW,(1,22)=__flow})[]

find_materialized_prop@2 EXIT out :[ (n,full,[dll_r5]), (p,full,[dll_r5]), (self,full,[dll_r5]), (t,partial,)]

find_materialized_prop@3@2
find_materialized_prop inp1 :[self,p,t,n]
find_materialized_prop inp2 : EXISTS(q_33,Anon_12,
q: self::dll_r5<p,q,t>@M#O[dll_r5_tail1][0][Derv][LHSCase] * 
t::node<Anon_12,q_33,n>@M[Derv]&q=q_33&{FLOW,(1,22)=__flow})[]
find_materialized_prop@3 EXIT out :[ (n,full,[dll_r5]), (p,full,[dll_r5]), (self,full,[dll_r5]), (t,partial,)]

EXPECT:
 find_materialized_prop@3 EXIT out :[(self,full,[dll_r5]), (t,partial,)]

*/

pred A<> == self=null  or  self::tree<c>* c::B<>
 inv true.
pred B<> == self=null or  self::node<c>* c::A<>
 inv true.

===================================================================

# mut-bug-1.slk  FIXED

Why is B<> pick as a type decaration rather
than view declaration? In mut-1.slk, we can
have mutual predicates with more than 1 parameter.

SOLN : If type declaration is not found, please
 assume that it is a view declaration.


ERROR: at mut-bug-1.slk_15:42_15:48 
Message: no type declaration named B is found
 
ERROR: at mut-bug-1.slk_17:41_17:47 
Message: no type declaration named A is found
===================================================================
# bugs/rose-bug-type.ss 

Why is there a type: check_child$node~tree~null

ERROR: at rose-bug-type.ss_31:15_31:45 
Message: trans_exp :: case CallNRecv :: procedure 2 check_child$node~tree~null is not found
 Stop Omega... 26 invocations Halting Reduce... 
caught
===================================================================
# bugs/rose-bug-type2.ss 

Typechecker has failed to pick error below with check_child(t.children,t,t)

Why wasn't check_child(t.children,t,t) flagged
as a type error. The error only appeared during trans_exp

ERROR: at rose-bug-type2.ss_32:15_32:42 
Message: trans_exp :: case CallNRecv :: procedure 2 check_child$node~tree~tree is not found
===================================================================
# swl.ss --en-logging-txt -tp om
./hip bugs/schorr-waite-list.ss -tp om --en-logging-txt  > a

PROBLEMS (i) could simplifier help push existential inwards
             and/or eliminate them, e.g nxt can be elim, while
             Mnt can be pushed inwards
(ii) Why ante/conseq seems to be wrong way for some examples
     such as 149 below.
-------------------- 
 id: 150; prover: ; loc: swl_ss_12:11_12:43; kind: Pred_Check_Inv
 Simplify:  exists(Mnxt:exists(nxt:M=union(Mnxt,bag({self})) & s!=self & self!=null & 
nxt!=s))
 res:  exists(Mnxt:exists(nxt:M=union(Mnxt,bag({self})) & s!=self & self!=null & 
nxt!=s))
 -------------------- 
 id: 149; prover: ; loc: swl_ss_12:11_12:43; kind: Pred_Check_Inv
 Imply: ante: s!=self
	     conseq:  (exists(Mnxt:exists(nxt:M=union(Mnxt,bag({self})) & s!=self & self!=null & 
nxt!=s)) | (self=null & M=bag() & s!=self))
 res: false
 -------------------- 
We have 4 large timeout from the above. Two of them seem to have exceeded
the 5s timeout we impose on mona proof. Why is this so?

no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 17.149072; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 4.832302; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 26.361647; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 4.880305; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

However, when I run it separately as a sleek command (see time.slk);
it seems to have adhered to the default time limits of 5seconds.

----------------


no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 21.965372; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 9.73661; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 31.249953; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 9.732609; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

--------

no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 16.365021; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 3.908244; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 25.205576; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 3.864241; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:1749: id: 314; prover: MONA; TIME: 42.110632; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

-------


----------

which seems to have exceeded the 3 sec timeout we placed
for imply_timeout. Can we check why these are not being
enforced by mona prover?

imply_timeout@34
imply_timeout inp1 : Mc=union(Mnxt_1007,bag({cur_1016})) & cur_1016!=sentinel_1008 & 
s_1004=sentinel_1008 & cur=cur_1016 & prev=prev_1015 & sentinel=sentinel' & 
cur!=null & sentinel=sentinel_1008 & sentinel=sentinel_1009 & 
n_50'=nxt_1006 & next_33_1014=nxt_1006 & cur_1016=prev_1027 & 
cur_1026=n_50' & cur_1026!=sentinel' & !(v_bool_37_944') & 
cur_1026!=sentinel' & !(v_bool_37_944') & cur_1026=null & v_bool_38_945' & 
cur_1026=null & v_bool_38_945' & cur'=prev_1027 & prev'=null & 
exists(sentinel_1061:cur'=sentinel_1061) & Mc_1030=bag() & 
exists(sentinel_1062:prev'!=sentinel_1062) & Mp_1031=bag() & 
(((exists(Mnxt:Mnxt_1007=union(Mnxt,bag({nxt_1006}))) & nxt_1006!=s_1004 & 
nxt_1006!=null) | (nxt_1006=null & Mnxt_1007=bag() & nxt_1006!=s_1004))) & 
(((exists(M1:Mp=union(bag({prev}),M1)) & prev!=sentinel_1009 & prev!=null) | 
(prev=sentinel_1009 & Mp=bag()))) & cur_1016!=null
imply_timeout inp2 : cur'=sentinel'
imply_timeout inp3 :timeout:3.
imply_timeout inp4 :234
imply_timeout@34 EXIT out :false
[mona.ml]:Timeout exception


 id: 234; prover: MONA; TIME: 31.249953; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
 Imply: ante: Mc=union(Mnxt_1007,bag({cur_1016})) & cur_1016!=sentinel_1008 & 
s_1004=sentinel_1008 & cur=cur_1016 & prev=prev_1015 & sentinel=sentinel' & 
cur!=null & sentinel=sentinel_1008 & sentinel=sentinel_1009 & 
n_50'=nxt_1006 & next_33_1014=nxt_1006 & cur_1016=prev_1027 & 
cur_1026=n_50' & cur_1026!=sentinel' & !(v_bool_37_944') & cur_1026=null & 
v_bool_38_945' & cur'=prev_1027 & prev'=null & Mc_1030=bag() & 
exists(sentinel_1108:prev'!=sentinel_1108) & Mp_1031=bag() & 
(((exists(Mnxt_1107:Mnxt_1007=union(Mnxt_1107,bag({nxt_1006}))) & 
nxt_1006!=s_1004 & nxt_1006!=null) | (nxt_1006=null & Mnxt_1007=bag() & 
nxt_1006!=s_1004))) & (((exists(M1_1106:Mp=union(bag({prev}),M1_1106)) & 
prev!=sentinel_1009 & prev!=null) | (prev=sentinel_1009 & Mp=bag()))) & 
cur_1016!=null
	     conseq:  cur'=sentinel'
 res: false

===================================================================
# swl-num.ss

Why ante/conseq seem to be reversed here? Is this
really required since we known inv is just an approx.

id: 150; prover: OMEGA CALCULATOR; loc: swl-num_ss_12:11_12:40; kind: Pred_Check_Inv
 Imply: ante: 0<=n & s!=self
	     conseq:  ((n=0 & self=null & self<=(s-1)) | (s<self & self!=null & 1<=n) | 
(self!=null & self<s & 1<=n) | (n=0 & s<self & self=null))
 res: false
===================================================================
# "bug-lbl-1.ss"

lg<"n":s,"b":M> == true & ["n":self = null & self != s; "b":M = {}] 
	or self::node<_,nxt> * nxt::lg<s,Mnxt> & ["b": M = union(Mnxt,{self}); "n": self != s]
inv ["n":self!=s];

since inv is supposed to contain just pure, why can't
we have:
inv ["n":self!=s];

Parsing file "bug-lbl-1.ss" by default parser...
File "bug-lbl-1.ss", line 9, characters 4-5
 --error: Stream.Error("[exl_pure] expected after OSQUARE (in [cexp_w])")
 at:(Program not linked with -g, cannot print stack backtrace)
===================================================================
# swl-lbl.ss -tp om --en-logging-txt

poor exists formation at expense of labels.
On the LHS, perhaps existential can be removed by
simply replacing with free vars. On the RHS,
existentials must be kept.

 id: 157; prover: MONA; loc: swl-lbl_ss_8:4_8:87; kind: Compute_Base_Case
 Simplify:  exists(Mnxt:exists(nxt:nxt!=s & nxt!=null & 
exists(Mnxt_858:Mnxt=union(Mnxt_858,bag({nxt})))) & M=union(Mnxt,
bag({self})))
 res:  exists(Mnxt:exists(nxt:nxt!=s & nxt!=null & 
exists(Mnxt_858:Mnxt=union(Mnxt_858,bag({nxt})))) & M=union(Mnxt,
bag({self})))

how did we get a [b,n]:

 id: 161; prover: MONA; loc: swl-lbl_ss_8:4_8:87; kind: Compute_Base_Case
 Sat:  (((AndList ([],self!=null) & ([b],M=union(bag(),bag({self})))
 & ([n],self=null & s!=self & s!=self & s!=null)) ) | 
((AndList ([b,n],exists(Mnxt:exists(nxt:nxt!=s & nxt!=null & 
          exists(Mnxt_858:Mnxt=union(Mnxt_858,bag({nxt})))) & M=union(Mnxt,
          bag({self}))) & s!=self & self!=null)
 & ([n],self=null & s!=self)) ))
 res: UNSAT

===================================================================
./hip bugs/schorr-waite-list.ss -tp om --en-logging-txt  > a

We have 4 large timeout from the above. Two of them seem to have exceeded
the 5s timeout we impose on mona proof. Why is this so?

no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 17.149072; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 4.832302; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 26.361647; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 4.880305; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

However, when I run it separately as a sleek command;
it seems to have adhered to the default time limits.
----------------


no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 21.965372; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 9.73661; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 31.249953; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 9.732609; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

--------

no_eps_proof_log_bugs_schorr-waite-list_ss.txt:358: id: 192; prover: MONA; TIME: 16.365021; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:417: id: 196; prover: MONA; TIME: 3.908244; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:790: id: 234; prover: MONA; TIME: 25.205576; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:806: id: 235; prover: MONA; TIME: 3.864241; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
no_eps_proof_log_bugs_schorr-waite-list_ss.txt:1749: id: 314; prover: MONA; TIME: 42.110632; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC

-------


----------

which seems to have exceeded the 3 sec timeout we placed
for imply_timeout. Can we check why these are not being
enforced by mona prover?

imply_timeout@34
imply_timeout inp1 : Mc=union(Mnxt_1007,bag({cur_1016})) & cur_1016!=sentinel_1008 & 
s_1004=sentinel_1008 & cur=cur_1016 & prev=prev_1015 & sentinel=sentinel' & 
cur!=null & sentinel=sentinel_1008 & sentinel=sentinel_1009 & 
n_50'=nxt_1006 & next_33_1014=nxt_1006 & cur_1016=prev_1027 & 
cur_1026=n_50' & cur_1026!=sentinel' & !(v_bool_37_944') & 
cur_1026!=sentinel' & !(v_bool_37_944') & cur_1026=null & v_bool_38_945' & 
cur_1026=null & v_bool_38_945' & cur'=prev_1027 & prev'=null & 
exists(sentinel_1061:cur'=sentinel_1061) & Mc_1030=bag() & 
exists(sentinel_1062:prev'!=sentinel_1062) & Mp_1031=bag() & 
(((exists(Mnxt:Mnxt_1007=union(Mnxt,bag({nxt_1006}))) & nxt_1006!=s_1004 & 
nxt_1006!=null) | (nxt_1006=null & Mnxt_1007=bag() & nxt_1006!=s_1004))) & 
(((exists(M1:Mp=union(bag({prev}),M1)) & prev!=sentinel_1009 & prev!=null) | 
(prev=sentinel_1009 & Mp=bag()))) & cur_1016!=null
imply_timeout inp2 : cur'=sentinel'
imply_timeout inp3 :timeout:3.
imply_timeout inp4 :234
imply_timeout@34 EXIT out :false
[mona.ml]:Timeout exception


 id: 234; prover: MONA; TIME: 31.249953; loc: bugs_schorr-waite-list_ss_43:2_43:26; kind: PRE_REC
 Imply: ante: Mc=union(Mnxt_1007,bag({cur_1016})) & cur_1016!=sentinel_1008 & 
s_1004=sentinel_1008 & cur=cur_1016 & prev=prev_1015 & sentinel=sentinel' & 
cur!=null & sentinel=sentinel_1008 & sentinel=sentinel_1009 & 
n_50'=nxt_1006 & next_33_1014=nxt_1006 & cur_1016=prev_1027 & 
cur_1026=n_50' & cur_1026!=sentinel' & !(v_bool_37_944') & cur_1026=null & 
v_bool_38_945' & cur'=prev_1027 & prev'=null & Mc_1030=bag() & 
exists(sentinel_1108:prev'!=sentinel_1108) & Mp_1031=bag() & 
(((exists(Mnxt_1107:Mnxt_1007=union(Mnxt_1107,bag({nxt_1006}))) & 
nxt_1006!=s_1004 & nxt_1006!=null) | (nxt_1006=null & Mnxt_1007=bag() & 
nxt_1006!=s_1004))) & (((exists(M1_1106:Mp=union(bag({prev}),M1_1106)) & 
prev!=sentinel_1009 & prev!=null) | (prev=sentinel_1009 & Mp=bag()))) & 
cur_1016!=null
	     conseq:  cur'=sentinel'
 res: false

===================================================================
# bug-2-swl.ss -tp om -nxpure 0

Procedure lscan$node~node~node FAIL-2

Exception Failure("Mona translation failure!!\nError in file monatemp line  column ") Occurred!
(Program not linked with -g, cannot print stack backtrace)

Error(s) detected when checking procedure lscan$node~node~node
Stop Omega... 37 invocations 
1 false contexts at: ( (42,24) )

Total verification time: 30.165884 second(s)
	Time spent in main process: 0.380023 second(s)
	Time spent in child processes: 29.785861 second(s)
===================================================================
# bug-3-view-swl.ss -tp om  # FIXED

when the invariant of a view fail, it did not report
a view name which could be helpful.
===================================================================
# bug-2-swl.ss

find_order@36
find_order inp1 : (!((Mc_r36=union(Mnxt_1017_r36,{cur_1026_r36}) & 
cur_1026_r36!=sentinel_1018_r36 & s_1014_r36=sentinel_1018_r36 & 
cur_1026_r36=cur_r36 & prev_1025_r36=prev_r36 & sentinel_r36=sentinel_r36' & 
cur_r36!=null & sentinel_1018_r36=sentinel_r36 & 
sentinel_1019_r36=sentinel_r36 & n_50_r36'=nxt_1016_r36 & 
next_39_1024_r36=nxt_1016_r36 & cur_1026_r36=prev_1037_r36 & 
cur_1036_r36=n_50_r36' & cur_1036_r36!=sentinel_r36' & 
!(v_bool_43_957_r36') & NULLV_r36=cur_1036_r36 & v_bool_44_958_r36' & 
cur_r36'=prev_1037_r36 & NULLV_r36=prev_r36' & Mc_1040_r36={} & 
nxt_1016_r36!=s_1014_r36 & (((NULLV_r36=nxt_1016_r36 & Mnxt_1017_r36={}) | 
(nxt_1016_r36!=null & Mnxt_1017_r36!=({})))) & 
(((prev_r36=sentinel_1019_r36 & Mp_r36={}) | (prev_r36!=sentinel_1019_r36 & 
Mp_r36!=({}) & prev_r36!=null))) & cur_1026_r36!=null & NULLV_r36=null)) | 
prev_r36'!=sentinel_1064_r36)
find_order inp2 :
find_order res2 :; (sentinel_1019_r36 1); (v_bool_43_957_r36' 2); (prev_r36 1); (prev_r36' 1); (Mp_r36 2); (s_1014_r36 1); (prev_1037_r36 1); (cur_1026_r36 1); (Mc_r36 2); (sentinel_r36 1); (sentinel_1018_r36 1); (cur_r36' 1); (cur_1036_r36 1); (prev_1025_r36 1); (Mnxt_1017_r36 2); (n_50_r36' 1); (v_bool_44_958_r36' 2); (nxt_1016_r36 1); (next_39_1024_r36 1); (sentinel_r36' 1); (cur_r36 1); (sentinel_1064_r36 0); (prev_r36' 0); (Mc_1040_r36 2); (NULLV_r36 1)
find_order@36 EXIT out :?

# bug-2-swl.slk

find_order@3
find_order inp1 : (!((Mc_r3=union(Mnxt_1017_r3,{cur_1026_r3}) & 
cur_1026_r3!=sentinel_1018_r3 & s_1014_r3=sentinel_1018_r3 & 
cur_1026_r3=cur_r3 & prev_1025_r3=prev_r3 & sentinel_r3=sentinel_r3' & 
cur_r3!=null & sentinel_1018_r3=sentinel_r3 & sentinel_1019_r3=sentinel_r3 & 
n_50_r3'=nxt_1016_r3 & next_39_1024_r3=nxt_1016_r3 & 
cur_1026_r3=prev_1037_r3 & cur_1036_r3=n_50_r3' & 
cur_1036_r3!=sentinel_r3' & !(v_bool_43_957_r3') & NULLV_r3=cur_1036_r3 & 
v_bool_44_958_r3' & cur_r3'=prev_1037_r3 & NULLV_r3=prev_r3' & 
Mc_1040_r3={} & nxt_1016_r3!=s_1014_r3 & (((NULLV_r3=nxt_1016_r3 & 
Mnxt_1017_r3={}) | (nxt_1016_r3!=null & Mnxt_1017_r3!=({})))) & 
(((prev_r3=sentinel_1019_r3 & Mp_r3={}) | (prev_r3!=sentinel_1019_r3 & 
Mp_r3!=({}) & prev_r3!=null))) & cur_1026_r3!=null & NULLV_r3=null)) | 
prev_r3'!=sentinel_1064_r3)
find_order inp2 :
find_order res2 :; (sentinel_1018_r3 1); (sentinel_1019_r3 1); (s_1014_r3 1); (Mc_1040_r3 2); (sentinel_r3 1); (cur_r3' 1); (prev_1037_r3 1); (NULLV_r3 1); (sentinel_r3' 1); (v_bool_43_957_r3' 2); (n_50_r3' 1); (prev_r3 1); (cur_r3 1); (cur_1026_r3 1); (v_bool_44_958_r3' 2); (Mp_r3 2); (Mnxt_1017_r3 2); (sentinel_1064_r3 1); (next_39_1024_r3 1); (nxt_1016_r3 1); (cur_1036_r3 1); (prev_r3' 1); (prev_1025_r3 1); (Mc_r3 2)
find_order@3 EXIT out :?
===================================================================
# ../hip schorr-waite-list-2.ss -tp om --en-logging-txt

The time-out for MONA is currently 5s. However, some tasks
are taking much longer. Is this due to some batch mode task
rather than interactive tasks? Is it possible to always
use interactive MONA proving? Why do we need batch MONA proving?

no_eps_proof_log_schorr-waite-list-2_ss.txt:350: id: 192; prover: MONA; TIME: 15.412962; loc: schorr-waite-list-2_ss_48:2_48:26; kind: PRE_REC
no_eps_proof_log_schorr-waite-list-2_ss.txt:392: id: 195; prover: MONA; TIME: 4.94431; loc: schorr-waite-list-2_ss_48:2_48:26; kind: PRE_REC
no_eps_proof_log_schorr-waite-list-2_ss.txt:685: id: 233; prover: MONA; TIME: 13.892869; loc: schorr-waite-list-2_ss_48:2_48:26; kind: PRE_REC

===================================================================
# schorr-waite-list-lbl.ss -tp om --en-sleek-logging-txt

There are two problems:
 (i) printing of ANDLIST can be more compact (see sleek log file)
 (ii) we have a failure below. can we figure out why?

 id: 98; caller: []; line: 27; classic: false; kind: [POST,
Check_Specs]; hec_num: 4; evars: [sentinel_1404,M_1405]; infer_vars: []; c_heap: 
prev::lg<sentinel_1255,Mp>@M * cur_1262::node<Anon_1251,prev_1261>@M

 checkentail nxt_1252::ls<p_1250,M1_1253>@M&
AndList[ []:cur=cur_1262 & prev=prev_1261 & n_42'=nxt_1252 & 
         next_33_1260=nxt_1252 & cur_1262=prev' & cur'=n_42' & 
         cur'=sentinel & v_bool_37_933' & cur'=sentinel & v_bool_37_933'
 ; ["n"]:cur_1262!=sentinel_1254 & p_1250=sentinel_1254 & cur!=sentinel & 
   sentinel=sentinel_1254 & sentinel=sentinel_1255 & 
   exists(sentinel_1404:sentinel_1255=sentinel_1404 & prev'!=sentinel_1404)
 ; ["s"]:Mc=union({cur_1262},M1_1253) & exists(M_1405:M_1405=union(Mp,
   {prev'}))] &
{FLOW,(22,23)=__norm}[]
 |-  EXISTS(sentinel_1404,M_1405: emp&
AndList[ ["n"]:cur'=sentinel & sentinel=sentinel_1404 & 
         sentinel_1255=sentinel_1404 & prev'!=sentinel_1404
 ; ["s"]:M_1405=union(Mc,Mp) & M_1405=union(Mp,{prev'})] &
{FLOW,(22,23)=__norm})[]. 
res:  failctx
         fe_kind: MAY
         fe_name: logical bug
         fe_locs: {
                   fc_message: failed in entailing pure formula(s) in conseq
                   fc_current_lhs_flow: {FLOW,(22,23)=__norm}}
===================================================================
# swl-x2b.slk  CG fixing label.ml

"" should be treated as a common label, so that below
succeeds.

checkentail true &
 ["": x=5;
  "n": y>x]
 |- true & 
     ["n":y>5].
===================================================================
# ll-back-3a.ss

This example works in default but not sa_logging branch!

Parsing file "ll-back-3a.ss" by default parser...

!!!  processing primitives "["prelude.ss"]
Starting Omega...oc

!!! dumping for finalize on hipStop Omega... 1 invocations caught
(Program not linked with -g, cannot print stack backtrace)

Exception occurred: Not_found
Error3(s) detected at main 

====================================================================
# 13-5.slk --sa-en-cont

infer [H1] H1(y)  |- y::lseg<null> .
print residue.

WARNING : Pushing 2 stk_estate (4)
Message: unsat_xpure : encountered a disjunctive formula 
!!! WARNING logtime exception:0.004caught
(Program not linked with -g, cannot print stack backtrace)
Entailment Failure (1) Failure("unsat_xpure : encountered a disjunctive formula \n")
===================================================================
# i13-5.slk

xform has self>0 instead of self!=null

  {1}->emp&p=self&{FLOW,(1,22)=__flow}[]
   || {2}->(exists p_12,q: self::node<q>@M * q::lseg<p_12>@M&p!=self & 
      p=p_12&{FLOW,(1,22)=__flow})[]
  xform: ((p!=self & self>0) | p=self)

===================================================================
# i13-5a.slk  (in bugs)

infer [H1] H1(y) & (x=2 | x>5)  |- y::lseg<null> .

./sleek i13-5a.slk --sa-en-cont --iesa --dsd

Using above triggers an unsat_xpure exception

!!! infer_deep_ante_issues triggered by --iesa
!!! if stk_estate > 1, can cause unsat_xpure exception
!!! Thai : can we convert below to single ctx by using pure or rather than CtxOr
!!! new_ante_fmls:[ HP_40(flted_18_39)&flted_18_39=null&{FLOW,(19,20)=__norm}[]]

ISSUES 
 1. added a flag --infer-en-split-ante that
    would trigger deep_lhs split of antecedent for pure inference
 2. Added simplify_with_pairwise to reduce disjunction
 3. To address
    - minimise on stk-estate
    - use pure disjunct rather than heap disjunct
    - balanced use of deep_lhs
      (i) try normal infer_pure first
      (ii) if fail, try deep_lhs cases?

keyword in code :  infer_deep_ante_issues 

For i13-5a example, the following are points to note:

This example added:

!!! WARNING : deep-ante-split activated
!!! split-1:[ x=2, 5<x]
!!! split-2:[ ((x=2 | 5<x)) & (((flted_18_41!=y & y!=null) | flted_18_41=y))]WARNING : Pushing 2 stk_estate (4)
 
However, we later generated two identical LHS term, that was
triggered by split of [x=2, 5<x]. Such split is probably
not meaningful since x is not an inferrable var but is
currently triggered by --iesa

It later generated two identical residue, and probably two
rel assumption, as well.

!!! new_ante_fmls:[ 
HP_42(flted_18_41)&flted_18_41=null&{FLOW,(19,20)=__norm}[], 
HP_42(flted_18_41)&flted_18_41=null&{FLOW,(19,20)=__norm}[]
]

I think you should do 2 things (i) first; then (ii)
(i) combine new_ante_fmls into a single pure-or always so
    that the unsat exception do not occur
(ii) allow infer_pure_m to be triggered on its own first;
     if it succeeds do not do deep_ante_split
(iii) there is also an issue with identical rel_assume 
    being introduced; but as this is harmless I think u
    may skip it first.

===================================================================
# baga-2.slk

pred l4<q> == 
  self::node<q>*q::node<_>
inv self!=null.
// baga {self,q}

pred l5<k> == 
  self::node<q>*q::node<_> & k=q
inv self!=null.

l4 is Ok but l5 is missing on 
a baga address.

need to get visible parameters and
extract equality from pure formula 
for substitution in xpure_symbolic

 missing on k for baga formula
 addr vars: self
  uni_vars: []
  bag of addr: self
  view_complex_inv: None
===================================================================
# baga-2.slk

(i) duplicated calls to formula_2_mem..
(ii) are they critical?

formula_2_mem@1
formula_2_mem inp1 : {1}->(exists q,Anon_11: self::node<q>@M * q::node<Anon_11>@M&k=q & q!=self&
{FLOW,(1,22)=__flow})[]
formula_2_mem@1 EXIT out : [[self,q]]

formula_2_mem@3
formula_2_mem inp1 : {1}->(exists q,Anon_11: self::node<q>@M * q::node<Anon_11>@M&k=q & q!=self&
{FLOW,(1,22)=__flow})[]
formula_2_mem@3 EXIT out : [[self,q]]

!!! xform(mix): exists(q:k=q & q!=self & q!=null) & self!=null
!!! view_addr_vars:[self]
!!! view_vars:[k]
!!! view_baga:[self,q]
!!! new_baga:[self]

formula_2_mem@5
formula_2_mem inp1 : {1}->(exists q,Anon_11: self::node<q>@M * q::node<Anon_11>@M&k=q & q!=self&
{FLOW,(1,22)=__flow})[]
formula_2_mem@5 EXIT out : [[self,q]]

formula_2_mem@7
formula_2_mem inp1 : {1}->(exists q,Anon_11: self::node<q>@M * q::node<Anon_11>@M&k=q & q!=self&
{FLOW,(1,22)=__flow})[]
formula_2_mem@7 EXIT out : [[self,q]]

formula_2_mem@9
formula_2_mem inp1 : {1}->self::node<q>@M * q::node<Anon_11>@M&k=q & q!=self&
{FLOW,(1,22)=__flow}[]
formula_2_mem@9 EXIT out : [[self,q]]

===================================================================
# baga-3.slk

pred l3a<> == 
  self::node<q>*q::node<_>  & self=q
inv self!=null.

  prune baga conditions: ([q])-1,([self])-2
should be:
  prune baga conditions: ([q])-1,([self,self])-2

pred l6<q:node> == 
  q::node<_> & self=null
  or self::node<r>*r::node<_> & r=q
inv q!=null.

Got:
  prune invs:3:
   ,[{1,2} -> {[q]} [ q!=null]; {1} -> {[q]} [ self=null; q!=null]; 
   {2} -> {[self]} [ q!=null; self!=null]]
Should be:
  prune invs:3:
   ,[{1,2} -> {[q]} [ q!=null]; {1} -> {[q]} [ self=null; q!=null]; 
   {2} -> {[self,q]} [ q!=null; self!=null]]

pred l7<q:node> == 
  self=null & q=null
  or self::node<r>*r::node<_> & r=q
inv true.

GOT:
  prune invs:3:
   ,[{4,5} -> {[]} []; {4} -> {[]} [ self=null; q=null]; 
   {5} -> {[self]} [ self!=null; q!=null]]
should be:
  prune invs:3:
   ,[{4,5} -> {[]} []; {4} -> {[]} [ self=null; q=null]; 
   {5} -> {[self,q]} [ self!=null; q!=null]]

===================================================================
# bug-classic-4a.slk: FIXED

infer_exact
[P1] n::node<_,null> & self=null
|- P1(self).
print residue.

 <1>(exists flted_23_51: emp&flted_23_51=null & self=null&{FLOW,(19,20)=__norm})[]
 inferred hprel: [// Sleek_Entail(2)
n::node<Anon_14,flted_23_51>@M&flted_23_51=null & 
self=null --> P1(self)]

PROBLEM : why did we include an unrelated n::node<_,null>
 when folding with unknown predicate?
===================================================================
# sp-5a.slk, sp-5b.slk: FIXED

These are very basic examples. I am surprised that they could
be wrong..

//(3)
infer_exact [P1] 
   self=null
|- P1(p) & self=p.
print residue.
// expect self=null --> P1(self)
/*
 <1>emp&self=null & p=null&{FLOW,(19,20)=__norm}[]
 inferred hprel: [// Sleek_Entail(1)
emp --> P1(p_18); 
// Sleek_Entail(1)
P1(p) --> emp&
p=null]
*/


//(3)
infer [P1] 
   self=null
|- P1(p) & self=p.
print residue.
// expect self=null --> P1(self)
/*
// Sleek_Entail(2)
P1(p) --> emp&
p=null]
*/

Entail (3) : Valid. 



//(3)
infer [P1] 
   self=null
|- P1(self) & self=p.
print residue.
// expect self=null --> P1(self)

/*
 <1>emp&self=null & p=self&{FLOW,(19,20)=__norm}[]
 inferred hprel: [// Sleek_Entail(3)
emp --> P1(p)]
*/


===================================================================
# sp-5c.slk: # sp-5e.slk: FIXED

//4
infer [P1] 
   self::node<_,_> 
|- P1(self) & self!=null.
print residue.

/*
// expecting it to succeed
// self::node<_,_> --> P1(self)

c_heap should come from LHS..

 --------------------
!!!  
id: 11; caller: []; line: 0; classic: false; kind: Sleek_Entail(4); hec_num: 4; evars: []; infer_vars: []; c_heap: P1(self)
 checkentail emp&{FLOW,(19,20)=__norm}[]
 |-  emp&self!=null&{FLOW,(19,20)=__norm}[]. 

*/

===================================================================
# baga-test-fail.slk

Unsound as below succeeded, even though it is supposed
to fail. The error was introduced when merging from default.

pred l6<q:node> == 
  q::node<_> & self=null
  or self::node<r>*r::node<_> & r=q
inv q!=null.
// baga {q}

// (9) Fail
checkentail x::l6<_> * x::l6<_> |- false.
===================================================================
# err-pure-inf.slk

Old branch (term-si) supports both inference below.
However, sa_logging fails for the second one. Why?
It seems pure inference is now somewhat broken here.

infer [a,b]   b=c |- a>b.
print residue.

infer [a,c]   b=c |- a>b.
print residue.

Old branch @ term_si give correct result:

Entail (1) : Valid. 
 <1>Base emp&b=c & b<a&{FLOW,(19,20)=__norm}[]
 inferred pure: [b<a]


Entail (2) : Valid. 
 <1>Base emp&b=c & c<a&{FLOW,(19,20)=__norm}[]
 inferred pure: [c<a]

# run-fast-test

Total number of errors: 5 in files:
  infer/infer5.slk({E3#Fail}) infer/infer12.slk({E14#Fail},{E3#Valid}) infer/infer13.slk({E5#Valid}) infer/infer14.slk({E14#Valid},{E16#Valid}) infer/infer16.slk({E5#Valid},{E6#Valid}).
T
===================================================================
# bugs/bubble-1.ss --esl --en-inf -p bubble

Can we tidy printing for --esl. It could be
an option that is on by default (e.g. --print-tidy)

 --------------------
!!!dumping for bubble$node FAIL2
!!!  
id: 423; caller: []; line: 51; TIME: 0.83; classic: false; kind: POST; hec_num: 5; evars: [n_2565,k1_2566,sm1_2567]; infer_vars: []; c_heap: emp
 checkentail r_1706::lls<flted_35_1704,k_1702,sm_1703>@M * xs'::node<v_1705,r_1528>@M * 
r_1528::node<v_1527,r_1706>@M&0<n_1540 & 0<n_1540 & 0<n_1540 & 0<n_1540 & 
k1_1566!=n_1540 & n_1540=flted_35_1704+1 & k1_1566<n_1540 & 
v_1705<=sm1_1567 & k1_1566=k_1702 & sm1_1567=sm_1703 & 0<n_1540 & 0<n_1540 & 
k!=n & n=flted_35_1526+1 & k<n & v_1527<=sm & k=k_1524 & sm=sm_1525 & 0<n & 
xs=xs' & k!=n & r_1528!=null & !(v_bool_57_1175') & r_1528!=null & 
!(v_bool_57_1175') & flted_35_1526=n_1540 & k_1524=k_1541 & 
sm_1525=sm_1542 & k_1541!=n_1540 & k_1524<=flted_35_1526 & 0<=k_1524 & 
tmp_2563 & k1_1566=1+k_1541 & sm1_1567<=sm_1542 & k_1541!=n_1540 & 
k_1541<=n_1540 & 0<=k_1541 & v_1705<v_1527 & !(v_bool_65_1173') & 
v_1705<v_1527 & !(v_bool_65_1173') & v_1527=val_70_1736 & 
v_1705=val_71_1748 & flag_2564 & v_boolean_76_1174' & flag_2564 & 
res=v_boolean_76_1174'&{FLOW,(26,27)=__norm}[]
 |-  (exists n_2565,k1_2566,sm1_2567: xs::lls<n_2565,k1_2566,sm1_2567>@M&
{FLOW,(26,27)=__norm})[]. 

===================================================================
 ./run-fast-tests.pl sleek_fracperm

Total number of errors: 7 in files:
  fracperm/norm1.slk({E4#Valid}) fracperm/norm3.slk({E2#Valid},{E3#Valid},{E4#Valid},{E5#Valid},{E6#Valid},{E7#Valid}) fracperm/norm4.slk({E2#Valid},{E3#Valid}) fracperm/combine_data.slk({E1#Valid},{E11#Valid},{E2#Valid},{E3#Valid},{E4#Valid},{E7#Valid},{E8#Valid},{E9#Valid}) fracperm/combine_simple.slk({E1#Valid},{E2#Valid},{E4#Valid},{E7#Valid}) fracperm/split-combine.slk({E14#Valid},{E15#Valid}) fracperm/combine2.slk({E1#Valid},{E2#Valid},{E4#Valid}).

===================================================================
# Shuffle-v.ss  vs rev-1.ss

unsoundness of hip ; log of sleek contains failure.

===================================================================
# sh-rev.sh


unsound lemma problem with

lemma_safe self::lseg<n,r>  <- self::lseg<m,q>*q::node<_,r> & n=m+1.

checkentail ni::node<_, l> * l::node<_,null> |- ni::lseg<2, l> * l::node<_, null>.
// valid but should fail

checkentail ni::node<_, l> * l::node<_,null> |- ni::lseg<1, l>*l::node<_,null>.

checkentail x::lseg<n,r> & n>0 |- x::lseg<n-1, l>*l::node<_,r>.
// fail but shd succeed?

print residue.
===================================================================
# sh-rev2.slk

lemma_safe self::lseg<n,r>  <- self::lseg<m,q>*q::node<_,r> & n=m+2.

checkentail_exact  self::node<_,r> & n=m+2 & m=0 & self=q
  |- self::lseg<n,r>.
// valid : base case
print residue.

/*
Why is a RD_lemma triggered?? when the RHS did not contain a node?
This lemma should only be triggered by a folding when both
LHS and RHS are x::lseg<..>

===================================================================
# sh-rev3a.slk  (unsoundness in lemma)

Must add sh-rev3a.slk and sh-rev3b.slk to run-fast-test!

Why was false triggered by lemma proving?
I guess it is not properly normalized.
I am concerned that unnormalized form leads to unsoundness.

id: 1; caller: []; line: 0; classic: true; kind: Verify_Lemma; hec_num: 5; evars: []; infer_vars: []; c_heap: emp
 checkentail q::node<_,r>@M&n=2+m & m=0 & q=self&{FLOW,(21,22)=__norm}[]
 |-  self::lseg<n,r>@M&{FLOW,(21,22)=__norm}[]. 
res:  1[
   hfalse&false&{FLOW,(21,22)=__norm}[]
   ]


Below came from sleek proving where the RHS was normalized as:
 |-  (exists n1,r1: self::lseg<n1,r1>@M & n1=n & r1=r). 

However, it is a weirf that we have instead:
 |-  (exists n,r: self::lseg<n,r>@M & ...)

--------

id: 20; caller: []; line: 25; classic: true; kind: Sleek_Entail(1); hec_num: 5; evars: [n_166,r_167]; infer_vars: []; c_heap: emp
 checkentail q::node<_,r>@M&q=self & m=0 & n=m+2&{FLOW,(21,22)=__norm}[]
 |-  (exists n,r: self::lseg<n,r>@M&{FLOW,(21,22)=__norm})[]. 
res:  1[
   emp&n=m+2 & m=0 & q=self & Anon_14=v_168 & q_169=r & exists(flted_5_176:flted_5_176=0) & exists(p_175:p_175=q_169) & exists(r_167:q_169=r_167) & exists(n_166:n_166=0+1)&{FLOW,(21,22)=__norm}[]
   ]
 
id: 28; caller: []; line: 25; classic: true; kind: Sleek_Entail(1); hec_num: 4; evars: [n_166,r_167]; infer_vars: []; c_heap: q::node<_,r>@M
 checkentail emp&exists(n_166:n_166=0+1) & exists(r_167:q=r_167) & 
exists(p_175:p_175=q) & exists(flted_5_176:flted_5_176=0) & q=r & Anon=v & 
q1=self & m=0 & n=m+2&{FLOW,(21,22)=__norm}[]
 |-  (exists n1,r1: emp&q=r1 & n1=0+1 & r=r1 & n=n1&{FLOW,(21,22)=__norm})[]. 
res:  failctx
         fe_kind: MUST
         fe_name: logical bug
         fe_locs: {
                   fc_message:  n=0+2 |-  n=1+0. LOCS:[24;5] (must-bug)
                   fc_current_lhs_flow: {FLOW,(3,4)=__Error}}

=======

!!! LP.lhs: (exists q_51,_,m_53: self::lseg<m_53,q_51>@M * q_51::node<_,r>@M&n=2+m_53&
{FLOW,(21,22)=__norm})[]
!!! LP.fv_lhs:[self,r,n]
!!! LP.lhs(unfolded): 
 (exists q_54,_,m_56: q_54::node<_,r>@M&q_54=self & m_56=0 & n=2+m_56&
 {FLOW,(21,22)=__norm})[]
 or (exists p_68,flted_5_69,v_70,q_71,q_54,_,m_56: self::node<v_70,q_71>@M * 
    q_71::lseg<flted_5_69,p_68>@M * q_54::node<_,r>@M&m_56=flted_5_69+1 & 
    p_68=q_54 & n=2+m_56&{FLOW,(21,22)=__norm})[]
 
!!! LP.rhs: EBase (exists n_45,r_46: self::lseg<n_45,r_46>@M&n=n_45 & r=r_46&
       {FLOW,(21,22)=__norm})[]

!!! LP.new_rhs: EBase (exists n_45,r_46: self::lseg<n_45,r_46>@M&n=n_45 & r=r_46&
       {FLOW,(21,22)=__norm})[]

>>> Calling process_coercion_check
>>> How come rhs lost some info

!!! LP.glob_vs_rhs:[]
!!! LP.fv_rhs:[]
!!! LP.rhs(after unfold): EBase self::lseg<n,r>@M&{FLOW,(21,22)=__norm}[]
!!! iconseq: EBase self_lem_13::lseg<n,r>@M&{FLOW,(21,22)=__norm}[]
===================================================================

without rd_lemma
----------------
Total number of errors: 2 in files:
  lemmas/lseg.slk({L1#Valid},{L2#Valid}) lemmas/rlseg.slk({L3#Valid}).
Total verification time: 0.00 second

Checking append-tail.ss
error at: append-tail.ss append

Total number of errors: 1 in files:
 error at: append-tail.ss append

with rd_lemma
-------------
Total number of errors: 1 in files:
  lemmas/lseg.slk({L1#Valid},{L2#Valid}).

Leads to unsoundness of sh-rev3a.slk

===================================================================
checkentail
 self=nx & bk=pr |- self::dll<bk,b,a>.
print residue.
/*
# fold-dll-1.slk

why fail?
                          es_must_error: Some(Cannot infer heap and pure 2)
                          es_trace:  COND ==>  UnmatchedRHSData ==> 
                          es_infer_vars_rel: []] <1>emp&self=nx & bk=pr&{FLOW,(21,22)=__norm}[]
===================================================================
# bug1.slk implict-var need to be disabled..

To add below,and to make disable the default (for smt-compete esp)
--dis-implicit-var
--en-implicit-var

checkentail_exact x1::ls<x2> * x2::node<next = x1> 
 |- x3::ls<x2> * x2::node<next = x3> .
print residue.

/*


run_infer:
 x1::ls<x2> * x2::node<x1>&{FLOW,(21,22)=__norm}[] [] |-  EBase exists (Expl)[](Impl)[x3](ex)[](exists x2_28: x3::ls<x2_28> * 
       x2::node<x3>&x2_28=x2&{FLOW,(21,22)=__norm})[]

*/
===================================================================
# ll2a.ss 

without --imm

int length (node x)
	infer[@term]
	requires x::ll<n>@L
        ensures res=n;

Checking procedure length$node... Proving binding in method length$node for spec  EAssume 
   emp&{FLOW,(24,25)=__norm}[]
   , Line 10

( [(,1 ); (,2 )]) bind: node  x'::node<val_13_1183',next_13_1184'> cannot be derived from context
ll2a.ss_13:24_13:30

===================================================================
# mapreduce.ss -tp parahip --eps -perm fperm --classic

 where is __false
 where is primitives Line 64?

!!!Full processing file "mapreduce.ss"
Parsing file "mapreduce.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Omega...oc

Last Proving Location: 1 File "primitives",Line:64,Col:0

ERROR: at _0:0_0:0 
Message: Can not find flow of __false
 Stop Omega... 0 invocations caught
 (Program not linked with -g, cannot print stack backtrace)

Exception occurred: Failure("Can not find flow of __false")
Error3(s) detected at main 
===================================================================
# infer13.slk

GOT

Entail (1) : Valid. 
Residue:
 <1>emp&q=z & z=inf_z_54&{FLOW,(4,5)=__norm#E}[]
 inferred heap: [z::lseg{}<inf_z_54>]
 inferred pure: [z=inf_z_54]
[[ SEARCH ==>  Match(x,x) ==>  COND ==>  InferHeap ==>  Match(z,q) ==> ]]

Why did we infer z::lseg<inf_z_54>? where did inf_z_54 came from?

===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
===================================================================
