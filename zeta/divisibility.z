//let [induction y] divides(x, y) := 
//	exists {z} y = x * z.

let [induction y] divides(x, y) 
be such that 
divides(x,y) <-> exists {z} y = x * z;
divides(x,y) -> divides(y,z) -> divides(x,z).

// Properties of divides relation
// These properties can be used to 
// provide an equivalence recursive
// definition!

theorem y = 0 -> divides(x,y).

theorem 0 < y & y < x -> ! divides(x,y).

theorem 0 < x & divides(x,y) -> divides(x,y+x).

theorem 0 < x & divides(x,y) -> divides(x,y-x).

theorem x < 0 & divides(0-x,y) -> divides(x,y).

theorem x < 0 & divides(x,y) -> divides(0-x,y).

theorem x = 0 & divides(x,y) -> y = 0.

// Reflexivity of divide
theorem divides(x, x).

// Antisymmetric property of divide
theorem 0 <= x & 0 <= y & divides(x,y) & 
	divides(y,x) -> x = y.

// Transitivity of divide relation
theorem divides(m, n) & divides(n, p) -> 
	divides(m, p).

// Every integer is even or odd
theorem divides(2,n) | divides(2,n+1).

// Generalization of the above to get division algorithm
//theorem 0 < x -> exists {z} (0 <= z & z < x & divides(x,y-z)).

let [induction x] isprime(x)
be such that
isprime(x) <-> x > 1 & forall {y} (1 < y & y < x -> ! divides(y,x)).

// Theorem of Eratosthenes
theorem p > 1 & forall {q} (1 < q & q < p & isprime(q) -> ! divides(q,p)) -> isprime(p).