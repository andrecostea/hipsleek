let [induction j-i] sumar(a,i,j)
such that
sumar(a,i,j)=s <-> 
((i > j & s = 0) |
(i <= j & sumar(a,i+1,j) = s - a[i])).
//j > i -> sumar(a,i,j) = 0;
//i <= j -> sumar(a,i,j) = a[i] + sumar(a,i+1,j).

let [induction j-i] sumal(a,i,j) such that
sumal(a,i,j)=s <-> 
((i > j & s = 0) |
(i <= j & sumal(a,i,j-1) = s - a[j])).
//j > i -> sumal(a,i,j) = 0;
//i <= j -> sumal(a,i,j) = sumal(a,i,j-1) + a[i].

theorem sumar(a,i+1,i) = 0.

theorem sumar(a,i,i) = a[i].

/*theorem i <= j -> sumar(a,i,j) = sumal(a,i,j).

// Sum = sum of two partitions
theorem i <= j & j <= k -> sumar(a,i,k) = sumar(a,i,j) + sumar(a,j+1,k).

let [induction j-i] relsumar(a,i,j,s) such that
relsumar(a,i,j,s) <-> (j < i & s = 0 | j >= i & relsumar(a,i+1,j,s-a[i])).

let [induction j-i] relsumal(a,i,j,s) such that
relsumal(a,i,j,s) <-> (j < i & s = 0 | j >= i & relsumal(a,i,j-1,s-a[j])).

theorem relsumar(a,i,j,s) -> relsumal(a,i,j,s).

let member(a,i,j,x) such that
member(a,i,j,x) <-> exists {k} (i <= k & k <= j & a[k] = x).

let idarr(a,b,i,j) such that
idarr(a,b,i,j) <-> forall {k} (i <= k & k <= j -> a[k] = b[k]).

// Identical arrays have the same sum
theorem idarr(a,b,i,j) -> sumar(a,i,j) = sumar(b,i,j).

*/

/* 
relation alldistinct(int[] a, int i, int j) ==
	forall(k, t : k < i | k >= t | t > j | a[k] != a[t]).

relation freq(int[] a, int i, int j, int x, int f) induction j - i ==
	(j > i & f = 0 |
	j <= i & a[i] != x & freq(a,i,j,x,f) |
	j <= i & a[i] = x & freq(a,i,j,x,f-1)).

relation upperbnd(int[] a, int i, int j, int u) induction j - i ==
	forall(k : k < i | k > j | a[k] <= u).

relation lowerbnd(int[] a, int i, int j, int u) induction j - i ==
	forall(k : k < i | k > j | a[k] >= u).

relation sorted(int[] a, int i, int j) induction j - i ==
	forall(k : k < i | k >= j | a[k] <= a[k+1]).

// recursive/constructive definition of permutation
relation permutation(int[] a, int[] b, int i, int j) induction j - i ==
	(i > j |	// base case : empty array
	forall(k : k < i | k > j | a[k] = b[k]) // reflexivity
	| permutation(a,b,i+1,j) & a[i] = b[i] 	// left extensionality
	| permutation(a,b,i,j-1) & a[j] = b[j] 	// right extensionality
	| permutation(a,b,i+1,j-1) & a[i] = b[j] & a[j] = b[i] // transposition
	| exists(c : permutation(a,c,i,j) & permutation(c,b,i,j))). // transitivity

// multiset definition: for any x, the number of occurences of x in a[i..j] and b[i..j] are identical
relation permutation2(int[] a, int[] b, int i, int j) induction j - i ==
	forall(x,fa,fb : !(freq(a,i,j,x,fa)) | !(freq(b,i,j,x,fb)) | fa = fb).

// a[1..n] is a permutation of 1,2,...,n
relation permutationstd(int[] a, int n) == true.

// definition using bijection
relation permutation3(int[] a, int n) == true.

relation dotprod(int[] a, int[] b, int i, int j, int p) ==
	(i > j & p = 0 | i <= j & dotprod(a,b,i+1,j,p-a[i]*b[i])).
	
relation mset(int[] a, int i, int j, int[] v, int[] f, int p) ==
	alldistinct(v,0,p) &
	forall(t : t < 0 | t > p | freq(a,i,j,v[t],f[t])) &	
	forall(k : k < i | k > j | exists(u : 0 <=u <= p & v[u] = a[k])).



// Sum = dot product of values & counts vectors
checkentail mset(a,i,j,v,f,p) & sum(a,i,j,f,s) |- dotprod(v,f,0,p,s).
checkentail mset(a,i,j,v,f,p) & dotprod(v,f,0,p,s) |- sum(a,i,j,f,s).

// Constructive definition of permutation implies content preservation
checkentail permutation(a,b,i,j) |- permutation2(a,b,i,j).

// And vice versa
checkentail permutation2(a,b,i,j) |- permutation(a,b,i,j).

// Sorted array with same content are identical

// x is not a member ==> count = 0
checkentail freq(a,i,j,x,0) |- !(member(a,i,j,x)).
checkentail !(member(a,i,j,x)) |- freq(a,i,j,x,0).

// If x < min{a} or x > max{a} then x does not occur in a i.e. x occurs in a for 0 time.
checkentail upperbnd(a,i,j,y) & x > y |- freq(a,i,j,x,0).
checkentail upperbnd(a,i,j,y) & x > y |- !(member(a,i,j,x)).

//checkentail lowerbnd(a,i,j,y) & x < y |- freq(a,i,j,x,0).
*/
