data node { int val ; node next }.

pred ll<n> == self = null & n = 0
	or self::node<next = r> * r::ll<n - 1>
	inv n >= 0.

pred pos_ll<n> == self = null & n = 0
	or self::node<d,r> * r::pos_ll<n - 1> & d>0
	inv n >= 0.

pred neg_ll<n> == self = null & n = 0
	or self::node<d,r> * r::neg_ll<n - 1> & d<0
	inv n >= 0.



//1. must failure
checkentail x::node<2,null> |- x::node<3,null> .
print residue.

//2. may failure
checkentail x::node<v,null> & v>2 |- x::node<3,null> .

//3. must failure
checkentail x::node<v,null> & v>2|- x::node<3,q>*q::node<_,null> .
//Entail(3)=Fail.(must) cause:15 q=null |- q.node


//4. must failure
checkentail x::node<v,null> & v>2 |- x::node<_,q>*q::node<_,null> .


//5. must failure
checkentail x::node<v,q>*q::node<_,null> |- x::node<_,null> .

//6. may failure
checkentail x::node<v,q>*q::node<_,null> |- x::node<2,q> .

//7. must failure
checkentail x::node<v,null> & v>0 |- x::node<v,q> & v<0.

//8. must failure - WRONG now may
checkentail x::ll<n> & n>0 |- x::ll<n+1> .

//9. may
checkentail true |- x::node<_,_> .

//10. may
checkentail y::node<_,_> & x!=y |- x::node<_,_> .

//11. may
checkentail y=null |- x::node<_,_> .

//12. must
checkentail x=y & y=null |- x::node<_,_> .

//13. may
checkentail x=y |- x::node<_,_> .

//14. must bug - FIXED
checkentail x=y |- x::node<_,_> * y::node<_,_>.
/*
AND reason missing..

Bad Context: 
              fe_kind: MUST{
                            fc_message:  y=x |-  x!=null & x!=y
                            fc_current_lhs_flow: {FLOW,(13,13)=__Error,}}

*/

//15. may
checkentail x!=y |- x::node<_,_> * y::node<_,_>.
/* 
Why \/ on LHS?

Entail(15)=Fail.(must) cause:15.3  y<x | x<y |-  x!=null & x!=y
printing here:  
Bad Context: 
              fe_kind: MUST{
                            fc_message:  y<x | x<y |-  x!=null & x!=y
                            fc_current_lhs_flow: {FLOW,(13,13)=__Error,}}

*/

//16. must bug - FIXED
checkentail true |- x::node<_,_> * x::node<_,_>.
//Entail(16)=Fail.(must) cause:15 contradiction in RHS

// soundness of must bug?

//17. may bug
checkentail x=y & y!=null |- x::node<_,_> .

//18. must bug
checkentail x=y & y=null |- x::node<_,_>*y::node<_,_> .

//19. must bug - WRONG now may
checkentail x::node<_,null> & x=y |- x::node<_,_>*y::node<_,_> .


//20. must-bug
checkentail x::node<_,null> & y=null  |- y::ll<n> & n>0.

//21. valid
checkentail x::node<_,null> & y=null  |- y::ll<n>.

//22. must-bug - FIXED
checkentail x::node<_,null> & y!=null  |- y::ll<n> & n=0.
/*
Why isn't it AND_reason?

Entail(22)=Fail.(must) cause:or[22  y!=null |-  y=null (must-bug).,15.3  true |-  n=0]
printing here:  
Bad Context:  
               fe_kind: MUST{
                             fc_message:  y!=null |-  y=null (must-bug).
                             fc_current_lhs_flow: {FLOW,(13,13)=__Error,}}
             FAIL_OR 
              
               fe_kind: MUST{
                             fc_message:  true |-  n=0
                             fc_current_lhs_flow: {FLOW,(13,13)=__Error,}}

*/


//23 valid
checkentail x::ll<n> & n>0  |- x!=null.

//24 must-bug
checkentail x::ll<n> & n>0  |- x=null.

//25 must-bug
checkentail x::pos_ll<n> & n=0 |- x::neg_ll<m> & m>0.

//26. must-bug
checkentail x::pos_ll<n> & x=null |- x::neg_ll<m> & m>0.

//27 must-bug
checkentail x=null |- x::neg_ll<m> & m>0.

//28 valid
checkentail x=null |- x=null or x::node<_,_>.


//29. may bug (|)
checkentail n=5 or n>0 or n>9 |- n>6.



