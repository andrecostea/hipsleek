
JUST FOR SLEEK or Proving LEMMA
===============================


  D1 & flow norm |- D2 & flow norm * R
  is_must_error(R) --> (extract_safe_must_state(R) ^^ flow norm)
  is_may_error(R)  --> R1 = R
  is_valid (R)  --> extract_safe_state(R) ^^ flow __Error 
           (succeeded when fail expected)
  -------------------------------------------
  D1 & flow norm |- D2 & flow __Error *  R1


PROVING for HIP
================

  D1 & norm  |- D2 & norm * R
  f1<:f2
  is_must_error(R) --> R1 = extract_safe_must_state(R)
  is_may_error(R) --> R1 = R
  is_valid (R)  --> R1 = update_flow(R, f1)
   ---------------------------------------------
  D1 & flow f1 |- D2 & flow f2 * R1


  __Sleek_Error <: __Error


  (* Error flow persist*)
   f1<:__Error
   not(f1<:f2)
  -------------------------------------------
  D1 & flow f1 |- D2 & flow f2 * (D1*flow f1)


 x::node<1,null> * D1 |- x::node<2,null> * D2 & flow __Error 
                    *  (D1 -> D2) & flow __Sleek_Error  (f=1 --> f=2)



  foo(x)
    require x::node<v,_> 
    ensures v;
    require x==null
    ensures true & flow __NullPtr_Error;
  {
    return x.next
  }


  x=null & norm |- (x::node<v,_> & norm) *  (true & flow __NullPtr_Error)
 

  int subs(Int[] x, int i)
  requires x::Arr<s> & 0<=i<s 
  ensures  x::Arr<s 
  requires x::Arr<s> & (i<0 | i>=s)
  ensures  x::Arr<s> & flow __Array_Bound_Err 



 x::node<_,_> * y::node<_,null>
  |- (x=null & flow = norm) * ( x!=null & y::node<_,null> & flow Sleek_Error)

   D1 |- D3
   D2 |- D4
 ------------------
 D1 * D2 |- D3 * D4



