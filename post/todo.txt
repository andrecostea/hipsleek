# foo-fact1.ss

int fact(int x)
  infer [@post]
  requires true  ensures true;

Please strengthen spec with an unknown post, e.g.
  requires true  ensures Upost1(x,res);
Before inference.
=======================================================
# foo-fact.ss -infer "@term"

Need to consider how post and @term are inferred
in sequence.

Post Inference result:
fact$int
 requires emp & factpre_0(x)[31]
 ensures emp & factpost_1127(x)[] & res=1+
(2*x) & 0<=x;

Termination Inference Result:
fact:  case {
  (x<=(0-1) | 1<=x) -> requires emp & MayLoop[]
 ensures emp & Uf(x,res); 
  x=0 -> requires emp & Term[31,1]
 ensures emp & Uf(x,res); 
  }

  infer [Uf]
  requires true  ensures Uf(x,res);
//  requires true ensures res=x;
{
  if (x==0) return 1;
  else return foo(1) + fact(x - 1);
}

This currently prints:

!!!REL POST :  Uf(x,res)
!!!POST:  res=1+(2*x) & 0<=x

Can we merge this post into our spec,
and then print it; as follows:

fact:
  requires true
  ensures res=1+2*x & x>=0;

The print out from @term is as follows:


=======================================================
# foo-fact.ss --reverify

Please write some output to indicate that re-verification
is being done. (DONE)

With --reverify:

Procedure fact$int SUCCESS.
Stop Omega... 17 invocations 
6 false contexts at: ( (17,2)  (17,11)  (17,9)  (18,7)  (18,16)  (18,14) )

!!! log(small):(0.070814,275)
Total verification time: 0.42959 second(s)

Without reverify:

Post Inference result:
fact$int
 requires emp & MayLoop[]
 ensures emp & res=1+(2*x) & 0<=x;

Procedure fact$int SUCCESS.
Stop Omega... 17 invocations 
6 false contexts at: ( (17,2)  (17,11)  (17,9)  (18,7)  (18,16)  (18,14) )

!!! log(small):(0.051432,238)
Total verification time: 0.368069 second(s)

----

Post Inference result:
fact$int
 requires emp & MayLoop[]
 ensures emp & res=1+(2*x) & 0<=x;

Obtained above but why did --reverify option fail?

-reverify option should subject the inferred code
to a re-verification process.

# it seems the --reverify option is using old spec
  of form Uf(x,res)

Checking procedure foo$int... 
Procedure foo$int SUCCESS.

Checking procedure fact$int... 

Post condition cannot be derived:
  (must) cause:  res=1 & x=0 |-  Uf(x,res). LOCS:[21;26;23] (must-bug)
OrR
  (must) cause:  0<=v_int_27_1317 & res=1+(2*v_int_27_1317)+1+1 & (v_int_27_1317+1)!=0 & 
v_int_27_1317+1=x |-  Uf(x,res). LOCS:[27;26;21;23] (must-bug)

Context of Verification Failure: 1 File "foo-fact.ss",Line:23,Col:25
Last Proving Location: 1 File "foo-fact.ss",Line:27,Col:14

ERROR: at foo-fact.ss_23:25_23:34 
Message: Post condition cannot be derived.

What does --reverify-all do?
Is it redundant?

--reverify-all gave:
Procedure fact$int SUCCESS.

without --reverify-all, still have:
Procedure fact$int SUCCESS.

=======================================================
# foo-fact2.ss

  infer [@term,@post]
  requires true  ensures true;

Since both @term and @post are specified; we should
stage it by inferring @post first.
After that, we would infer @term.

We thus expect:
 Post Inference result:
 fact:
  requires true 
  ensures res=1+2*x & x>=0;

Then:
 Termination Inference Result:
 fact:  

fact:  case {
  1<=x -> requires emp & Term[31,3,-1+(1*x)]
 ensures emp & res=1+2*x & x>=0; 
  x<=(0-1) -> requires emp & Loop[]
 ensures false & false; 
  x=0 -> requires emp & Term[31,1]
 ensures emp & res=1+2*x & x>=0; 
  }

=======================================================
# fact1.ss (DONE)

int fact(int x)
  infer [@pre_n,x,@term,@post_n]
  requires true  
  ensures true;

Need to support a mix of
infer_consts @sym and varid.
Thus, the need for twoAns type
=======================================================
# pre-1a.slk (DONE)

relation R(int x,int y).
infer [R] x>y & R(x,y) |- x>0.
print residue.

 <1>emp&0<=y & R(x,y) & y<x&{FLOW,(21,22)=__norm}[]
 inferred pure: [true]
 inferred rel: [RELASS [R]: ( R(x,y)) -->  0<=y]


Why is there a useless true pre?
 inferred pure: [true]
=======================================================
# pre-1a.slk 
 (DONE - added 
  let cp = List.filter (fun f -> not(CP.isConstTrue f)) cp in
 )
relation R(int x,int y).
infer [R] x>y & R(x,y) |- x>0.
print residue.

 <1>emp&0<=y & R(x,y) & y<x&{FLOW,(21,22)=__norm}[]
 inferred pure: [true]
 inferred rel: [RELASS [R]: ( R(x,y)) -->  0<=y]


Why is there a useless true pre?
 inferred pure: [true]
=======================================================
# post-2.ss (DONE)

int fact(int x)
  infer [Uf]
  requires true  ensures Uf(x,res);

This currently prints:

!!!REL POST :  Uf(x,res)
!!!POST:  x=res-1 & 1<=res
!!!REL PRE :  true

Can we merge this post into our spec,
and then print it; as follows: (DONE)

Post Inference result:
fact$int
 requires emp & MayLoop[]
 ensures emp & x=res-1 & 1<=res;

The print out from @term is as follows:

Termination Inference Result:
fact:  case {
  1<=x -> requires emp & MayLoop[]
 ensures emp & true; 
  x<=(0-1) -> requires emp & MayLoop[]
 ensures emp & true; 
  x=0 -> requires emp & Term[31,1]
 ensures emp & true; 
  }

=======================================================
# post-2a.ss (DONE)

  infer [Uf]
  requires x>=0 ensures Uf(x,res);
1

GOT:

Post Inference result:
fact$int
 requires emp & 0<=xrequires emp & MayLoop[]
 ensures emp & x=res-1 & 1<=res;

Can we flatter/unnest spec to obtain:

Post Inference result:
fact$int
 requires emp & 0<=x & MayLoop[]
 ensures emp & x=res-1 & 1<=res;

=======================================================
# post-2b.ss

  infer [@post_n]
  requires true  ensures true;

This currently does not do post inference.

Checking procedure fact$int... 
Procedure fact$int SUCCESS.

The idea is to form a post relation,
say post_fact(x,res) to try infer a
good pure post-condition for the function.

It would need to introduce, a fresh:
 relation post_fact(int n, int r).

and then form:

  infer [post_fact]
  requires true  
  ensures post_fact(n,res);

Before passing to hip for inference similar
to post-2.ss.

=======================================================
# fact-case2.ss --pcp (DONE)

 case {
  x=0 -> ensures res=1;
  x>0 -> ensures res>=1;
  x<0 -> requires false ensures false;
}
{
  if (x==0) return 1;
  else return 1 + fact(x - 1);
}

why EList? Why missing ensures false?

static  EList :ECase case {
               x=0 -> EList :EBase emp&MayLoop[]&{FLOW,(1,27)=__flow}[]
                                     EAssume 
                                       emp&res=1&{FLOW,(24,25)=__norm}[]
               0<x -> EList :EBase emp&MayLoop[]&{FLOW,(1,27)=__flow}[]
                                     EAssume 
                                       emp&1<=res&{FLOW,(24,25)=__norm}[]
               ;
               x<0 -> EBase hfalse&false&{FLOW,(24,25)=__norm}[] 
               }

Expects (maybe can be handled at parser):
========================================
# fact-case2-ss.

Can flatten nested spec:

static  ECase case {
        x=0 -> EBase emp&MayLoop[]&{FLOW,(1,27)=__flow}[]
                       EAssume 
                         emp&res=1&{FLOW,(24,25)=__norm}[]
                          ;
        0<x -> EBase emp&MayLoop[]&{FLOW,(1,27)=__flow}[]
                       EAssume 
                         emp&1<=res&{FLOW,(24,25)=__norm}[]
                          ;
        x<0 -> EBase hfalse&false&{FLOW,(24,25)=__norm}[]
                       EBase emp&MayLoop[]&{FLOW,(1,27)=__norm}[]
                               EAssume 
                                 hfalse&false&{FLOW,(24,25)=__norm}[]
--> (simpler to use)
        x<0 -> EBase hfalse&false & MayLoop[] & __norm
               EAssume hfalse&false&{FLOW,(24,25)=__norm}[]
        }
=======================================================
# mut-rec1.ss

Please look at examples of mutual-recursive fixpoint
in fixcalc. Please see how to invoke those commands.

Please add aux-recursion as well to your example

Checking procedure foo2$int... 
!!! WARNING : Inferable vars include some external variables!
vars:[Uf1,Uf2] pre_post_vars:[Uf2,res,n]

*************************************
*******pure relation assumption ******
*************************************
[RELDEFN Uf1: ( res=0 & n<=0) -->  Uf1(n,res),
RELDEFN Uf1: ( Uf2(v_int_30_1193,v_int_30_1197) & 0<=v_int_30_1193 & v_int_30_1197=res-1 & 
n=v_int_30_1193+1) -->  Uf1(n,res),
RELDEFN Uf2: ( res=0 & n<=0) -->  Uf2(n,res),
RELDEFN Uf2: ( Uf1(v_int_39_1229,v_int_39_1236) & 0<=v_int_39_1229 & v_int_39_1236=res-1 & 
n=v_int_39_1229+1) -->  Uf2(n,res)]
*************************************

!!! PROBLEM with fix-point calculation
Procedure foo2$int FAIL.(2)
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
=======================================================
