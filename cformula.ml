(*
  Created 21-Feb-2006

  Formula
*)

open Globals

module Err = Error
module CP = Cpure
module U = Util

type t_formula = (* type constraint *)
	(* commented out on 09.06.08 : we have decided to remove for now the type information related to the OO extension
	| TypeExact of t_formula_sub_type (* for t = C *)
	| TypeSub of t_formula_sub_type (* for t <: C *)
	| TypeSuper of t_formula_sub_type (* for t < C *)
	*)
	| TypeAnd of t_formula_and
	| TypeTrue
	| TypeFalse

and t_formula_sub_type = { t_formula_sub_type_var : CP.spec_var;
						   t_formula_sub_type_type : ident }

and t_formula_and = { t_formula_and_f1 : t_formula;
					  t_formula_and_f2 : t_formula }


and struc_formula = ext_formula list

and ext_formula = 
	| ECase of ext_case_formula
	| EBase of ext_base_formula
	| EAssume of ((Cpure.spec_var list) *formula* formula_label)


and ext_case_formula =
	{
		formula_case_branches : (Cpure.formula * struc_formula ) list;
		formula_case_exists : Cpure.spec_var list; (*should be absolete, to be removed *)
		formula_case_pos : loc 		
	}

and ext_base_formula =
	{
		 formula_ext_explicit_inst : Cpure.spec_var list;
		 formula_ext_implicit_inst : Cpure.spec_var list;
		 formula_ext_exists : Cpure.spec_var list;
		 formula_ext_base : formula;
		 formula_ext_continuation : struc_formula;
		 formula_ext_pos : loc
	}

and formula =
  | Base of formula_base
  | Or of formula_or
  | Exists of formula_exists

and formula_base = { formula_base_heap : h_formula;
					 formula_base_pure : CP.formula;
					 formula_base_type : t_formula;
					 formula_base_flow : flow_formula;
                     formula_base_branches : (branch_label * CP.formula) list;
					 formula_base_pos : loc }

and formula_or = { formula_or_f1 : formula;
				   formula_or_f2 : formula;
				   formula_or_pos : loc }

and formula_exists = { formula_exists_qvars : CP.spec_var list;
					   formula_exists_heap : h_formula;
					   formula_exists_pure : CP.formula;
					   formula_exists_type : t_formula;
					   formula_exists_flow : flow_formula;
                       formula_exists_branches : (branch_label * CP.formula) list;
 					   formula_exists_pos : loc }

and flow_formula = { formula_flow_interval : nflow;
					 formula_flow_link : (ident option)}
and flow_store = {
		formula_store_name : ident;
		formula_store_value : flow_formula;		
	}
	
and flow_treatment = 
	| Flow_combine
	| Flow_replace
					 
and h_formula = (* heap formula *)
  | Star of h_formula_star
  | DataNode of h_formula_data
  | ViewNode of h_formula_view
  | HTrue
  | HFalse
  

and h_formula_star = { h_formula_star_h1 : h_formula;
					   h_formula_star_h2 : h_formula;
					   h_formula_star_pos : loc }

and h_formula_data = { h_formula_data_node : CP.spec_var;
					   h_formula_data_name : ident;
					   h_formula_data_arguments : CP.spec_var list;
					   h_formula_data_label : formula_label option;
					   h_formula_data_pos : loc }

and h_formula_view = { h_formula_view_node : CP.spec_var;
					   h_formula_view_name : ident;
					   h_formula_view_arguments : CP.spec_var list;
					   h_formula_view_modes : mode list;
					   h_formula_view_coercible : bool;
					   h_formula_view_origins : ident list;
					   (* if this view is generated by a coercion from another view c, 
						  then c is in h_formula_view_origins. Used to avoid loopy coercions *)
					   h_formula_view_label : formula_label option;
					   h_formula_view_pos : loc }

and approx_disj = 
  | ApproxBase of approx_disj_base
  | ApproxOr of approx_disj_or

and approx_formula =
  | ApproxCon of approx_disj
  | ApproxAnd of approx_formula_and
	  
and approx_disj_base = { approx_disj_base_vars : CP.spec_var list;
						 (* list of variables that _must_ point to objects *)
						 approx_disj_base_formula : CP.formula }
	
and approx_disj_or = { approx_disj_or_d1 : approx_disj;
					   approx_disj_or_d2 : approx_disj }

and approx_formula_and = { approx_formula_and_a1 : approx_formula;
						   approx_formula_and_a2 : approx_formula }

(* utility functions *)

(*--- 09.05.2000 *)
(* pretty printing for a spec_var list *)
let rec string_of_spec_var_list l = match l with 
  | []               -> ""
  | h::[]            -> string_of_spec_var h 
  | h::t             -> (string_of_spec_var h) ^ "," ^ (string_of_spec_var_list t)

and string_of_spec_var = function 
  | CP.SpecVar (_, id, p) -> id ^ (match p with 
    | Primed   -> "'"
    | Unprimed -> "")
(*09.05.2000 ---*)

let rec formula_of_heap h pos = mkBase h (CP.mkTrue pos) TypeTrue (mkTrueFlow ()) [] pos
and formula_of_heap_fl h fl pos = mkBase h (CP.mkTrue pos) TypeTrue fl [] pos

and struc_formula_of_heap h pos = [EBase { 
		 formula_ext_explicit_inst = [];	 formula_ext_implicit_inst = []; formula_ext_exists = [];
		 formula_ext_base = formula_of_heap h pos;
		 formula_ext_continuation = [];
		 formula_ext_pos = pos}]
		 
and struc_formula_of_formula f pos = [EBase { 
		 formula_ext_explicit_inst = [];	 formula_ext_implicit_inst = []; formula_ext_exists = [];
		 formula_ext_base = f;
		 formula_ext_continuation = [];
		 formula_ext_pos = pos}]
		 
		 
and mkTrueFlow () = 
	{formula_flow_interval = !top_flow_int; formula_flow_link = None;}
	

and mkFalseFlow = {formula_flow_interval = false_flow_int; formula_flow_link = None;}

and mkNormalFlow () = { formula_flow_interval = !n_flow_int; formula_flow_link = None;}

and formula_of_pure p pos = mkBase HTrue p TypeTrue (mkTrueFlow ()) [] pos

(*and mkTrueFlowTest = {formula_flow_interval = (-3,-3); formula_flow_link = None;}
and formula_of_pure_test p pos = mkBase HTrue p TypeTrue (mkTrueFlow) [] pos*)
and formula_of_pure_with_branches p br pos = mkBase HTrue p TypeTrue (mkTrueFlow ()) br pos

and formula_of_pure_with_branches_fl p br fl pos = mkBase HTrue p TypeTrue fl br pos
and formula_of_base base = Base(base)

and data_of_h_formula h = match h with
  | DataNode d -> d
  | _ -> failwith ("data_of_h_formula: input is not a data node")

(*and isStrictConstFalse f = match f with
  | Exists ({formula_exists_heap = h;
		   formula_exists_pure = p;
           formula_exists_branches = br; 
		   formula_exists_flow = fl;})
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
           formula_base_branches = br; 
		   formula_base_flow = fl;}) ->
             (h = HFalse || CP.isConstFalse p || (List.filter (fun (_,f) -> CP.isConstFalse f) br <> []))&&
			 (is_false_flow fl.formula_flow_interval)
  | _ -> false
*)
and isAnyConstFalse f = match f with
  | Exists ({formula_exists_heap = h;
		   formula_exists_pure = p;
           formula_exists_branches = br; 
		   formula_exists_flow = fl;})
  | Base ({formula_base_heap = h;
		   formula_base_pure = p;
           formula_base_branches = br; 
		   formula_base_flow = fl;}) ->
             (h = HFalse || CP.isConstFalse p || (List.filter (fun (_,f) -> CP.isConstFalse f) br <> []))||
			 (is_false_flow fl.formula_flow_interval)
  | _ -> false
  
and isConstETrue f = 
	if (List.length f)<>1 then false
	else
	match (List.hd f) with
	  | EBase b -> (isStrictConstTrue b.formula_ext_base) &&(List.length b.formula_ext_continuation)==0
	  | _ -> false
  
and isConstEFalse f = 
	if (List.length f)<>1 then false
	else
	match (List.hd f) with
	  | EBase b -> (isAnyConstFalse b.formula_ext_base)  
	  | _ -> false
  					   
and isStrictConstTrue f = match f with
  | Exists ({formula_exists_heap = HTrue;
		   formula_exists_pure = p;
           formula_exists_branches = br; 
		   formula_exists_flow = fl; })
  | Base ({formula_base_heap = HTrue;
		   formula_base_pure = p;
           formula_base_branches = br;
		   formula_base_flow = fl;}) -> 
             CP.isConstTrue p && (List.filter (fun (_,f) -> not (CP.isConstTrue f)) br = [])&&(is_true_flow fl.formula_flow_interval)
	  (* don't need to care about formula_base_type  *)
  | _ -> false
  
and isAnyConstTrue f = match f with
  | Exists ({formula_exists_heap = HTrue;
		   formula_exists_pure = p;
           formula_exists_branches = br; 
		   formula_exists_flow = fl; })
  | Base ({formula_base_heap = HTrue;
		   formula_base_pure = p;
           formula_base_branches = br;
		   formula_base_flow = fl;}) -> 
             CP.isConstTrue p && (List.filter (fun (_,f) -> not (CP.isConstTrue f)) br = [])
	  (* don't need to care about formula_base_type  *)
  | _ -> false

and is_complex_heap (h : h_formula) : bool = match h with
  | HTrue | HFalse -> false
  | _ -> true

and is_coercible (h : h_formula) : bool = match h with
  | ViewNode ({h_formula_view_coercible = c}) -> c
  | _ -> false

(*
  perform simplification incrementally
*)

and mkAndType f1 f2 = match f1 with
  | TypeTrue -> f2
  | TypeFalse -> TypeFalse
  | _ -> begin
	  match f2 with
		| TypeTrue -> f1
		| TypeFalse -> TypeFalse
		| _ -> TypeAnd ({t_formula_and_f1 = f1; t_formula_and_f2 = f2})
	end

	
(*let flow_eqs_n (p1,p2) pos:formula = 
	mkAnd (BForm (Lte ((mkVar flow_var pos), (IConst (p2,pos)), pos)))
		  (BForm (Lte ((IConst (p1,pos)), (mkVar flow_var pos), pos))) pos

	
let flow_eqs (s:string) pos:formula = 
	let (p1,p2) = (Util.get_hash_of_exc s) in
	flow_eqs_n (p1,p2) pos*)
	
(*and equal_flows1 f1 (f2:Globals.nflow) : bool =  is_member_pure f1 (flow_eqs_n f2 no_pos)*)
(*and equal_flows ((n11,n12):Globals.nflow)((n21,n22):Globals.nflow) : bool =  (n11==n21)&&(n12==n22)*)


(*assume none is invalid*)
and overlapping (n1,n2) (p1,p2) : bool = not(((n2<p1)||(p2<n1))&&(n1<n2)&&(p1<p2))
and intersect_flow (n1,n2)(p1,p2) : (int*int)= ((if (n1<p1) then p1 else n1),(if (n2<p2) then n2 else p2))

and is_false_flow (p1,p2) :bool = (p2==0)&&(p1==0)
and is_true_flow p :bool = (equal_flow_interval !Globals.n_flow_int p)
		
and equal_flow_interval (n1,n2) (p1,p2) : bool = (n1==p1)&&(n2==p2) 

(*first subsumes the second*)
and subsume_flow (n1,n2)(p1,p2) : bool = if (is_false_flow (p1,p2)) then true else (n1<=p1)&&(p2<=n2) 

and overlap_flow t1 t2 : bool = (subsume_flow t1 t2) || (subsume_flow t2 t1)

and subtract_flow (n1,n2) (p1,p2)  : (nflow list) = 
  if n1<p1 then (n1,p1-1)::(subtract_flow (p1,n2) (p1,p2))
  else if n2>p2 then [(p2+1,n2)]
  else []

and disjoint_flow t1 t2 : bool = not(overlap_flow t1 t2) 

and subsume_flow_f (n1,n2) f :bool = subsume_flow (n1,n2) f.formula_flow_interval

and subsume_flow_ff f1 f2 :bool = subsume_flow f1.formula_flow_interval f2.formula_flow_interval

and get_flow_from_stack c l pos = 
	try
		let r = List.find (fun h-> ((String.compare h.formula_store_name c)==0)) l in
		r.formula_store_value
	with Not_found -> Err.report_error { 
				Err.error_loc = pos;
				Err.error_text = "the flow var stack \n"^
					(String.concat " " (List.map (fun h-> (h.formula_store_name^"= "^
						(let rr = h.formula_store_value.formula_flow_interval in
							(string_of_int (fst rr))^(string_of_int (snd rr)))^" ")) l))^
					"\ndoes not contain "^c}

and set_flow_in_formula_override (n:flow_formula) (f:formula):formula = match f with
	| Base b-> Base {b with formula_base_flow = n}
	| Exists b-> Exists {b with formula_exists_flow = n}
	| Or b-> Or {formula_or_f1 = set_flow_in_formula_override n b.formula_or_f1;
				 formula_or_f2 = set_flow_in_formula_override n b.formula_or_f2;
				 formula_or_pos = b.formula_or_pos}
				 
and set_flow_in_formula (n:flow_formula) (f:formula):formula = match f with
	| Base b-> Base {b with formula_base_flow = if (subsume_flow_f !n_flow_int b.formula_base_flow) then n else b.formula_base_flow}
	| Exists b-> Exists {b with formula_exists_flow = if (subsume_flow_f !n_flow_int b.formula_exists_flow) then n else b.formula_exists_flow}
	| Or b-> Or {formula_or_f1 = set_flow_in_formula_override n b.formula_or_f1;
				 formula_or_f2 = set_flow_in_formula_override n b.formula_or_f2;
				 formula_or_pos = b.formula_or_pos}
				 
and set_flow_to_link_f flow_store f pos = match f with
	| Base b-> Base {b with formula_base_flow = 
								if (equal_flow_interval b.formula_base_flow.formula_flow_interval false_flow_int) then b.formula_base_flow
								else
								if (subsume_flow !n_flow_int b.formula_base_flow.formula_flow_interval ) then
									match b.formula_base_flow.formula_flow_link with
									| None -> Error.report_error { Error.error_loc = pos;Error.error_text = "simple flow where link required"}
									| Some v -> get_flow_from_stack v flow_store pos
								else b.formula_base_flow}
	| Exists b-> Exists {b with formula_exists_flow = 
								if (equal_flow_interval b.formula_exists_flow.formula_flow_interval false_flow_int) then b.formula_exists_flow
								else
								if (subsume_flow !n_flow_int b.formula_exists_flow.formula_flow_interval ) then 
									match b.formula_exists_flow.formula_flow_link with
									| None -> Error.report_error { Error.error_loc = pos;Error.error_text = "simple flow where link required"}
									| Some v -> get_flow_from_stack v flow_store pos
								else b.formula_exists_flow}
	| Or b-> Or {formula_or_f1 = set_flow_to_link_f flow_store b.formula_or_f1 pos;
				 formula_or_f2 = set_flow_to_link_f flow_store b.formula_or_f2 pos;
				 formula_or_pos = b.formula_or_pos}

and flow_formula_of_formula (f:formula) (*pos*) : flow_formula = match f with
	| Base b-> b.formula_base_flow
	| Exists b-> b.formula_exists_flow
	| Or b-> 
		let fl1 = flow_formula_of_formula b.formula_or_f1 in
		let fl2 = flow_formula_of_formula b.formula_or_f2 in
		if (equal_flow_interval fl1.formula_flow_interval fl2.formula_flow_interval) then fl1
		else Err.report_error { Err.error_loc = no_pos;
								Err.error_text = "flow_formula_of_formula: disjunctive formula"}

and substitute_flow_in_f to_flow from_flow (f:formula):formula = match f with
	| Base b-> Base {b with formula_base_flow = 
		if (equal_flow_interval from_flow b.formula_base_flow.formula_flow_interval) then 
		{formula_flow_interval = to_flow; formula_flow_link = b.formula_base_flow.formula_flow_link}
		else b.formula_base_flow;}
	| Exists b-> Exists{b with formula_exists_flow = 
		if (equal_flow_interval from_flow b.formula_exists_flow.formula_flow_interval) then 
		{formula_flow_interval = to_flow; formula_flow_link = b.formula_exists_flow.formula_flow_link}
		else b.formula_exists_flow;}	
	| Or b-> Or {formula_or_f1 = substitute_flow_in_f to_flow from_flow b.formula_or_f1;
				 formula_or_f2 = substitute_flow_in_f to_flow from_flow b.formula_or_f2;
				 formula_or_pos = b.formula_or_pos}

and substitute_flow_into_f to_flow (f:formula):formula = match f with
	| Base b-> Base {b with formula_base_flow = 
		{formula_flow_interval = to_flow; formula_flow_link = b.formula_base_flow.formula_flow_link}}
	| Exists b-> Exists{b with formula_exists_flow = 
		{formula_flow_interval = to_flow; formula_flow_link = b.formula_exists_flow.formula_flow_link}}
	| Or b-> Or {formula_or_f1 = substitute_flow_into_f to_flow b.formula_or_f1;
				 formula_or_f2 = substitute_flow_into_f to_flow b.formula_or_f2;
				 formula_or_pos = b.formula_or_pos}
				 
and substitute_flow_in_struc_f to_flow from_flow (f:struc_formula):struc_formula = 
let helper (f:ext_formula) = match f with
	| EBase b -> EBase {b with formula_ext_base = substitute_flow_in_f to_flow from_flow b.formula_ext_base ; 
								   formula_ext_continuation = substitute_flow_in_struc_f to_flow from_flow  b.formula_ext_continuation}
	| ECase b -> ECase {b with formula_case_branches = List.map (fun (c1,c2) -> (c1,(substitute_flow_in_struc_f to_flow from_flow  c2))) b.formula_case_branches}
	| EAssume (x,b,y) -> EAssume (x,(substitute_flow_in_f to_flow from_flow  b),y)
	in
List.map helper f	
								
(*this is used for adding formulas, links will be ignored since the only place where links can appear is in the context, the first one will be kept*)
and mkAndFlow (fl1:flow_formula) (fl2:flow_formula) flow_tr :flow_formula = 
	let int1 = fl1.formula_flow_interval in
	let int2 = fl2.formula_flow_interval in
	let r = if (is_false_flow int1) then fl1
		else if (is_false_flow int2) then fl2
		else match flow_tr with
			| Flow_replace -> 
				{	formula_flow_interval = int2;
					formula_flow_link = match (fl1.formula_flow_link,fl2.formula_flow_link)with
					| None,None -> None
					| Some s,None-> Some s
					| None, Some s -> Some s
					| _ ->  Err.report_error { Err.error_loc = no_pos; Err.error_text = "mkAndFlow: can not and two flows with two links"};}
			| Flow_combine ->
				if (overlapping int1 int2) then 
					{	formula_flow_interval = intersect_flow int1 int2;
						formula_flow_link = match (fl1.formula_flow_link,fl2.formula_flow_link)with
							| None,None -> None
							| Some s,None-> Some s
							| None, Some s -> Some s
							| _ ->  Err.report_error { Err.error_loc = no_pos; Err.error_text = "mkAndFlow: can not and two flows with two links"};}
				else {formula_flow_interval = false_flow_int; formula_flow_link = None} in
	(*let string_of_flow_formula f c = 
	"{"^f^",("^(string_of_int (fst c.formula_flow_interval))^","^(string_of_int (snd c.formula_flow_interval))^
	")="^(Util.get_closest c.formula_flow_interval)^","^(match c.formula_flow_link with | None -> "" | Some e -> e)^"}" in

	let _ = print_string ("\n"^(string_of_flow_formula "f1 " fl1)^"\n"^
							   (string_of_flow_formula "f2 " fl2)^"\n"^
								(string_of_flow_formula "r " r)^"\n") in*)
	r
				
and mkTrue (flowt: flow_formula) pos = Base ({formula_base_heap = HTrue; 
						formula_base_pure = CP.mkTrue pos; 
						formula_base_type = TypeTrue; 
						formula_base_flow = flowt (*(mkTrueFlow ())*);
                        formula_base_branches = [];
						formula_base_pos = pos})

and mkFalse (flowt: flow_formula) pos = Base ({formula_base_heap = HFalse; 
						 formula_base_pure = CP.mkFalse pos; 
						 formula_base_type = TypeFalse;
						 formula_base_flow = flowt (*mkFalseFlow*); (*Cpure.flow_eqs any_flow pos;*)
                         formula_base_branches = [];
						 formula_base_pos = pos})
						 
and mkEFalse flowt pos = EBase({
		 formula_ext_explicit_inst = [];
		 formula_ext_implicit_inst = [];
		 formula_ext_exists = [];
		 formula_ext_base = mkFalse flowt pos;
		 formula_ext_continuation = [];
		 formula_ext_pos = pos})

and mkETrue flowt pos = EBase({
		 formula_ext_explicit_inst = [];
		 formula_ext_implicit_inst = [];
		 formula_ext_exists = [];
		 formula_ext_base = mkTrue flowt pos;
		 formula_ext_continuation = [];
		 formula_ext_pos = pos})
		 
and mkOr f1 f2 pos =
(*	let f_comp c1 c2 = 
		let f1 = flow_formula_of_formula c1 in
		let f2 = flow_formula_of_formula c2 in
		equal_flow_interval f1.formula_flow_interval f2.formula_flow_interval in*)
	let rec liniarize_or c = match c with
		| Or f -> 
			let p11,p12,p13 = liniarize_or f.formula_or_f1 in
			let p21,p22,p23 = liniarize_or f.formula_or_f2 in
			(p11@p21, p12@p22, p13@p23)
		| Exists _ -> ([],[],[c]) 
		| Base f -> 
			if (isAnyConstFalse c) then ([],[c],[])
			else if (isAnyConstTrue c) then ([c],[],[])
			else ([],[],[c])
			(*let fl = f.formula_base_flow in
			if (equal_flow_interval fl.formula_flow_interval !top_flow_int) then ([c],[],[])
			else if (equal_flow_interval fl.formula_flow_interval false_flow_int) then ([],[c],[])
			else ([],[],[c])*) in
  if isStrictConstTrue f1 || isStrictConstTrue f2 then
	mkTrue (mkTrueFlow ()) pos
  else if isAnyConstFalse f1 then f2
  else if isAnyConstFalse f2 then f1
  else 	
	(*let f1_t,f1_f,f1_o = liniarize_or f1 in
	let f2_t,f2_f,f2_o = liniarize_or f2 in
	let f_t = Util.remove_dups_f (f1_t@f2_t) f_comp in
	let f_f = Util.remove_dups_f (f1_f@f2_f) f_comp in	
	let f_o = f1_o@f2_o in
	let f_f = List.filter (fun c-> 
		let fl_c = flow_formula_of_formula c in
		not (List.exists (fun d-> 
			let fl_d = flow_formula_of_formula d in
			subsume_flow_ff fl_d fl_c ) (f_o@f_t))) f_f in
	let f_o = List.filter (fun c->
		let fl_c = flow_formula_of_formula c in
		not (List.exists (fun d-> 
			let fl_d = flow_formula_of_formula d in
			subsume_flow_ff fl_d fl_c ) f_t)) f_o in
	let f_l = f_t@f_f@f_o in
	if (List.length f_l)<1 then 
		Err.report_error {Err.error_loc = pos;
						  Err.error_text = "Concatenating two empty formulas"}
	else List.fold_left (fun a c -> Or ({formula_or_f1 = a; formula_or_f2 = c; formula_or_pos = pos})) (List.hd f_l) (List.tl f_l)*)
	Or ({formula_or_f1 = f1; formula_or_f2 = f2; formula_or_pos = pos})
  
and mkBase (h : h_formula) (p : CP.formula) (t : t_formula) (fl : flow_formula) b (pos : loc) = 
  if CP.isConstFalse p || h = HFalse || (is_false_flow fl.formula_flow_interval)  then 
	mkFalse fl pos
  else 
	Base ({formula_base_heap = h; 
		   formula_base_pure = p; 
		   formula_base_type = t;
		   formula_base_flow = fl;
           formula_base_branches = b;
		   formula_base_pos = pos})

and mkStarH (f1 : h_formula) (f2 : h_formula) (pos : loc) = match f1 with
  | HFalse -> HFalse
  | HTrue -> f2
  | _ -> match f2 with
	  | HFalse -> HFalse
	  | HTrue -> f1
	  | _ -> Star ({h_formula_star_h1 = f1; 
					h_formula_star_h2 = f2; 
					h_formula_star_pos = pos})

				
let rec mkStar (f1 : formula) (f2 : formula) flow_tr (pos : loc) =
  let h1, p1, fl1, b1, t1 = split_components f1 in
  let h2, p2, fl2, b2, t2 = split_components f2 in
  let h = mkStarH h1 h2 pos in
  let p = CP.mkAnd p1 p2 pos in
  let t = mkAndType t1 t2 in
  let b = CP.merge_branches b1 b2 in
  let fl = mkAndFlow fl1 fl2 flow_tr in
  mkBase h p t fl b pos
   
and combine_and_pure (f1:formula)(p:Cpure.formula)(f2:Cpure.formula):Cpure.formula*bool = 
	if (isAnyConstFalse f1) then (Cpure.mkFalse no_pos,false)
		else if (isAnyConstTrue f1) then (f2,true)
			else (sem_and p f2)
and sem_and (p:Cpure.formula)(f2:Cpure.formula):(Cpure.formula*bool) = 
	let ys =  Cpure.split_conjunctions f2 in
	let ys' = List.filter (fun c-> not (Cpure.is_member_pure c p)) ys in
	let y = Cpure.join_conjunctions ys' in
	if (Cpure.isConstFalse y) then (Cpure.mkFalse no_pos,false)
		else if (Cpure.isConstTrue y) then (p,false)
			else  ((Cpure.mkAnd p y no_pos),true)

and sintactic_search (f:formula)(p:Cpure.formula):bool = match f with
	| Or b-> false		
	| Base _					
	| Exists _-> 
		let _, pl, _, br, _ = split_components f in		
		(Cpure.is_member_pure p pl) ||(List.exists (fun (_,c)->Cpure.is_member_pure p c) br)
		
and mkStar_combine (f1 : formula) (f2 : formula) flow_tr (pos : loc) = 
  let h1, p1, fl1, b1, t1 = split_components f1 in
  let h2, p2, fl2, b2, t2 = split_components f2 in
  let h = mkStarH h1 h2 pos in
  let p,_ = combine_and_pure f1 p1 p2 in
  let t = mkAndType t1 t2 in
  let b = CP.merge_branches b1 b2 in
  let fl =  mkAndFlow fl1 fl2 flow_tr in
  mkBase h p t fl b pos


and mkAnd_pure_and_branch (f1 : formula) (p2 : Cpure.formula) b2 (pos : loc):formula = 
  if (isAnyConstFalse f1) then f1
   else 
		let h1, p1, fl1, b1, t1 = split_components f1 in		
		if (Cpure.isConstTrue p1) then mkBase h1 p2 t1 fl1 (CP.merge_branches b1 b2) pos
			else mkBase h1 (Cpure.mkAnd p1 p2 pos) t1 fl1 (CP.merge_branches b1 b2)  pos

   
and mkExists (svs : CP.spec_var list) (h : h_formula) (p : CP.formula) (t : t_formula) (fl:flow_formula) b (pos : loc) =
  let tmp = Base ({formula_base_heap = h;
				   formula_base_pure = p;
				   formula_base_type = t;
				   formula_base_flow = fl;
                   formula_base_branches = b;
				   formula_base_pos = pos}) in
  let fvars = fv tmp in
  let qvars = U.intersect svs fvars in (* used only these for the quantified formula *)
	if U.empty qvars then
	  tmp
	else
	  Exists ({formula_exists_qvars = qvars; 
			   formula_exists_heap =  h; 
			   formula_exists_pure = p;
			   formula_exists_type = t;
			   formula_exists_flow = fl;
               formula_exists_branches = b;
			   formula_exists_pos = pos})

and is_view (h : h_formula) = match h with
  | ViewNode _ -> true
  | _ -> false

and is_data (h : h_formula) = match h with
  | DataNode _ -> true
  | _ -> false

and get_node_name (h : h_formula) = match h with
  | ViewNode ({h_formula_view_name = c}) 
  | DataNode ({h_formula_data_name = c}) -> c
  | _ -> failwith ("get_node_name: invalid argument")

and get_view_origins (h : h_formula) = match h with
  | ViewNode ({h_formula_view_origins = origs}) -> origs
  | _ -> failwith ("get_view_origins: not a view")

and get_view_modes (h : h_formula) = match h with
  | ViewNode ({h_formula_view_modes = modes}) -> modes
  | _ -> failwith ("get_view_modes: not a view")

and h_add_origins (h : h_formula) origs = match h with
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2;
		   h_formula_star_pos = pos}) ->
	  Star ({h_formula_star_h1 = h_add_origins h1 origs;
			 h_formula_star_h2 = h_add_origins h2 origs;
			 h_formula_star_pos = pos})
  | ViewNode vn -> ViewNode {vn with h_formula_view_origins = origs @ vn.h_formula_view_origins}
  | _ -> h
  
and add_origins (f : formula) origs = match f with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2;
		 formula_or_pos = pos}) -> 
	  Or ({formula_or_f1 = add_origins f1 origs;
		 formula_or_f2 = add_origins f2 origs ;
		 formula_or_pos = pos})
  | Base b -> Base ({b with formula_base_heap = h_add_origins b.formula_base_heap origs})
  | Exists e -> Exists ({e with formula_exists_heap = h_add_origins e.formula_exists_heap origs})
  
  
and add_struc_origins (f:struc_formula) origs = 
	let rec helper (f: struc_formula) =
		let ext_f (f:ext_formula) = match f with
		| ECase b -> ECase {b with formula_case_branches = List.map (fun (c1,c2) -> (c1,(helper c2))) b.formula_case_branches}
		| EBase b -> EBase {b with formula_ext_base = add_origins b.formula_ext_base origs ; 
								   formula_ext_continuation = helper b.formula_ext_continuation}
		| EAssume (x,b,y) ->  EAssume (x,(add_origins b origs),y)
		in
	List.map ext_f f in	
    helper f

and no_change (svars : CP.spec_var list) (pos : loc) : CP.formula = match svars with
  | sv :: rest ->
	  let f = CP.mkEqVar (CP.to_primed sv) (CP.to_unprimed sv) pos in
	  let restf = no_change rest pos in
		CP.mkAnd f restf pos
  | [] -> CP.mkTrue pos

and pos_of_struc_formula (f:struc_formula): loc =
	if (List.length f)==0 then no_pos
		else match (List.hd f) with
		| ECase b -> b.formula_case_pos
		| EBase b -> b.formula_ext_pos
		| EAssume (x,b,_)-> pos_of_formula b

and pos_of_formula (f : formula) : loc = match f with
  | Base ({formula_base_pos = pos}) -> pos
  | Or ({formula_or_pos = pos}) -> pos
  | Exists ({formula_exists_pos = pos}) -> pos
  
and struc_fv (f: struc_formula) : CP.spec_var list = 
	let rec ext_fv (f:ext_formula): CP.spec_var list = match f with
		| ECase b -> 
		CP.difference (Util.remove_dups (List.fold_left (fun a (c1,c2) -> a@(CP.fv c1)@(struc_fv c2) ) [] b.formula_case_branches))
		b.formula_case_exists
		| EBase b -> 
			let e = struc_fv b.formula_ext_continuation in
			let be = fv b.formula_ext_base in
			CP.difference (Util.remove_dups (e@be)) (b.formula_ext_explicit_inst @ b.formula_ext_implicit_inst@ b.formula_ext_exists)				
		| EAssume (x,b,_) -> fv b
	in Util.remove_dups (List.fold_left (fun a c-> a@(ext_fv c)) [] f)

	
and struc_post_fv (f:struc_formula):Cpure.spec_var list =
		let rec helper (f:ext_formula): Cpure.spec_var list = match f with
		| ECase b-> List.fold_left (fun a (c1,c2)-> a@(struc_post_fv c2)) [] b.formula_case_branches
		| EBase b->	struc_post_fv b.formula_ext_continuation
		| EAssume (x,b,_)-> fv b
		in	
List.fold_left (fun a c-> a@(helper c)) [] f
	
and fv (f : formula) : CP.spec_var list = match f with
  | Or ({formula_or_f1 = f1; 
		 formula_or_f2 = f2}) -> Util.remove_dups (fv f1 @ fv f2)
  | Base ({formula_base_heap = h; 
		   formula_base_pure = p;
		   formula_base_branches = br;
		   formula_base_type = t}) -> 
	  Util.remove_dups (List.fold_left (fun a (c1,c2)-> (CP.fv c2)@a) (h_fv h @ CP.fv p) br)
	  (* Util.remove_dups (h_fv h @ CP.fv p @ t_fv t) *)
  | Exists ({formula_exists_qvars = qvars; 
			 formula_exists_heap = h; 
			 formula_exists_pure = p; 
			 formula_exists_type = t;
			 formula_exists_flow = fl;
			 formula_exists_branches = br;
			 formula_exists_pos = pos}) -> 
	  let fvars = fv (Base ({formula_base_heap = h; 
							 formula_base_pure = p; 
							 formula_base_type = t;
							 formula_base_flow = fl;
                             formula_base_branches = br;
							 formula_base_pos = pos})) in
	  let res = CP.difference fvars qvars in
		res
	
and h_fv (h : h_formula) : CP.spec_var list = match h with
  | Star ({h_formula_star_h1 = h1; 
		   h_formula_star_h2 = h2; 
		   h_formula_star_pos = pos}) -> Util.remove_dups (h_fv h1 @ h_fv h2)
  | DataNode ({h_formula_data_node = v; 
			   h_formula_data_arguments = vs0}) ->
	  (*let vs = List.tl (List.tl vs0) in*)
	  let vs = vs0 in
		if List.mem v vs then vs else v :: vs
  | ViewNode ({h_formula_view_node = v; 
			   h_formula_view_arguments = vs}) -> if List.mem v vs then vs else v :: vs
  | HTrue | HFalse -> []

and f_top_level_vars (f : formula) : CP.spec_var list = match f with
  | Base ({formula_base_heap = h}) -> (top_level_vars h)
  | Or ({ formula_or_f1 = f1;
		formula_or_f2 = f2}) -> (f_top_level_vars f1) @ (f_top_level_vars f2)
  | Exists ({formula_exists_heap = h}) -> (top_level_vars h)
  
and top_level_vars (h : h_formula) : CP.spec_var list = match h with
  | Star ({h_formula_star_h1 = h1; 
		   h_formula_star_h2 = h2}) -> (top_level_vars h1) @ (top_level_vars h2)
  | DataNode ({h_formula_data_node = v}) 
  | ViewNode ({h_formula_view_node = v}) -> [v]
  | HTrue | HFalse -> []

and get_formula_pos (f : formula) = match f with
  | Base ({formula_base_pos = p}) -> p
  | Or ({formula_or_pos = p}) -> p
  | Exists ({formula_exists_pos = p}) -> p 


(* substitution *)

and subst_avoid_capture (fr : CP.spec_var list) (t : CP.spec_var list) (f : formula) =
  let fresh_fr = CP.fresh_spec_vars fr in
  (*--- 09.05.2000 *)
	(*let _ = (print_string ("\n[cformula.ml, line 307]: fresh name = " ^ (string_of_spec_var_list fresh_fr) ^ "!!!!!!!!!!!\n")) in*)
	(*09.05.2000 ---*)
  let st1 = List.combine fr fresh_fr in
  let st2 = List.combine fresh_fr t in
  let f1 = subst st1 f in
  let f2 = subst st2 f1 in
	f2

(*
and subst_var_list_avoid_capture fr t svs = 
  let fresh_fr = fresh_spec_vars fr in
  let st1 = List.combine fr fresh_fr in
  let st2 = List.combine fresh_fr t in
  let svs1 = subst_var_list st1 svs in
  let svs2 = subst_var_list st2 svs1 in
	svs2
*)
and subst_var_list sst (svs : Cpure.spec_var list) = match svs with
  | [] -> []
  | sv :: rest ->
      let new_vars = subst_var_list sst rest in
      let new_sv = match List.filter (fun st -> fst st = sv) sst with
		| [(fr, t)] -> t
		| _ -> sv in
		new_sv :: new_vars

and subst_struc_avoid_capture (fr : CP.spec_var list) (t : CP.spec_var list) (f : struc_formula):struc_formula =
		let fresh_fr = CP.fresh_spec_vars fr in
	  let st1 = List.combine fr fresh_fr in
  	let st2 = List.combine fresh_fr t in
  	let f1 = subst_struc st1 f in
  	let f2 = subst_struc st2 f1 in
	f2
and subst_struc sst (f : struc_formula) = match sst with
  | s :: rest -> subst_struc rest (apply_one_struc s f)
  | [] -> f 
 
and subst_struc_pre sst (f : struc_formula) = match sst with
  | s :: rest -> subst_struc_pre rest (apply_one_struc_pre s f)
  | [] -> f 

and apply_one_struc_pre  ((fr, t) as s : (CP.spec_var * CP.spec_var)) (f : struc_formula):struc_formula = 
	let rec helper (f:ext_formula):ext_formula = match f with
		| ECase b -> 
			ECase ({b with 
			formula_case_branches = List.map (fun (c1,c2)-> ((CP.apply_one s c1),(apply_one_struc_pre s c2)) ) b.formula_case_branches})
		| EBase b ->
			EBase ({
				 formula_ext_explicit_inst = List.map (subst_var s)  b.formula_ext_explicit_inst;
				 formula_ext_implicit_inst = List.map (subst_var s)  b.formula_ext_implicit_inst;
				 formula_ext_exists = List.map (subst_var s)  b.formula_ext_exists;
				 formula_ext_base = apply_one s  b.formula_ext_base;
				 formula_ext_continuation = apply_one_struc_pre s b.formula_ext_continuation;
				 formula_ext_pos = b.formula_ext_pos	
				})
		| EAssume (x,b,y)-> if (List.mem fr x) then f
						  else EAssume (x, (apply_one s b),y)
		in	
		List.map helper f
  
and apply_one_struc  ((fr, t) as s : (CP.spec_var * CP.spec_var)) (f : struc_formula):struc_formula = 
	let rec helper (f:ext_formula):ext_formula = match f with
		| ECase b -> 
			ECase ({b with 
			formula_case_branches = List.map (fun (c1,c2)-> ((CP.apply_one s c1),(apply_one_struc s c2)) ) b.formula_case_branches})
		| EBase b ->
			EBase ({
				 formula_ext_explicit_inst = List.map (subst_var s)  b.formula_ext_explicit_inst;
				 formula_ext_implicit_inst = List.map (subst_var s)  b.formula_ext_implicit_inst;
				 formula_ext_exists = List.map (subst_var s)  b.formula_ext_exists;
				 formula_ext_base = apply_one s  b.formula_ext_base;
				 formula_ext_continuation = apply_one_struc s b.formula_ext_continuation;
				 formula_ext_pos = b.formula_ext_pos	
				})
		| EAssume (x,b,y)-> EAssume((subst_var_list [s] x),(apply_one s b),y) in	
		List.map helper f
	
and subst sst (f : formula) = match sst with
  | s :: rest -> subst rest (apply_one s f)
  | [] -> f 
      
and subst_var (fr, t) (o : CP.spec_var) = if CP.eq_spec_var fr o then t else o

and apply_one ((fr, t) as s : (CP.spec_var * CP.spec_var)) (f : formula) = match f with
  | Or ({formula_or_f1 = f1; formula_or_f2 = f2; formula_or_pos = pos}) -> 
      Or ({formula_or_f1 = apply_one s f1; formula_or_f2 =  apply_one s f2; formula_or_pos = pos})
  | Base ({formula_base_heap = h; 
		   formula_base_pure = p; 
		   formula_base_type = t;
		   formula_base_flow = fl;
           formula_base_branches = b;
		   formula_base_pos = pos}) -> 
      Base ({formula_base_heap = h_apply_one s h; 
			 formula_base_pure = CP.apply_one s p; 
			 formula_base_type = t;
			 formula_base_flow = fl;
             formula_base_branches = List.map (fun (l, p1) -> (l, CP.apply_one s p1)) b;
			 formula_base_pos = pos})
  | Exists ({formula_exists_qvars = qsv; 
			 formula_exists_heap = qh; 
			 formula_exists_pure = qp; 
			 formula_exists_type = tconstr;
			 formula_exists_flow = fl;
             formula_exists_branches = b;
			 formula_exists_pos = pos}) -> 
	  if List.mem (CP.name_of_spec_var fr) (List.map CP.name_of_spec_var qsv) then f 
	  else Exists ({formula_exists_qvars = qsv; 
					formula_exists_heap =  h_apply_one s qh; 
					formula_exists_pure = CP.apply_one s qp; 
					formula_exists_type = tconstr;
					formula_exists_flow = fl;
                    formula_exists_branches = List.map (fun (l, p1) -> (l, CP.apply_one s p1)) b;
					formula_exists_pos = pos})
		

and h_apply_one ((fr, t) as s : (CP.spec_var * CP.spec_var)) (f : h_formula) = match f with
  | Star ({h_formula_star_h1 = f1; 
		   h_formula_star_h2 = f2; 
		   h_formula_star_pos = pos}) -> 
      Star ({h_formula_star_h1 = h_apply_one s f1; 
			 h_formula_star_h2 = h_apply_one s f2; 
			 h_formula_star_pos = pos})
  | ViewNode ({h_formula_view_node = x; 
			   h_formula_view_name = c; 
			   h_formula_view_arguments = svs; 
			   h_formula_view_modes = modes;
			   h_formula_view_coercible = coble;
			   h_formula_view_origins = orgs;
			   h_formula_view_label = lbl;
			   h_formula_view_pos = pos}) -> 
      ViewNode ({h_formula_view_node = subst_var s x; 
				 h_formula_view_name = c; 
				 h_formula_view_arguments = List.map (subst_var s) svs;
				 h_formula_view_modes = modes;
				 h_formula_view_coercible = coble;
				 h_formula_view_origins = orgs;
				 h_formula_view_label = lbl;
				 h_formula_view_pos = pos})
  | DataNode ({h_formula_data_node = x; 
			   h_formula_data_name = c; 
			   h_formula_data_arguments = svs; 
			   h_formula_data_label = lbl;
			   h_formula_data_pos = pos}) -> 
      DataNode ({h_formula_data_node = subst_var s x; 
				 h_formula_data_name = c; 
				 h_formula_data_arguments = List.map (subst_var s) svs;
				 h_formula_data_label = lbl;
				 h_formula_data_pos = pos})
  | HTrue -> f
  | HFalse -> f

(* normalization *)
(* normalizes ( \/ (EX v* . /\ ) ) * ( \/ (EX v* . /\ ) ) *)
and normalize_keep_flow (f1 : formula) (f2 : formula) flow_tr (pos : loc) = match f1 with
  | Or ({formula_or_f1 = o11; formula_or_f2 = o12; formula_or_pos = _}) ->
      let eo1 = normalize o11 f2 pos in
      let eo2 = normalize o12 f2 pos in
		mkOr eo1 eo2 pos
  | _ -> begin
      match f2 with
		| Or ({formula_or_f1 = o21; formula_or_f2 = o22; formula_or_pos = _}) ->
			let eo1 = normalize f1 o21 pos in
			let eo2 = normalize f1 o22 pos in
			  mkOr eo1 eo2 pos
		| _ -> begin
			let rf1 = rename_bound_vars f1 in
			let rf2 = rename_bound_vars f2 in
			let qvars1, base1 = split_quantifiers rf1 in
			let qvars2, base2 = split_quantifiers rf2 in
			let new_base = mkStar_combine base1 base2 flow_tr pos in
			let new_h, new_p, new_fl, b, new_t = split_components new_base in
			let resform = mkExists (qvars1 @ qvars2) new_h new_p new_t new_fl b pos in (* qvars[1|2] are fresh vars, hence no duplications *)
			  resform
		  end
    end
	
and normalize (f1 : formula) (f2 : formula) (pos : loc) = 
	normalize_keep_flow f1 f2 Flow_combine pos
(*
match f1 with
  | Or ({formula_or_f1 = o11; formula_or_f2 = o12; formula_or_pos = _}) ->
      let eo1 = normalize o11 f2 pos in
      let eo2 = normalize o12 f2 pos in
		mkOr eo1 eo2 pos
  | _ -> begin
      match f2 with
		| Or ({formula_or_f1 = o21; formula_or_f2 = o22; formula_or_pos = _}) ->
			let eo1 = normalize f1 o21 pos in
			let eo2 = normalize f1 o22 pos in
			  mkOr eo1 eo2 pos
		| _ -> begin
			let rf1 = rename_bound_vars f1 in
			let rf2 = rename_bound_vars f2 in
			let qvars1, base1 = split_quantifiers rf1 in
			let qvars2, base2 = split_quantifiers rf2 in
			let new_base = mkStar_combine base1 base2 pos in
			let new_h, new_p, new_fl, b, new_t = split_components new_base in
			let resform = mkExists (qvars1 @ qvars2) new_h new_p new_t new_fl b pos in (* qvars[1|2] are fresh vars, hence no duplications *)
			  resform
		  end
    end*)
and normalize_combine (f1 : formula) (f2 : formula) (pos : loc) = match f1 with
  | Or ({formula_or_f1 = o11; formula_or_f2 = o12; formula_or_pos = _}) ->
      let eo1 = normalize_combine o11 f2 pos in
      let eo2 = normalize_combine o12 f2 pos in
		mkOr eo1 eo2 pos
  | _ -> begin
      match f2 with
		| Or ({formula_or_f1 = o21; formula_or_f2 = o22; formula_or_pos = _}) ->
			let eo1 = normalize_combine f1 o21 pos in
			let eo2 = normalize_combine f1 o22 pos in
			  mkOr eo1 eo2 pos
		| _ -> begin
			let rf1 = rename_bound_vars f1 in
			let rf2 = rename_bound_vars f2 in
			let qvars1, base1 = split_quantifiers rf1 in
			let qvars2, base2 = split_quantifiers rf2 in
			let new_base = mkStar_combine base1 base2 Flow_combine pos in
			let new_h, new_p, new_fl, b, new_t = split_components new_base in
			let resform = mkExists (qvars1 @ qvars2) new_h new_p new_t new_fl b pos in (* qvars[1|2] are fresh vars, hence no duplications *)
			  resform
		  end
    end
	
(* -- 13.05.2008 *)
(* normalizes but only renames the bound variables of f1 that clash with variables from fv(f2) *)
and normalize_only_clash_rename (f1 : formula) (f2 : formula) (pos : loc) = match f1 with
  | Or ({formula_or_f1 = o11; formula_or_f2 = o12; formula_or_pos = _}) ->
      let eo1 = normalize_only_clash_rename o11 f2 pos in
      let eo2 = normalize_only_clash_rename o12 f2 pos in
		mkOr eo1 eo2 pos
  | _ -> begin
      match f2 with
		| Or ({formula_or_f1 = o21; formula_or_f2 = o22; formula_or_pos = _}) ->
			let eo1 = normalize_only_clash_rename f1 o21 pos in
			let eo2 = normalize_only_clash_rename f1 o22 pos in
			  mkOr eo1 eo2 pos
		| _ -> begin
			let rf1 = (fst (rename_clash_bound_vars f1 f2)) in
			let rf2 = (*rename_bound_vars*) f2 in
			let qvars1, base1 = split_quantifiers rf1 in
			let qvars2, base2 = split_quantifiers rf2 in
			let new_base = mkStar_combine base1 base2 Flow_combine pos in
			let new_h, new_p, new_fl, b, new_t = split_components new_base in
			let resform = mkExists (qvars1 @ qvars2) new_h new_p new_t new_fl b pos in (* qvars[1|2] are fresh vars, hence no duplications *)
			  resform
		  end
    end
(* 13.05.2008 -- *)

(* split a conjunction into heap constraints, pure pointer constraints, *)
(* and Presburger constraints *)
and split_components (f : formula) = 
if (isAnyConstFalse f) then (HFalse,(Cpure.mkFalse no_pos),(flow_formula_of_formula f),[],TypeFalse)
else match f with
  | Base ({formula_base_heap = h; 
		   formula_base_pure = p; 
           formula_base_branches = b;
		   formula_base_flow =fl;
		   formula_base_type = t}) -> (h, p, fl, b, t)
  | Exists ({formula_exists_heap = h; 
		   formula_exists_pure = p; 
           formula_exists_branches = b;
		   formula_exists_flow = fl;
		   formula_exists_type = t}) -> (h, p, fl, b, t) 		   
  (*| Exists ({formula_exists_pos = pos}) -> 
      Err.report_error {Err.error_loc = pos;
						Err.error_text = "split_components: don't expect EXISTS"}*)
  | Or ({formula_or_pos = pos}) -> 
  
  
      Err.report_error {Err.error_loc = pos;
						Err.error_text = "split_components: don't expect OR"}
				
and split_quantifiers (f : formula) : (CP.spec_var list * formula) = match f with
  | Exists ({formula_exists_qvars = qvars; 
			 formula_exists_heap =  h; 
			 formula_exists_pure = p; 
			 formula_exists_type = t;
			 formula_exists_flow = fl;
			 formula_exists_branches = b;
			 formula_exists_pos = pos}) -> 
      (qvars, mkBase h p t fl b pos)
  | Base _ -> ([], f)
  | _ -> failwith ("split_quantifiers: invalid argument")

and add_quantifiers (qvars : CP.spec_var list) (f : formula) : formula = match f with
  | Base ({formula_base_heap = h; 
		   formula_base_pure = p; 
		   formula_base_type = t;
		   formula_base_flow = fl;
           formula_base_branches = b;
		   formula_base_pos = pos}) -> mkExists qvars h p t fl b pos
  | Exists ({formula_exists_qvars = qvs; 
			 formula_exists_heap = h; 
			 formula_exists_pure = p; 
			 formula_exists_type = t;
			 formula_exists_flow = fl;
             formula_exists_branches = b;
			 formula_exists_pos = pos}) -> 
	  let new_qvars = U.remove_dups (qvs @ qvars) in
		mkExists new_qvars h p t fl b pos
  | _ -> failwith ("add_quantifiers: invalid argument")

(* 19.05.2008 *)
and remove_quantifiers (qvars : CP.spec_var list) (f : formula) : formula = match f with
  | Base _ -> f
  | Exists ({formula_exists_qvars = qvs; 
			 formula_exists_heap = h; 
			 formula_exists_pure = p; 
			 formula_exists_type = t;
			 formula_exists_flow = fl;
             formula_exists_branches = b;
			 formula_exists_pos = pos}) -> 
	  let new_qvars = (List.filter (fun x -> not(List.exists (fun y -> CP.eq_spec_var x y) qvars)) qvs) in
	  	if (List.length new_qvars == 0) then mkBase h p t fl b pos
	  	else mkExists new_qvars h p t fl b pos
  | _ -> failwith ("add_quantifiers: invalid argument")
(* 19.05.2008 *)

and push_struc_exists (qvars : CP.spec_var list) (f : struc_formula) = 
	List.map (fun c-> match c with
	| EBase b -> EBase {b with formula_ext_exists = b.formula_ext_exists @ qvars}
	| ECase b -> ECase {b with formula_case_exists = b.formula_case_exists @ qvars}
	| EAssume (x,b,y) -> EAssume (x,(push_exists qvars b),y)) f 


and push_exists (qvars : CP.spec_var list) (f : formula) = match f with
  | Or ({formula_or_f1 = f1; formula_or_f2 = f2; formula_or_pos = pos}) -> 
	  let new_f1 = push_exists qvars f1 in
	  let new_f2 = push_exists qvars f2 in
	  let resform = mkOr new_f1 new_f2 pos in
		resform
  | _ -> add_quantifiers qvars f

(* 19.05.2008 *)
and pop_exists (qvars : CP.spec_var list) (f : formula) = match f with
  | Or ({formula_or_f1 = f1; formula_or_f2 = f2; formula_or_pos = pos}) -> 
	  let new_f1 = pop_exists qvars f1 in
	  let new_f2 = pop_exists qvars f2 in
	  let resform = mkOr new_f1 new_f2 pos in
		resform
  | _ -> remove_quantifiers qvars f
(* 19.05.2008 *)

and rename_struc_bound_vars (f:struc_formula):struc_formula =
	let rec helper (f:ext_formula):ext_formula = match f with
		| ECase b-> 
			let sst3 = List.map (fun v -> (v,(CP.fresh_spec_var v))) b.formula_case_exists in
			let f = ECase {b with formula_case_exists = (snd (List.split sst3));
						   formula_case_branches = List.map (fun (c1,c2)-> 
						   ((Cpure.rename_top_level_bound_vars c1),(rename_struc_bound_vars c2))) b.formula_case_branches} in
			List.hd(subst_struc sst3 [f])
		| EBase b-> 
			let sst1 = List.map (fun v -> (v,(CP.fresh_spec_var v))) b.formula_ext_explicit_inst in
			let sst2 = List.map (fun v -> (v,(CP.fresh_spec_var v))) b.formula_ext_implicit_inst in
			let sst3 = List.map (fun v -> (v,(CP.fresh_spec_var v))) b.formula_ext_exists in
			let sst = sst1@sst2@sst3 in
			let f = EBase {b with 
				formula_ext_implicit_inst = (snd (List.split sst2));
				formula_ext_explicit_inst = (snd (List.split sst1));
				formula_ext_exists = (snd (List.split sst3));
				formula_ext_base = rename_bound_vars b.formula_ext_base;
				formula_ext_continuation = rename_struc_bound_vars b.formula_ext_continuation;
				}in
			let f = subst_struc sst [f] in
			(List.hd f)
		| EAssume (x,b,y)-> EAssume (x,(rename_bound_vars b),y)
			in
	List.map helper f

and rename_bound_vars (f : formula) = match f with
  | Or ({formula_or_f1 = f1; formula_or_f2 = f2; formula_or_pos = pos}) ->
	  let rf1 = rename_bound_vars f1 in
	  let rf2 = rename_bound_vars f2 in
	  let resform = mkOr rf1 rf2 pos in
		resform
  | Base _ -> f
  | Exists _ ->
	  let qvars, base_f = split_quantifiers f in
	  let new_qvars = CP.fresh_spec_vars qvars in
	  (*--- 09.05.2000 *)
		(*let _ = (print_string ("\n[cformula.ml, line 519]: fresh name = " ^ (string_of_spec_var_list new_qvars) ^ "!!!!!!!!!!!\n")) in*)
		(*09.05.2000 ---*)
	  let rho = List.combine qvars new_qvars in
	  let new_base_f = subst rho base_f in
	  let resform = add_quantifiers new_qvars new_base_f in
		resform

(* -- 13.05.2008 *)
(* rename only those bound vars of f1 which clash with fv(f2) *)
(* return the new formula and the list of fresh names *)
and rename_struc_clash_bound_vars (f1 : struc_formula) (f2 : formula) : struc_formula  = 
	let rec helper (f1:ext_formula):(ext_formula) = match f1 with
		| EAssume (x,b,y)-> EAssume (x,(fst(rename_clash_bound_vars b f2)),y)
		| ECase b ->  
			let r = List.map (fun (c1,c2) -> (c1,(rename_struc_clash_bound_vars c2 f2))) b.formula_case_branches in
			let new_exs = List.map (fun v -> (if (check_name_clash v f2) then (v,(CP.fresh_spec_var v)) else (v,v))) b.formula_case_exists in
			let rho = (List.filter (fun (v1,v2) -> (not (CP.eq_spec_var v1 v2))) new_exs) in
			ECase {formula_case_exists = (snd (List.split new_exs));
					formula_case_branches = List.map (fun (c1,c2)-> ((Cpure.subst rho c1),(subst_struc rho c2))) r;
					formula_case_pos = b.formula_case_pos}
		| EBase b -> 
			let new_base_f,c1 = rename_clash_bound_vars b.formula_ext_base f2 in
			let new_imp = List.map (fun v -> (if (check_name_clash v f2) then (v,(CP.fresh_spec_var v)) else (v,v))) b.formula_ext_implicit_inst in
			let new_exp = List.map (fun v -> (if (check_name_clash v f2) then (v,(CP.fresh_spec_var v)) else (v,v))) b.formula_ext_explicit_inst in
			let new_exs = List.map (fun v -> (if (check_name_clash v f2) then (v,(CP.fresh_spec_var v)) else (v,v))) b.formula_ext_exists in
			(* fresh_qvars contains only the freshly generated names *)
			let rho_imp = (List.filter (fun (v1,v2) -> (not (CP.eq_spec_var v1 v2)))  new_imp) in
			let rho_exp = (List.filter (fun (v1,v2) -> (not (CP.eq_spec_var v1 v2)))  new_exp) in
			let rho_exs = (List.filter (fun (v1,v2) -> (not (CP.eq_spec_var v1 v2)))  new_exs) in
			let rho = rho_imp@rho_exp@rho_exs in
			let new_base_f = subst rho new_base_f in
			let new_cont_f = subst_struc rho b.formula_ext_continuation in
			let new_cont_f = rename_struc_clash_bound_vars new_cont_f f2 in
			EBase {b with 
				formula_ext_implicit_inst = (snd (List.split new_imp));
				formula_ext_explicit_inst = (snd (List.split new_exp));
				formula_ext_exists = (snd (List.split new_exs));
				formula_ext_base = new_base_f;
				formula_ext_continuation = new_cont_f;
				}in
		List.map helper f1

and rename_clash_bound_vars (f1 : formula) (f2 : formula) : (formula * CP.spec_var list) = match f1 with
  | Or ({formula_or_f1 = or1; formula_or_f2 = or2; formula_or_pos = pos}) ->
	  let (rf1, fvar1) = (rename_clash_bound_vars or1 f2) in
	  let (rf2, fvar2) = (rename_clash_bound_vars or2 f2) in
	  let resform = mkOr rf1 rf2 pos in
		(resform, fvar1@fvar2)
  | Base _ -> (f1, [])
  | Exists _ ->
	  let qvars, base_f = split_quantifiers f1 in
	  let new_qvars = (List.map (fun v -> (if (check_name_clash v f2) then (CP.fresh_spec_var v) else v)) qvars) in
	  (* fresh_qvars contains only the freshly generated names *)
	  let fresh_qvars = (List.filter (fun v1 -> (not (List.exists (fun v2 -> CP.eq_spec_var v1 v2) qvars)))  new_qvars) in
	  let rho = List.combine qvars new_qvars in
	  let new_base_f = subst rho base_f in
	  let resform = add_quantifiers new_qvars new_base_f in
		(resform, fresh_qvars)

and check_name_clash (v : CP.spec_var) (f : formula) : bool =
	let spec_vars = fv f in
	(*let _ = print_string ("[cformula.ml, line 467]: Spec vars: " ^ (string_of_spec_var_list spec_vars) ^ "\n") in*)
		(List.exists (fun c -> (CP.eq_spec_var c v)) spec_vars)
(* 13.05.2008 -- *)

(* composition operator: it suffices to define composition in terms of  *)
(* the * operator, as the & operator is just a special case when one of *)
(* the term is pure                                                     *)

and compose_formula (delta : formula) (phi : formula) (x : CP.spec_var list) flow_tr (pos : loc) =
  let rs = CP.fresh_spec_vars x in
  (*--- 09.05.2000 *)
	(*let _ = (print_string ("\n[cformula.ml, line 533]: fresh name = " ^ (string_of_spec_var_list rs) ^ "!!!!!!!!!!!\n")) in*)
	(*09.05.2000 ---*)
  let rho1 = List.combine (List.map CP.to_unprimed x) rs in
  let rho2 = List.combine (List.map CP.to_primed x) rs in
  let new_delta = subst rho2 delta in
  let new_phi = subst rho1 phi in
  let new_f = normalize_keep_flow new_delta new_phi flow_tr pos in
  let resform = push_exists rs new_f in
	resform
	
and view_node_types (f:formula):ident list = 
	let rec helper (f:h_formula):ident list =  match f with
		| Star b -> Util.remove_dups ((helper b.h_formula_star_h1)@(helper b.h_formula_star_h2))
		| ViewNode b -> [b.h_formula_view_name]
		| _ -> [] in
	match f with
	| Or b-> Util.remove_dups ((view_node_types b.formula_or_f1) @ (view_node_types b.formula_or_f2))
	| Base b -> helper b.formula_base_heap
	| Exists b -> helper b.formula_exists_heap

(*
  Other utilities.
*)

and get_var_type v (f: formula): (CP.typ*bool) = 
	let fv_list = fv f in
	let res_list = Util.remove_dups (List.filter (fun c-> ((String.compare v (CP.name_of_spec_var c))==0)) fv_list) in
	match List.length res_list with
	| 0 -> (CP.Prim Void,false)
	| 1 -> (CP.type_of_spec_var (List.hd res_list),true)
	| _ -> Err.report_error { Err.error_loc = no_pos; Err.error_text = "could not find a coherent "^v^" type"}

and get_result_type (f: formula): (CP.typ*bool) = get_var_type res f

	
and disj_count (f0 : formula) = match f0 with
  | Or ({formula_or_f1 = f1;
		 formula_or_f2 = f2}) ->
	  let c1 = disj_count f1 in
	  let c2 = disj_count f2 in
		1 + c1 + c2

  | _ -> 1

(* context functions *)
	
type entail_state = {
  es_formula : formula; (* can be any formula *)
  es_heap : h_formula; (* consumed nodes *)
  es_pure : (CP.formula * (branch_label * CP.formula) list);
  es_evars : CP.spec_var list;
  (*used by lemmas*)
  es_ivars : CP.spec_var list; (* ivars are the variables to be instantiated (for the universal lemma application)  *)
  es_expl_vars : CP.spec_var list; (* vars to be explicit instantiated *)
  es_ante_evars : CP.spec_var list;
  es_must_match : bool;
  (*used by late instantiation*)
  es_gen_expl_vars: CP.spec_var list; 
  es_gen_impl_vars: CP.spec_var list; 
  es_unsat_flag : bool; (* true - unsat already performed; false - requires unsat test *)
  es_pp_subst : (CP.spec_var * CP.spec_var) list;
  es_arith_subst : (CP.spec_var * CP.exp) list;
  es_success_pts : (formula_label * formula_label)  list  ;(* successful pt from conseq *)
  es_residue_pts : formula_label  list  ;(* residue pts from antecedent *)
  es_id      : int              ; (* unique +ve id *)
  es_orig_ante   : formula        ;  (* original antecedent formula *) 
  es_orig_conseq : struc_formula ;
  es_path_label : path_trace;
}

and context = 
  | Ctx of entail_state
  | OCtx of (context * context) (* disjunctive context *)
  (*| FailCtx of (fail_context list)*)

and fail_context = {
      fc_message : string;          (* error message *)
      fc_current_lhs : entail_state;     (* LHS context with success points *)
      fc_orig_conseq : struc_formula;     (* RHS conseq at the point of failure *)
      fc_failure_pts : formula_label list;     (* failure points in conseq *) 
      }  
  
and fail_type =
  | Basic_Reason of fail_context option
  | Or_Reason of (fail_type * fail_type)
  | And_Reason of (fail_type * fail_type)
  
and list_context = 
  | FailCtx of fail_type 
  | SuccCtx of context list
  
and branch_fail = path_trace * fail_type

and branch_ctx =  path_trace * context

and partial_context = (branch_fail list) * (branch_ctx list)

and list_partial_context = partial_context list
   

let empty_es flowt pos = 
	let x = mkTrue flowt pos in
{
  es_formula = x;
  es_heap = HTrue;
  es_pure = (CP.mkTrue pos, []);
  es_evars = [];
  es_must_match = false;
  es_ivars = [];
  es_expl_vars = [];
  es_ante_evars = [];
  es_gen_expl_vars = []; 
  es_gen_impl_vars = []; 
  es_pp_subst = [];
  es_unsat_flag = true;
  es_arith_subst = [];
  es_success_pts = [];
  es_residue_pts  = [];
  es_id = 0 ;
  es_orig_ante = x;
  es_orig_conseq = [mkETrue flowt pos] ;
  es_path_label  =[];
}

let empty_ctx flowt pos = Ctx (empty_es flowt pos)

let false_ctx flowt pos = 
	let x = mkFalse flowt pos in
	Ctx ({(empty_es flowt pos) with es_formula = x ; es_orig_ante = x; })

let true_ctx flowt pos = Ctx (empty_es flowt pos)

(*let isStrictFalseCtx ctx = match ctx with
  | Ctx es -> isStrictConstFalse es.es_formula
  | _ -> false*)

let isAnyFalseCtx ctx = match ctx with
  | Ctx es -> isAnyConstFalse es.es_formula
  | _ -> false  

let isAnyFalsePartialCtx (fc,sc) = (fc=[]) &&
  List.for_all (fun (_,s) -> isAnyFalseCtx s) sc

(* let isSuccessPartialCtx ((fc,sc):partial_context) = (fc=[])  *)

(* let isFailPartialCtx (pc:partial_context) = not(isSuccessPartialCtx pc) *)
 
(* let isAnySuccessListPartialCtx (cl:list_partial_context) =  List.exists isSuccessPartialCtx cl *)

(* let isFailListPartialCtx (cl:list_partial_context) =  List.for_all isFailPartialCtx cl *)
 
let isAnyFalseListCtx ctx = match ctx with
  | SuccCtx lc ->List.exists isAnyFalseCtx lc
  | FailCtx _ -> false
  
let isStrictTrueCtx ctx = match ctx with
  | Ctx es -> isStrictConstTrue es.es_formula
  | _ -> false

let isAnyTrueCtx ctx = match ctx with
  | Ctx es -> isAnyConstTrue es.es_formula
  | _ -> false
  
let rec allFalseCtx ctx = match ctx with
	| Ctx es -> isAnyFalseCtx ctx
	| OCtx (c1,c2) -> (allFalseCtx c1) && (allFalseCtx c2)

let mkOCtx ctx1 ctx2 pos =
  (*if (isFailCtx ctx1) || (isFailCtx ctx2) then or_fail_ctx ctx1 ctx2
  else*)  if isStrictTrueCtx ctx1 || isStrictTrueCtx ctx2 then
	true_ctx (mkTrueFlow ()) pos
  else if isAnyFalseCtx ctx1 then ctx2
  else if isAnyFalseCtx ctx2 then ctx1
  else OCtx (ctx1,ctx2) 

let or_context c1 c2 = mkOCtx c1 c2 no_pos 
  
let rec or_context_list (cl10 : context list) (cl20 : context list) : context list = 
  let rec helper cl1 cl2 = match cl1 with
	| c1 :: rest ->
		let tmp1 = or_context_list rest cl2 in
		let tmp2 = List.map (or_context c1) cl2 in
		  tmp2 @ tmp1 
	| [] -> []
  in
	if Util.empty cl20 then
	  []
	else
	  let tmp = helper cl10 cl20 in
		tmp
  
let mkFailCtx_in (ft:fail_type) = FailCtx ft

let mk_fail_partial_context_label (ft:fail_type) (lab:path_trace) : (partial_context) = ([(lab,ft)], []) 

let mk_partial_context (c:context) : (partial_context) = ([], [ ([], c) ] ) 

let mk_partial_context_label (c:context) (lab:path_trace) : (partial_context) = ([], [ (lab, c) ] ) 
 
let mk_list_partial_context_label (c:list_context) (lab:path_trace): (list_partial_context) =
  match c with
    | FailCtx fr ->  [( [(lab,fr)] ,[])]
    | SuccCtx cl -> List.map (fun c -> mk_partial_context_label c lab) cl

let mk_list_partial_context (c:list_context) : (list_partial_context) =
  mk_list_partial_context_label c []



let repl_label_list_partial_context (lab:path_trace) (cl:list_partial_context) : list_partial_context 
    = List.map (fun (fl,sl) -> (fl, List.map (fun (_,c) -> (lab,c)) sl)) cl
  
  
  (*context set union*)

let fold_context_left c_l = match (List.length c_l) with
  | 0 ->  Err.report_error {Err.error_loc = no_pos;  
              Err.error_text = "folding empty context list \n"}
  | 1 -> (List.hd c_l)
  | _ ->  List.fold_left (fun a c-> 
    match a,c with
     | FailCtx t1 ,FailCtx t2 -> FailCtx (Or_Reason (t1,t2))
     | FailCtx t1,SuccCtx t2 -> SuccCtx t2
     | SuccCtx t1,FailCtx t2 -> SuccCtx t1
     | SuccCtx t1,SuccCtx t2 -> SuccCtx (t1@t2)) (List.hd c_l) (List.tl c_l)
  
  (*list_context or*)
let or_list_context c1 c2 = match c1,c2 with
     | FailCtx t1 ,FailCtx t2 -> FailCtx (And_Reason (t1,t2))
     | FailCtx t1 ,SuccCtx t2 -> FailCtx t1
     | SuccCtx t1 ,FailCtx t2 -> FailCtx t2
     | SuccCtx t1 ,SuccCtx t2 -> SuccCtx (or_context_list t1 t2)

let isFailCtx cl = match cl with 
	| FailCtx _ -> true
	| SuccCtx _ -> false


let isFailPartialCtx (fs,ss) =
if (U.empty ss) then true else false

let isFailListPartialCtx cl =
  List.for_all isFailPartialCtx cl 

let isSuccessPartialCtx (fs,ss) =
if (U.empty fs) then true else false

let isSuccessListPartialCtx cl =
  List.exists isSuccessPartialCtx cl 
  
let rank (t:partial_context):float = match t with
  | ( [] ,[] ) -> Err.report_error {Err.error_loc = no_pos;  Err.error_text = " rank: recieved an empty partial_context\n"}
  | ( [] , _ ) -> 1.
  | ( _  ,[] ) -> 0.
  | ( l1 , l2) -> 
    let fn,sn =float (List.length(l1)), float(List.length(l2)) in
    sn /.(fn +. sn)
  
let list_partial_context_union (l1:list_partial_context) (l2:list_partial_context):list_partial_context = l1 @ l2

let select n l = 
  if n<=0 then l 
    else (U.take n l) @(List.filter (fun c-> (rank c)==1.) (U.drop n l))

let list_partial_context_union_n (l1:list_partial_context) (l2:list_partial_context) n :list_partial_context = 
    select n  (List.sort (fun a1 a2 -> 
      truncate 
        (
          (
            (rank a2)-.
              (rank a1)
          )
          *.
          1000.
        )) (l1 @ l2))

let rec merge_fail (f1:branch_fail list) (f2:branch_fail list) : (branch_fail list * path_trace list) =
  match f1,f2 with
    | [],xs -> xs, (List.map (fun (p,_)->p) xs)
    | xs,[] -> xs, (List.map (fun (p,_)->p) xs)
    | (l1,b1)::z1,(l2,b2)::z2 -> 
	if path_trace_eq l1 l2 then 
	  let res,pt = merge_fail z1 z2 in
	    ((l1,And_Reason (b1,b2))::res, l1::pt)
	else if path_trace_lt l1 l2 then 
	  let res,pt = merge_fail z1 f2 in
	    ((l1,b1)::res, l1::pt)
	else let res,pt = merge_fail f1 z2 in
	  ((l2,b2)::res, l2::pt)

let merge_partial_context_or ((f1,s1):partial_context) ((f2,s2):partial_context) : partial_context =
  let (res_f,pt_fail_list) = merge_fail f1 f2 in
  let rec merge_success s1 s2 = match s1,s2 with
    | [],xs | xs,[] -> xs   
        (* List.filter (fun (l,_) -> not (List.mem l pt_fail_list)) xs *)
    | (l1,b1)::z1,(l2,b2)::z2 -> 
	    if path_trace_eq l1 l2 then 
	      let res = merge_success z1 z2 in
	      ((l1,or_context b1 b2)::res)
	    else if path_trace_lt l1 l2 then 
	      let res = merge_success z1 s2 in
	      (l1,b1)::res
	    else let res = merge_success s1 z2 in
	    (l2,b2)::res in
  (res_f,merge_success s1 s2)

let remove_dupl_false sl = List.hd(sl)::(List.filter (fun (_,oc) -> not (isAnyFalseCtx oc) ) (List.tl sl))

let simple_or pc1 pc2 =  ( (fst pc1)@(fst pc2),  remove_dupl_false ((snd pc1)@(snd pc2)) ) 

let list_partial_context_or_naive (l1:list_partial_context) (l2:list_partial_context) : list_partial_context = 
  List.concat (List.map (fun pc1-> (List.map (simple_or pc1) l2)) l1)
  (* List.concat (List.map (fun pc1-> (List.map (merge_partial_context_or pc1) l2)) l1) *)

let list_partial_context_or (l1:list_partial_context) (l2:list_partial_context) : list_partial_context = 
  List.concat (List.map (fun pc1-> (List.map (simple_or pc1) l2)) l1)
  (* List.concat (List.map (fun pc1-> (List.map (merge_partial_context_or pc1) l2)) l1) *)




  
  
(*let isFailCtx (ctx:context):bool = match ctx with
  | FailCtx es -> true
  | _ -> false
  
let rec isAnyFailCtx c = match c with
	| OCtx (c1,c2) -> (isAnyFailCtx c1) || (isAnyFailCtx c2) 
	| Ctx _ -> false
  
let isAnyFailCtx_list cl = List.exists isAnyFailCtx cl
    
  
let merge_two_fail_ctx (ctx1:context list) (ctx2:context list) :context list = match ctx1, ctx2 with
	| [FailCtx fs1], [FailCtx fs2] -> [FailCtx (fs1 @ fs2)]
	| [] , t -> t
	| t , [] -> t
	| _,_ -> Err.report_error {Err.error_loc = no_pos;  Err.error_text = "malfunction in mkOCtx with FailCtx \n"}
  
let or_fail_ctx ctx1 ctx2 : context = match (ctx1,ctx2) with
	| FailCtx fs1, FailCtx fs2 -> FailCtx (fs1 @ fs2)
	| _ , FailCtx fs2 ->  FailCtx fs2
	| FailCtx fs1 , _ ->  FailCtx fs1
	| _,_ -> Err.report_error {Err.error_loc = no_pos;  Err.error_text = "malfunction in mkOCtx with FailCtx \n"}
	
(*normalize for set of contexts if all fail the result is fail otherwise filter the failed contexts*)
let normalize_fail_ctx_list (cl:context list) : context list =  if cl==[] then []
	else if List.for_all isFailCtx cl then 
		[List.fold_left or_fail_ctx (List.hd cl) (List.tl cl)]
	else List.filter (fun c-> not (isFailCtx c)) cl
	 
let remove_empty_fail_ctx c : context list = match c with 
	| [] -> [FailCtx[]]
	| _ -> c
	*) 

let rec build_context ctx f pos = match f with
  | Base _ | Exists _ -> 
	  let es = estate_of_context ctx pos in
		Ctx ({es with es_formula = f;es_unsat_flag =false;})
  | Or ({formula_or_f1 = f1; formula_or_f2 = f2; formula_or_pos = _}) -> 
	  let c1 = build_context ctx f1 pos in
	  let c2 = build_context ctx f2 pos in
		or_context c1 c2
	
(* 09.05.2008 ---*)		

and set_context_formula (ctx : context) (f : formula) : context = match ctx with
  | Ctx es -> begin
	  match f with
		| Or ({formula_or_f1 = f1; formula_or_f2 = f2; formula_or_pos = pos}) ->
			let cf1 = set_context_formula ctx f1 in
			let cf2 = set_context_formula ctx f2 in
			  mkOCtx  cf1 cf2 pos
		| _ -> Ctx {es with es_formula = f;es_unsat_flag =false;}
	end
  | OCtx (c1, c2) ->
	  let nc1 = set_context_formula c1 f in
	  let nc2 = set_context_formula c2 f in
		mkOCtx nc1 nc2 (pos_of_formula f) 

and get_estate_must_match (es : entail_state) : bool = 
	es.es_must_match

and set_estate_must_match (es: entail_state) : entail_state = 	
	let es_new = {es with es_must_match = true} in
		es_new
	
and set_context_must_match (ctx : context) : context = match ctx with 
  | Ctx (es) -> Ctx(set_estate_must_match es)
  | OCtx (ctx1, ctx2) -> OCtx((set_context_must_match ctx1), (set_context_must_match ctx2))


and estate_of_context (ctx : context) (pos : loc) = match ctx with
  | Ctx es -> es
  | _ -> Err.report_error {Err.error_loc = pos;
						   Err.error_text = "estate_of_context: disjunctive or fail context"}

						   
and flow_formula_of_ctx (ctx : context) (pos : loc) = match ctx with
  | Ctx es -> flow_formula_of_formula es.es_formula
  | _ -> Err.report_error {Err.error_loc = pos;
						   Err.error_text = "flow_of_context: disjunctive or fail context"}

and set_flow_in_ctx_override (c:context) (f:flow_formula) :context = match c with
	| Ctx c1-> Ctx {c1 with es_formula = set_flow_in_formula_override f c1.es_formula}
	| OCtx (c1,c2) -> OCtx ((set_flow_in_ctx_override c1 f),(set_flow_in_ctx_override c2 f))
		
and change_flow_ctx from_fl to_fl ctx_list = 
	let rec helper c = match c with
		| Ctx c -> Ctx {c with es_formula = substitute_flow_in_f to_fl from_fl c.es_formula;}
		| OCtx (c1,c2)-> OCtx ((helper c1), (helper c2)) in
	List.map helper ctx_list
	
(*23.10.2008*)

and compose_context_formula (ctx : context) (phi : formula) (x : CP.spec_var list) flow_tr (pos : loc) : context = match ctx with
  | Ctx es -> begin
	  match phi with
		| Or ({formula_or_f1 = phi1; formula_or_f2 =  phi2; formula_or_pos = _}) ->
			let new_c1 = compose_context_formula ctx phi1 x flow_tr pos in
			let new_c2 = compose_context_formula ctx phi2 x flow_tr pos in
			let res = (mkOCtx new_c1 new_c2 pos ) in
			  res
		| _ -> Ctx {es with es_formula = compose_formula es.es_formula phi x flow_tr pos;es_unsat_flag =false;}
	end
  | OCtx (c1, c2) -> 
	  let new_c1 = compose_context_formula c1 phi x flow_tr pos in
	  let new_c2 = compose_context_formula c2 phi x flow_tr pos in
	  let res = (mkOCtx new_c1 new_c2 pos) in
		res
(*TODO: expand simplify_context to normalize by flow type *)
and simplify_context (ctx:context):context = 
	if (allFalseCtx ctx) then (false_ctx (mkFalseFlow) no_pos)
								else  ctx
		
and normalize_es (f : formula) (pos : loc) (result_is_sat:bool) (es : entail_state): context = 
	Ctx {es with es_formula = normalize es.es_formula f pos; es_unsat_flag = es.es_unsat_flag&&result_is_sat} 

and normalize_es_combine (f : formula) (result_is_sat:bool)(pos : loc) (es : entail_state): context =
	Ctx {es with es_formula = normalize_combine es.es_formula f pos; es_unsat_flag = es.es_unsat_flag&&result_is_sat;} 
		
and combine_and (f1:formula) (f2:Cpure.formula) :formula*bool = match f1 with
	| Or ({formula_or_f1 = o11; formula_or_f2 = o12; formula_or_pos = pos}) ->
	 print_string ("malfunction: inner or has not been converted to a CtxOr!");
      Error.report_error {
		Error.error_loc = pos;
		Error.error_text = ("malfunction: inner or has not been converted to a CtxOr!") }
	| Base ({ formula_base_pure = p;} as b) -> 
			let r1,r2 = (combine_and_pure f1 p f2) in
			(Base{b with formula_base_pure = r1}, r2)					 
	| Exists ({formula_exists_qvars = evars;
			   formula_exists_pure = p ;} as b) -> 
			if (List.length (Util.intersect (Cpure.fv f2) evars))=0 then
				let r1,r2 = (combine_and_pure f1 p f2) in
				(Exists {b with formula_exists_pure = r1},r2)	  
				else 
					let rf1 = rename_bound_vars f1 in
					(combine_and rf1 f2)
		
and normalize_no_rename_context_formula (ctx : context) (p : Cpure.formula) : context = 
	let rec push_pure (f:formula):formula = match f with
		| Base b-> Base {b with formula_base_pure = Cpure.mkAnd p b.formula_base_pure b.formula_base_pos}
		| Exists b -> Exists {b with formula_exists_pure = Cpure.mkAnd p b.formula_exists_pure b.formula_exists_pos}
		| Or b -> Or {
				   formula_or_f1 = push_pure b.formula_or_f1;
				   formula_or_f2 = push_pure b.formula_or_f2;
				   formula_or_pos = b.formula_or_pos
				}in
match ctx with
  | Ctx es -> Ctx {es with es_formula = push_pure es.es_formula;es_unsat_flag  =false;}
  | OCtx (c1, c2) ->
	  let nc1 = normalize_no_rename_context_formula c1 p in
	  let nc2 = normalize_no_rename_context_formula c2 p in
	  let res = OCtx (nc1, nc2) in
		res
		
(* -- 17.05.2008 *)
and normalize_clash_es (f : formula) (pos : loc) (result_is_sat:bool)(es:entail_state): context = match f with
	| Or ({formula_or_f1 = phi1; formula_or_f2 =  phi2; formula_or_pos = _}) ->
		let new_c1 = normalize_clash_es phi1 pos result_is_sat es in
		let new_c2 = normalize_clash_es phi2 pos result_is_sat es in
		let res = (mkOCtx new_c1 new_c2 pos) in
		res
	| _ -> Ctx {es with es_formula = normalize_only_clash_rename es.es_formula f pos; es_unsat_flag =es.es_unsat_flag&&result_is_sat}
	
(* 17.05.2008 -- *)

and formula_of_context ctx0 = match ctx0 with
  | OCtx (c1, c2) ->
	  let f1 = formula_of_context c1 in
	  let f2 = formula_of_context c2 in
		mkOr f1 f2 no_pos
  | Ctx es -> es.es_formula
  
(* -- added 16.05.2008 *)  
and formula_of_list_context (ctx : list_context) : formula =  match ctx with
  | FailCtx _ -> mkTrue (mkTrueFlow()) no_pos
  | SuccCtx ls -> List.fold_left (fun a c-> mkOr (formula_of_context c) a no_pos)
          (mkFalse (mkTrueFlow ()) no_pos) ls
(* 16.05.2008 -- *)

and formula_of_list_partial_context (ls : list_partial_context) : formula =  
  List.fold_left (fun a c-> mkOr (formula_of_partial_context c) a no_pos)
          (mkFalse (mkTrueFlow ()) no_pos) ls

and formula_of_partial_context ((fl,sl) : partial_context) : formula =  
  List.fold_left (fun a (_,c)-> mkOr (formula_of_context c) a no_pos)
          (mkFalse (mkTrueFlow ()) no_pos) sl

and disj_count_ctx (ctx0 : context) = match ctx0 with
  | OCtx (c1, c2) ->
	  let t1 = disj_count_ctx c1 in
	  let t2 = disj_count_ctx c2 in
		1 + t1 + t2
  | Ctx es -> disj_count es.es_formula

(*
and find_type_var (tc : h_formula) (v : ident) : CP.spec_var option = match tc with
  | Star ({h_formula_star_h1 = h1;
		   h_formula_star_h2 = h2}) -> begin
	  let tmp1 = find_type_var h1 v in
		match tmp1 with
		  | Some _ -> tmp1
		  | None -> find_type_var h2 v
	end
  | DataNode ({h_formula_data_arguments = args}) -> Some (List.hd args)
  | ViewNode _ | HTrue | HFalse -> None
*)

let rec set_flow_in_context_override f_f ctx = match ctx with
	| Ctx es -> Ctx {es with es_formula = (set_flow_in_formula_override f_f es.es_formula)}
	| OCtx (c1,c2) -> OCtx ((set_flow_in_context_override f_f c1),(set_flow_in_context_override f_f c2))





(* order nodes in topological order *)

module Node = struct
  type t = h_formula
  let compare = compare
  let hash = Hashtbl.hash
  let equal = (=)
end

module NG = Graph.Imperative.Digraph.Concrete(Node)
module TopoNG = Graph.Topological.Make(NG)

(*
  return the same formula with nodes rearranged in topological
  order based on the points-to relation of the heap nodes.
*)
(*
let topologize_formula (h0 : h_formula) : h_formula =
  let g = NG.create () in
*)

(*************************************************************************************************************************
	05.06.2008:
	Utilities for existential quantifier elimination: 
	- before we were only searching for substitutions of k form v1 = v2 and then substitute ex v1. P(v1) --> P(v2)
	- now, we want to be more aggressive and search for substitutions of the form v1 = exp2; however, we can only apply these substitutions to the pure part 
	(due to the way shape predicates are recorded --> root pointer and args are suppose to be spec vars)
*************************************************************************************************************************)	 
let rec subst_exp sst (f : formula) = match sst with
  | s :: rest -> 
	  let new_f = subst_exp rest (apply_one_exp s f) in
	  (*let fv_new_f = fv new_f in
		 	if List.mem (fst s) fv_new_f then 
		 		let f = add_quantifiers [(fst s)] new_f in
		 		let qvars, base_f = split_quantifiers f in
		 		let h, p, t = split_components base_f in
		 	 		mkExists qvars h (CP.mkAnd p (CP.mkEqExp (CP.mkVar (fst s) no_pos) (snd s) no_pos) no_pos) t no_pos 
			else*) new_f
  | [] -> f 
  
and subst_var_exp (fr, t) (o : CP.spec_var) = if CP.eq_spec_var fr o then t else o

and apply_one_exp ((fr, t) as s : (CP.spec_var * CP.exp)) (f : formula) = match f with
  | Or ({formula_or_f1 = f1; formula_or_f2 = f2; formula_or_pos = pos}) -> 
      Or ({formula_or_f1 = apply_one_exp s f1; formula_or_f2 =  apply_one_exp s f2; formula_or_pos = pos})
  | Base ({formula_base_heap = h; 
		   formula_base_pure = p; 
		   formula_base_type = t;
           formula_base_branches = b;
		   formula_base_flow = fl;
		   formula_base_pos = pos}) -> 
    Base ({formula_base_heap = h; 
			formula_base_pure = CP.apply_one_exp s p;
			formula_base_flow = fl;
     	(* TODO: dolve this *)
		 	(*formula_base_pure = CP.elim_idents (CP.apply_one_exp s p);*) (* substitute + easy simplification - eliminate identities where LHS identic to RHS *)
		 	formula_base_type = t;
            formula_base_branches = List.map (fun (l, p1) -> (l, CP.apply_one_exp s p1)) b;
		 	formula_base_pos = pos})
  | Exists ({formula_exists_qvars = qsv; 
			 formula_exists_heap = qh; 
			 formula_exists_pure = qp; 
			 formula_exists_type = tconstr;
             formula_exists_branches = b;
			 formula_exists_flow = fl;
			 formula_exists_pos = pos}) -> 
	  if List.mem (CP.name_of_spec_var fr) (List.map CP.name_of_spec_var qsv) then f 
	  else Exists ({formula_exists_qvars = qsv; 
					formula_exists_heap =  qh; 
					formula_exists_pure = CP.apply_one_exp s qp; 
					formula_exists_type = tconstr;
					formula_exists_flow = fl;
                    formula_exists_branches = List.map (fun (l, p1) -> (l, CP.apply_one_exp s p1)) b;
					formula_exists_pos = pos})

(*and combine_branch b *)
  
and replace_branches b = function
  | Or f -> failwith "replace_branches doesn't expect an Or"
  | Base f -> Base {f with formula_base_branches = b;}
  | Exists f -> Exists {f with formula_exists_branches = b;}
;;

let flatten_branches p br =
  List.fold_left (fun p (l, f) -> CP.And (p, f,no_pos)) p br
;;

let rec split_struc_formula (f0:struc_formula):(formula*formula) list = 
	let rec ext_to_formula (f:ext_formula):(formula*formula) list = match f with
		| ECase b-> let r = List.concat (List.map 
			(fun (c1,c2)-> 
				let ff = formula_of_pure c1 b.formula_case_pos in
				let ll = split_struc_formula c2 in
				List.map (fun (d1,d2)-> ((normalize d1 ff b.formula_case_pos),d2)) ll
			) b.formula_case_branches) in
			List.map (fun (c1,c2)-> ((push_exists b.formula_case_exists c1),(push_exists b.formula_case_exists c2))) r 
		| EBase b-> 
				let ll = split_struc_formula b.formula_ext_continuation in
				let e = List.map (fun (c1,c2)-> ((normalize c1 b.formula_ext_base b.formula_ext_pos),c2)) ll in
				let nf = ((*b.formula_ext_explicit_inst@b.formula_ext_implicit_inst@*)b.formula_ext_exists) in
				let e = List.map (fun (c1,c2)-> ((push_exists nf c1),(push_exists nf c2))) e in
				e
		| EAssume (x,b,_)-> [((mkTrue (mkNormalFlow ()) no_pos),b)]
			in	
	List.fold_left (fun a c-> a@(ext_to_formula c)) [] f0	;;

let rec struc_to_formula (f0:struc_formula):formula = 
	let rec ext_to_formula (f:ext_formula):formula = match f with
		| ECase b-> let r = 
			if (List.length b.formula_case_branches) >0 then
			List.fold_left 
			(fun a (c1,c2)-> 
				(*let ng = Cpure.Not (c1,b.formula_case_pos) in*)
				if (isConstEFalse c2) then a
				else
				(mkOr a (normalize_combine 
							(mkBase HTrue c1 TypeTrue (mkTrueFlow ()) [] b.formula_case_pos ) 
							(struc_to_formula c2)
							b.formula_case_pos
						) 
						b.formula_case_pos
				)
				)
			(mkFalse (mkFalseFlow) b.formula_case_pos) b.formula_case_branches 
			else mkTrue (mkTrueFlow ()) b.formula_case_pos in
			push_exists b.formula_case_exists r 
		| EBase b-> 
				let e = normalize_combine b.formula_ext_base (struc_to_formula b.formula_ext_continuation) b.formula_ext_pos in
				let nf = push_exists ((*b.formula_ext_explicit_inst@b.formula_ext_implicit_inst@*)b.formula_ext_exists) e in
				nf
		| EAssume (_,b,_)-> b 
			in	
	if (List.length f0)>0 then
		List.fold_left (fun a c-> mkOr a (ext_to_formula c) no_pos) (mkFalse (mkFalseFlow) no_pos)f0
	else mkTrue (mkTrueFlow ()) no_pos	
	
and formula_to_struc_formula (f:formula):struc_formula =
	let rec helper (f:formula):struc_formula = match f with
		| Base b-> [EBase ({
			 		formula_ext_explicit_inst =[];
		 			formula_ext_implicit_inst = [];
					formula_ext_exists = [];
		 			formula_ext_base = f;
					formula_ext_continuation = [];
		 			formula_ext_pos = b.formula_base_pos})]
		| Exists b-> [EBase ({
			 		formula_ext_explicit_inst =[];
		 			formula_ext_implicit_inst = [];
					formula_ext_exists = [];
		 			formula_ext_base = f;
					formula_ext_continuation = [];
		 			formula_ext_pos = b.formula_exists_pos})]
		| Or b->  (helper b.formula_or_f1)@(helper b.formula_or_f2) in			
	(helper f)

and plug_ref_vars (f0:struc_formula) (w:Cpure.spec_var list):struc_formula = 
	let rec filter_quantifiers w f = match f with
	| Base _ -> f
	| Exists b -> Exists {b with formula_exists_qvars = Util.difference b.formula_exists_qvars w;}
	| Or b -> Or {b with 
						formula_or_f1 = filter_quantifiers w b.formula_or_f1;
						formula_or_f2 = filter_quantifiers w b.formula_or_f2;}in
	let rec helper (f0:ext_formula):ext_formula = match f0 with
	| EAssume (_,b,t)->  EAssume (w,(filter_quantifiers  w b),t)
	| ECase b -> ECase {b with formula_case_branches = List.map (fun (c1,c2)-> (c1,(plug_ref_vars c2 w))) b.formula_case_branches}
	| EBase b -> EBase {b with formula_ext_continuation = plug_ref_vars b.formula_ext_continuation w}in 
	List.map helper f0


and count_or c = match c with
			| Ctx _ -> 1
			| OCtx (c1,c2) -> (count_or c1)+(count_or c2)		
			
and find_false_ctx ctx pos =
  match ctx with
   | FailCtx _ -> ()
   | SuccCtx ctx ->
	if (List.exists isAnyFalseCtx ctx) then 
    false_ctx_line_list := Util.remove_dups (pos::!false_ctx_line_list) else ()

and find_false_list_partial_ctx ctx pos =
    if (List.exists isAnyFalsePartialCtx ctx) then 
      false_ctx_line_list := Util.remove_dups (pos::!false_ctx_line_list) 
    else ()
	
	(*
and filter_node (c: context) (p1:spec_var):context = 
	let rec helper_filter (f:formula):formula = match f with
		| Or b -> 
		| Base b ->
		| Exists b ->
	in match c with
		|OCtx (c1,c2) -> OCtx ((filter_node c1 p1),(filter_node c2 p2))
		| Ctx c -> Ctx {c with es_formula = (helper_filter c.es_formula)}
*)

and guard_vars f = Util.remove_dups (List.fold_left (fun a f-> a@(match f with
	| ECase b-> Util.remove_dups (List.fold_left (fun a (c1,c2)-> a@(Cpure.fv c1)@(guard_vars c2)) [] b.formula_case_branches)
	| EBase b -> Util.difference (guard_vars b.formula_ext_continuation) b.formula_ext_exists
	| EAssume b-> [])) [] f)
	
and set_unsat_flag (ctx:context) (nf:bool):context = match ctx with
| OCtx(c1,c2)-> OCtx ((set_unsat_flag c1 nf),(set_unsat_flag c2 nf))
| Ctx c-> Ctx {c with es_unsat_flag = nf}

and filter_heap (f:formula):formula option = match f with
	| Or b-> begin 
				match (filter_heap b.formula_or_f1) with
					| None -> None (*(filter_heap b.formula_or_f2)*)
					| Some d1-> match (filter_heap b.formula_or_f2) with
								| None -> None
								| Some d2 -> Some (mkOr d1 d2 b.formula_or_pos)
			 end
	| Base b-> begin 
					match b.formula_base_heap with
					 | Star _
					 | DataNode _ 
					 | ViewNode _ -> None
					 | HTrue 
					 | HFalse -> Some f
				end
	| Exists b-> 
				begin
					match b.formula_exists_heap with
					 | Star _
					 | DataNode _ 
					 | ViewNode _ -> None
					 | HTrue 
					 | HFalse -> Some f
				end

and set_es_evars (c:context)(v:Cpure.spec_var list):context = match c with
	| OCtx (c1,c2)-> OCtx ((set_es_evars c1 v),(set_es_evars c2 v))
	| Ctx e -> Ctx {e with es_evars = v}
	
and purge_f_pures f l = 
	let rec purge_pures f = match f with 
	  | Cpure.BForm (b,_)-> 
			if List.exists (fun c->  b = c) l then Cpure.mkTrue no_pos 
					else f 
	  | Cpure.And (f1,f2,l)-> Cpure.mkAnd (purge_pures f1) (purge_pures f2) l
	  | Cpure.Or _ 
	  | Cpure.Not _ -> f
	  | Cpure.Forall (q,f,lbl,l) -> Cpure.Forall (q,(purge_pures f),lbl,l) 
	  | Cpure.Exists (q,f,lbl,l) -> Cpure.Exists (q,(purge_pures f),lbl,l)
	in
	match f with
	| Base b-> Base {b with formula_base_pure = purge_pures b.formula_base_pure}
	| Exists b-> Exists {b with formula_exists_pure = purge_pures b.formula_exists_pure}
	| Or b-> Or {  formula_or_f1 = purge_f_pures b.formula_or_f1 l;
				   formula_or_f2 = purge_f_pures b.formula_or_f2 l;
				   formula_or_pos = b.formula_or_pos}
	
and clean_case_guard_redundancy f l:struc_formula = List.map (fun c-> 
	match c with
	| EBase b -> EBase{b with 
		formula_ext_base = (purge_f_pures b.formula_ext_base l);	
		formula_ext_continuation = clean_case_guard_redundancy b.formula_ext_continuation l}

	| ECase b -> ECase{b with formula_case_branches = (
		List.map (fun (c1,c2)-> 
			let n_l = ((Cpure.b_form_list c1)@l) in
			(c1,(clean_case_guard_redundancy c2 n_l))) b.formula_case_branches) }	
	| _ -> c
	) f

and case_to_disjunct f  =
let rec push_pure c f =  match f with
	| ECase _ -> f (*this should never occur*) 
	| EBase b-> EBase {b with formula_ext_base = normalize_combine b.formula_ext_base (formula_of_pure c no_pos) no_pos}
	| _ -> EBase {
		 formula_ext_explicit_inst = [];
		 formula_ext_implicit_inst = [];
		 formula_ext_exists = [];
		 formula_ext_base = formula_of_pure c no_pos;
		 formula_ext_continuation = [f];
		 formula_ext_pos = no_pos;
	}
	
and helper f = match f with
	| ECase b-> List.concat (List.map (fun (c1,c2)-> 
										let f = case_to_disjunct c2 in 
										List.map (push_pure c1) f) b.formula_case_branches)
	| EBase b-> [EBase {b with formula_ext_continuation = (case_to_disjunct b.formula_ext_continuation)}]
	| _ -> [f] in
List.concat (List.map helper f)


and res_retrieve stab clean_res fl =
	if clean_res then  
		try 
			let r = Some (Hashtbl.find stab res) in
			(if (subsume_flow !exc_flow_int (Util.get_hash_of_exc fl)) then (Hashtbl.remove stab res) else ());
			r
		with Not_found -> None
	else None

	
and res_replace stab rl clean_res fl =
	if clean_res&&(subsume_flow !exc_flow_int (Util.get_hash_of_exc fl)) then 
		((Hashtbl.remove stab res);
		match rl with 
			| None -> () 
			| Some e-> Hashtbl.add stab res e) 
	else ()
	
(* start label - can be simplified *)	
let get_start_label ctx = match ctx with
  | FailCtx _ -> ""
  | SuccCtx sl -> 
    let rec helper c= match c with
      | Ctx e -> if (List.length e.es_path_label)==0 then "" else snd(fst (Util.list_last e.es_path_label))
      | OCtx (c1,c2) -> helper c1 in
	helper (List.hd sl)

let get_start_partial_label (ctx:list_partial_context) =
  let rec helper c= match c with
    | Ctx e -> if (List.length e.es_path_label)==0 then "" else snd(fst (Util.list_last e.es_path_label))
    | OCtx (c1,c2) -> helper c1 in
  let pc = List.hd ctx in
    if (rank pc) < 1. then ""
    else let (_,ls) = pc in
      helper (snd (List.hd ls))

	
let rec replace_heap_formula_label nl f = match f with
	| Star b -> Star {b with 
			h_formula_star_h1 = replace_heap_formula_label nl b.h_formula_star_h1; 
			h_formula_star_h2 = replace_heap_formula_label nl b.h_formula_star_h2; }
	| DataNode b -> DataNode {b with h_formula_data_label = (nl ())}
	| ViewNode b -> ViewNode {b with h_formula_view_label = (nl ())}
	| HTrue 
	| HFalse -> f
	
let rec replace_pure_formula_label nl f = match f with
  | CP.BForm (bf,_) -> CP.BForm (bf,(nl()))
  | CP.And (b1,b2,b3) -> CP.And ((replace_pure_formula_label nl b1),(replace_pure_formula_label nl b2),b3)
  | CP.Or (b1,b2,b3,b4) -> CP.Or ((replace_pure_formula_label nl b1),(replace_pure_formula_label nl b2),(nl()),b4)
  | CP.Not (b1,b2,b3) -> CP.Not ((replace_pure_formula_label nl b1),(nl()),b3)
  | CP.Forall (b1,b2,b3,b4) -> CP.Forall (b1,(replace_pure_formula_label nl b2),(nl()),b4)
  | CP.Exists (b1,b2,b3,b4) -> CP.Exists (b1,(replace_pure_formula_label nl b2),(nl()),b4)
    	
let rec replace_formula_label1 nl f = match f with
	| Base b->Base {b with 
			formula_base_heap = replace_heap_formula_label nl b.formula_base_heap ;
			formula_base_pure = replace_pure_formula_label nl b.formula_base_pure ;
			formula_base_branches = List.map (fun (c1,c2)-> (c1,( replace_pure_formula_label nl c2))) b.formula_base_branches; }
	| Exists b->Exists {b with 
			formula_exists_heap = replace_heap_formula_label nl b.formula_exists_heap ;
			formula_exists_pure = replace_pure_formula_label nl b.formula_exists_pure ;
            formula_exists_branches = List.map (fun (c1,c2)-> (c1,( replace_pure_formula_label nl c2))) b.formula_exists_branches; }
	| Or b -> Or {b with 
			formula_or_f1 = replace_formula_label1 nl b.formula_or_f1;
			formula_or_f2 = replace_formula_label1 nl b.formula_or_f2;	}
			
let rec replace_struc_formula_label1 nl f = List.map (fun f-> match f with
	| EBase b -> EBase {b with 
			formula_ext_base = replace_formula_label1 nl b.formula_ext_base;
			formula_ext_continuation = replace_struc_formula_label1 nl b.formula_ext_continuation}
	| ECase b -> ECase { b with formula_case_branches = 
			List.map (fun (c1,c2)-> (replace_pure_formula_label nl c1), (replace_struc_formula_label1 nl c2)) b.formula_case_branches}
	| EAssume (b1,b2,b3)-> EAssume (b1,(replace_formula_label1 nl b2),b3) ) f
	
let replace_struc_formula_label nl f = replace_struc_formula_label1 (fun c -> nl) f
let replace_struc_formula_label_fresh f = replace_struc_formula_label1 (fun c -> (fresh_branch_point_id "")) f
let replace_formula_label nl f = replace_formula_label1 (fun c -> nl) f
let replace_formula_label_fresh f = replace_formula_label1 (fun c -> (fresh_branch_point_id "")) f

let rec residue_labels_in_formula f = 
	let rec residue_labels_in_heap f = match f with
		| Star b -> (residue_labels_in_heap b.h_formula_star_h1) @ (residue_labels_in_heap b.h_formula_star_h2)
		| DataNode b -> (match b.h_formula_data_label with Some s-> [s] | _ -> [])
		| ViewNode b -> (match b.h_formula_view_label with Some s-> [s] | _ -> [])
		| HTrue 
		| HFalse -> [] in match f with
	| Base b-> residue_labels_in_heap b.formula_base_heap 
	| Exists b->residue_labels_in_heap b.formula_exists_heap
	| Or b -> (residue_labels_in_formula b.formula_or_f1) @ (residue_labels_in_formula b.formula_or_f2)

let get_node_label n =  match n with
	| DataNode b -> b.h_formula_data_label
	| ViewNode b -> b.h_formula_view_label
	| _ -> None
	
	
	
let rec transform_h_formula f (e:h_formula):h_formula = 
	let r =  f e in 
	match r with
	| Some e1 -> e1
	| None  -> match e with	 
		| Star s -> Star {s with 
			h_formula_star_h1 = transform_h_formula f s.h_formula_star_h1;
			h_formula_star_h2 = transform_h_formula f s.h_formula_star_h2;}
	    | DataNode _
	    | ViewNode _
	    | HTrue
	    | HFalse -> e
	
let rec transform_formula f (e:formula):formula =
	let (_, f_f, f_h_f, f_p_t) = f in
	let r =  f_f e in 
	match r with
	| Some e1 -> e1
	| None  -> match e with	 
		| Base b -> Base{b with 
			formula_base_heap = transform_h_formula f_h_f b.formula_base_heap;
			formula_base_pure =  CP.transform_formula f_p_t b.formula_base_pure;
			formula_base_branches =  List.map (fun (c1,c2) -> (c1, (CP.transform_formula f_p_t c2))) b.formula_base_branches;}
		| Or o -> Or {o with 
			formula_or_f1 = transform_formula f o.formula_or_f1;
			formula_or_f2 = transform_formula f o.formula_or_f2;}
		| Exists e -> Exists {e with
			formula_exists_heap = transform_h_formula f_h_f e.formula_exists_heap;
			formula_exists_pure = CP.transform_formula f_p_t e.formula_exists_pure;
			formula_exists_branches = List.map (fun (c1,c2) -> (c1, (CP.transform_formula f_p_t c2))) e.formula_exists_branches;}
		
		
let rec transform_ext_formula f (e:ext_formula) :ext_formula = 
  let (f_e_f, f_f, f_h_f, f_p_t) = f in
	let r = f_e_f e in 
	match r with
	| Some e1 -> e1
	| None -> match e with
		| ECase c -> ECase {c with 
			formula_case_branches = List.map (fun (c1,c2)-> 
				((CP.transform_formula f_p_t c1),(transform_struc_formula f c2))) c.formula_case_branches}
		| EBase b -> EBase{b with 
				 formula_ext_base = transform_formula f b.formula_ext_base;
				 formula_ext_continuation = transform_struc_formula f b.formula_ext_continuation;
				}
		| EAssume (v,e,pid)-> EAssume (v,(transform_formula f e),pid)
    
and transform_struc_formula f (e:struc_formula)	:struc_formula = 
	List.map (transform_ext_formula f) e
		
    
let rec transform_context f (c:context):context = 
	match c with
	| Ctx e -> (f e)
	| OCtx (c1,c2) -> mkOCtx (transform_context f c1)(transform_context f c2) no_pos
		
let rec transform_fail_ctx f (c:fail_type) : fail_type = 
  match c with
    | Basic_Reason br ->Basic_Reason (f br)
    | Or_Reason (ft1,ft2) ->Or_Reason ((transform_fail_ctx f ft1),(transform_fail_ctx f ft2))
    | And_Reason (ft1,ft2) ->And_Reason ((transform_fail_ctx f ft1),(transform_fail_ctx f ft2))
  
let transform_list_context f (c:list_context):list_context = 
  let f_c,f_f = f in
  match c with
    | FailCtx fc -> FailCtx (transform_fail_ctx f_f fc)
    | SuccCtx sc -> SuccCtx ((List.map (transform_context f_c)) sc)
    
let transform_partial_context f ((fail_c, succ_c):partial_context) : partial_context = 
  let f_c,f_f = f in
  let f_res = List.map (fun (lbl, f_t) -> (lbl, transform_fail_ctx f_f f_t )) fail_c in
  let s_res = List.map (fun (lbl, ctx) -> (lbl, transform_context f_c ctx) ) succ_c in
    (f_res,s_res)

  (* let f_b_f, f_b_c, f_fail_ctx,f_ctx =f in  *)
  (* let r1,r2 = (f_b_f fail_c, f_b_c succ_c) in *)
  (* let f_res = match (r1) with *)
  (*   | Some s -> s *)
  (*   | None  -> List.map (fun (lbl, f_t) -> (lbl, transform_fail_ctx f_fail_ctx f_t )) fail_c in *)
  (* let s_res = match (r2) with *)
  (*   | Some s -> s *)
  (*   | None  -> List.map (fun (lbl, ctx) -> (lbl, transform_context f_ctx ctx) ) succ_c in *)
  (* (f_res,s_res) *)
    
    
let transform_list_partial_context f (c:list_partial_context):list_partial_context = 
  List.map (transform_partial_context f) c
    
    
let rec fold_fail_context f (c:fail_type) = 
  (*let f_br,f_or,f_and = f in*)
  match c with
    | Basic_Reason br -> f c []
    | Or_Reason (ft1,ft2) -> f c [(fold_fail_context f ft1);(fold_fail_context f ft2)]
    | And_Reason (ft1,ft2) -> f c [(fold_fail_context f ft1);(fold_fail_context f ft2)]
    
(*let rec fold_list_context f (c:list_context) = 
  let f_f,f_c = f in
  match c with
    | FailCtx fc -> fold_fail_context f_f fc
    | SuccCtx sc -> List.map (fold_context f_c) sc*)
    
let rename_labels transformer e =
	let n_l_f n_l = match n_l with
				| None -> (fresh_branch_point_id "")
				| Some (_,s) -> (fresh_branch_point_id s) in	
    let f_e_f e = None in
	let f_f e = None in
	let rec f_h_f e = match e with 
		| Star s -> None
	    | DataNode d -> Some (DataNode {d with h_formula_data_label = n_l_f d.h_formula_data_label})
	    | ViewNode v -> Some (ViewNode {v with h_formula_view_label = n_l_f v.h_formula_view_label})
	    | HTrue
	    | HFalse -> Some e in
	let f_b e = Some e in
	let f_e e = Some e in
	let f_p_f e = 
		match e with
		| CP.BForm (b,f_l) -> Some (CP.BForm (b,(n_l_f f_l)))
		| CP.And (e1,e2,l) -> None
		| CP.Or (e1,e2,f_l,l) -> (Some (CP.Or (e1,e2,(n_l_f f_l),l)))
		| CP.Not (e1,f_l, l) -> (Some (CP.Not (e1,(n_l_f f_l),l)))
		| CP.Forall (v,e1,f_l, l) -> (Some (CP.Forall (v,e1,(n_l_f f_l),l)))
		| CP.Exists (v,e1,f_l, l) -> (Some (CP.Exists (v,e1,(n_l_f f_l),l)))in
	 transformer (f_e_f,f_f,f_h_f,(f_p_f,f_b,f_e)) e

let rename_labels_struc (e:struc_formula):struc_formula = rename_labels transform_struc_formula e
let rename_labels_formula (e:formula):formula = rename_labels transform_formula e
		 		
let rename_labels_formula_ante  e=
	let n_l_f n_l = match n_l with
				| None -> (fresh_branch_point_id "")
				| Some (_,s) -> (fresh_branch_point_id s) in	
    let f_e_f e = None in
	let f_f e = None in
	let rec f_h_f e = match e with 
		| Star s -> None
	    | DataNode d -> Some (DataNode {d with h_formula_data_label = n_l_f d.h_formula_data_label})
	    | ViewNode v -> Some (ViewNode {v with h_formula_view_label = n_l_f v.h_formula_view_label})
	    | HTrue
	    | HFalse -> Some e in
	let f_b e = Some e in
	let f_e e = Some e in
	let f_p_f e = Some e in			
	transform_formula (f_e_f,f_f,f_h_f,(f_p_f,f_b,f_e)) e
			 
  

and pop_expl_impl_context (expvars : CP.spec_var list) (impvars : CP.spec_var list) (ctx : list_context)  : list_context = 
  transform_list_context ((fun es -> Ctx{es with 
				es_gen_expl_vars = Util.difference es.es_gen_expl_vars expvars; 
				es_gen_impl_vars = Util.difference es.es_gen_impl_vars impvars;
				es_evars = Util.difference es.es_evars expvars;
				}), fun c->c) ctx

and push_exists_list_context (qvars : CP.spec_var list) (ctx : list_context) : list_context = 
  transform_list_context ((fun es -> Ctx{es with es_formula = push_exists qvars es.es_formula}),(fun c->c)) ctx


and push_exists_list_partial_context (qvars : CP.spec_var list) (ctx : list_partial_context) : list_partial_context = 
  transform_list_partial_context ((fun es -> Ctx{es with es_formula = push_exists qvars es.es_formula}),(fun c->c)) ctx

and push_exists_context (qvars : CP.spec_var list) (ctx : context) : context = 
  transform_context (fun es -> Ctx{es with es_formula = push_exists qvars es.es_formula}) ctx

and push_expl_impl_list_context (expvars : CP.spec_var list) (impvars : CP.spec_var list) (ctx : list_context)  : list_context = 
 transform_list_context ((fun es -> Ctx{es with 
				es_gen_expl_vars = es.es_gen_expl_vars @ expvars; 
				es_gen_impl_vars = es.es_gen_impl_vars @ impvars;
				(*es_evars = es.es_evars@ expvars;*)}),(fun c->c)) ctx
        
and push_expl_impl_context (expvars : CP.spec_var list) (impvars : CP.spec_var list) (ctx : context)  : context = 
 transform_context (fun es -> Ctx{es with 
				es_gen_expl_vars = es.es_gen_expl_vars @ expvars; 
				es_gen_impl_vars = es.es_gen_impl_vars @ impvars;
				(*es_evars = es.es_evars@ expvars;*)}) ctx
        
and pop_exists_context (qvars : CP.spec_var list) (ctx : list_context) : list_context = 
transform_list_context ((fun es -> Ctx{es with es_formula = pop_exists qvars es.es_formula}),(fun c->c)) ctx

and pop_exists_estate (qvars : CP.spec_var list) (es : entail_state) : entail_state = 
	let new_es = {es with 
		es_evars = (List.filter (fun x -> not (List.exists (fun y -> (CP.eq_spec_var x y)) qvars)) es.es_evars);
		es_formula = pop_exists qvars es.es_formula
	}
	in new_es
  
 (* add a list of existential vars, evars, to each context in the list ctx *)
and add_exist_vars_to_ctx_list (ctx : list_context) (evars	: CP.spec_var list) : list_context = 
  transform_list_context ((fun es-> Ctx{es with es_formula = (add_quantifiers evars es.es_formula)}),(fun c->c)) ctx


and change_ret_flow_ctx ctx_list =
  transform_list_context ((fun es -> Ctx{es with es_formula = substitute_flow_in_f !n_flow_int !ret_flow_int es.es_formula;})
    ,(fun c->c)) ctx_list

and change_ret_flow_partial_ctx ctx_list = 
  transform_list_partial_context ((fun es -> Ctx{es with es_formula = substitute_flow_in_f !n_flow_int !ret_flow_int es.es_formula;})
    ,(fun c->c)) ctx_list

let add_path_id ctx (pi1,pi2) = match pi1 with
	| None -> ctx
	| Some s -> 
    let fct e = Ctx{e with es_path_label = (s,pi2)::e.es_path_label} in    
    transform_context fct ctx
	
let add_path_id_ctx_list c (pi1,pi2)  = match pi1 with
	| None -> c
	| Some s ->	      
    let fct e = Ctx{e with es_path_label = (s,pi2)::e.es_path_label} in    
    transform_list_context (fct,(fun c-> c)) c
 
let add_path_id_ctx_partial_list (c:list_partial_context) (pi1,pi2) : list_partial_context = match pi1 with
	| None -> c
	| Some s ->	      
    let fct e = Ctx{e with es_path_label = (s,pi2)::e.es_path_label} in    
    transform_list_partial_context (fct,(fun c-> c)) c
   
let normalize_max_renaming_list_partial_context f pos b ctx = 
    if !Globals.max_renaming then transform_list_partial_context ((normalize_es f pos b),(fun c->c)) ctx
      else transform_list_partial_context ((normalize_clash_es f pos b),(fun c->c)) ctx
    
    
let normalize_max_renaming f pos b ctx = 
  if !Globals.max_renaming then transform_list_context ((normalize_es f pos b),(fun c->c)) ctx
  else transform_list_context ((normalize_clash_es f pos b),(fun c->c)) ctx

let normalize_max_renaming_s f pos b ctx = 
  if !Globals.max_renaming then transform_context (normalize_es f pos b) ctx
  else transform_context (normalize_clash_es f pos b) ctx

  
(*
  to be used in the type-checker. After every entailment, the history of consumed nodes
  must be cleared.
*)
let clear_entailment_history_es (es :entail_state) :context = 
 Ctx {(empty_es (mkTrueFlow ()) no_pos) with es_formula = es.es_formula; es_path_label = es.es_path_label;} 
 
let clear_entailment_history (ctx : context) : context =  
  transform_context clear_entailment_history_es ctx
  
let clear_entailment_history_list (ctx : list_context) : list_context = 
  transform_list_context (clear_entailment_history_es,(fun c->c)) ctx 

let clear_entailment_history_partial_list (ctx : list_partial_context) : list_partial_context = 
  transform_list_partial_context (clear_entailment_history_es,(fun c->c)) ctx 

  
let fold_partial_context_left_or (c_l:(list_partial_context list)) = match (List.length c_l) with
  | 0 ->  Err.report_error {Err.error_loc = no_pos;  
              Err.error_text = "folding empty partial context list \n"}
  | 1 -> (List.hd c_l)
  | _ -> List.fold_left (fun a c->  list_partial_context_or a c)
      (List.hd c_l) (List.tl c_l)

let fold_partial_context_left_union (c_l:(list_partial_context list)) = match (List.length c_l) with
  | 0 ->  Err.report_error {Err.error_loc = no_pos;  
              Err.error_text = "folding empty partial context list \n"}
  | 1 -> (List.hd c_l)
  | _ -> List.fold_left (fun a c->  list_partial_context_union a c) (List.hd c_l) (List.tl c_l)

let conv (c:entail_state) (nf:nflow) = (Ctx {c 
with es_formula = 
(substitute_flow_into_f nf c.es_formula) } )

let conv_lst (c:entail_state) (nf_lst:nflow list) = 
  match nf_lst with
    | [] -> None
    | x::xs -> Some (List.fold_left (fun acc_ctx y -> OCtx (conv c y,acc_ctx)) (conv c x)  xs)

let rec splitter (c:context) 
    (nf:nflow) 
    (* : (context option, context option) (\* caught, escaped *\)   *)
    =
  match c with
    | Ctx b -> 
	let ff =(flow_formula_of_ctx c no_pos) in	
	  if (subsume_flow nf ff.formula_flow_interval) then  (Some c,None)
	  else if not(overlapping nf ff.formula_flow_interval) then (None,Some c)
          else let t_caught = intersect_flow nf ff.formula_flow_interval in
	  let t_escape_lst = subtract_flow nf ff.formula_flow_interval in
             (Some (conv b t_caught), conv_lst b t_escape_lst)
    | OCtx (b1,b2) -> 
	let (r11,r12) = splitter b1 nf in
	let (r21,r22) = splitter b2 nf in
	let r1 = match (r11,r21) with 
	  | None, None -> None
	  | Some c, None -> Some c
	  | None, Some c -> Some c
	  | Some c1, Some c2 -> Some (mkOCtx c1 c2 no_pos)	in
	let r2 = match (r12,r22) with 
	  | None, None -> None
	  | Some c, None -> Some c
	  | None, Some c -> Some c
	  | Some c1, Some c2 -> Some (mkOCtx c1 c2 no_pos) in
	  (r1,r2) 

let splitter_partial_context  (nf:nflow) 
    (fn:  context ->  list_partial_context) (fn_esc: context -> context) ((fl,sl):partial_context) : list_partial_context = 
  let r = List.map (fun (l,c)-> 
		      let r1,r2 = splitter c nf in 
		      let r1 = match r1 with
			| Some c-> Some (repl_label_list_partial_context l (fn c ))  (* CF.SuccCtx[(CF.simplify_context c)] *)
			| None -> None in
			match (r1,r2) with
			  | None, None -> Err.report_error {Err.error_loc = no_pos;
							    Err.error_text = "Split can not return both empty contexts\n"}
			  | Some cl,None -> cl
			  | None, Some c -> [mk_partial_context (fn_esc c)]
			  | Some cl,Some c -> 
			      list_partial_context_or cl 
				[(mk_partial_context 
				    (fn_esc c))] 
		   ) sl 
  in
    list_partial_context_or [ (fl, []) ] (fold_partial_context_left_or r)

(* let splitter_partial_context_pc  (nf:nflow) 

    context -> partial_context_list
    list_partial_context -> partial_context_list

    branch_ctx list -> partial_context_list
    partial_context -> partial_context_list

   *)
(*     (fn:  Partial_context ->  list_partial_context) (fn_esc: context -> context) ((fl,sl):partial_context) : list_partial_context =  *)
(*   let r = List.map (fun (l,c)->  *)
(* 		      let r1,r2 = splitter c nf in  *)
(* 		      let r1 = match r1 with *)
(* 			| Some c-> Some (repl_label_list_partial_context l (fn c ))  (\* CF.SuccCtx[(CF.simplify_context c)] *\) *)
(* 			| None -> None in *)
(* 			match (r1,r2) with *)
(* 			  | None, None -> Err.report_error {Err.error_loc = no_pos; *)
(* 							    Err.error_text = "Split can not return both empty contexts\n"} *)
(* 			  | Some cl,None -> cl *)
(* 			  | None, Some c -> [mk_partial_context (fn_esc c)] *)
(* 			  | Some cl,Some c ->  *)
(* 			      list_partial_context_or cl  *)
(* 				[(mk_partial_context  *)
(* 				    (fn_esc c))]  *)
(* 		   ) sl  *)
(*   in *)
(*     list_partial_context_or [ (fl, []) ] (fold_partial_context_left r) *)
