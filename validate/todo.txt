==================================================================
# infer1.slk

 <1>HP_33(b_35)&a=a_34 & b=b_35&{FLOW,(19,20)=__norm}[]
 inferred hprel: [H1(y) --> y::node<a,b>@M * HP_33(b)]

Why did we get above?

Should it not be:
 inferred hprel: [H1(y) --> y::node<a_34,b_35>@M * HP_33(b_35)]
                                    ^^^^ ^^^^            ^^^^
rather than immediately bound to a,b which came about only after 
the matching.

Should use the free vars:
validate Valid:[
( [H1,b],
   HP_32(b_34)&a=a_33 & b=b_34,
  [H1(y) --> y::node<a,b>@M * HP_32(b)]
)
]
==================================================================
Below should have succeeded too.

validate Valid:[
( [H1,b],
//   HP_32(b_34)&a=a_33 & b=b_34,
   HP_32(b),
  [H1(y) --> y::node<_,bb>@M * HP_32(bb)]
  //[H1(y) --> y::node<a,b>@M * HP_32(b)]
)
].
// I think it should be OK to change b->bb
// the problem is that your inferred hp_rel should have been
// inferred hprel: [H1(y) --> y::node<a_1,b_2>@M * HP_35(b_2)]
// or you could have renamed the existentially quantified vars.
==================================================================
# ex4.slk

If {} is empty, can be omit its printing.
  q_122::ll{}<flted_7_126>(must)
should be printed as:  
  q_122::ll<flted_7_126>(must)

==================================================================
# ex4a.slk

checkentail x::node<_,null> |- x::ll<n>.
print residue.
expect Valid.
expect_infer R{x!=null & n=1}.

Why is below not executed?

  let () = x_binfo_pp "Evan: place to add expect_infer code" no_pos in
  ()

==================================================================
# ex4a.slk

--pcp

GOT:
Expected Residue :  emp&x!=null & n=1&{FLOW,(20,21)=__norm#E}[]

Can we have:

expect_infer: 
 R{emp&x!=null & n=1&{FLOW,(20,21)=__norm#E}[]}
 ..

====================================================

# ex4a.slk

# Need to check
   current residue |- expected residue

# It seems that consumed heap is missing

!!! **sleekengine.ml#1599:expected residue: emp&x!=null & n=1&{FLOW,(20,21)=__norm#E}[]
!!! **sleekengine.ml#1602:current residue:
Some(( [
  emp&0+1=n & q_45=flted_11_35 & Anon_44=Anon_13 & flted_11_35=null&{FLOW,(20,21)=__norm#E}[]

==================================================================

# ex4a.slk --print-extra (to show consumed heap)

Some(( [
  emp&0+1=n & q_45=flted_11_35 & Anon_44=Anon_13 & flted_11_35=null&{FLOW,(20,21)=__norm#E}[]
  es_heap(consumed):
  x::node<Anon_13,flted_11_35>
  ],true))Stop z3... 39 invocations Stop Omega... 16 invocations 

==================================================================
err4b.slk (FIXED by removing add_last_diff line)

# Why isn't there a type error with the node<null> scenario?

!!! **sleekengine.ml#1129:ivars:[]Exception(look_up_view_def_raw):Not_found
Exception(do_match):Invalid_argument("List.combine")
Exception(process_action):Invalid_argument("List.combine")
Exception(process_action):Invalid_argument("List.combine")
Exception(heap_entail_non_empty_rhs_heap):Invalid_argument("List.combine")
Exception(heap_entail_conjunct_helper):Invalid_argument("List.combine")

==================================================================
../sleek ex4e-expect-linearize.slk | grep Expect

# Try support: I, RA etc

Expect_Infer 2.1: Valid. ( x::node<bb,q> * q::node<bb_70,flted_16_69>&flted_16_69=null & bb_70=bb&
Expect_Infer 2.2: Valid. ( x::node<bb,q> * q::node<bb_81,Anon_13>&bb_81=bb&{FLOW,(20,21)=__norm#E}[])
Expect_Infer 2.3: Valid. ( x::node<bb,q1> * q1::node<bb_89,Anon_14>&bb_89=bb&{FLOW,(20,21)=__norm#E}[])
Expect_Infer 2.4: Fail. ( x::node<bb,q> * q::node<flted_19_98,Anon_15>&flted_19_98=1+bb&
Expect_Infer 2.5: Fail. ( x::node<bb,Anon_16> * qq::node<bb_107,Anon_17>&bb_107=bb&
Expect_Infer 2.6: Valid. ( x::node<bb,Anon_18> * q::node<bb_116,Anon_19>&bb_116=bb&
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
==================================================================
