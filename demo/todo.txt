# dll.ss

Mona not working?

../hip dll.ss -p insert -tp mona

!!!Full processing file "dll.ss"
Parsing file "dll.ss" by default parser...
!!! processing primitives "["prelude.ss"]

==========================================================================
# dll.ss


redlog giving timeouts?

chinwn@loris-7:~/hg/sl_default/demo$ ../hip dll.ss -p insert -tp redlog

!!!Full processing file "dll.ss"
Parsing file "dll.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Reduce... 
Starting Omega.../usr/local/bin/oc
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
==========================================================================
 ex3-app-twice.ss

node appendthree$node~node~node(  node x,  node y,  node z)static  EBase exists (Expl)[](Impl)[nnn; mmm; kkk](ex)[]x::ll{}<nnn> * 
       y::ll{}<mmm> * z::ll{}<kkk>&0<nnn&{FLOW,(4,5)=__norm#E}[]
         EBase emp&MayLoop[]&{FLOW,(4,5)=__norm#E}[]
                 EAssume 
                   (exists eee: x::ll{}<eee>&eee=kkk+nnn+mmm&
                   {FLOW,(4,5)=__norm#E}[]


Why are there nnn,mmm,kkk>=0 in post-checking?
Above post did not have it

id: 10; caller: []; line: 0; classic: false; kind: POST; hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp
 checkentail (exists eee_1535: x'::ll{}<eee_1535>&res=x' & 0<=mmm_1529 & 0<=nnn_1528 & 
eee_1535=mmm_1529+nnn_1528 & 0<=eee_1534 & 0<=kkk & mmm_1529=kkk & 
nnn_1528=eee_1534 & 0<=mmm_1522 & 0<=nnn_1521 & eee_1534=mmm_1522+nnn_1521 & 
0<=nnn & 0<=mmm & mmm_1522=mmm & nnn_1521=nnn & x'=x & y'=y & z'=z & 0<nnn&
{FLOW,(4,5)=__norm#E}[]
 |-  (exists eee_1519: x::ll{}<eee_1519>&0<=nnn & 0<=mmm & 0<=kkk & eee_1519=kkk+
nnn+mmm&{FLOW,(4,5)=__norm#E}[]. 
ho_vars: nothing?
res:  1[
   emp&res=x' & 0<=mmm_1529 & 0<=nnn_1528 & eee_1536=mmm_1529+nnn_1528 & 0<=eee_1534 & 0<=kkk & mmm_1529=kkk & nnn_1528=eee_1534 & 0<=mmm_1522 & 0<=nnn_1521 & eee_1534=mmm_1522+nnn_1521 & 0<=nnn & 0<=mmm & mmm_1522=mmm & nnn_1521=nnn & x'=x & y'=y & z'=z & 0<nnn&{FLOW,(4,5)=__norm#E}[]
   ]
==========================================================================
# ex3a

node appendthree(node x, node y,node z)
  requires x::ll<nn> * y::ll<mm> * z::ll<kk> & x!=null
  ensures x::ll<ee>& ee=nn+mm+kk & nn>0;

Why did post nn>0 fail?

Procedure appendthree$node~node~node FAIL.(2)

Exception Failure("Post condition cannot be derived.") Occurred!

Error(s) detected when checking procedure appendthree$node~node~node
Stop Omega... 122 invocations 
0 false contexts at: ()

==========================================================================
# ex21

incorrect to have false in post-state; do we
need to turn on a flag? it is incorrect!
Once assert/assume fail, the method should fail.

!!! **typechecker.ml#2010:Dprint:[x]
dprint(simpl): ex21-assert-assume.ss:7: ctx:  List of Failesc Context: [FEC(0, 0, 1  [(,0 ); (,1 )])]

Successful States:
[
 Label: [(,0 ); (,1 )]
 State:hfalse&false&{FLOW,(4,5)=__norm#E}[]

 ]

Procedure foo$int SUCCESS.

==========================================================================
# ex21a (default)

{
  if (x>0) {
    assert x'>=5 assume true;
    dprint;
    assert x'>=0;
    assert x'<0;
  }
}

incorrect to have false in post-state; do we
need to turn on a flag? it is incorrect!
Once assert/assume fail, the method should fail.

assert/assume:ex21a-assert-assume.ss:6: 4:  : failed


!!! **typechecker.ml#2010:Dprint:[x]
dprint(simpl): ex21a-assert-assume.ss:7: ctx:  List of Failesc Context: [FEC(0, 0, 1  [(,0 ); (,1 )])]

Successful States:
[
 Label: [(,0 ); (,1 )]
 State:hfalse&false&{FLOW,(4,5)=__norm#E}[]

 ]


Procedure foo$int SUCCESS.

==========================================================================
# ex21d --dis-efa-exc (FIXED)

How come we still have exception even though they
are disabled. I expect FailCtx to be shown when
residue is being printed; not exceptions.

Entail 1: Fail.(must) cause: 0<x |-  x<0. LOCS:[1] (must-bug)
Residue:
 <1>emp&0<x&{FLOW,(4,5)=__norm#E}[]

Entail 2: Fail.(may) cause: 0<x |-  x<5. LOCS:[5] (may-bug)
Residue:
 <1>emp&0<x&{FLOW,(4,5)=__norm#E}[]

Residue:
 <1>emp&0<x&{FLOW,(4,5)=__norm#E}[]
==========================================================================
# ex21j --dis-efa-exc: DONE for pure implication

Need to support @err_may and @err_must for
local infer error as exception..
==========================================================================
# ex21j --efa-exc

infer [@dis_err] x>0 |- x<0 .
// failctx must_err
print residue.

Got: What does { } mean?
I believe empty context is either
undefined or false.

Entail (1) : Fail.(must) cause: 0<x |-  x<0. LOCS:[2] (must-bug)
Residue:
 { }

I would expect instead:

MaybeErr Context: 
                   fe_kind: MUST
                   fe_name: logical bug
                   fe_locs: {
                             fc_message:  0<x |-  x<0. LOCS:[2] (must-bug)
                             fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]false
==========================================================================
--efa-exc

   bind --> efa-exc: errors/infer/ex1-exc-bind.ss
   assert-assume --> efa-exc: errors/infer/ex2-exc-assert.ss

   pre-cond --dis-efa-exc: errors/infer/ex3-exc-pred.ss
   post --dis-efa-exc: : errors/infer/ex4-exc-post.ss

==========================================================================
# ex21a1.ss --efa-exc

Context of Verification Failure: _0:0_0:0
Last Proving Location: ex21a1-assert-assume.ss_6:4_6:28
Procedure foo$int FAIL.(2)
Exception Failure("Proving assert/assume failed") Occurred!

Why isn't dprint working?
I expect MayError exception to be printed.
How come --efa not working?

id: 0; caller: []; line: 6; classic: false; kind: Assert/Assume; hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp
 checkentail htrue&x'=x&{FLOW,(4,5)=__norm#E}[]
 |-  emp&5<=x'&{FLOW,(4,5)=__norm#E}[]. 
ho_vars: nothing?
res:  failctx
         fe_kind: MAY
         fe_name: logical bug
         fe_locs: {
                   fc_message:  true |-  5<=x'. LOCS:[2;6] (may-bug)
                   fc_current_lhs_flow: {FLOW,(4,11)=__MayError#E}}
[[empty]]false

==========================================================================
# ex21a2.slk

# Can we log the @err_must etc below? (DONE)

# Can we move exception to a lower-level?
 
infer [@dis_err] x'=x |- x'<=5.
print residue.
  /*
Residue:
 
MaybeErr Context: 
                   fe_kind: MAY
                   fe_name: logical bug
                   fe_locs: {
                             fc_message:  true |-  x'<=5. LOCS:[2] (may-bug)
                             fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]
CEX:false
  */

infer [@err_must] x'=x |- x'<=6.
print residue.

  /*
Entail (2) : Fail.(may) cause: true |-  x'<=5. LOCS:[5] (may-bug)
  */

# --esl

id: 0; caller: []; line: 0; classic: false; kind: Sleek_Entail(1); hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp; others: [@dis_err]
 checkentail emp&x'=x&{FLOW,(4,5)=__norm#E}[]
 |-  emp&x'<=5&{FLOW,(4,5)=__norm#E}[]. 
ho_vars: nothing?
res:  failctx
         fe_kind: MAY
         fe_name: logical bug
         fe_locs: {
                   fc_message:  true |-  x'<=5. LOCS:[2] (may-bug)
                   fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]false
 
id: 1; caller: []; line: 0; classic: false; kind: Sleek_Entail(2); hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp; others: [@err_must]
 checkentail emp&x'=x&{FLOW,(4,5)=__norm#E}[]
 |-  emp&x'<=6&{FLOW,(4,5)=__norm#E}[]. 
ho_vars: nothing?
res:  failctx
         fe_kind: MAY
         fe_name: logical bug
         fe_locs: {
                   fc_message:  true |-  x'<=6. LOCS:[17] (may-bug)
                   fc_current_lhs_flow: {FLOW,(4,8)=__MayError#E}}
[[empty]]false

==========================================================================
id: 0; caller: []; line: 0; classic: false; kind: Sleek_Entail(1); hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp; others: [] globals: [@err_must]


local setting takes precedence over global setting
   dis_err > err_may > err_must
     dis_err & err_may --> dis_err
     dis_err & err_must --> dis_err
     err_may & err_must --> err_may

==========================================================================

Why did we have @err_must for global?

--exc-efa
id: 0; caller: []; line: 6; classic: false; kind: Assert/Assume; hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp; others: [@err_must] globals: [@err_must]

--dis-exc-efa
others: [] globals: [@err_must]


==========================================================================
# ex21a1 --efa-exc -dre "heap_entail"

Why @err_must still result in MaybeErr context
and not __ErrorMay exception?

(==solver.ml#14797==)
heap_entail_one_context_struc#2@5@4@3@2@1
heap_entail_one_context_struc#2 inp1 : EBase emp&5<=x'&{FLOW,(4,5)=__norm#E}[]
heap_entail_one_context_struc#2 inp2 : es_formula: htrue&x'=x & MayLoop[]&{FLOW,(4,5)=__norm#E}[]
 es_infer_obj: [@err_must]
 es_cond_path: [0]
 es_infer_vars_rel: []
 es_unsat_flag: false
heap_entail_one_context_struc#2 inp3 :is_folding:false
heap_entail_one_context_struc#2 inp4 :has_post:false
heap_entail_one_context_struc#2@5 EXIT: 
MaybeErr Context: 
                   fe_kind: MAY
                   fe_name: logical bug
                   fe_locs: {
                             fc_message:  true |-  5<=x'. LOCS:[2;6] (may-bug)
                             fc_current_lhs_flow: {FLOW,(4,11)=__MayError#E}}
[[empty]]
CEX:false

==========================================================================
# ex21a5 --efa-exc -dre "heap_entail": DONE

Checking procedure foo2$int... 
assert/assume:ex21a5-assert-assume.ss:23: 4:  : failed

Can we have failed (MAY ERROR)
     or failed (MUST ERROR) 
for assert wo assume.

==========================================================================
# ex21a6
 --efa-exc -dre "heap_entail"

# Why is there empty_context?


Checking procedure foo2$cell... 
( []) :ex21a6-bind.ss:9: 10: bind: node  x'::cell<val_9_1431'>@L cannot be deriv
ed from context

(Cause of Bind Failure):ex21a6-bind.ss:9: 10:  List of Failesc Context: [FEC(

!! **typechecker.ml#2065:Dprint:[x_15,x]
dprint:ex21a6-bind.ss:10 empty context

Can we have failed (MAY ERROR)
     or failed (MUST ERROR) 
for assert wo assume.



# ex21a6
 --efa-exc -dre "heap_entail"

Why below did not trigger an error exception?

(==solver.ml#14798==)
heap_entail_one_context_struc#2@5@4@3@2@1
heap_entail_one_context_struc#2 inp1 : EBase x'::cell<val_9_1431'>@L&{FLOW,(1,28)=__flow#E}[]
heap_entail_one_context_struc#2 inp2 : es_formula: htrue&x'=x & MayLoop[]&{FLOW,(4,5)=__norm#E}[]
 es_infer_obj: [@err_must]
 es_cond_path: [0]
 es_infer_vars_rel: []
heap_entail_one_context_struc#2 inp3 :is_folding:false
heap_entail_one_context_struc#2 inp4 :has_post:true
heap_entail_one_context_struc#2@5 EXIT: 
MaybeErr Context: 
                   fe_kind: MAY
                   fe_name: separation entailment
                   fe_locs: {
                             fc_message: do_unmatched_rhs : x'::cell<val_9_1431'>@L
                             fc_current_lhs_flow: {FLOW,(4,11)=__MayError#E}}
[[ COND ==>  UnmatchedRHSData ==> ]]
CEX:false

Checking procedure foo2$int... 
assert/assume:ex21a5-assert-assume.ss:23: 4:  : failed

==========================================================================
# ex21a8 --efa-exc -dre "heap_entail"

--efa-exc triggers must-err exception for pre-condition checking
# Why is there a verification failure 
and empty context?

Checking procedure foo2$cell... 
!!! **typechecker.ml#2065:Dprint:[x]
dprint:ex21a8-pre.ss:14 empty context
Procedure foo2$cell result FAIL.(1)

However, heap_entail seems fine:

(==solver.ml#4304==)
heap_entail_one_context#13@8@7@6@5@4@3@2@1
heap_entail_one_context#13 inp1 : es_formula: htrue&x'=x & MayLoop[]&{FLOW,(4,5)=__norm#E}[]
 es_infer_obj: [@err_must]
 es_gen_impl_vars: [Anon_11]
 es_cond_path: [0]
 es_infer_vars_rel: []
heap_entail_one_context#13 inp2 : x'::cell<Anon_11>&{FLOW,(4,5)=__norm#E}[]
heap_entail_one_context#13@8 EXIT: [
  htrue&x'=x&{FLOW,(4,11)=__MayError#E}[]
  ]

--dis-efa-exc triggers pre-cond failure

Starting Omega.../usr/local/bin/oc

Checking procedure foo2$cell... 
Proving precondition in method pre_call$cell Failed.
  (may) cause: do_unmatched_rhs : x'::cell<Anon_11>

Context of Verification Failure: _0:0_0:0

Last Proving Location: ex21a8-pre.ss_13:2_13:13

Procedure foo2$cell FAIL.(2)

--efa-may

sleek triggers @err_may. 

id: 0; caller: []; line: 13; classic: false; kind: PRE; hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp; others: [@err_may] globals: [@err_may]
 checkentail htrue&x'=x&{FLOW,(4,5)=__norm#E}[]
 |-  x'::cell<Anon_11>&{FLOW,(4,5)=__norm#E}[]. 
ho_vars: nothing?
res:  1[
   htrue&x'=x&{FLOW,(4,11)=__MayError#E}[]
   ]

# However, we still get empty context error.

!!! **typechecker.ml#2065:Dprint:[x]
dprint:ex21a8-pre.ss:14 empty context
Procedure foo2$cell result FAIL.(1)
==========================================================================
# ex21e2

//1
infer [@err_must] x'=x |- y::node<_>.
print residue.
// GOT __Error but Expects __Error_May 

/*
Entail (1) : Fail.(must) cause:do_unmatched_rhs : y::node<Anon_11>

Residue:
 <1>emp&x'=x&{FLOW,(18,19)=__Error#E}[]
[[ COND ==>  UnmatchedRHSData ==> ]]
*/

infer [] x'=x |- y::node<_>.
print residue.
// expects MaybeErr Context

infer [] y!=null |- y::node<_>.
print residue.
// GOT MaybeErr Context, but expects MustErrCtx

//4
infer [@err_may] x'=x |- y::node<_>.
print residue.
// expects __ErrorMay but got __Error

//(5)
infer [@err_may] y=null |- y::node<_>.
print residue.
// expects __ErrorMay but got __Error
==========================================================================
# ex21f2.slk: FIXED

# 5 & 7 has problem above

//5
infer [@dis_err] x'=8 |- x'<=5.
print residue.
//expects MustErr Context but got MaybeErr Context

//7
infer [] x'=8 |- x'<=6.
print residue.
// expects MustErr Context but got MaybeErr Context
==========================================================================
# ex21f2.slk --esl (FIXED)

Can we suppress sleek_dump during sleek_invocation?

!!!dumping for sleek_dump(fail)
!!!  
 id: 2<0; prover: Z3; loc: _0:0_0:0; kind: Sleek_Entail(1)
 raw proof:no proof raw result:no result
 Imply: ante: x'=x
             conseq:  x'<=5
 res: false
 --------------------
!!!dumping for sleek_dump(fail)
!!!  
id: 0; caller: []; line: 0; classic: false; kind: Sleek_Entail(1); hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp; others: [@dis_err] globals: []
 checkentail emp&x'=x&{FLOW,(20,21)=__norm#E}[]
 |-  emp&x'<=5&{FLOW,(20,21)=__norm#E}[]. 
ho_vars: nothing?
res:  failctx
         fe_kind: MAY
         fe_name: logical bug
         fe_locs: {
                   fc_message:  true |-  x'<=5. LOCS:[4] (may-bug)
                   fc_current_lhs_flow: {FLOW,(20,21)=__norm#E}}
[[empty]]false
==========================================================================
# ex21a8

(==solver.ml#4318==)
heap_entail_one_context#13@8@7@6@5@4@3@2@1
heap_entail_one_context#13 inp1 : es_formula: htrue&x'=x & MayLoop[]&{FLOW,(4,5)=__norm#E}[]
 es_infer_obj: [@err_must]
 es_gen_impl_vars: [Anon_11]
 es_cond_path: [0]
 es_infer_vars_rel: []
heap_entail_one_context#13 inp2 : x'::cell<Anon_11>&{FLOW,(4,5)=__norm#E}[]
heap_entail_one_context#13@8 EXIT: [
  htrue&x'=x&{FLOW,(4,11)=__MayError#E}[]
  ]

(==norm.ml#1054==)
heap_entail_after_sat@19@18@17@16@15@14@7@6@5@4@3@2@1
heap_entail_after_sat inp1 : es_formula: htrue&x'=x&{FLOW,(4,11)=__MayError#E}[]
 es_infer_obj: [@err_must]
 es_cond_path: [0]
 es_var_measures 1: Some(MayLoop[]{})
 es_trace:  COND ==>  UnmatchedRHSData ==> 
 es_infer_vars_rel: []
heap_entail_after_sat inp2 : emp&MayLoop[]&{FLOW,(4,5)=__norm#E}[]
heap_entail_after_sat@19 EXIT: []

==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
