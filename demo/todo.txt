# dll.ss

Mona not working?

../hip dll.ss -p insert -tp mona

!!!Full processing file "dll.ss"
Parsing file "dll.ss" by default parser...
!!! processing primitives "["prelude.ss"]

==========================================================================
# dll.ss


redlog giving timeouts?

chinwn@loris-7:~/hg/sl_default/demo$ ../hip dll.ss -p insert -tp redlog

!!!Full processing file "dll.ss"
Parsing file "dll.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Reduce... 
Starting Omega.../usr/local/bin/oc
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
==========================================================================
 ex3-app-twice.ss

node appendthree$node~node~node(  node x,  node y,  node z)static  EBase exists (Expl)[](Impl)[nnn; mmm; kkk](ex)[]x::ll{}<nnn> * 
       y::ll{}<mmm> * z::ll{}<kkk>&0<nnn&{FLOW,(4,5)=__norm#E}[]
         EBase emp&MayLoop[]&{FLOW,(4,5)=__norm#E}[]
                 EAssume 
                   (exists eee: x::ll{}<eee>&eee=kkk+nnn+mmm&
                   {FLOW,(4,5)=__norm#E}[]


Why are there nnn,mmm,kkk>=0 in post-checking?
Above post did not have it

id: 10; caller: []; line: 0; classic: false; kind: POST; hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp
 checkentail (exists eee_1535: x'::ll{}<eee_1535>&res=x' & 0<=mmm_1529 & 0<=nnn_1528 & 
eee_1535=mmm_1529+nnn_1528 & 0<=eee_1534 & 0<=kkk & mmm_1529=kkk & 
nnn_1528=eee_1534 & 0<=mmm_1522 & 0<=nnn_1521 & eee_1534=mmm_1522+nnn_1521 & 
0<=nnn & 0<=mmm & mmm_1522=mmm & nnn_1521=nnn & x'=x & y'=y & z'=z & 0<nnn&
{FLOW,(4,5)=__norm#E}[]
 |-  (exists eee_1519: x::ll{}<eee_1519>&0<=nnn & 0<=mmm & 0<=kkk & eee_1519=kkk+
nnn+mmm&{FLOW,(4,5)=__norm#E}[]. 
ho_vars: nothing?
res:  1[
   emp&res=x' & 0<=mmm_1529 & 0<=nnn_1528 & eee_1536=mmm_1529+nnn_1528 & 0<=eee_1534 & 0<=kkk & mmm_1529=kkk & nnn_1528=eee_1534 & 0<=mmm_1522 & 0<=nnn_1521 & eee_1534=mmm_1522+nnn_1521 & 0<=nnn & 0<=mmm & mmm_1522=mmm & nnn_1521=nnn & x'=x & y'=y & z'=z & 0<nnn&{FLOW,(4,5)=__norm#E}[]
   ]
==========================================================================
# ex3a

node appendthree(node x, node y,node z)
  requires x::ll<nn> * y::ll<mm> * z::ll<kk> & x!=null
  ensures x::ll<ee>& ee=nn+mm+kk & nn>0;

Why did post nn>0 fail?

Procedure appendthree$node~node~node FAIL.(2)

Exception Failure("Post condition cannot be derived.") Occurred!

Error(s) detected when checking procedure appendthree$node~node~node
Stop Omega... 122 invocations 
0 false contexts at: ()

==========================================================================
# ex21

incorrect to have false in post-state; do we
need to turn on a flag? it is incorrect!
Once assert/assume fail, the method should fail.

!!! **typechecker.ml#2010:Dprint:[x]
dprint(simpl): ex21-assert-assume.ss:7: ctx:  List of Failesc Context: [FEC(0, 0, 1  [(,0 ); (,1 )])]

Successful States:
[
 Label: [(,0 ); (,1 )]
 State:hfalse&false&{FLOW,(4,5)=__norm#E}[]

 ]

Procedure foo$int SUCCESS.

==========================================================================
# ex21a (default)

{
  if (x>0) {
    assert x'>=5 assume true;
    dprint;
    assert x'>=0;
    assert x'<0;
  }
}

incorrect to have false in post-state; do we
need to turn on a flag? it is incorrect!
Once assert/assume fail, the method should fail.

assert/assume:ex21a-assert-assume.ss:6: 4:  : failed


!!! **typechecker.ml#2010:Dprint:[x]
dprint(simpl): ex21a-assert-assume.ss:7: ctx:  List of Failesc Context: [FEC(0, 0, 1  [(,0 ); (,1 )])]

Successful States:
[
 Label: [(,0 ); (,1 )]
 State:hfalse&false&{FLOW,(4,5)=__norm#E}[]

 ]


Procedure foo$int SUCCESS.

==========================================================================
# ex21d --dis-efa-exc (FIXED)

How come we still have exception even though they
are disabled. I expect FailCtx to be shown when
residue is being printed; not exceptions.

Entail 1: Fail.(must) cause: 0<x |-  x<0. LOCS:[1] (must-bug)
Residue:
 <1>emp&0<x&{FLOW,(4,5)=__norm#E}[]

Entail 2: Fail.(may) cause: 0<x |-  x<5. LOCS:[5] (may-bug)
Residue:
 <1>emp&0<x&{FLOW,(4,5)=__norm#E}[]

Residue:
 <1>emp&0<x&{FLOW,(4,5)=__norm#E}[]
==========================================================================
# ex21j --dis-efa-exc: DONE for pure implication

Need to support @err_may and @err_must for
local infer error as exception..
==========================================================================
# ex21j --efa-exc

infer [@dis_err] x>0 |- x<0 .
// failctx must_err
print residue.

Got: What does { } mean?
I believe empty context is either
undefined or false.

Entail (1) : Fail.(must) cause: 0<x |-  x<0. LOCS:[2] (must-bug)
Residue:
 { }

I would expect instead:

MaybeErr Context: 
                   fe_kind: MUST
                   fe_name: logical bug
                   fe_locs: {
                             fc_message:  0<x |-  x<0. LOCS:[2] (must-bug)
                             fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]false
==========================================================================
--efa-exc

   bind --> efa-exc: errors/infer/ex1-exc-bind.ss
   assert-assume --> efa-exc: errors/infer/ex2-exc-assert.ss

   pre-cond --dis-efa-exc: errors/infer/ex3-exc-pred.ss
   post --dis-efa-exc: : errors/infer/ex4-exc-post.ss

==========================================================================
# ex21a1.ss --efa-exc

Context of Verification Failure: _0:0_0:0
Last Proving Location: ex21a1-assert-assume.ss_6:4_6:28
Procedure foo$int FAIL.(2)
Exception Failure("Proving assert/assume failed") Occurred!

Why isn't dprint working?
I expect MayError exception to be printed.
How come --efa not working?

id: 0; caller: []; line: 6; classic: false; kind: Assert/Assume; hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp
 checkentail htrue&x'=x&{FLOW,(4,5)=__norm#E}[]
 |-  emp&5<=x'&{FLOW,(4,5)=__norm#E}[]. 
ho_vars: nothing?
res:  failctx
         fe_kind: MAY
         fe_name: logical bug
         fe_locs: {
                   fc_message:  true |-  5<=x'. LOCS:[2;6] (may-bug)
                   fc_current_lhs_flow: {FLOW,(4,11)=__MayError#E}}
[[empty]]false

==========================================================================
# ex21a2.slk

# Can we log the @err_must etc below? (DONE)

# Can we move exception to a lower-level?
 
infer [@dis_err] x'=x |- x'<=5.
print residue.
  /*
Residue:
 
MaybeErr Context: 
                   fe_kind: MAY
                   fe_name: logical bug
                   fe_locs: {
                             fc_message:  true |-  x'<=5. LOCS:[2] (may-bug)
                             fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]
CEX:false
  */

infer [@err_must] x'=x |- x'<=6.
print residue.

  /*
Entail (2) : Fail.(may) cause: true |-  x'<=5. LOCS:[5] (may-bug)
  */

# --esl

id: 0; caller: []; line: 0; classic: false; kind: Sleek_Entail(1); hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp; others: [@dis_err]
 checkentail emp&x'=x&{FLOW,(4,5)=__norm#E}[]
 |-  emp&x'<=5&{FLOW,(4,5)=__norm#E}[]. 
ho_vars: nothing?
res:  failctx
         fe_kind: MAY
         fe_name: logical bug
         fe_locs: {
                   fc_message:  true |-  x'<=5. LOCS:[2] (may-bug)
                   fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]false
 
id: 1; caller: []; line: 0; classic: false; kind: Sleek_Entail(2); hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp; others: [@err_must]
 checkentail emp&x'=x&{FLOW,(4,5)=__norm#E}[]
 |-  emp&x'<=6&{FLOW,(4,5)=__norm#E}[]. 
ho_vars: nothing?
res:  failctx
         fe_kind: MAY
         fe_name: logical bug
         fe_locs: {
                   fc_message:  true |-  x'<=6. LOCS:[17] (may-bug)
                   fc_current_lhs_flow: {FLOW,(4,8)=__MayError#E}}
[[empty]]false

==========================================================================
id: 0; caller: []; line: 0; classic: false; kind: Sleek_Entail(1); hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp; others: [] globals: [@err_must]


local setting takes precedence over global setting
   dis_err > err_may > err_must
     dis_err & err_may --> dis_err
     dis_err & err_must --> dis_err
     err_may & err_must --> err_may

==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
