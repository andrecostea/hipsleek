# dll.ss

Mona not working?

../hip dll.ss -p insert -tp mona

!!!Full processing file "dll.ss"
Parsing file "dll.ss" by default parser...
!!! processing primitives "["prelude.ss"]

==========================================================================
# dll.ss


redlog giving timeouts?

chinwn@loris-7:~/hg/sl_default/demo$ ../hip dll.ss -p insert -tp redlog

!!!Full processing file "dll.ss"
Parsing file "dll.ss" by default parser...

!!! processing primitives "["prelude.ss"]
Starting Reduce... 
Starting Omega.../usr/local/bin/oc
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
Nested Timer(stop)
==========================================================================
 ex3-app-twice.ss

node appendthree$node~node~node(  node x,  node y,  node z)static  EBase exists (Expl)[](Impl)[nnn; mmm; kkk](ex)[]x::ll{}<nnn> * 
       y::ll{}<mmm> * z::ll{}<kkk>&0<nnn&{FLOW,(4,5)=__norm#E}[]
         EBase emp&MayLoop[]&{FLOW,(4,5)=__norm#E}[]
                 EAssume 
                   (exists eee: x::ll{}<eee>&eee=kkk+nnn+mmm&
                   {FLOW,(4,5)=__norm#E}[]


Why are there nnn,mmm,kkk>=0 in post-checking?
Above post did not have it

id: 10; caller: []; line: 0; classic: false; kind: POST; hec_num: 1; evars: []; infer_vars: [ ]; c_heap: emp
 checkentail (exists eee_1535: x'::ll{}<eee_1535>&res=x' & 0<=mmm_1529 & 0<=nnn_1528 & 
eee_1535=mmm_1529+nnn_1528 & 0<=eee_1534 & 0<=kkk & mmm_1529=kkk & 
nnn_1528=eee_1534 & 0<=mmm_1522 & 0<=nnn_1521 & eee_1534=mmm_1522+nnn_1521 & 
0<=nnn & 0<=mmm & mmm_1522=mmm & nnn_1521=nnn & x'=x & y'=y & z'=z & 0<nnn&
{FLOW,(4,5)=__norm#E}[]
 |-  (exists eee_1519: x::ll{}<eee_1519>&0<=nnn & 0<=mmm & 0<=kkk & eee_1519=kkk+
nnn+mmm&{FLOW,(4,5)=__norm#E}[]. 
ho_vars: nothing?
res:  1[
   emp&res=x' & 0<=mmm_1529 & 0<=nnn_1528 & eee_1536=mmm_1529+nnn_1528 & 0<=eee_1534 & 0<=kkk & mmm_1529=kkk & nnn_1528=eee_1534 & 0<=mmm_1522 & 0<=nnn_1521 & eee_1534=mmm_1522+nnn_1521 & 0<=nnn & 0<=mmm & mmm_1522=mmm & nnn_1521=nnn & x'=x & y'=y & z'=z & 0<nnn&{FLOW,(4,5)=__norm#E}[]
   ]
==========================================================================
# ex3a

node appendthree(node x, node y,node z)
  requires x::ll<nn> * y::ll<mm> * z::ll<kk> & x!=null
  ensures x::ll<ee>& ee=nn+mm+kk & nn>0;

Why did post nn>0 fail?

Procedure appendthree$node~node~node FAIL.(2)

Exception Failure("Post condition cannot be derived.") Occurred!

Error(s) detected when checking procedure appendthree$node~node~node
Stop Omega... 122 invocations 
0 false contexts at: ()

==========================================================================
# ex21

incorrect to have false in post-state; do we
need to turn on a flag? it is incorrect!
Once assert/assume fail, the method should fail.

!!! **typechecker.ml#2010:Dprint:[x]
dprint(simpl): ex21-assert-assume.ss:7: ctx:  List of Failesc Context: [FEC(0, 0, 1  [(,0 ); (,1 )])]

Successful States:
[
 Label: [(,0 ); (,1 )]
 State:hfalse&false&{FLOW,(4,5)=__norm#E}[]

 ]

Procedure foo$int SUCCESS.

==========================================================================
# ex21a (default)

{
  if (x>0) {
    assert x'>=5 assume true;
    dprint;
    assert x'>=0;
    assert x'<0;
  }
}

incorrect to have false in post-state; do we
need to turn on a flag? it is incorrect!
Once assert/assume fail, the method should fail.

assert/assume:ex21a-assert-assume.ss:6: 4:  : failed


!!! **typechecker.ml#2010:Dprint:[x]
dprint(simpl): ex21a-assert-assume.ss:7: ctx:  List of Failesc Context: [FEC(0, 0, 1  [(,0 ); (,1 )])]

Successful States:
[
 Label: [(,0 ); (,1 )]
 State:hfalse&false&{FLOW,(4,5)=__norm#E}[]

 ]


Procedure foo$int SUCCESS.

==========================================================================
# ex21d --dis-efa-exc (FIXED)

How come we still have exception even though they
are disabled. I expect FailCtx to be shown when
residue is being printed; not exceptions.

Entail 1: Fail.(must) cause: 0<x |-  x<0. LOCS:[1] (must-bug)
Residue:
 <1>emp&0<x&{FLOW,(4,5)=__norm#E}[]

Entail 2: Fail.(may) cause: 0<x |-  x<5. LOCS:[5] (may-bug)
Residue:
 <1>emp&0<x&{FLOW,(4,5)=__norm#E}[]

Residue:
 <1>emp&0<x&{FLOW,(4,5)=__norm#E}[]
==========================================================================
# ex21j --dis-efa-exc: DONE for pure implication

Need to support @err_may and @err_must for
local infer error as exception..
==========================================================================
# ex21j --efa-exc

infer [@dis_err] x>0 |- x<0 .
// failctx must_err
print residue.

Got: What does { } mean?
I believe empty context is either
undefined or false.

Entail (1) : Fail.(must) cause: 0<x |-  x<0. LOCS:[2] (must-bug)
Residue:
 { }

I would expect instead:

MaybeErr Context: 
                   fe_kind: MUST
                   fe_name: logical bug
                   fe_locs: {
                             fc_message:  0<x |-  x<0. LOCS:[2] (must-bug)
                             fc_current_lhs_flow: {FLOW,(4,5)=__norm#E}}
[[empty]]false
==========================================================================
--efa-exc

   bind --> efa-exc: errors/infer/ex1-exc-bind.ss
   assert-assume --> efa-exc: errors/infer/ex2-exc-assert.ss

   pre-cond --dis-efa-exc: errors/infer/ex3-exc-pred.ss
   post --dis-efa-exc: : errors/infer/ex4-exc-post.ss

==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
==========================================================================
